# Japanese translations for PACKAGE package
# Copyright (C) 2022 Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# Automatically generated, 2022.
#
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2022-08-17 08:59+0900\n"
"PO-Revision-Date: 2022-08-17 08:59+0900\n"
"Last-Translator: Automatically generated\n"
"Language-Team: none\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#. type: Title ##
#: ../src/Appendices/Neovim.md:364 ../src/Tutorial/DPair.md:1191
#: ../src/Tutorial/DataTypes.md:1319 ../src/Tutorial/Dependent.md:872
#: ../src/Tutorial/Eq.md:1085 ../src/Tutorial/Folds.md:1051
#: ../src/Tutorial/Functions1.md:524 ../src/Tutorial/Functions2.md:924
#: ../src/Tutorial/Functor.md:1395 ../src/Tutorial/IO.md:1095
#: ../src/Tutorial/Interfaces.md:792 ../src/Tutorial/Predicates.md:1358
#: ../src/Tutorial/Traverse.md:1109
#, no-wrap
msgid "Conclusion"
msgstr "まとめ"

#. type: Plain text
#: ../src/Appendices/Neovim.md:374 ../src/Tutorial/DPair.md:1206
#: ../src/Tutorial/DataTypes.md:1368 ../src/Tutorial/Dependent.md:910
#: ../src/Tutorial/Eq.md:1098 ../src/Tutorial/Folds.md:1064
#: ../src/Tutorial/Functions1.md:583 ../src/Tutorial/Functions2.md:964
#: ../src/Tutorial/Functor.md:1427 ../src/Tutorial/IO.md:1125
#: ../src/Tutorial/Interfaces.md:821 ../src/Tutorial/Predicates.md:1369
#: ../src/Tutorial/Prim.md:1411 ../src/Tutorial/Traverse.md:1148
#, no-wrap
msgid ""
"<!-- vi: filetype=idris2\n"
"-->\n"
msgstr ""
"<!-- vi: filetype=idris2\n"
"-->\n"

#. type: Title ###
#: ../src/Tutorial/DPair.md:348 ../src/Tutorial/DataTypes.md:261
#: ../src/Tutorial/Dependent.md:444 ../src/Tutorial/Eq.md:279
#: ../src/Tutorial/Folds.md:373 ../src/Tutorial/Functor.md:381
#: ../src/Tutorial/IO.md:317 ../src/Tutorial/Interfaces.md:189
#: ../src/Tutorial/Predicates.md:305 ../src/Tutorial/Prim.md:448
#: ../src/Tutorial/Traverse.md:247
#, no-wrap
msgid "Exercises part 1"
msgstr "演習 その1"

#. type: Title ###
#: ../src/Tutorial/DPair.md:653 ../src/Tutorial/DataTypes.md:436
#: ../src/Tutorial/Dependent.md:623 ../src/Tutorial/Eq.md:555
#: ../src/Tutorial/Folds.md:668 ../src/Tutorial/Functor.md:962
#: ../src/Tutorial/IO.md:728 ../src/Tutorial/Interfaces.md:352
#: ../src/Tutorial/Predicates.md:672 ../src/Tutorial/Prim.md:712
#: ../src/Tutorial/Traverse.md:574
#, no-wrap
msgid "Exercises part 2"
msgstr "演習 その2"

#. type: Title ###
#: ../src/Tutorial/DPair.md:1128 ../src/Tutorial/DataTypes.md:742
#: ../src/Tutorial/Dependent.md:843 ../src/Tutorial/Eq.md:826
#: ../src/Tutorial/Folds.md:988 ../src/Tutorial/Functor.md:1232
#: ../src/Tutorial/IO.md:949 ../src/Tutorial/Interfaces.md:624
#: ../src/Tutorial/Predicates.md:1020 ../src/Tutorial/Prim.md:936
#: ../src/Tutorial/Traverse.md:1016
#, no-wrap
msgid "Exercises part 3"
msgstr "演習 その3"

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:1362 ../src/Tutorial/Dependent.md:904
#: ../src/Tutorial/Functions1.md:575 ../src/Tutorial/Functions2.md:954
#: ../src/Tutorial/IO.md:1118 ../src/Tutorial/Interfaces.md:813
#, no-wrap
msgid "What's next"
msgstr "お次は？"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Folds.md:1019 ../src/Tutorial/IO.md:753
#: ../src/Tutorial/Traverse.md:267
#, no-wrap
msgid ""
"   data List01 : (nonEmpty : Bool) -> Type -> Type where\n"
"     Nil  : List01 False a\n"
"     (::) : a -> List01 False a -> List01 ne a\n"
msgstr ""
"   data List01 : (nonEmpty : Bool) -> Type -> Type where\n"
"     Nil  : List01 False a\n"
"     (::) : a -> List01 False a -> List01 ne a\n"

#. type: Title #
#: ../src/Tutorial/IO.md:1
#, no-wrap
msgid "IO: Programming with Side Effects"
msgstr "IO: 副作用のあるプログラミング"

#. type: Plain text
#: ../src/Tutorial/IO.md:7
msgid ""
"So far, all our examples and exercises dealt with pure, total functions.  We "
"didn't read or write content from or to files, nor did we write any messages "
"to the standard output. It is time to change that and learn, how we can "
"write effectful programs in Idris."
msgstr ""
"ここまでの全ての例や演習で、純粋で全域な関数を扱ってきました。\n"
"ファイルから内容を読んだり書き込んだり、\n"
"標準出力に文言を書き込んだりするようなことはしてきませんでした。\n"
"今こそ流れを変え、副作用のあるプログラムをIdrisで書く方法を学ぶときです。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/IO.md:8
#, no-wrap
msgid ""
"module Tutorial.IO\n"
"\n"
"import Data.List1\n"
"import Data.String\n"
"import Data.Vect\n"
"\n"
"import System.File\n"
"\n"
"%default total\n"
msgstr ""
"module Tutorial.IO\n"
"\n"
"import Data.List1\n"
"import Data.String\n"
"import Data.Vect\n"
"\n"
"import System.File\n"
"\n"
"%default total\n"

#. type: Title ##
#: ../src/Tutorial/IO.md:20
#, no-wrap
msgid "Pure Side Effects?"
msgstr "純粋な副作用？"

#. type: Plain text
#: ../src/Tutorial/IO.md:24
msgid ""
"If we once again look at the *hello world* example from the [introduction]"
"(Intro.md), it had the following type and implementation:"
msgstr ""
"[導入](Intro.md)の*hello world*の例をもう一度見ると、以下の型と実装がありまし"
"た。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/IO.md:25
#, no-wrap
msgid ""
"hello : IO ()\n"
"hello = putStrLn \"Hello World!\"\n"
msgstr ""
"hello : IO ()\n"
"hello = putStrLn \"Hello World!\"\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:32
msgid ""
"If you load this module in a REPL session and evaluate `hello`, you'll get "
"the following:"
msgstr ""
"このモジュールをREPLセッションに読み込んで`hello`を評価すると、以下が得られる"
"でしょう。"

#. type: Fenced code block (repl)
#: ../src/Tutorial/IO.md:33
#, no-wrap
msgid ""
"Tutorial.IO> hello\n"
"MkIO (prim__putStr \"Hello World!\")\n"
msgstr ""
"Tutorial.IO> hello\n"
"MkIO (prim__putStr \"Hello World!\")\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:41
msgid ""
"This might not be what you expected, given that we'd actually wanted the "
"program to just print \"Hello World!\". In order to explain what's going on "
"here, we need to quickly look at how evaluation at the REPL works."
msgstr ""
"実際にはプログラムに単に \"Hello World!\" を印字してほしかったとしたら、\n"
"この振舞いは期待したものではないでしょう。\n"
"ここで起こっていることを説明するためには、\n"
"REPLでどのように評価が行われるのかを軽く知っておかねばなりません。"

#. type: Plain text
#: ../src/Tutorial/IO.md:51
msgid ""
"When we evaluate some expression at the REPL, Idris tries to reduce it to a "
"value until it gets stuck somewhere. In the above case, Idris gets stuck at "
"function `prim__putStr`. This is a *foreign function* defined in the "
"*Prelude*, which has to be implemented by each backend in order to be "
"available there. At compile time (and at the REPL), Idris knows nothing "
"about the implementations of foreign functions and therefore can't reduce "
"foreign function calls, unless they are built into the compiler itself. But "
"even then, values of type `IO a` (`a` being a type parameter) are typically "
"not reduced."
msgstr ""
"REPLで何らかの式を評価するとき、Idrisは行き着くところまで値に簡略しようとしま"
"す。\n"
"上の場合、Idrisは関数`prim__putStr`で立ち止まります。\n"
"これは*Prelude*で定義された*異邦関数*であり、\n"
"それぞれのバックエンドで実装されることで使えるようになるものです。\n"
"コンパイル時（そしてREPL時）は、Idrisは異邦関数の実装について何も知らず、\n"
"したがってコンパイラ自身に組込まれていない限り異邦関数を簡略することはできま"
"せん。\n"
"なので型`IO a`（`a`は型変数）の値も同様に大抵は簡略できないのです。"

#. type: Plain text
#: ../src/Tutorial/IO.md:61
#, no-wrap
msgid ""
"It is important to understand that values of type `IO a` *describe*\n"
"a program, which, when being *executed*, will return a value of type `a`,\n"
"after performing arbitrary side effects along the way. For instance,\n"
"`putStrLn` has type `String -> IO ()`. Read this as: \"`putStrLn` is a function,\n"
"which, when given a `String` argument, will return a description of\n"
"an effectful program with an output type of `()`\".\n"
"(`()` is syntactic sugar for type `Unit`, the\n"
"empty tuple defined at the *Prelude*, which has only one value called `MkUnit`,\n"
"for which we can also use `()` in our code.)\n"
msgstr ""
"型`IO a`の値はプログラムを*記述*している、ということを理解することは大事です。\n"
"これは*実行*されると型`a`の値を返しますが、その道すがら任意の副作用を生じてからなのです。\n"
"例えば`putStrLn`は型`String -> IO ()`です。\n"
"読み下すとすればこうです。\n"
"「`putStrLn`は関数で、`String`引数を与えられると、\n"
"出力型が`()`の副作用付きのプログラムの記述を返す。」\n"
"（`()`は型`Unit`の糖衣構文で、*Prelude*で定義されている空タプルです。\n"
"`Unit`には唯一`MkUnit`という名前の値があり、コードでも`()`を使えるのです。）\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:72
#, no-wrap
msgid ""
"Since values of type `IO a` are mere descriptions of effectful computations,\n"
"functions returning such values or taking such values as\n"
"arguments are still *pure* and thus referentially transparent.\n"
"It is, however, not possible to extract a value of type `a` from\n"
"a value of type `IO a`, that is, there is no generic function `IO a -> a`,\n"
"as such a function would inadvertently execute the side\n"
"effects when extracting the result from its argument,\n"
"thus breaking referential transparency.\n"
"(Actually, there *is* such a function called `unsafePerformIO`.\n"
"Do not ever use it in your code unless you know what you are doing.)\n"
msgstr ""
"型`IO a`の値は作用付き計算の記述に過ぎないことから、\n"
"そのような値を返したり引数として値を取ったりする関数はそれでもなお*純粋*で、つまりは参照透過なのです。\n"
"しかしながら、型`a`の値を型`IO a`の値から抽出することは不可能です。\n"
"というのは、汎化関数`IO a -> a`は存在しないということですが、\n"
"これは関数が引数から結果を抽出するときにうっかり副作用を実行するであろうからで、\n"
"つまりは参照透過性を破っているのです。\n"
"（実は`unsafePerformIO`という名前の関数が*あります*。\n"
"何をするものかわかっていない限り、決してコードで使わないでください。）\n"

#. type: Title ###
#: ../src/Tutorial/IO.md:73
#, no-wrap
msgid "Do Blocks"
msgstr "doブロック"

#. type: Plain text
#: ../src/Tutorial/IO.md:83
#, no-wrap
msgid ""
"If you are new to pure functional programming, you might now - rightfully -\n"
"mumble something about how useless it is to\n"
"have descriptions of effectful programs without being able to run them.\n"
"So please, hear me out. While we are not able to run values of type\n"
"`IO a` when writing programs, that is, there is no function of\n"
"type `IO a -> a`, we are able to chain such computations and describe more\n"
"complex programs. Idris provides special syntax for this: *Do blocks*.\n"
"Here's an example:\n"
msgstr ""
"純粋関数型プログラミングを始めたてだったら、\n"
"今頃恐らく、というかきっと、実行できない作用付きプログラムのの記述の役立たなさを愚痴っているかもしれません。\n"
"まあ、聞いてください。\n"
"型`IO a`の値を実行することはできない、\n"
"つまり型`IO a -> a`の関数はどこにもありませんが、\n"
"こうした計算を連鎖させてより複雑なプログラムを記述できます。\n"
"Idrisはこのための特別な文法、*doブロック*を提供しています。\n"
"以下は例です。\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/IO.md:84
#, no-wrap
msgid ""
"readHello : IO ()\n"
"readHello = do\n"
"  name <- getLine\n"
"  putStrLn $ \"Hello \" ++ name ++ \"!\"\n"
msgstr ""
"readHello : IO ()\n"
"readHello = do\n"
"  name <- getLine\n"
"  putStrLn $ \"Hello \" ++ name ++ \"!\"\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:93
msgid ""
"Before we talk about what's going on here, let's give this a go at the REPL:"
msgstr "何が起こっているのかをお話しする前に、REPLでやってみましょう。"

#. type: Fenced code block (repl)
#: ../src/Tutorial/IO.md:94
#, no-wrap
msgid ""
"Tutorial.IO> :exec readHello\n"
"Stefan\n"
"Hello Stefan!\n"
msgstr ""
"Tutorial.IO> :exec readHello\n"
"Stefan\n"
"Hello Stefan!\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:104
msgid ""
"This is an interactive program, which will read a line from standard input "
"(`getLine`), assign the result to variable `name`, and then use `name` to "
"create a friendly greeting and write it to standard output."
msgstr ""
"これは対話的プログラムであり、標準入力から1行読んで (`getLine`)、\n"
"結果を変数`name`に代入し、\n"
"そうして`name`を使って気さくな挨拶文をつくって標準出力に書き込みます。"

#. type: Plain text
#: ../src/Tutorial/IO.md:114
#, no-wrap
msgid ""
"Note the `do` keyword at the beginning of the implementation of `readHello`:\n"
"It starts a *do block*, where we can chain `IO` computations and bind\n"
"intermediary results to variables using arrows pointing\n"
"to the left (`<-`), which can then be used in later\n"
"`IO` actions. This concept is powerful enough to let us encapsulate arbitrary\n"
"programs with side effects in a single value of type `IO`. Such a\n"
"description can then be returned by function `main`, the main entry point\n"
"to an Idris program, which is being executed when we run a compiled\n"
"Idris binary.\n"
msgstr ""
"`readHello`の実装の初めにある`do`キーワードに注目してください。\n"
"このキーワードから*doブロック*が始まり、\n"
"ここでは`IO`計算を連鎖できたり、\n"
"左向きの矢印 (`<-`) を使って中間結果を変数に束縛し、あとの`IO`行動で使えるようにできたりします。\n"
"型`IO`の値1つに副作用付きの任意のプログラムを内蔵化できるほどこの概念は強力です。\n"
"このような表現はそれから関数`main`から返されます。\n"
"`main`はIdrisプログラムへの主な入口で、コンパイルされたIdrisバイナリを走らせるときに実行されます。\n"

#. type: Title ###
#: ../src/Tutorial/IO.md:115
#, no-wrap
msgid "The Difference between Program Description and Execution"
msgstr "プログラム記述と実行の違い"

#. type: Plain text
#: ../src/Tutorial/IO.md:120
msgid ""
"In order to better understand the difference between *describing* an "
"effectful computation and *executing* or *running* it, here is a small "
"program:"
msgstr ""
"作用のある計算を*記述*することと、*実行し*たり*走らせ*たりすること、この違い"
"をよりよく理解するために、\n"
"以下の小さなプラグラムを見てみましょう。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/IO.md:121
#, no-wrap
msgid ""
"launchMissiles : IO ()\n"
"launchMissiles = putStrLn \"Boom! You're dead.\"\n"
"\n"
"friendlyReadHello : IO ()\n"
"friendlyReadHello = do\n"
"  _ <- putStrLn \"Please enter your name.\"\n"
"  readHello\n"
"\n"
"actions : Vect 3 (IO ())\n"
"actions = [launchMissiles, friendlyReadHello, friendlyReadHello]\n"
"\n"
"runActions : Vect (S n) (IO ()) -> IO ()\n"
"runActions (_ :: xs) = go xs\n"
"  where go : Vect k (IO ()) -> IO ()\n"
"        go []        = pure ()\n"
"        go (y :: ys) = do\n"
"          _ <- y\n"
"          go ys\n"
"\n"
"readHellos : IO ()\n"
"readHellos = runActions actions\n"
msgstr ""
"launchMissiles : IO ()\n"
"launchMissiles = putStrLn \"Boom! You're dead.\"\n"
"\n"
"friendlyReadHello : IO ()\n"
"friendlyReadHello = do\n"
"  _ <- putStrLn \"Please enter your name.\"\n"
"  readHello\n"
"\n"
"actions : Vect 3 (IO ())\n"
"actions = [launchMissiles, friendlyReadHello, friendlyReadHello]\n"
"\n"
"runActions : Vect (S n) (IO ()) -> IO ()\n"
"runActions (_ :: xs) = go xs\n"
"  where go : Vect k (IO ()) -> IO ()\n"
"        go []        = pure ()\n"
"        go (y :: ys) = do\n"
"          _ <- y\n"
"          go ys\n"
"\n"
"readHellos : IO ()\n"
"readHellos = runActions actions\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:153
#, no-wrap
msgid ""
"Before I explain what the code above does, please note function\n"
"`pure` used in the implementation of `runActions`. It is\n"
"a constrained function, about which we will learn in the next\n"
"chapter. Specialized to `IO`, it has generic type `a -> IO a`:\n"
"It allows us to wrap a value in an `IO` action. The resulting\n"
"`IO` program will just return the wrapped value without performing\n"
"any side effects. We can now look at the big picture of what's\n"
"going on in `readHellos`.\n"
msgstr ""
"上のコードが何をするのかを説明する前に、\n"
"`runActions`の実装で使われている関数`pure`を見てください。\n"
"これは制約付き関数ですが、これについては次の章で学びましょう。\n"
"`IO`に特化すれば汎化型`a -> IO a`です。\n"
"つまり値を`IO`行動に包むことができます。\n"
"`IO`プログラムの結果は副作用を生じることなく単に包まれた値を返します。\n"
"これで`readHellos`で何が起こっているのかを大局的に眺められます。\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:160
msgid ""
"First, we define a friendlier version of `readHello`: When executed, this "
"will ask about our name explicitly. Since we will not use the result of "
"`putStrLn` any further, we can use an underscore as a catch-all pattern "
"here. Afterwards, `readHello` is invoked. We also define `launchMissiles`, "
"which, when being executed, will lead to the destruction of planet earth."
msgstr ""
"まず、`readHello`のよりやさしい版を定義します。\n"
"実行されると名前をはっきりと尋ねます。\n"
"`putStrLn`の結果をこれ以上使うことがないので、全て堰き止めるパターンとしての"
"下線文字をここで使えます。\n"
"そのあとで`readHello`が呼び出されます。\n"
"`launchMissiles`も定義します。\n"
"これが実行されると惑星地球が破壊されてしまいます。"

#. type: Plain text
#: ../src/Tutorial/IO.md:169
msgid ""
"Now, `runActions` is the function we use to demonstrate that *describing* an "
"`IO` action is not the same as *running* it. It will drop the first action "
"from the non-empty vector it takes as its argument and return a new `IO` "
"action, which describes the execution of the remaining `IO` actions in "
"sequence. If this behaves as expected, the first `IO` action passed to "
"`runActions` should be silently dropped together with all its potential side "
"effects."
msgstr ""
"さて、`runActions`は`IO`行動を*記述する*ことが*走らせる*ことと同じではないこ"
"とを実演する関数です。\n"
"これは引数として取る非空ベクタから最初の行動を切り落として新しい`IO`行動を返"
"します。\n"
"返される行動は残りの`IO`行動を順番に実行する記述です。\n"
"もしこれが期待通りに振る舞うとしたら、\n"
"`runActions`に渡された最初の`IO`行動はあらゆる潜在的な副作用とともに黙殺され"
"ます。"

#. type: Plain text
#: ../src/Tutorial/IO.md:174
msgid ""
"When we execute `readHellos` at the REPL, we will be asked for our name "
"twice, although `actions` also contains `launchMissiles` at the beginning. "
"Luckily, although we described how to destroy the planet, the action was not "
"executed, and we are (probably) still here."
msgstr ""
"REPLで`readHellos`を実行すると、\n"
"`actions`は最初に`launchMissiles`も含んでいますが、名前を2回尋ねられます。\n"
"惑星を破壊する方法を記述したものの、\n"
"運よくその行動は実行されず、そして私達は（たぶん）まだここに立っています。"

#. type: Plain text
#: ../src/Tutorial/IO.md:176
msgid "From this example we learn several things:"
msgstr "この例からいくつかのことを学びました。"

#. type: Bullet: '* '
#: ../src/Tutorial/IO.md:180
msgid ""
"Values of type `IO a` are *pure descriptions* of programs, which, when being "
"*executed*, perform arbitrary side effects before returning a value of type "
"`a`."
msgstr ""
"型`IO a`の値はプログラムの*純粋記述*です。\n"
"この記述が*実行*されると型`a`の値を返す前にありとあらゆる副作用を生じます。"

#. type: Bullet: '* '
#: ../src/Tutorial/IO.md:184
msgid ""
"Values of type `IO a` can be safely returned from functions and passed "
"around as arguments or in data structures, without the risk of them being "
"executed."
msgstr ""
"型`IO a`の値は安全に関数から返したり引数やデータ構造に入れて受け渡したりでき"
"ます。\n"
"実行される惧れはありません。"

#. type: Bullet: '* '
#: ../src/Tutorial/IO.md:187
msgid ""
"Values of type `IO a` can be safely combined in *do blocks* to *describe* "
"new `IO` actions."
msgstr "型`IO a`の値は*doブロック*で安全に新しい`IO`行動に結合できます。"

#. type: Bullet: '* '
#: ../src/Tutorial/IO.md:191
msgid ""
"An `IO` action will only ever get executed when it's passed to `:exec` at "
"the REPL, or when it is the `main` function of a compiled Idris program that "
"is being executed."
msgstr ""
"`IO`行動は、REPLで`:exec`に渡されたり、\n"
"コンパイルされたIdrisプログラムの`main`関数から実行されるものであったりすると"
"きにのみ実行されます。"

#. type: Bullet: '* '
#: ../src/Tutorial/IO.md:196
msgid ""
"It is not possible to ever break out of the `IO` context: There is no "
"function of type `IO a -> a`, as such a function would need to execute its "
"argument in order to extract the final result, and this would break "
"referential transparency."
msgstr ""
"`IO`文脈の殻を破ることは絶対にできません。\n"
"つまり型`IO a -> a`の関数はありませんが、\n"
"それはそうした関数が最終的な結果を抽出するために引数を順番に実行する必要があ"
"り、\n"
"これが参照透過性を破るからです。"

#. type: Title ###
#: ../src/Tutorial/IO.md:197
#, no-wrap
msgid "Combining Pure Code with `IO` Actions"
msgstr "純粋なコードと`IO`行動をくっつける"

#. type: Plain text
#: ../src/Tutorial/IO.md:202
msgid ""
"The title of this subsection is somewhat misleading. `IO` actions *are* pure "
"values, but what is typically meant here, is that we combine non-`IO` "
"functions with effectful computations."
msgstr ""
"この小節の題はどこか誤読を誘うところがあります。\n"
"`IO`行動は純粋な値*です*が、\n"
"ここでの意味は`IO`ではない関数と作用のある計算をくっつけることです。"

#. type: Plain text
#: ../src/Tutorial/IO.md:208
msgid ""
"As a demonstration, in this section we are going to write a small program "
"for evaluating arithmetic expressions. We are going to keep things simple "
"and allow only expressions with a single operator and two arguments, both of "
"which must be integers, for instance `12 + 13`."
msgstr ""
"実演として本節では計算式を評価する小さなプログラムを書いていきます。\n"
"話を簡単にして演算子1つと2つの引数がある式のみ許すことにします。\n"
"引数はどちらも整数でなければならず、例えば`12 + 13`です。"

#. type: Plain text
#: ../src/Tutorial/IO.md:216
msgid ""
"We are going to use function `split` from `Data.String` in *base* to "
"tokenize arithmetic expressions. We are then trying to parse the two integer "
"values and the operator. These operations might fail, since user input can "
"be invalid, so we also need an error type. We could actually just use "
"`String`, but I consider it to be good practice to use custom sum types for "
"erroneous conditions."
msgstr ""
"*base*の`Data.String`由来の関数`split`を使って計算式を字句解析していきま"
"す。\n"
"それから2つの整数値と演算子のパースを試みます。\n"
"利用者の入力は不正かもしれず、これらの操作は失敗するかもしれません。\n"
"そのためエラー型も必要です。\n"
"実のところエラー型には単に`String`を使ってもいいのですが、\n"
"エラーの条件のための自前の直和型を使うことは良い作法だと考えます。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/IO.md:217
#, no-wrap
msgid ""
"data Error : Type where\n"
"  NotAnInteger    : (value : String) -> Error\n"
"  UnknownOperator : (value : String) -> Error\n"
"  ParseError      : (input : String) -> Error\n"
"\n"
"dispError : Error -> String\n"
"dispError (NotAnInteger v)    = \"Not an integer: \" ++ v ++ \".\"\n"
"dispError (UnknownOperator v) = \"Unknown operator: \" ++ v ++ \".\"\n"
"dispError (ParseError v)      = \"Invalid expression: \" ++ v ++ \".\"\n"
msgstr ""
"data Error : Type where\n"
"  NotAnInteger    : (value : String) -> Error\n"
"  UnknownOperator : (value : String) -> Error\n"
"  ParseError      : (input : String) -> Error\n"
"\n"
"dispError : Error -> String\n"
"dispError (NotAnInteger v)    = \"Not an integer: \" ++ v ++ \".\"\n"
"dispError (UnknownOperator v) = \"Unknown operator: \" ++ v ++ \".\"\n"
"dispError (ParseError v)      = \"Invalid expression: \" ++ v ++ \".\"\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:231
msgid ""
"In order to parse integer literals, we use function `parseInteger` from "
"`Data.String`:"
msgstr ""
"整数表記をパースするために`Data.String`の関数`parseInteger`を使います。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/IO.md:232
#, no-wrap
msgid ""
"readInteger : String -> Either Error Integer\n"
"readInteger s = maybe (Left $ NotAnInteger s) Right $ parseInteger s\n"
msgstr ""
"readInteger : String -> Either Error Integer\n"
"readInteger s = maybe (Left $ NotAnInteger s) Right $ parseInteger s\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:239
msgid ""
"Likewise, we declare and implement a function for parsing arithmetic "
"operators:"
msgstr "同様に計算演算子をパースする関数を宣言し実装します。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/IO.md:240
#, no-wrap
msgid ""
"readOperator : String -> Either Error (Integer -> Integer -> Integer)\n"
"readOperator \"+\" = Right (+)\n"
"readOperator \"*\" = Right (*)\n"
"readOperator s   = Left (UnknownOperator s)\n"
msgstr ""
"readOperator : String -> Either Error (Integer -> Integer -> Integer)\n"
"readOperator \"+\" = Right (+)\n"
"readOperator \"*\" = Right (*)\n"
"readOperator s   = Left (UnknownOperator s)\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:254
msgid ""
"We are now ready to parse and evaluate simple arithmetic expressions. This "
"consists of several steps (splitting the input string, parsing each "
"literal), each of which can fail.  Later, when we learn about monads, we "
"will see that do blocks can be used in such occasions just as well. However, "
"in this case we can use an alternative syntactic convenience: Pattern "
"matching in let bindings. Here is the code:"
msgstr ""
"これで簡単な計算式をパースし評価する準備ができました。\n"
"これはいくつかの段階（入力文字列を分割し、それぞれの表記をパースする）からな"
"り、\n"
"それぞれの段階は失敗しうるものです。\n"
"あとでモナドを学んだら、\n"
"doブロックがそうした場合にちょうど同じように使えることを見ていきます。\n"
"しかしこの場合代わりの文法的な便宜を図れます。\n"
"let束縛でパターンマッチするのです。\n"
"以下がコードです。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/IO.md:255
#, no-wrap
msgid ""
"eval : String -> Either Error Integer\n"
"eval s =\n"
"  let [x,y,z]  := forget $ split isSpace s | _ => Left (ParseError s)\n"
"      Right v1 := readInteger x  | Left e => Left e\n"
"      Right op := readOperator y | Left e => Left e\n"
"      Right v2 := readInteger z  | Left e => Left e\n"
"   in Right $ op v1 v2\n"
msgstr ""
"eval : String -> Either Error Integer\n"
"eval s =\n"
"  let [x,y,z]  := forget $ split isSpace s | _ => Left (ParseError s)\n"
"      Right v1 := readInteger x  | Left e => Left e\n"
"      Right op := readOperator y | Left e => Left e\n"
"      Right v2 := readInteger z  | Left e => Left e\n"
"   in Right $ op v1 v2\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:280
msgid ""
"Let's break this down a bit. On the first line, we split the input string at "
"all whitespace occurrences. Since `split` returns a `List1` (a type for non-"
"empty lists exported from `Data.List1` in *base*) but pattern matching on "
"`List` is more convenient, we convert the result using `Data.List1.forget`. "
"Note, how we use a pattern match on the left hand side of the assignment "
"operator `:=`.  This is a partial pattern match (*partial* meaning, that it "
"doesn't cover all possible cases), therefore we have to deal with the other "
"possibilities as well, which is done after the vertical line. This can be "
"read as follows: \"If the pattern match on the left hand side is successful, "
"and we get a list of exactly three tokens, continue with the `let` "
"expression, otherwise return a `ParseError` in a `Left` immediately\"."
msgstr ""
"これを少し解剖しましょう。\n"
"最初の行では入力文字列を全ての空白のある位置で分割します。\n"
"`split`は`List1`（*base*の`Data.List1`から高階されている非空のリスト型）を返"
"しますが、\n"
"`List`でパターン照合するほうがもっと便利なので、\n"
"`Data.List1.forget`を使って結果を変換します。\n"
"ここで代入演算子`:=`の左側でパターン照合を使っていますね。\n"
"これは部分パターン照合（*部分*というのは、全ての可能な場合を網羅していないか"
"らです）なので、\n"
"他の可能性も同様に対処しなければいけません。\n"
"その対処は垂直線のあとで行われます。\n"
"これは次のように読めます。\n"
"「もし左側のパターン照合が成功し、ちょうど3つの字句のリストが得られたら、\n"
"`let`式を続ける。\n"
"そうでなければ直ちに`ParseError`を`Left`に入れて返す。」"

#. type: Plain text
#: ../src/Tutorial/IO.md:286
msgid ""
"The other three lines behave exactly the same: Each has a partial pattern "
"match on the left hand side with instructions what to return in case of "
"invalid input after the vertical bar. We will later see, that this syntax is "
"also available in *do blocks*."
msgstr ""
"他の3行はちょうど同じように振舞います。\n"
"つまり、それぞれに左側に部分パターン照合がありつつ、\n"
"垂直棒のあとに不正な入力の場合に何を返すかという説明があります。\n"
"あとで見ていきますが、この構文は*doブロック*でも使えます。"

#. type: Plain text
#: ../src/Tutorial/IO.md:294
msgid ""
"Note, how all of the functionality implemented so far is *pure*, that is, it "
"does not describe computations with side effects. (One could argue that "
"already the possibility of failure is an observable *effect*, but even then, "
"the code above is still referentially transparent, can be easily tested at "
"the REPL, and evaluated at compile time, which is the important thing here.)"
msgstr ""
"ここで、これまで実装してきた機能の全ては*純粋*で、\n"
"副作用のある計算を記述していません。\n"
"（すでに失敗の可能性は観測できる*作用*だと言い張ることもできますが、\n"
"しかしそうだとしても上のコードはそれでも参照透過で、\n"
"REPLで簡単に試せたりコンパイル時に評価できます。\n"
"ここではこれが大事です。）"

#. type: Plain text
#: ../src/Tutorial/IO.md:298
msgid ""
"Finally, we can wrap this functionality in an `IO` action, which reads a "
"string from standard input and tries to evaluate the arithmetic expression:"
msgstr ""
"ついにこの機能を`IO`行動に包むことができます。\n"
"これは標準入力から文字列を読み取って計算式を評価しようとします。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/IO.md:299
#, no-wrap
msgid ""
"exprProg : IO ()\n"
"exprProg = do\n"
"  s <- getLine\n"
"  case eval s of\n"
"    Left err  => do\n"
"      putStrLn \"An error occured:\"\n"
"      putStrLn (dispError err)\n"
"    Right res => putStrLn (s ++ \" = \" ++ show res)\n"
msgstr ""
"exprProg : IO ()\n"
"exprProg = do\n"
"  s <- getLine\n"
"  case eval s of\n"
"    Left err  => do\n"
"      putStrLn \"An error occured:\"\n"
"      putStrLn (dispError err)\n"
"    Right res => putStrLn (s ++ \" = \" ++ show res)\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:316
msgid ""
"Note, how in `exprProg` we were forced to deal with the possibility of "
"failure and handle both constructors of `Either` differently in order to "
"print a result.  Note also, that *do blocks* are ordinary expressions, and "
"we can, for instance, start a new *do block* on the right hand side of a "
"case expression."
msgstr ""
"`exprProg`で失敗する可能性に対処することを強いられており、\n"
"結果を表示するために`Either`の両方の構築子をそれぞれ扱っていますよね。\n"
"あと、*doブロック*は普通の式なので、\n"
"例えばcase式の右側で新しい*doブロック*を始められますよ。"

#. type: Plain text
#: ../src/Tutorial/IO.md:329
msgid ""
"In these exercises, you are going to implement some small command-line "
"applications. Some of these will potentially run forever, as they will only "
"stop when the user enters a keyword for quitting the application. Such "
"programs are no longer provably total. If you added the `%default total` "
"pragma at the top of your source file, you'll need to annotate these "
"functions with `covering`, meaning that you covered all cases in all pattern "
"matches but your program might still loop due to unrestricted recursion."
msgstr ""
"この演習では小さなコマンドラインアプリケーションを実装していきます。\n"
"いくつかのものはアプリケーションを終了するためにキーワードを入力したときだけ"
"止まるものなので、\n"
"潜在的に永久に実行されます。\n"
"そうしたプログラムはもはや全域であることは証明されません。\n"
"ソースファイルの冒頭に`%default total`プラグマを加えていたら、\n"
"これらの関数を`covering`で註釈する必要があります。\n"
"これは全てのパターン照合の全ての場合を網羅できているものの、\n"
"制約のない再帰によりプログラムが堂々巡りになるかもしれないことを意味します。"

#. type: Bullet: '1. '
#: ../src/Tutorial/IO.md:333
msgid ""
"Implement function `rep`, which will read a line of input from the terminal, "
"evaluate it using the given function, and print the result to standard "
"output:"
msgstr ""
"関数`rep`を実装してください。\n"
"これは端末からの入力のうち1行を読み、与えられた関数を使って評価し、\n"
"そして標準出力に結果を印字します。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/IO.md:334
#, no-wrap
msgid "   rep : (String -> String) -> IO ()\n"
msgstr "   rep : (String -> String) -> IO ()\n"

#. type: Bullet: '2. '
#: ../src/Tutorial/IO.md:341
msgid ""
"Implement function `repl`, which behaves just like `rep` but will repeat "
"itself forever (or until being forcefully terminated):"
msgstr ""
"関数`repl`を実装してください。\n"
"これは`rep`のように振舞いますが、\n"
"（強制的に終了されるまで）永遠に関数自身を繰り返します。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/IO.md:342
#, no-wrap
msgid ""
"   covering\n"
"   repl : (String -> String) -> IO ()\n"
msgstr ""
"   covering\n"
"   repl : (String -> String) -> IO ()\n"

#. type: Bullet: '3. '
#: ../src/Tutorial/IO.md:351
msgid ""
"Implement function `replTill`, which behaves just like `repl` but will only "
"continue looping if the given function returns a `Right`. If it returns a "
"`Left`, `replTill` should print the final message wrapped in the `Left` and "
"then stop."
msgstr ""
"関数`replTill`を実装してください。\n"
"これはちょうど`repl`のように振舞いますが、\n"
"与えられた関数が`Right`を返したときだけ繰り返すのを続けます。\n"
"`Left`を返したら`replTill`は`Left`に包まれた最後の文言で印字し、それから停止"
"します。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/IO.md:352
#, no-wrap
msgid ""
"   covering\n"
"   replTill : (String -> Either String String) -> IO ()\n"
msgstr ""
"   covering\n"
"   replTill : (String -> Either String String) -> IO ()\n"

#. type: Bullet: '4. '
#: ../src/Tutorial/IO.md:364
msgid ""
"Write a program, which reads arithmetic expressions from standard input, "
"evaluates them using `eval`, and prints the result to standard output. The "
"program should loop until users stops it by entering \"done\", in which case "
"the program should terminate with a friendly greeting.  Use `replTill` in "
"your implementation."
msgstr ""
"計算式を標準入力から読み、`eval`を使って評価し、\n"
"標準出力に結果を印字するプログラムを書いてください。\n"
"プログラムは利用者が \"done\" と入力して停止させるまで繰り返します。\n"
"停止された場合はプログラムは気さくな挨拶とともに終了します。\n"
"実装では`replTill`を使ってください。"

#. type: Bullet: '5. '
#: ../src/Tutorial/IO.md:373
msgid ""
"Implement function `replWith`, which behaves just like `repl` but uses some "
"internal state to accumulate values.  At each iteration (including the very "
"first one!), the current state should be printed to standard output using "
"function `dispState`, and the next state should be computed using function "
"`next`.  The loop should terminate in case of a `Left` and print a final "
"message using `dispResult`:"
msgstr ""
"関数`replWith`を実装してください。\n"
"これはちょうど`repl`と同じように振舞いますが、\n"
"内部状態を使って値を積み重ねます。\n"
"それぞれの回（初回も含みます！）で関数`dispState`を使って現在の状態が標準出力"
"に印字され、\n"
"次の状態は関数`next`を使って計算されます。\n"
"繰り返しは`Left`の場合に終了し、`dispResult`を使って最後の文言を印字します。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/IO.md:374
#, no-wrap
msgid ""
"   covering\n"
"   replWith :  (state      : s)\n"
"            -> (next       : s -> String -> Either res s)\n"
"            -> (dispState  : s -> String)\n"
"            -> (dispResult : res -> s -> String)\n"
"            -> IO ()\n"
msgstr ""
"   covering\n"
"   replWith :  (state      : s)\n"
"            -> (next       : s -> String -> Either res s)\n"
"            -> (dispState  : s -> String)\n"
"            -> (dispResult : res -> s -> String)\n"
"            -> IO ()\n"

#. type: Bullet: '6. '
#: ../src/Tutorial/IO.md:388
msgid ""
"Use `replWith` from Exercise 5 to write a program for reading natural "
"numbers from standard input and printing the accumulated sum of these "
"numbers.  The program should terminate in case of invalid input and if a "
"user enters \"done\"."
msgstr ""
"問題5の`replWith`を使って、標準入力から自然数を読み、\n"
"積み重ねられたこれらの数値の合計を印字するプログラムを書いてください。\n"
"プログラムは不正な入力の場合と利用者が \"done\" が入力したときに終了します。"

#. type: Title ##
#: ../src/Tutorial/IO.md:389
#, no-wrap
msgid "Do Blocks, Desugared"
msgstr "doブロックとその脱糖"

#. type: Plain text
#: ../src/Tutorial/IO.md:402
msgid ""
"Here's an important piece of information: There is nothing special about *do "
"blocks*. They are just syntactic sugar, which is converted to a sequence of "
"operator applications.  With [syntactic sugar](https://en.wikipedia.org/wiki/"
"Syntactic_sugar), we mean syntax in a programming language that makes it "
"easier to express certain things in that language without making the "
"language itself any more powerful or expressive.  Here, it means you could "
"write all the `IO` programs without using `do` notation, but the code you'll "
"write will sometimes be harder to read, so *do blocks* provide nicer syntax "
"for these occasions."
msgstr ""
"ここで大事なお知らせがあります。\n"
"*doブロック*について特別なことは何もないということです。\n"
"これは単なる糖衣構文で、演算子の適用の羅列に変換されます。\n"
"[糖衣構文](https://en.wikipedia.org/wiki/Syntactic_sugar)があれば、\n"
"少しも言語自体を強力にしたり表現力豊かにすることなく、\n"
"その言語で特定のことを表現することをより簡単にできるようなプログラミング言語"
"での構文で書くことができます。\n"
"つまり全ての`IO`プログラムを`do`記法を使わずに書くことができるのですが、\n"
"書いたコードはしばしば読みにくくなるでしょう。\n"
"*doブロック*はそうした場合によりよい構文を提供するものです。"

#. type: Plain text
#: ../src/Tutorial/IO.md:404
msgid "Consider the following example program:"
msgstr "以下のプログラム例について考えます。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/IO.md:405
#, no-wrap
msgid ""
"sugared1 : IO ()\n"
"sugared1 = do\n"
"  str1 <- getLine\n"
"  str2 <- getLine\n"
"  str3 <- getLine\n"
"  putStrLn (str1 ++ str2 ++ str3)\n"
msgstr ""
"sugared1 : IO ()\n"
"sugared1 = do\n"
"  str1 <- getLine\n"
"  str2 <- getLine\n"
"  str3 <- getLine\n"
"  putStrLn (str1 ++ str2 ++ str3)\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:416
msgid ""
"The compiler will convert this to the following program *before "
"disambiguating function names and type checking*:"
msgstr ""
"コンパイラは*関数名の曖昧性を解決して型検査する前に*これを以下のプログラムに"
"変換します。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/IO.md:417
#, no-wrap
msgid ""
"desugared1 : IO ()\n"
"desugared1 =\n"
"  getLine >>= (\\str1 =>\n"
"    getLine >>= (\\str2 =>\n"
"      getLine >>= (\\str3 =>\n"
"        putStrLn (str1 ++ str2 ++ str3)\n"
"      )\n"
"    )\n"
"  )\n"
msgstr ""
"desugared1 : IO ()\n"
"desugared1 =\n"
"  getLine >>= (\\str1 =>\n"
"    getLine >>= (\\str2 =>\n"
"      getLine >>= (\\str3 =>\n"
"        putStrLn (str1 ++ str2 ++ str3)\n"
"      )\n"
"    )\n"
"  )\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:432
#, no-wrap
msgid ""
"There is a new operator (`(>>=)`) called *bind* in the\n"
"implementation of `desugared1`. If you look at its type\n"
"at the REPL, you'll see the following:\n"
msgstr ""
"*bind*と呼ばれる新しい演算子 (`>>=`) が`desugared1`の実装中にあります。\n"
"REPLで型を見ると以下のようになっています。\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/IO.md:433
#, no-wrap
msgid ""
"Main> :t (>>=)\n"
"Prelude.>>= : Monad m => m a -> (a -> m b) -> m b\n"
msgstr ""
"Main> :t (>>=)\n"
"Prelude.>>= : Monad m => m a -> (a -> m b) -> m b\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:441
msgid ""
"This is a constrained function requiring an interface called `Monad`.  We "
"will talk about `Monad` and some of its friends in the next chapter. "
"Specialized to `IO`, *bind* has the following type:"
msgstr ""
"これは制約付き関数で`Monad`と呼ばれるインターフェースを必要とします。\n"
"`Monad`とその仲間達については次章でお話しします。\n"
"`IO`に限っていうと*bind*は以下の型を持ちます。"

#. type: Fenced code block (repl)
#: ../src/Tutorial/IO.md:442
#, no-wrap
msgid ""
"Main> :t (>>=) {m = IO}\n"
">>= : IO a -> (a -> IO b) -> IO b\n"
msgstr ""
"Main> :t (>>=) {m = IO}\n"
">>= : IO a -> (a -> IO b) -> IO b\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:451
msgid ""
"This describes a sequencing of `IO` actions. Upon execution, the first `IO` "
"action is being run and its result is being passed as an argument to the "
"function generating the second `IO` action, which is then also being "
"executed."
msgstr ""
"これは`IO`行動の連接を表現しています。\n"
"実行にあたって最初の`IO`行動が走り、\n"
"その結果が2つ目の`IO`行動を生成する関数に引数として渡されます。\n"
"2つ目の`IO`行動もそれから実行されていきます。"

#. type: Plain text
#: ../src/Tutorial/IO.md:466
msgid ""
"You might remember, that you already implemented something similar in an "
"earlier exercise: In [Algebraic Data Types](DataTypes.md), you implemented "
"*bind* for `Maybe` and `Either e`. We will learn in the next chapter, that "
"`Maybe` and `Either e` too come with an implementation of `Monad`. For now, "
"suffice to say that `Monad` allows us to run computations with some kind of "
"effect in sequence by passing the *result* of the first computation to the "
"function returning the second computation. In `desugared1` you can see, how "
"we first perform an `IO` action and use its result to compute the next `IO` "
"action and so on. The code is somewhat hard to read, since we use several "
"layers of nested anonymous function, that's why in such cases, *do blocks* "
"are a nice alternative to express the same functionality."
msgstr ""
"お気付きかもしれませんが、以前の演習で似たようなものを既に実装していまし"
"た。\n"
"[代数的データ型](DataTypes.md)で`Maybe`と`Either e`に*bind*を実装しました"
"ね。\n"
"次の章で学ぶことになりますが、\n"
"`Maybe`と`Either e`もまた`Monad`の実装が付属しています。\n"
"さしあたって言うべきこととしては、\n"
"`Monad`があれば何らかの種類の作用付きの計算を、\n"
"最初の計算の*結果*を2つ目の計算が返す関数に渡すことで、\n"
"順繰りに走らせられるということです。\n"
"`desugared1`を見るとわかりますが、\n"
"最初に`IO`行動を実施し、その結果を次の`IO`行動の計算に使い、というようになっ"
"ています。\n"
"コードはどこか読み辛いものですが、\n"
"これは何層にも入れ子になった匿名関数があるからで、\n"
"だからこそそうした場合に*doブロック*が同じ機能を表現するよりよい代替となるの"
"です。"

#. type: Plain text
#: ../src/Tutorial/IO.md:471
msgid ""
"Since *do block* are always desugared to sequences of applied *bind* "
"operators, we can use them to chain any monadic computation. For instance, "
"we can rewrite function `eval` by using a *do block* like so:"
msgstr ""
"*doブロック*は常に*bind*演算子の適用の羅列に脱糖されるため、\n"
"これを使っていかなるモナド計算をも連鎖させられます。\n"
"例えば関数`eval`を*doブロック*を使って書き換えられます。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/IO.md:472
#, no-wrap
msgid ""
"evalDo : String -> Either Error Integer\n"
"evalDo s = case forget $ split isSpace s of\n"
"  [x,y,z] => do\n"
"    v1 <- readInteger x\n"
"    op <- readOperator y\n"
"    v2 <- readInteger z\n"
"    Right $ op v1 v2\n"
"  _       => Left (ParseError s)\n"
msgstr ""
"evalDo : String -> Either Error Integer\n"
"evalDo s = case forget $ split isSpace s of\n"
"  [x,y,z] => do\n"
"    v1 <- readInteger x\n"
"    op <- readOperator y\n"
"    v2 <- readInteger z\n"
"    Right $ op v1 v2\n"
"  _       => Left (ParseError s)\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:488
msgid ""
"Don't worry, if this doesn't make too much sense yet. We will see many more "
"examples, and you'll get the hang of this soon enough. The important thing "
"to remember is how *do blocks* are always converted to sequences of *bind* "
"operators as shown in `desugared1`."
msgstr ""
"まだよく飲み込めていなくても心配ないです。\n"
"より多くの例を見ていくことで、もうじきに会得できるでしょう。\n"
"覚えておくべき大事なことは*doブロック*が常に`desugared1`に示したような\n"
"*bind*演算子の羅列に変換されるということです。"

#. type: Title ###
#: ../src/Tutorial/IO.md:489
#, no-wrap
msgid "Binding Unit"
msgstr "Unitを束縛する"

#. type: Plain text
#: ../src/Tutorial/IO.md:492
msgid "Remember our implementation of `friendlyReadHello`? Here it is again:"
msgstr ""
"`friendlyReadHello`の実装を覚えていますか？\n"
"以下に再掲します。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/IO.md:493
#, no-wrap
msgid ""
"friendlyReadHello' : IO ()\n"
"friendlyReadHello' = do\n"
"  _ <- putStrLn \"Please enter your name.\"\n"
"  readHello\n"
msgstr ""
"friendlyReadHello' : IO ()\n"
"friendlyReadHello' = do\n"
"  _ <- putStrLn \"Please enter your name.\"\n"
"  readHello\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:505
msgid ""
"The underscore in there is a bit ugly and unnecessary. In fact, a common use "
"case is to just chain effectful computations with result type `Unit` (`()`), "
"merely for the side effects they perform. For instance, we could repeat "
"`friendlyReadHello` three times, like so:"
msgstr ""
"下線文字がちょっと見辛く不必要です。\n"
"実際、よくある使用例は結果の型が`Unit` (`()`) で作用のある計算を単に連鎖させ"
"るだけであり、\n"
"発生する副作用だけがほしいのです。\n"
"例えば`friendlyReadHello`を3回繰り返すことができます、こんな風に。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/IO.md:506
#, no-wrap
msgid ""
"friendly3 : IO ()\n"
"friendly3 = do\n"
"  _ <- friendlyReadHello\n"
"  _ <- friendlyReadHello\n"
"  friendlyReadHello\n"
msgstr ""
"friendly3 : IO ()\n"
"friendly3 = do\n"
"  _ <- friendlyReadHello\n"
"  _ <- friendlyReadHello\n"
"  friendlyReadHello\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:516
msgid ""
"This is such a common thing to do, that Idris allows us to drop the bound "
"underscores altogether:"
msgstr ""
"これはよくあることなので、Idrisでは下線文字への束縛を一気に削ぎ落とすことがで"
"きます。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/IO.md:517
#, no-wrap
msgid ""
"friendly4 : IO ()\n"
"friendly4 = do\n"
"  friendlyReadHello\n"
"  friendlyReadHello\n"
"  friendlyReadHello\n"
"  friendlyReadHello\n"
msgstr ""
"friendly4 : IO ()\n"
"friendly4 = do\n"
"  friendlyReadHello\n"
"  friendlyReadHello\n"
"  friendlyReadHello\n"
"  friendlyReadHello\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:527
msgid "Note, however, that the above gets desugared slightly differently:"
msgstr "ただしかし、上記は僅かに違う風に脱糖されます。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/IO.md:528
#, no-wrap
msgid ""
"friendly4Desugared : IO ()\n"
"friendly4Desugared =\n"
"  friendlyReadHello >>\n"
"  friendlyReadHello >>\n"
"  friendlyReadHello >>\n"
"  friendlyReadHello\n"
msgstr ""
"friendly4Desugared : IO ()\n"
"friendly4Desugared =\n"
"  friendlyReadHello >>\n"
"  friendlyReadHello >>\n"
"  friendlyReadHello >>\n"
"  friendlyReadHello\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:538
#, no-wrap
msgid "Operator `(>>)` has the following type:\n"
msgstr "演算子 `(>>)` は以下の型を持ちます。\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/IO.md:539
#, no-wrap
msgid ""
"Main> :t (>>)\n"
"Prelude.>> : Monad m => m () -> Lazy (m b) -> m b\n"
msgstr ""
"Main> :t (>>)\n"
"Prelude.>> : Monad m => m () -> Lazy (m b) -> m b\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:550
msgid ""
"Note the `Lazy` keyword in the type signature. This means, that the wrapped "
"argument will be *lazily evaluated*. This makes sense in many occasions. For "
"instance, if the `Monad` in question is `Maybe` the result will be `Nothing` "
"if the first argument is `Nothing`, in which case there is no need to even "
"evaluate the second argument."
msgstr ""
"型処方中に`Lazy`キーワードがありますね。\n"
"これが意味するのは、包まれた引数が*遅延評価*されるということです。\n"
"これは多くの場合理に適っています。\n"
"例えばもし問題の`Monad`が`Maybe`であれば、最初の引数が`Nothing`なら結果が"
"`Nothing`になるでしょう。\n"
"その場合2つ目の引数を評価する必要さえないのです。"

#. type: Title ###
#: ../src/Tutorial/IO.md:551
#, no-wrap
msgid "Do, Overloaded"
msgstr "doをオーバーロード"

#. type: Plain text
#: ../src/Tutorial/IO.md:562
#, no-wrap
msgid ""
"Because Idris supports function and operator overloading, we\n"
"can write custom *bind* operators, which allows us to\n"
"use *do notation* for types without an implementation\n"
"of `Monad`. For instance, here is a custom implementation of\n"
"`(>>=)` for sequencing computations returning vectors.\n"
"Every value in the first vector (of length `m`)\n"
"will be converted to a vector of length `n`, and\n"
"the results will be concatenated leading to\n"
"a vector of length `m * n`:\n"
msgstr ""
"Idrisでは関数と演算子のオーバーロードができるので、\n"
"自前の*束縛*演算子を書くことができ、\n"
"これによって`Monad`の実装を持たない型にも*do記法*が使えます。\n"
"例えば以下はベクタを返す連続計算のための`(>>=)`の自前実装です。\n"
"（長さ`m`の）1つ目のベクタ中の全ての値が長さ`n`のベクタに変換され、\n"
"連結された結果となるため長さ`m * n`のベクタになります。\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/IO.md:563
#, no-wrap
msgid ""
"flatten : Vect m (Vect n a) -> Vect (m * n) a\n"
"flatten []        = []\n"
"flatten (x :: xs) = x ++ flatten xs\n"
"\n"
"(>>=) : Vect m a -> (a -> Vect n b) -> Vect (m * n) b\n"
"as >>= f = flatten (map f as)\n"
msgstr ""
"flatten : Vect m (Vect n a) -> Vect (m * n) a\n"
"flatten []        = []\n"
"flatten (x :: xs) = x ++ flatten xs\n"
"\n"
"(>>=) : Vect m a -> (a -> Vect n b) -> Vect (m * n) b\n"
"as >>= f = flatten (map f as)\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:580
#, no-wrap
msgid ""
"It is not possible to write an implementation of `Monad`,\n"
"which encapsulates this behavior, as the types wouldn't\n"
"match: Monadic *bind* specialized to `Vect` has\n"
"type `Vect k a -> (a -> Vect k b) -> Vect k b`. As you\n"
"see, the sizes of all three occurrences of `Vect`\n"
"have to be the same, which is not what we expressed\n"
"in our custom version of *bind*. Here is an example to\n"
"see this in action:\n"
msgstr ""
"この振舞いを内蔵化するような`Monad`の実装を書くことはできません。\n"
"型が合わないからです。\n"
"というのは、`Vect`に特化したモナドな*束縛*は`Vect k a -> (a -> Vect k b) -> Vect k b`の型を持つからです。\n"
"見てわかるように出現する3箇所の`Vect`大きさはどれも同じであり、\n"
"これは自家製の*束縛*で表現しているものと異なります。\n"
"実際に動かしてみた例は以下です。\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/IO.md:581
#, no-wrap
msgid ""
"modString : String -> Vect 4 String\n"
"modString s = [s, reverse s, toUpper s, toLower s]\n"
"\n"
"testDo : Vect 24 String\n"
"testDo = IO.do\n"
"  s1 <- [\"Hello\", \"World\"]\n"
"  s2 <- [1, 2, 3]\n"
"  modString (s1 ++ show s2)\n"
msgstr ""
"modString : String -> Vect 4 String\n"
"modString s = [s, reverse s, toUpper s, toLower s]\n"
"\n"
"testDo : Vect 24 String\n"
"testDo = IO.do\n"
"  s1 <- [\"Hello\", \"World\"]\n"
"  s2 <- [1, 2, 3]\n"
"  modString (s1 ++ show s2)\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:601
msgid ""
"Try to figure out how `testDo` works by desugaring it manually and then "
"comparing its result with what you expected at the REPL. Note, how we helped "
"Idris disambiguate, which version of the *bind* operator to use by prefixing "
"the `do` keyword with part of the operator's namespace.  In this case, this "
"wasn't strictly necessary, although `Vect k` does have an implementation of "
"`Monad`, but it is still good to know that it is possible to help the "
"compiler with disambiguating do blocks."
msgstr ""
"手ずから脱糖してみて、`testDo`がどのように動いているのかを調べてみてくださ"
"い。\n"
"それからその結果とREPLで得られたものとを比較しましょう。\n"
"なお、ここではIdrisが曖昧さを解決できるように手助けしました。\n"
"演算子の名前空間の一部で`do`キーワードに前置することで、\n"
"どの版の*束縛*演算子を使うべきかを伝えています。\n"
"この場合、`Vect k`は`Monad`の実装を持ちますが、厳密には必要ではありません。\n"
"しかしそれでもコンパイラがdoブロックの曖昧さを解決することを手伝うことができ"
"ると知っておくことは良いことです。"

#. type: Plain text
#: ../src/Tutorial/IO.md:605
#, no-wrap
msgid ""
"Of course, we can (and should!) overload `(>>)` in the\n"
"same manner as `(>>=)`, if we want to overload the\n"
"behavior of *do blocks*.\n"
msgstr ""
"もちろん、`(>>=)`と同じ作法で`(>>)`をオーバーロードすることもできます（し、やるべきです！）。\n"
"もしdoブロックの振舞いをオーバーロードしたければね。\n"

#. type: Title ####
#: ../src/Tutorial/IO.md:606
#, no-wrap
msgid "Modules and Namespaces"
msgstr "モジュールと名前空間"

#. type: Plain text
#: ../src/Tutorial/IO.md:614
msgid ""
"Every data type, function, or operator can be unambiguously identified by "
"prefixing it with its *namespace*. A function's namespace typically is the "
"same as the module where it was defined.  For instance, the fully qualified "
"name of function `eval` would be `Tutorial.IO.eval`. Function and operator "
"names must be unique in their namespace."
msgstr ""
"あらゆるデータ型、関数、演算子は名前空間を前置することで曖昧さなく識別される"
"ようにできます。\n"
"関数の名前空間は大抵定義されているモジュールと同じです。\n"
"例えば関数`eval`の完全に限定された名前は`Tutorial.IO.eval`になります。\n"
"関数と演算子の名前は名前空間において唯一でなければいけません。"

#. type: Plain text
#: ../src/Tutorial/IO.md:620
msgid ""
"As we already learned, Idris can often disambiguate between functions with "
"the same name but defined in different namespaces based on the types "
"involved. If this is not possible, we can help the compiler by *prefixing* "
"the function or operator name with a *suffix* of the full namespace. Let's "
"demonstrate this at the REPL:"
msgstr ""
"既に見てきたように、Idrisはよく同名で異なる名前空間の関数を紐付く型で曖昧解決"
"します。\n"
"これができなければ、関数や演算子の名前に完全な名前空間の後ろ部分を前置するこ"
"とでコンパイラを手助けできます。\n"
"REPLで実演します。"

#. type: Fenced code block (repl)
#: ../src/Tutorial/IO.md:621
#, no-wrap
msgid ""
"Tutorial.IO> :t (>>=)\n"
"Prelude.>>= : Monad m => m a -> (a -> m b) -> m b\n"
"Tutorial.IO.>>= : Vect m a -> (a -> Vect n b) -> Vect (m * n) b\n"
msgstr ""
"Tutorial.IO> :t (>>=)\n"
"Prelude.>>= : Monad m => m a -> (a -> m b) -> m b\n"
"Tutorial.IO.>>= : Vect m a -> (a -> Vect n b) -> Vect (m * n) b\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:633
#, no-wrap
msgid ""
"As you can see, if we load this module in a REPL session and\n"
"inspect the type of `(>>=)`, we get two results as two\n"
"operators with this name are in scope. If we only want\n"
"the REPL to print the type of our custom *bind* operator,\n"
"is is sufficient to prefix it with `IO`, although we could\n"
"also prefix it with its full namespace:\n"
msgstr ""
"見てとれるように、本モジュールをREPLセッションで読み込んで`(>>=)`の型を調べると、\n"
"その名前の2つの演算子が結果に出てきます。\n"
"REPLに自前の束縛演算子のみを印字させたいときは、\n"
"`IO`を前置しておけば充分です。\n"
"完全な名前空間を前置することもできますけどね。\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/IO.md:634
#, no-wrap
msgid ""
"Tutorial.IO> :t IO.(>>=)\n"
"Tutorial.IO.>>= : Vect m a -> (a -> Vect n b) -> Vect (m * n) b\n"
"Tutorial.IO> :t Tutorial.IO.(>>=)\n"
"Tutorial.IO.>>= : Vect m a -> (a -> Vect n b) -> Vect (m * n) b\n"
msgstr ""
"Tutorial.IO> :t IO.(>>=)\n"
"Tutorial.IO.>>= : Vect m a -> (a -> Vect n b) -> Vect (m * n) b\n"
"Tutorial.IO> :t Tutorial.IO.(>>=)\n"
"Tutorial.IO.>>= : Vect m a -> (a -> Vect n b) -> Vect (m * n) b\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:649
msgid ""
"Since function names must be unique in their namespace and we still may want "
"to define two overloaded versions of a function in an Idris module, Idris "
"makes it possible to add additional namespaces to modules. For instance, in "
"order to define another function called `eval`, we need to add it to its own "
"namespace (note, that all definitions in a namespace must be indented by the "
"same amount of white space):"
msgstr ""
"関数名は名前空間で唯一でなければいけない一方で、\n"
"それでも1つのIdrisのモジュールで2つのオーバーロードされた版の関数を定義したい"
"ときがあるかもしれないので、\n"
"Idrisではモジュールに追加の名前空間を加えられます。\n"
"例えば`eval`という名前の別の関数を定義するためには、\n"
"それ自身の名前空間に加える必要があります。\n"
"（1つの名前空間中の全定義が同量の空白文字で前置されなければいけないことに注意"
"です。）"

#. type: Fenced code block (idris)
#: ../src/Tutorial/IO.md:650
#, no-wrap
msgid ""
"namespace Foo\n"
"  export\n"
"  eval : Nat -> Nat -> Nat\n"
"  eval = (*)\n"
"\n"
"-- prefixing `eval` with its namespace is not strictly necessary here\n"
"testFooEval : Nat\n"
"testFooEval = Foo.eval 12 100\n"
msgstr ""
"namespace Foo\n"
"  export\n"
"  eval : Nat -> Nat -> Nat\n"
"  eval = (*)\n"
"\n"
"-- `eval`を名前空間で前置していますが、ここでは厳密には不必要です\n"
"testFooEval : Nat\n"
"testFooEval = Foo.eval 12 100\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:665
msgid ""
"Now, here is an important thing: For functions and data types to be "
"accessible from outside their namespace or module, they need to be "
"*exported* by annotating them with the `export` or `public export` keywords."
msgstr ""
"さて、ここで大切な話があります。\n"
"外部の名前空間やモジュールから到達できる関数やデータ型というのは、\n"
"`export`や`public export`キーワードで印を付けることで*輸出*しなくてはいけませ"
"ん。"

#. type: Plain text
#: ../src/Tutorial/IO.md:674
msgid ""
"The difference between `export` and `public export` is the following: A "
"function annotated with `export` exports its type and can be called from "
"other namespaces. A data type annotated with `export` exports its type "
"constructor but not its data constructors.  A function annotated with "
"`public export` also exports its implementation. This is necessary to use "
"the function in compile-time computations. A data type annotated with "
"`public export` exports its data constructors as well."
msgstr ""
"`export`と`public export`の違いは次の通り。\n"
"`export`の印が付けられた関数は型を輸出しており他の名前空間から呼ぶことができ"
"ます。\n"
"`export`の印が付けられたデータ型は型構築子を輸出しますがデータ構築子は輸出し"
"ません。\n"
"`public export`の印が付けられた関数は実装も輸出します。\n"
"これはコンパイル時計算に使うために必要です。\n"
"`public export`の印が付けられたデータ型はデータ構築子も輸出します。"

#. type: Plain text
#: ../src/Tutorial/IO.md:680
msgid ""
"In general, consider annotating data types with `public export`, since "
"otherwise you will not be able to create values of these types or "
"deconstruct them in pattern matches. Likewise, unless you plan to use your "
"functions in compile-time computations, annotate them with `export`."
msgstr ""
"一般的にデータ型は`public export`の印を付けることを検討してください。\n"
"さもないとその型の値を作れなかったりパターン照合で解体できないからです。\n"
"また、関数をコンパイル時計算で使う予定がないときは`export`の印を付けましょ"
"う。"

#. type: Title ###
#: ../src/Tutorial/IO.md:681
#, no-wrap
msgid "Bind, with a Bang"
msgstr "束縛 〜びっくりマークを添えて〜"

#. type: Plain text
#: ../src/Tutorial/IO.md:688
msgid ""
"Sometimes, even *do blocks* are too noisy to express a combination of "
"effectful computations. In this case, we can prefix the effectful parts with "
"an exclamation mark (wrapping them in parentheses if they contain additional "
"white space), while leaving pure expressions unmodified:"
msgstr ""
"ときどき*doブロック*さえも作用付き計算の組み合わせを表現するのに目にうるさい"
"ことがあります。\n"
"この場合、純粋な式を変更しないままで、作用のある部分にびっくりマークを前置す"
"ることができます。\n"
"（作用のある部分に空白がある場合、括弧で囲みます。）"

#. type: Fenced code block (idris)
#: ../src/Tutorial/IO.md:689
#, no-wrap
msgid ""
"getHello : IO ()\n"
"getHello = putStrLn $ \"Hello \" ++ !getLine ++ \"!\"\n"
msgstr ""
"getHello : IO ()\n"
"getHello = putStrLn $ \"Hello \" ++ !getLine ++ \"!\"\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:695
msgid "The above gets desugared to the following *do block*:"
msgstr "上記は以下の*doブロック*に脱糖されます。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/IO.md:696
#, no-wrap
msgid ""
"getHello' : IO ()\n"
"getHello' = do\n"
"  s <- getLine\n"
"  putStrLn $ \"Hello \" ++ s ++ \"!\"\n"
msgstr ""
"getHello' : IO ()\n"
"getHello' = do\n"
"  s <- getLine\n"
"  putStrLn $ \"Hello \" ++ s ++ \"!\"\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:704
msgid "Here is another example:"
msgstr "以下は別の例です。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/IO.md:705
#, no-wrap
msgid ""
"bangExpr : String -> String -> String -> Maybe Integer\n"
"bangExpr s1 s2 s3 =\n"
"  Just $ !(parseInteger s1) + !(parseInteger s2) * !(parseInteger s3)\n"
msgstr ""
"bangExpr : String -> String -> String -> Maybe Integer\n"
"bangExpr s1 s2 s3 =\n"
"  Just $ !(parseInteger s1) + !(parseInteger s2) * !(parseInteger s3)\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:712
msgid "And here is the desugared *do block*:"
msgstr "そしてこれは以下の*doブロック*に脱糖されます。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/IO.md:713
#, no-wrap
msgid ""
"bangExpr' : String -> String -> String -> Maybe Integer\n"
"bangExpr' s1 s2 s3 = do\n"
"  x1 <- parseInteger s1\n"
"  x2 <- parseInteger s2\n"
"  x3 <- parseInteger s3\n"
"  Just $ x1 + x2 * x3\n"
msgstr ""
"bangExpr' : String -> String -> String -> Maybe Integer\n"
"bangExpr' s1 s2 s3 = do\n"
"  x1 <- parseInteger s1\n"
"  x2 <- parseInteger s2\n"
"  x3 <- parseInteger s3\n"
"  Just $ x1 + x2 * x3\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:727
msgid ""
"Please remember the following: Syntactic sugar has been introduced to make "
"code more readable or more convenient to write. If it is abused just to show "
"how clever you are, you make things harder for other people (including your "
"future self!)  reading and trying to understand your code."
msgstr ""
"次のことを心に留めておきましょう。\n"
"糖衣構文はコードをより読みやすくしたり書くのを便利にしたりするために導入され"
"ました。\n"
"自分がどれほど賢いかを誇示するためだけに乱用すると、\n"
"他のひと（と将来のあなたも！）がコードを読んで理解しようとすることが難しくな"
"ります。"

#. type: Bullet: '1. '
#: ../src/Tutorial/IO.md:733
msgid ""
"Reimplement the following *do blocks*, once by using *bang notation*, and "
"once by writing them in their desugared form with nested *bind*s:"
msgstr ""
"以下の*doブロック*を再実装してください。\n"
"1つはびっくりマーク記法を使って、\n"
"もう1つは入れ子の*束縛*の形式に脱糖した形で書いてください。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/IO.md:734
#, no-wrap
msgid ""
"   ex1a : IO String\n"
"   ex1a = do\n"
"     s1 <- getLine\n"
"     s2 <- getLine\n"
"     s3 <- getLine\n"
"     pure $ s1 ++ reverse s2 ++ s3\n"
"\n"
"   ex1b : Maybe Integer\n"
"   ex1b = do\n"
"     n1 <- parseInteger \"12\"\n"
"     n2 <- parseInteger \"300\"\n"
"     Just $ n1 + n2 * 100\n"
msgstr ""
"   ex1a : IO String\n"
"   ex1a = do\n"
"     s1 <- getLine\n"
"     s2 <- getLine\n"
"     s3 <- getLine\n"
"     pure $ s1 ++ reverse s2 ++ s3\n"
"\n"
"   ex1b : Maybe Integer\n"
"   ex1b = do\n"
"     n1 <- parseInteger \"12\"\n"
"     n2 <- parseInteger \"300\"\n"
"     Just $ n1 + n2 * 100\n"

#. type: Bullet: '2. '
#: ../src/Tutorial/IO.md:752
msgid ""
"Below is the definition of an indexed family of types, the index of which "
"keeps track of whether the value in question is possibly empty or provably "
"non-empty:"
msgstr ""
"以下は指標付けられた型族で、注目する値が空か証明的に空でないかのいずれかを取"
"る値を指標で追跡します。"

#. type: Plain text
#: ../src/Tutorial/IO.md:766
#, no-wrap
msgid ""
"   Please note, that the `Nil` case *must* have the `nonEmpty`\n"
"   tag set to `False`, while with the *cons* case, this is\n"
"   optional. So, a `List01 False a` can be empty or non-empty,\n"
"   and we'll only find out, which is the case, by pattern\n"
"   matching on it. A `List01 True a` on the other hand *must*\n"
"   be a *cons*, as for the `Nil` case the `nonEmpty` tag is\n"
"   always set to `False`.\n"
msgstr ""
"   注目していただきたいのは、`Nil`の場合では`nonEmpty`札が`False`に設定されて*いなければならず*、\n"
"   一方で*cons*の場合はどちらでもよいということです。\n"
"   なので、`List 01 False a`は空もしくは非空のどちらもありえて、\n"
"   どちらなのかはパターン照合することでのみ調べられます。\n"
"   他方で、`Nil`の場合は`nonEmpty`札が常に`False`なので、\n"
"   `List01 True a`は*cons*でなくてはいけません。\n"

#. type: Bullet: '   1. '
#: ../src/Tutorial/IO.md:768
msgid "Declare and implement function `head` for non-empty lists:"
msgstr "関数`head`を非空のリストに対して宣言し実装してください。"

#. type: Plain text
#: ../src/Tutorial/IO.md:772
#, no-wrap
msgid ""
"      ```idris\n"
"      head : List01 True a -> a\n"
"      ```\n"
msgstr ""
"      ```idris\n"
"      head : List01 True a -> a\n"
"      ```\n"

#. type: Bullet: '   2. '
#: ../src/Tutorial/IO.md:776
msgid ""
"Declare and implement function `weaken` for converting any `List01 ne a` to "
"a `List01 False a` of the same length and order of values."
msgstr ""
"あらゆる`List01 ne a`を同じ長さと値の順番の`List01 False a`に変換する関数"
"`weaken`を宣言し実装してください。"

#. type: Bullet: '   3. '
#: ../src/Tutorial/IO.md:779
msgid ""
"Declare and implement function `tail` for extracting the possibly empty tail "
"from a non-empty list."
msgstr ""
"非空のリストから空になりうる尾っぽを取り出す関数`tail`を宣言し実装してくださ"
"い。"

#. type: Bullet: '   4. '
#: ../src/Tutorial/IO.md:784
msgid ""
"Implement function `(++)` for concatenating two values of type `List01`. "
"Note, how we use a type-level computation to make sure the result is non-"
"empty if and only if at least one of the two arguments is non-empty:"
msgstr ""
"型`List 01`の値を連結する関数`(++)`を実装してください。\n"
"以下で、どのように型段階計算を使って、\n"
"2つのうち少なくとも1つが非空であるときに限って、\n"
"結果が非空であることを確かめているかに注目してください。"

#. type: Plain text
#: ../src/Tutorial/IO.md:788
#, no-wrap
msgid ""
"      ```idris\n"
"      (++) : List01 b1 a -> List01 b2 a -> List01 (b1 || b2) a\n"
"      ```\n"
msgstr ""
"      ```idris\n"
"      (++) : List01 b1 a -> List01 b2 a -> List01 (b1 || b2) a\n"
"      ```\n"

#. type: Bullet: '   5. '
#: ../src/Tutorial/IO.md:794
msgid ""
"Implement utility function `concat'` and use it in the implementation of "
"`concat`. Note, that in `concat` the two boolean tags are passed as "
"unrestricted implicits, since you will need to pattern match on these to "
"determine whether the result is provably non-empty or not:"
msgstr ""
"小間物関数`concat'`を実装して`concat`の実装で使ってください。\n"
"`concat`には2枚の真偽値の札が制約なし暗黙子として渡されていますね。\n"
"これは結果が証明的に非空かそうでないかを、この札でパターン照合することで決定"
"する必要があるからです。"

#. type: Plain text
#: ../src/Tutorial/IO.md:797
#, no-wrap
msgid ""
"      ```idris\n"
"      concat' : List01 ne1 (List01 ne2 a) -> List01 False a\n"
msgstr ""
"      ```idris\n"
"      concat' : List01 ne1 (List01 ne2 a) -> List01 False a\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:802
#, no-wrap
msgid ""
"      concat :  {ne1, ne2 : _}\n"
"             -> List01 ne1 (List01 ne2 a)\n"
"             -> List01 (ne1 && ne2) a\n"
"      ```\n"
msgstr ""
"      concat :  {ne1, ne2 : _}\n"
"             -> List01 ne1 (List01 ne2 a)\n"
"             -> List01 (ne1 && ne2) a\n"
"      ```\n"

#. type: Bullet: '   6. '
#: ../src/Tutorial/IO.md:804
msgid "Implement `map01`:"
msgstr "`map01`を実装してください。"

#. type: Plain text
#: ../src/Tutorial/IO.md:808
#, no-wrap
msgid ""
"      ```idris\n"
"      map01 : (a -> b) -> List01 ne a -> List01 ne b\n"
"      ```\n"
msgstr ""
"      ```idris\n"
"      map01 : (a -> b) -> List01 ne a -> List01 ne b\n"
"      ```\n"

#. type: Bullet: '   7. '
#: ../src/Tutorial/IO.md:811
msgid ""
"Implement a custom *bind* operator in namespace `List01` for sequencing "
"computations returning `List01`s."
msgstr ""
"`List01`を返す計算を並べるための、自前の*束縛*演算子を名前空間`List01`に実装"
"してください。"

#. type: Plain text
#: ../src/Tutorial/IO.md:814
#, no-wrap
msgid ""
"      Hint: Use `map01` and `concat` in your implementation and\n"
"      make sure to use unrestricted implicits where necessary.\n"
msgstr ""
"      解決の糸口：実装では`map01`と`concat`を、\n"
"      必要に応じて制約なし暗黙子を使ってくださいね。\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:817
#, no-wrap
msgid ""
"      You can use the following examples to test your\n"
"      custom *bind* operator:\n"
msgstr "      自前の*束縛*演算子が動くことを確かめるためには以下の例が使えます。\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:823
#, no-wrap
msgid ""
"      ```idris\n"
"      -- this and lf are necessary to make sure, which tag to use\n"
"      -- when using list literals\n"
"      lt : List01 True a -> List01 True a\n"
"      lt = id\n"
msgstr ""
"      ```idris\n"
"      -- これとlfはリスト表記を使うときにどちらの札を使うのかを確定させるために必要です。\n"
"      lt : List01 True a -> List01 True a\n"
"      lt = id\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:826
#, no-wrap
msgid ""
"      lf : List01 False a -> List01 False a\n"
"      lf = id\n"
msgstr ""
"      lf : List01 False a -> List01 False a\n"
"      lf = id\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:833
#, no-wrap
msgid ""
"      test : List01 True Integer\n"
"      test = List01.do\n"
"        x  <- lt [1,2,3]\n"
"        y  <- lt [4,5,6,7]\n"
"        op <- lt [(*), (+), (-)]\n"
"        [op x y]\n"
msgstr ""
"      test : List01 True Integer\n"
"      test = List01.do\n"
"        x  <- lt [1,2,3]\n"
"        y  <- lt [4,5,6,7]\n"
"        op <- lt [(*), (+), (-)]\n"
"        [op x y]\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:841
#, no-wrap
msgid ""
"      test2 : List01 False Integer\n"
"      test2 = List01.do\n"
"        x  <- lt [1,2,3]\n"
"        y  <- Nil {a = Integer}\n"
"        op <- lt [(*), (+), (-)]\n"
"        lt [op x y]\n"
"      ```\n"
msgstr ""
"      test2 : List01 False Integer\n"
"      test2 = List01.do\n"
"        x  <- lt [1,2,3]\n"
"        y  <- Nil {a = Integer}\n"
"        op <- lt [(*), (+), (-)]\n"
"        lt [op x y]\n"
"      ```\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:857
msgid ""
"Some notes on Exercise 2: Here, we combined the capabilities of `List` and "
"`Data.List1` in a single indexed type family.  This allowed us to treat list "
"concatenation correctly: If at least one of the arguments is provably non-"
"empty, the result is also non-empty. To tackle this correctly with `List` "
"and `List1`, a total of four concatenation functions would have to be "
"written. So, while it is often possible to define distinct data types "
"instead of indexed families, the latter allow us to perform type-level "
"computations to be more precise about the pre- and postconditions of the "
"functions we write, at the cost of more-complex type signatures.  In "
"addition, sometimes it's not possible to derive the values of the indices "
"from pattern matching on the data values alone, so they have to be passed as "
"unerased (possibly implicit) arguments."
msgstr ""
"演習2に数点補足します。\n"
"ここでは`List`と`Data.List1`の能力を単一の指標付けられた型族にまとめていま"
"す。\n"
"これによりリストの結合を正しく扱えます。\n"
"つまり、少なくとも一方の引数が証明的に非空であるなら、結果もまた非空なので"
"す。\n"
"このことを`List`と`List1`で取り組もうとすると、\n"
"合計4つの結合関数を書く必要があるでしょう。\n"
"なので、指標付けられた型族の代わりに個々のデータ型を定義できることはよくあり"
"ますが、\n"
"指標付けられた型族のほうが、より複雑な型処方と引き換えに、\n"
"書く関数のより精密な事前・事後条件のある型段階計算を行えます。\n"
"加えて、データ値へのパターン照合だけからでは指標値を導出できないことはしばし"
"ばあり、\n"
"そのため消去されない（暗黙にできる）引数として渡さなければなりません。"

#. type: Plain text
#: ../src/Tutorial/IO.md:864
msgid ""
"Please remember, that *do blocks* are first desugared, before type-checking, "
"disambiguating which *bind* operator to use, and filling in implicit "
"arguments. It is therefore perfectly fine to define *bind* operators with "
"arbitrary constraints or implicit arguments as was shown above. Idris will "
"handle all the details, *after* desugaring the *do blocks*."
msgstr ""
"覚えておいてほしいことは、*doブロック*が最初に脱糖されるもので、\n"
"それは型検査やどの*束縛*演算子かの曖昧解決をするかや暗黙引数を埋めていくより"
"前だということです。\n"
"したがって上記のような好きな制約や暗黙引数付きの*束縛*演算子を定義することは"
"全くもって大丈夫なのです。\n"
"Idrisは*doブロック*を脱糖した*後*に全ての詳細を取り扱います。"

#. type: Title ##
#: ../src/Tutorial/IO.md:865
#, no-wrap
msgid "Working with Files"
msgstr "ファイルを取り回す"

#. type: Plain text
#: ../src/Tutorial/IO.md:872
msgid ""
"Module `System.File` from the *base* library exports utilities necessary to "
"work with file handles and read and write from and to files. When you have a "
"file path (for instance \"/home/hock/idris/tutorial/tutorial.ipkg\"), the "
"first thing we will typically do is to try and create a file handle (of type "
"`System.File.File` by calling `fileOpen`)."
msgstr ""
"モジュール`System.File`は*base*ライブラリに由来し、\n"
"ファイル制御子を取り回したりファイルを読み書きしたりするのに必要な小間物を輸"
"出しています。\n"
"ファイルパス（例えば\"/home/hock/idris/tutorial/tutorial.ipkg\"）があると"
"き、\n"
"よく最初にすることはファイル制御子（型は`System.File.File`で`fileOpen`という"
"名前）を作ろうとすることです。"

#. type: Plain text
#: ../src/Tutorial/IO.md:874
msgid "Here is a program for counting all empty lines in a Unix/Linux-file:"
msgstr "以下はUnix/Linux上のファイル中の全空行を数えるプログラムです。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/IO.md:875
#, no-wrap
msgid ""
"covering\n"
"countEmpty : (path : String) -> IO (Either FileError Nat)\n"
"countEmpty path = openFile path Read >>= either (pure . Left) (go 0)\n"
"  where covering go : Nat -> File -> IO (Either FileError Nat)\n"
"        go k file = do\n"
"          False <- fEOF file | True => closeFile file $> Right k\n"
"          Right \"\\n\" <- fGetLine file\n"
"            | Right _  => go k file\n"
"            | Left err => closeFile file $> Left err\n"
"          go (k + 1) file\n"
msgstr ""
"covering\n"
"countEmpty : (path : String) -> IO (Either FileError Nat)\n"
"countEmpty path = openFile path Read >>= either (pure . Left) (go 0)\n"
"  where covering go : Nat -> File -> IO (Either FileError Nat)\n"
"        go k file = do\n"
"          False <- fEOF file | True => closeFile file $> Right k\n"
"          Right \"\\n\" <- fGetLine file\n"
"            | Right _  => go k file\n"
"            | Left err => closeFile file $> Left err\n"
"          go (k + 1) file\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:894
#, no-wrap
msgid ""
"In the example above, I invoked `(>>=)` without starting a *do block*.\n"
"Make sure you understand what's going on here. Reading concise functional\n"
"code is important in order to understand other people's code.\n"
"Have a look at function `either` at the REPL, try figuring out what\n"
"`(pure . Left)` does, and note how we use a curried version of `go`\n"
"as the second argument to `either`.\n"
msgstr ""
"上の例で*doブロック*なしに`(>>=)`を呼び出しました。\n"
"このときに起こることを確実に理解しましょう。\n"
"簡潔な関数型コードを読むことは他人のコードを理解するためには大切です。\n"
"REPLで関数`either`を見たり、\n"
"`(pure . Left)`がしていることを調べたり、\n"
"`go`のカリー化された版を`either`の2つ目の引数として使っていることに注目したりしてください。\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:905
msgid ""
"Function `go` calls for some additional explanations. First, note how we "
"used the same syntax for pattern matching intermediary results as we also "
"saw for `let` bindings. As you can see, we can use several vertical bars to "
"handle more than one additional pattern. In order to read a single line from "
"a file, we use function `fGetLine`. As with most operations working with the "
"file system, this function might fail with a `FileError`, which we have to "
"handle correctly. Note also, that `fGetLine` will return the line including "
"its trailing newline character `'\\n'`, so in order to check for empty "
"lines, we have to match against `\"\\n\"` instead of the empty string `\"\"`."
msgstr ""
"関数`go`については追加で説明せねばなりません。\n"
"まず、`let`束縛でも見たのと同じ構文で、結果にそのままパターン照合を使っている"
"ところに着目しましょう。\n"
"見てとれるようにいくつかの垂直棒を使って1つ以上の追加のパターンを制御できま"
"す。\n"
"ファイルから1行読むために関数`fGetLine`を使っています。\n"
"ファイルシステムでのほとんどの操作につきものですが、\n"
"この関数は`FileError`を返すかもしれません。\n"
"そのような場合に正しく対処する必要があります。\n"
"さらに言えば`fGetLine`は空行のとき末尾の改行文字`'\\n'`を含む行を返すので、\n"
"空行を確認するためには空文字列`\"\"`の代わりに`\"\\n\"`に照合する必要がありま"
"す。"

#. type: Plain text
#: ../src/Tutorial/IO.md:910
msgid ""
"Finally, `go` is not provably total and rightfully so.  Files like `/dev/"
"urandom` or `/dev/zero` provide infinite streams of data, so `countEmpty` "
"will never terminate when invoked with such a file path."
msgstr ""
"最後に`go`は証明的に全域ではなく、それはそうです。\n"
"`/dev/urandom`や`/dev/zero`のようなファイルはデータの無限ストリームを提供して"
"おり、\n"
"そのため`countEmpty`がそのようなファイルパスで呼び出されたときは終了すること"
"がないでしょう。"

#. type: Title ###
#: ../src/Tutorial/IO.md:911
#, no-wrap
msgid "Safe Resource Handling"
msgstr "安全な資源制御"

#. type: Plain text
#: ../src/Tutorial/IO.md:919
msgid ""
"Note, how we had to manually open and close the file handle in `countEmpty`. "
"This is error-prone and tedious. Resource handling is a big topic, and we "
"definitely won't be going into the details here, but there is a convenient "
"function exported from `System.File`: `withFile`, which handles the opening, "
"closing and handling of file errors for us."
msgstr ""
"`countEmpty`で手動でファイル制御子を開いたり閉じたりしなければなりませんでし"
"たね。\n"
"これはエラーの温床ですし億劫です。\n"
"資源制御は大きな話題であり、ここではその詳細に踏み込むことはありませんが、\n"
"`System.File`から輸出されている便利な関数があります。\n"
"それは`withFile`で、これはファイルを開いたり閉じたりファイルのエラーの制御の"
"面倒を見てくれたりします。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/IO.md:920
#, no-wrap
msgid ""
"covering\n"
"countEmpty' : (path : String) -> IO (Either FileError Nat)\n"
"countEmpty' path = withFile path Read pure (go 0)\n"
"  where covering go : Nat -> File -> IO (Either FileError Nat)\n"
"        go k file = do\n"
"          False <- fEOF file | True => pure (Right k)\n"
"          Right \"\\n\" <- fGetLine file\n"
"            | Right _  => go k file\n"
"            | Left err => pure (Left err)\n"
"          go (k + 1) file\n"
msgstr ""
"covering\n"
"countEmpty' : (path : String) -> IO (Either FileError Nat)\n"
"countEmpty' path = withFile path Read pure (go 0)\n"
"  where covering go : Nat -> File -> IO (Either FileError Nat)\n"
"        go k file = do\n"
"          False <- fEOF file | True => pure (Right k)\n"
"          Right \"\\n\" <- fGetLine file\n"
"            | Right _  => go k file\n"
"            | Left err => pure (Left err)\n"
"          go (k + 1) file\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:937
msgid ""
"Go ahead, and have a look at the type of `withFile`, then have a look how we "
"use it to simplify the implementation of `countEmpty'`. Reading and "
"understanding slightly more complex function types is important when "
"learning to program in Idris."
msgstr ""
"さあ、`withFile`の型を眺めてみて、\n"
"それからこれを使って`countEmpty'`の実装をどのように簡単にしているのか見てみま"
"しょう。\n"
"ちょっとだけより複雑な関数の型を読んで理解することはIdrisで書かれたプログラム"
"を学ぶ上で大事です。"

#. type: Title ####
#: ../src/Tutorial/IO.md:938
#, no-wrap
msgid "Interface `HasIO`"
msgstr "インターフェース`HasIO`"

#. type: Plain text
#: ../src/Tutorial/IO.md:948
msgid ""
"When you look at the `IO` functions we used so far, you'll notice that most "
"if not all of them actually don't work with `IO` itself but with a type "
"parameter `io` with a constraint of `HasIO`. This interface allows us to "
"*lift* a value of type `IO a` into another context. We will see use cases "
"for this in later chapters, especially when we talk about monad "
"transformers. For now, you can treat these `io` parameters as being "
"specialized to `IO`."
msgstr ""
"これまで使ってきた`IO`関数を見ると、\n"
"全てではないにしてもほとんどが実際には`IO`そのものを扱ってはおらず、\n"
"制約`HasIO`を持つ型変数`io`を使っていることに気付きます。\n"
"このインターフェースのおかげで型`IO a`の値を他の文脈に*持ち上げ*ることができ"
"ます。\n"
"この使用例については後の章、特にモナド変換子について話すときに見ていきましょ"
"う。\n"
"現段階ではこれらの`io`変数を`IO`に特化させたものとして扱ってよいです。"

#. type: Bullet: '1. '
#: ../src/Tutorial/IO.md:959
msgid ""
"As we have seen in the examples above, `IO` actions working with file "
"handles often come with the risk of failure. We can therefore simplify "
"things by writing some utility functions and a custom *bind* operator to "
"work with these nested effects. In a new namespace `IOErr`, implement the "
"following utility functions and use these to further cleanup the "
"implementation of `countEmpty'`:"
msgstr ""
"上の例で見てきたように、ファイル制御子を取り回す`IO`行動には失敗する危険性が"
"付き纏います。\n"
"したがってこういった入れ子の作用がを扱ういくらかの小間物関数と自前の*束縛*演"
"算子を書くことで、\n"
"話を簡単にすることができます。\n"
"新しい名前空間`IOErr`の中で以下の小間物関数を実装し、\n"
"これらを使ってさらに`countEmpty'`の実装を綺麗にしましょう。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/IO.md:960
#, no-wrap
msgid ""
"   pure : a -> IO (Either e a)\n"
"\n"
"   fail : e -> IO (Either e a)\n"
"\n"
"   lift : IO a -> IO (Either e a)\n"
"\n"
"   catch : IO (Either e1 a) -> (e1 -> IO (Either e2 a)) -> IO (Either e2 a)\n"
"\n"
"   (>>=) : IO (Either e a) -> (a -> IO (Either e b)) -> IO (Either e b)\n"
"\n"
"   (>>) : IO (Either e ()) -> Lazy (IO (Either e a)) -> IO (Either e a)\n"
msgstr ""
"   pure : a -> IO (Either e a)\n"
"\n"
"   fail : e -> IO (Either e a)\n"
"\n"
"   lift : IO a -> IO (Either e a)\n"
"\n"
"   catch : IO (Either e1 a) -> (e1 -> IO (Either e2 a)) -> IO (Either e2 a)\n"
"\n"
"   (>>=) : IO (Either e a) -> (a -> IO (Either e b)) -> IO (Either e b)\n"
"\n"
"   (>>) : IO (Either e ()) -> Lazy (IO (Either e a)) -> IO (Either e a)\n"

#. type: Bullet: '2. '
#: ../src/Tutorial/IO.md:977
msgid ""
"Write a function `countWords` for counting the words in a file.  Consider "
"using `Data.String.words` and the utilities from exercise 1 in your "
"implementation."
msgstr ""
"ファイル中の単語を数える関数`countWords`を書いてください。\n"
"実装では`Data.String.words`と演習1の小間物を使うことを検討してください。"

#. type: Bullet: '3. '
#: ../src/Tutorial/IO.md:983
msgid ""
"We can generalize the functionality used in `countEmpty` and `countWords`, "
"by implementing a helper function for iterating over the lines in a file and "
"accumulating some state along the way. Implement `withLines` and use it to "
"reimplement `countEmpty` and `countWords`:"
msgstr ""
"ファイル中の行を順次処理し道中の状態を累積するお助け関数を実装することで、\n"
"`countEmpty`と`countWords`で使う機能を一般化することができます。\n"
"`withLines`を実装し、それを使って`countEmpty`と`countWords`を実装してくださ"
"い。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/IO.md:984
#, no-wrap
msgid ""
"   covering\n"
"   withLines :  (path : String)\n"
"             -> (accum : s -> String -> s)\n"
"             -> (initialState : s)\n"
"             -> IO (Either FileError s)\n"
msgstr ""
"   covering\n"
"   withLines :  (path : String)\n"
"             -> (accum : s -> String -> s)\n"
"             -> (initialState : s)\n"
"             -> IO (Either FileError s)\n"

#. type: Bullet: '4. '
#: ../src/Tutorial/IO.md:996
msgid ""
"We often use a `Monoid` for accumulating values.  It is therefore convenient "
"to specialize `withLines` for this case. Use `withLines` to implement "
"`foldLines` according to the type given below:"
msgstr ""
"値を累積するのによく`Monoid`が使われます。\n"
"この場合は`withLines`に特化させると便利になるということですね。\n"
"`withLines`を使って`foldLines`を以下の型に沿って実装してください。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/IO.md:997
#, no-wrap
msgid ""
"   covering\n"
"   foldLines :  Monoid s\n"
"             => (path : String)\n"
"             -> (f    : String -> s)\n"
"             -> IO (Either FileError s)\n"
msgstr ""
"   covering\n"
"   foldLines :  Monoid s\n"
"             => (path : String)\n"
"             -> (f    : String -> s)\n"
"             -> IO (Either FileError s)\n"

#. type: Bullet: '5. '
#: ../src/Tutorial/IO.md:1012
msgid ""
"Implement function `wordCount` for counting the number of lines, words, and "
"characters in a text document. Define a custom record type together with an "
"implementation of `Monoid` for storing and accumulating these values and use "
"`foldLines` in your implementation of `wordCount`."
msgstr ""
"1つの文字文書中の行数、単語数、文字数を形状する関数`wordCount`を実装してくだ"
"さい。\n"
"これらの値を保管し累積できるように自前のレコード型を`Monoid`の実装とともに定"
"義し、\n"
"`foldLines`を`wordCount`の実装で使ってください。"

#. type: Title ##
#: ../src/Tutorial/IO.md:1013
#, no-wrap
msgid "How `IO` is Implemented"
msgstr "`IO`はどのように実装されているのか"

#. type: Plain text
#: ../src/Tutorial/IO.md:1019
msgid ""
"In this final section of an already lengthy chapter, we will risk a glance "
"at how `IO` is implemented in Idris. It is interesting to note, that `IO` is "
"not a built-in type but a regular data type with only one minor speciality. "
"Let's learn about it at the REPL:"
msgstr ""
"随分長くなってしまった章のこの最後の節では、\n"
"勇気を出してIdrisでどのように`IO`が実装されているのか覗いてみましょう。\n"
"面白いことに、`IO`は組み込み型ではないものの、1点些細な特異性がある以外は普通"
"のデータ型なのです。\n"
"そのことをREPLで学びましょう。"

#. type: Fenced code block (repl)
#: ../src/Tutorial/IO.md:1020
#, no-wrap
msgid ""
"Tutorial.IO> :doc IO\n"
"data PrimIO.IO : Type -> Type\n"
"  Totality: total\n"
"  Constructor: MkIO : (1 _ : PrimIO a) -> IO a\n"
"  Hints:\n"
"    Applicative IO\n"
"    Functor IO\n"
"    HasLinearIO IO\n"
"    Monad IO\n"
msgstr ""
"Tutorial.IO> :doc IO\n"
"data PrimIO.IO : Type -> Type\n"
"  Totality: total\n"
"  Constructor: MkIO : (1 _ : PrimIO a) -> IO a\n"
"  Hints:\n"
"    Applicative IO\n"
"    Functor IO\n"
"    HasLinearIO IO\n"
"    Monad IO\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:1037
msgid ""
"Here, we learn that `IO` has a single data constructor called `MkIO`, which "
"takes a single argument of type `PrimIO a` with quantity *1*. We are not "
"going to talk about the quantities here, as in fact they are not important "
"to understand how `IO` works."
msgstr ""
"ここで`IO`が`MkIO`という名前の単一データ構築子を持ち、\n"
"この構築子が型`PrimIO a`で数量子*1*の単一引数を取ることがわかります。\n"
"今は数量子についてお話ししませんが、それは実のところ`IO`の仕組みを理解するの"
"には重要ではないからです。"

#. type: Plain text
#: ../src/Tutorial/IO.md:1039
msgid "Now, `PrimIO a` is a type alias for the following function:"
msgstr "さて、`PrimIO`は以下の関数の型別称です。"

#. type: Fenced code block (repl)
#: ../src/Tutorial/IO.md:1040
#, no-wrap
msgid ""
"Tutorial.IO> :printdef PrimIO\n"
"PrimIO.PrimIO : Type -> Type\n"
"PrimIO a = (1 _ : %World) -> IORes a\n"
msgstr ""
"Tutorial.IO> :printdef PrimIO\n"
"PrimIO.PrimIO : Type -> Type\n"
"PrimIO a = (1 _ : %World) -> IORes a\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:1049
msgid ""
"Again, don't mind the quantities. There is only one piece of the puzzle "
"missing: `IORes a`, which is a publicly exported record type:"
msgstr ""
"繰り返しますが数量子は気にしないでください。\n"
"唯一の見つかっていないパズルピースは`IORes a`で、\n"
"これは公に輸出されているレコード型です。"

#. type: Fenced code block (repl)
#: ../src/Tutorial/IO.md:1050
#, no-wrap
msgid ""
"Solutions.IO> :doc IORes\n"
"data PrimIO.IORes : Type -> Type\n"
"  Totality: total\n"
"  Constructor: MkIORes : a -> (1 _ : %World) -> IORes a\n"
msgstr ""
"Solutions.IO> :doc IORes\n"
"data PrimIO.IORes : Type -> Type\n"
"  Totality: total\n"
"  Constructor: MkIORes : a -> (1 _ : %World) -> IORes a\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:1059
msgid ""
"So, to put this all together, `IO` is a wrapper around something similar to "
"the following function type:"
msgstr ""
"ですので、このことを全てまとめると、`IO`は以下の関数型に似た何かの梱包になり"
"ます。"

#. type: Fenced code block (repl)
#: ../src/Tutorial/IO.md:1060
#, no-wrap
msgid "%World -> (a, %World)\n"
msgstr "%World -> (a, %World)\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:1072
msgid ""
"You can think of type `%World` as a placeholder for the state of the outside "
"world of a program (file system, memory, network connections, and so on). "
"Conceptually, to execute an `IO a` action, we pass it the current state of "
"the world, and in return get an updated world state plus a result of type "
"`a`. The world state being updated represents all the side effects "
"describable in a computer program."
msgstr ""
"型`%World`のことはプログラムの外側の世界の状態（ファイルシステム、記憶装置、"
"ネットワーク接続など）の\n"
"仮置場のように考えられます。\n"
"概念的には、`IO`行動を実行するには世界の現在の状態を渡し、\n"
"更新された世界状態に加えて型`a`の結果が返却される形です。\n"
"更新される世界状態はコンピュータプログラムで表現できる副作用の全てを表現しま"
"す。"

#. type: Plain text
#: ../src/Tutorial/IO.md:1088
msgid ""
"Now, it is important to understand that there is no such thing as the *state "
"of the world*. The `%World` type is just a placeholder, which is converted "
"to some kind of constant that's passed around and never inspected at "
"runtime. So, if we had a value of type `%World`, we could pass it to an `IO "
"a` action and execute it, and this is exactly what happens at runtime: A "
"single value of type `%World` (an uninteresting placeholder like `null`, "
"`0`, or - in case of the JavaScript backends - `undefined`)  is passed to "
"the `main` function, thus setting the whole program in motion. However, it "
"is impossible to programmatically create a value of type `%World` (it is an "
"abstract, primitive type), and therefore we cannot ever extract a value of "
"type `a` from an `IO a` action (modulo `unsafePerformIO`)."
msgstr ""
"ここで理解しておいてほしいことは、*世界の状態*なんてものはないということで"
"す。\n"
"`%World`型はただの仮置場であって、\n"
"受け渡されはするものの実行時に一度も中身が調べられないような類の定数に変換さ"
"れます。\n"
"なので型`%World`の値があったとして、\n"
"`IO a`行動に渡して実行することはできますが、\n"
"これは必ず実行時に起こることなのです。\n"
"つまり、型`%World`の単一の値\n"
"（特に意味のない仮置場で`null`や`0`や、JavaScriptバックエンドでは`undefined`"
"のような値）は\n"
"`main`関数に渡され、\n"
"それから全体のプログラムが動き始めます。\n"
"しかし、型`%World`の値をプログラムで生み出すことは不可能であり、\n"
"したがって型`a`の値を`IO a`行動から抽出することは決してできないのです"
"（`unsafePerformIO`を除く）。"

#. type: Plain text
#: ../src/Tutorial/IO.md:1094
msgid ""
"Once we will talk about monad transformers and the state monad, you will see "
"that `IO` is nothing else but a state monad in disguise but with an abstract "
"state type, which makes it impossible for us to run the stateful computation."
msgstr ""
"モナド変換子と状態モナドについてお話ししたあとでは、\n"
"`IO`が抽象的な状態型付きではあれど変装した状態モナドに過ぎないとわかるでしょ"
"う。\n"
"この抽象的な点により作用付き計算を走らせることができないようになっています。"

#. type: Bullet: '* '
#: ../src/Tutorial/IO.md:1099
msgid ""
"Values of type `IO a` describe programs with side effects, which will "
"eventually result in a value of type `a`."
msgstr ""
"型`IO a`の値は副作用付きのプログラムを記述しており、\n"
"最終的に型`a`の値になります。"

#. type: Bullet: '* '
#: ../src/Tutorial/IO.md:1104
msgid ""
"While we cannot safely extract a value of type `a` from an `IO a`, we can "
"use several combinators and syntactic constructs to combine `IO` actions and "
"build more-complex programs."
msgstr ""
"安全に`IO a`から型`a`の値を取り出すことはできませんが、\n"
"いくつかの結合子と構文的建材によって`IO`行動を組み合わせたりより複雑なプログ"
"ラムを構築できます。"

#. type: Bullet: '* '
#: ../src/Tutorial/IO.md:1107
msgid ""
"*Do blocks* offer a convenient way to run and combine `IO` actions "
"sequentially."
msgstr "*doブロック*があると`IO`行動を順番に組み合わせるのが便利になります。"

#. type: Bullet: '* '
#: ../src/Tutorial/IO.md:1110
msgid ""
"*Do blocks* are desugared to nested applications of *bind* operators "
"(`(>>=)`)."
msgstr "*doブロック*は*束縛*演算子 (`(>>=)`) の入れ子の適用に脱糖されます。"

#. type: Bullet: '* '
#: ../src/Tutorial/IO.md:1114
msgid ""
"*Bind* operators, and thus *do blocks*, can be overloaded to achieve custom "
"behavior instead of the default (monadic) *bind*."
msgstr ""
"*束縛*演算子、そして*doブロック*は、\n"
"既定の（モナドな）*束縛*の代わりとなる自前の振舞いを実現するためにオーバー"
"ロードできます。"

#. type: Bullet: '* '
#: ../src/Tutorial/IO.md:1117
msgid ""
"Under the hood, `IO` actions are stateful computations operating on a "
"symbolic `%World` state."
msgstr ""
"見えないところでは、`IO`行動は象徴としての`%World`状態を操作する状態付き計算"
"になっています。"

#. type: Plain text
#: ../src/Tutorial/IO.md:1123
msgid ""
"Now, that we had a glimpse at *monads* and the *bind* operator, it is time "
"to in the [next chapter](Functor.md) introduce `Monad` and some related "
"interfaces for real."
msgstr ""
"さて、*モナド*と*束縛*演算子をチラ見したところで、\n"
"[次章](Functor.md)でいよいよ`Monad`と関連する実際のインターフェースのいくつか"
"を紹介する時が来ました。"
