# Japanese translations for PACKAGE package
# Copyright (C) 2022 Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# Automatically generated, 2022.
#
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2023-03-06 20:57+0900\n"
"PO-Revision-Date: 2023-03-06 21:41+0900\n"
"Last-Translator: Automatically generated\n"
"Language-Team: none\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#. type: Title ###
#: ../src/Tutorial/Dependent.md:1 ../src/Tutorial/Intro.md:90
#, no-wrap
msgid "Dependent Types"
msgstr "依存型"

#. type: Title ###
#: ../src/Tutorial/Functor.md:1420 ../src/Tutorial/Intro.md:444
#, no-wrap
msgid "What's next?"
msgstr "お次は？"

#. type: Title #
#: ../src/Tutorial/Intro.md:1
#, no-wrap
msgid "Introduction"
msgstr "導入"

#. type: Plain text
#: ../src/Tutorial/Intro.md:15
msgid ""
"Welcome to my Idris 2 tutorial. I'll try and treat as many aspects of the "
"Idris 2 programming language as possible here.  All `.md` files in here a "
"literate Idris files: They consist of Markdown (hence the `.md` ending), "
"which is being pretty printed by GitHub together with Idris code blocks, "
"which can be type checked and built by the Idris compiler (more on this "
"later).  Note, however, that regular Idris source files use an `.idr` "
"ending, and that you go with that file type unless you end up writing much "
"more prose than code as I do at the moment. Later in this tutorial, you'll "
"have to solve some exercises, the solutions of which can be found in the "
"`src/Solutions` subfolder. There, I use regular `.idr` files."
msgstr ""
"Idris 2 入門へようこそ。\n"
"ここではプログラミング言語 Idris 2 のできるだけ多くの側面を扱ってみることにし"
"ます。\n"
"ここにある全ての `.md` ファイルは文芸的 Idris ファイルです。\n"
"つまり、Markdownで書かれていて（だから `.md` で終わります）、\n"
"Idris のコードブロックを混じえつつ GitHub で綺麗に表示され、\n"
"そして Idris のコンパイラで型検査とビルドができます（これについては後述）。\n"
"ただし、通常の Idris のソースファイルは `.idr` で終わりますし、\n"
"ここで私がやっているようにコードよりも地の文をかなり多く書かない限り、\n"
"そのファイルの種類を使うものです。\n"
"この入門のあとに、\n"
"いくつかの演習問題を解くことになりますが、\n"
"解答は `src/Solutions` サブフォルダにあります。\n"
"そこでは通常の `.idr` ファイルにしています。"

#. type: Plain text
#: ../src/Tutorial/Intro.md:23
msgid ""
"Before we begin, make sure to install the Idris compiler on your system.  "
"Throughout this tutorial, I assume you installed the *pack* package manager "
"and setup a skeleton package as described [here](../Appendices/Install.md). "
"It is certainly possible to follow along with just the Idris compiler "
"installed by other means, but some adjustments will be necessary when "
"starting REPL sessions or building executables."
msgstr ""
"始める前にシステムにIdrisコンパイラがインストールされていることを確かめてくだ"
"さい。この入門全体を通じて、*pack*パッケージ管理をインストールし[こちら](../"
"Appendices/Install.md)に解説されているようにパッケージの骨組をセットアップし"
"ていることを前提とします。何らかの別の方法でインストールしたIdrisコンパイラ単"
"体で読み進めることも確かにできますが、REPLセッションを始めたり実行ファイルを"
"ビルドしたりするには調整が必要となるでしょう。"

#. type: Plain text
#: ../src/Tutorial/Intro.md:27
msgid ""
"Every Idris source file should typically start with a module name plus some "
"necessary imports, and this document is no exception:"
msgstr ""
"あらゆる Idris のソースファイルにおいて、\n"
"モジュール名といくらかの必要となるインポートから始まるのが典型で、\n"
"この文書も例外ではありません。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Intro.md:28
#, no-wrap
msgid "module Tutorial.Intro\n"
msgstr "module Tutorial.Intro\n"

#. type: Plain text
#: ../src/Tutorial/Intro.md:35
msgid ""
"A module name consists of a list of identifiers separated by dots and must "
"reflect the folder structure plus the module file's name."
msgstr ""
"モジュール名はドットで区切られた識別子の連なりからなっており、\n"
"フォルダの構造とモジュールファイル名を反映したものでなくてはいけません。"

#. type: Title ##
#: ../src/Tutorial/Intro.md:36
#, no-wrap
msgid "About the Idris Programming Language"
msgstr "プログラミング言語Idrisについて"

#. type: Plain text
#: ../src/Tutorial/Intro.md:41
msgid ""
"Idris is a *pure*, *dependently typed*, *total* *functional* programming "
"language. I'll quickly explain each of these adjectives in this section."
msgstr ""
"Idrisは *純粋* で *依存型* で *全域* な *関数型* プログラミング言語です。\n"
"この節でこれらの形容詞について簡単に説明します。"

#. type: Title ###
#: ../src/Tutorial/Intro.md:42
#, no-wrap
msgid "Functional Programming"
msgstr "関数型プログラミング"

#. type: Plain text
#: ../src/Tutorial/Intro.md:56
msgid ""
"In functional programming languages, functions are first-class constructs, "
"meaning that they can be assigned to variables, passed as arguments to other "
"functions, and returned as results from functions. Unlike for instance in "
"object-oriented programming languages, in functional programming, functions "
"are the main form of abstraction. This means that whenever we find a common "
"pattern or (almost) identical code in several parts of a project, we try to "
"abstract over this in order to have to write the corresponding code only "
"once.  We do this by introducing one or more new functions implementing this "
"behavior. Doing so, we often try to be as general as possible to make our "
"functions as versatile to use as possible."
msgstr ""
"関数型プログラミング言語では、関数は第一級の構築子です。というのは、関数は変"
"数に代入することができますし、他の関数の引数に渡すことができますし、そして関"
"数の結果として返すこともできます。オブジェクト指向プログラミング言語などとは"
"異なり、関数型プログラミングでは、抽象化が主に関数の形式で行われます。つま"
"り、プロジェクトのいくつかの箇所で共通するパターンや（ほぼ）同じコードを見つ"
"けたときは、いつでも該当のコードをたった一度だけ書けばいいように抽象化を試み"
"るのです。これには、その挙動を実装する1つ以上の新しい関数を導入します。そうす"
"るにあたっては、できる限り関数が多彩なものになるように可能な限り一般化された"
"ものになるよう試みます。"

#. type: Plain text
#: ../src/Tutorial/Intro.md:60
msgid ""
"Functional programming languages are concerned with the evaluation of "
"functions, unlike classical imperative languages, which are concerned with "
"the execution of statements."
msgstr ""
"関数型プログラミング言語では関数の演算に着目しますが、\n"
"これは古典的な手続き型言語とは違います。\n"
"手続き型言語では文の実行に着目していました。"

#. type: Title ###
#: ../src/Tutorial/Intro.md:61
#, no-wrap
msgid "Pure Functional Programming"
msgstr "純粋関数型プログラミング"

#. type: Plain text
#: ../src/Tutorial/Intro.md:71
msgid ""
"Pure functional programming languages come with an additional important "
"guarantee: Functions don't have side effects like writing to a file or "
"mutating global state. They can only compute a result from their arguments "
"possibly by invoking other pure functions, *and nothing else*. As a "
"consequence, given the same input, they will *always* generate the same "
"output.  This property is known as [referential transparency](https://en."
"wikipedia.org/wiki/Referential_transparency)."
msgstr ""
"純粋関数型プログラミング言語は、\n"
"関数型プログラミング言語に重要な保証がついたものです。\n"
"その保証とは、関数が副作用を持たないことで、\n"
"例えばファイルへの書き込みや大域状態の変更を行いません。\n"
"関数は引数から結果を計算するもので、\n"
"他の純粋な関数を呼び出すかもしれませんが、\n"
"*その他には何も呼び出しません*。\n"
"その結果として、\n"
"同じ入力があったとすると、\n"
"*常に* 同じ出力を生成することになります。\n"
"この性質は[参照透過性](https://en.wikipedia.org/wiki/"
"Referential_transparency)として知られています。"

#. type: Plain text
#: ../src/Tutorial/Intro.md:73
msgid "Pure functions have several advantages:"
msgstr "純粋な関数にはいくつかの利点があります。"

#. type: Bullet: '* '
#: ../src/Tutorial/Intro.md:76
msgid ""
"They can easily be tested by specifying (possibly randomly generated)  sets "
"of input arguments together with the expected results."
msgstr ""
"関数をテストするのが簡単です。\n"
"いくつかの入力（乱択による生成でも可）と期待値を指定します。"

#. type: Bullet: '* '
#: ../src/Tutorial/Intro.md:80
msgid ""
"They are thread-safe, since the don't mutate global state, and as such can "
"be freely used in several computations running in parallel."
msgstr ""
"関数はスレッドセーフです。\n"
"なぜなら大域状態を変更しないからです。\n"
"そして、並列実行される計算でも自由に使えます。"

#. type: Plain text
#: ../src/Tutorial/Intro.md:82
msgid "There are, of course, also some disadvantages:"
msgstr "純粋な関数にももちろん欠点があります。"

#. type: Bullet: '* '
#: ../src/Tutorial/Intro.md:85
msgid ""
"Some algorithms are hard to implement efficiently using only pure functions."
msgstr "純粋関数だけでは、効率良く実装することが困難なアルゴリズムがあります。"

#. type: Bullet: '* '
#: ../src/Tutorial/Intro.md:89
msgid ""
"Writing programs that actually *do* something (have some observable effect) "
"is a bit trickier but certainly possible."
msgstr ""
"実際に何かを *する* プログラム（何らかの観測可能な効果を伴う）を書くのにひと"
"工夫いることです。\n"
"でも、確実にできます。"

#. type: Plain text
#: ../src/Tutorial/Intro.md:97
msgid ""
"Idris is a strongly, statically typed programming language. This means, that "
"every Idris expression is given a *type* (for instance: integer, list of "
"strings, boolean, function from integer to boolean, etc.)  and types are "
"verified at compile time to rule out certain common programming errors."
msgstr ""
"Idrisは強力かつ静的に型付けされたプログラミング言語です。つまり、あらゆる"
"Idrisの式には *型*（例えば整数、文字列のリスト、真偽値、整数から真偽値への関"
"数など）があり、型はコンパイル時に検証されます。この時点でプログラミングにお"
"いてよくあるエラーを排除できます。"

#. type: Plain text
#: ../src/Tutorial/Intro.md:103
msgid ""
"For instance, if a function expects an argument of type `String` (a sequence "
"of unicode characters, such as `\"Hello123\"`), it is a *type error* to "
"invoke this function with an argument of type `Integer`, and the Idris "
"compiler will refuse to generate an executable from such an ill-typed "
"program."
msgstr ""
"例えば、もしある関数が `String` 型（unicode文字の連なりで、 `\"Hello123\"` な"
"ど）\n"
"の引数を期待しているとすれば、\n"
"この関数を `Integer` 型で呼び出すと *型エラー* になります。\n"
"そして、Idrisのコンパイラはそのような型付けできていないプログラムから\n"
"実行可能プログラムを生成しません。"

#. type: Plain text
#: ../src/Tutorial/Intro.md:111
msgid ""
"Being *statically typed* means that the Idris compiler will catch type "
"errors at *compile time*, that is, before it generates an executable program "
"that can be run. The opposite to this are *dynamically typed* languages such "
"as Python, which check for type errors at *runtime*, that is, when a program "
"is being executed. It is the philosophy of statically typed languages to "
"catch as many type errors as possible before there even is a program that "
"can be run."
msgstr ""
"*静的に型付け*されていることはIdrisコンパイラが*コンパイル時*、つまり走らせら"
"れる実行可能ファイルを生成する前に型エラーを捕捉できるということです。この対"
"極にあるのが*動的に型付け*されたPythonのような言語で、こちらはエラーを*実行時"
"*、つまりプログラムが実行されているときに確認します。走らせられるプログラムが"
"できあがる前にできる限り多くの型エラーを捕捉することは静的型付け言語の思想で"
"す。"

#. type: Plain text
#: ../src/Tutorial/Intro.md:119
msgid ""
"Even more, Idris is *dependently typed*, which is one of its most "
"characteristic properties in the landscape of programming languages. In "
"Idris, types are *first class*: Types can be passed as arguments to "
"functions, and functions can return types as their results. Even more, types "
"can *depend* on other *values*.  What this means, and why this is incredibly "
"useful, we'll explore in due time."
msgstr ""
"さらに言えば、Idrisは *依存型* です。\n"
"この依存型というものは、プログラミング言語界隈では最も特徴的な性質の1つで"
"す。\n"
"Idrisでは型は第一級です。\n"
"つまり、型は関数の引数に渡せますし、関数は計算結果として型を返すことができま"
"す。\n"
"さらにさらに、型は他の *値* に *依存* することもできます。\n"
"このことが何を意味するのか、そしてなぜこれが滅茶苦茶役に立つのかということ"
"を、\n"
"その時が来たときに探索することにしましょう。"

#. type: Title ###
#: ../src/Tutorial/Intro.md:120
#, no-wrap
msgid "Total Functions"
msgstr "全域関数"

#. type: Plain text
#: ../src/Tutorial/Intro.md:127
msgid ""
"A *total* function is a pure function, that is guaranteed to return a value "
"of the expected return type for every possible input in a finite number of "
"computational steps. A total function will never fail with an exception or "
"loop infinitely, although it can still take arbitrarily long to compute its "
"result"
msgstr ""
"*全域* な関数は純粋な関数である必要があります。つまり全ての取り得る入力につい"
"て有限の計算過程を経て期待された返却型の値を返すことが保証されています。全域"
"関数は例外や無限ループで失敗することは決してありませんが、結果を計算するのに"
"どこまでも長い時間が掛かる可能性があります。"

#. type: Plain text
#: ../src/Tutorial/Intro.md:136
msgid ""
"Idris comes with a totality checker built-in, which enables us to verify the "
"functions we write to be provably total. Totality in Idris is opt-in, as in "
"general, checking the totality of an arbitrary computer program is "
"undecidable (see also the [halting problem](https://en.wikipedia.org/wiki/"
"Halting_problem)).  However, if we annotate a function with the `total` "
"keyword, Idris will fail with a type error, if its totality checker cannot "
"verify that the function in question is indeed total."
msgstr ""
"Idrisには全域性検査器が組込まれています。この検査器により、書いた関数が証明に"
"よって全域であることを検証することができます。Idrisにおける全域性はオプション"
"で有効にするものです。一般に、任意のコンピュータプログラムの全域性の判定は決"
"定不能です（[停止性問題](https://en.wikipedia.org/wiki/Halting_problem)も参照"
"のこと）。しかし、関数に `total` キーワードの註釈を付けた場合、全域性検査器が"
"その関数をたしかに全域かどうか検証できなければ、Idrisは型エラーとして失敗させ"
"ます。"

#. type: Title ##
#: ../src/Tutorial/Intro.md:137
#, no-wrap
msgid "Using the REPL"
msgstr "REPLを使う"

#. type: Plain text
#: ../src/Tutorial/Intro.md:144
msgid ""
"Idris comes with a useful REPL (an acronym for *Read Evaluate Print Loop*), "
"which we will use for tinkering with small ideas, and for quickly "
"experimenting with the code we just wrote.  In order to start a REPL "
"session, run the following command in a terminal:"
msgstr ""
"Idrisには便利なREPL（*Read Evaluate Print Loop*の頭字語）があります。REPLでは"
"ちょっとしたアイディアをもとにいじってみたり、書いたばかりのコードで素早く実"
"験したりできます。REPLセッションを始めるためには、以下のコマンドを端末で実行"
"します。"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Intro.md:145
#, no-wrap
msgid "pack repl\n"
msgstr "pack repl\n"

#. type: Plain text
#: ../src/Tutorial/Intro.md:150
msgid "Idris should now be ready to accept you commands:"
msgstr "そうしたら、Idrisがコマンドを受け付けるようになります。"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Intro.md:151
#, no-wrap
msgid ""
"     ____    __     _         ___\n"
"    /  _/___/ /____(_)____   |__ \\\n"
"    / // __  / ___/ / ___/   __/ /     Version 0.5.1-3c532ea35\n"
"  _/ // /_/ / /  / (__  )   / __/      https://www.idris-lang.org\n"
" /___/\\__,_/_/  /_/____/   /____/      Type :? for help\n"
"\n"
"Welcome to Idris 2.  Enjoy yourself!\n"
"Main>\n"
msgstr ""
"     ____    __     _         ___\n"
"    /  _/___/ /____(_)____   |__ \\\n"
"    / // __  / ___/ / ___/   __/ /     Version 0.5.1-3c532ea35\n"
"  _/ // /_/ / /  / (__  )   / __/      https://www.idris-lang.org\n"
" /___/\\__,_/_/  /_/____/   /____/      Type :? for help\n"
"\n"
"Welcome to Idris 2.  Enjoy yourself!\n"
"Main>\n"

#. type: Plain text
#: ../src/Tutorial/Intro.md:164
msgid ""
"We can go ahead and enter some simple arithmetic expressions. Idris will "
"*evaluate* these and print the result:"
msgstr ""
"簡単な計算式を入力してみましょう。\n"
"Idrisは式を *評価* して結果を表示します。"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Intro.md:165
#, no-wrap
msgid ""
"Main> 2 * 4\n"
"8\n"
"Main> 3 * (7 + 100)\n"
"321\n"
msgstr ""
"Main> 2 * 4\n"
"8\n"
"Main> 3 * (7 + 100)\n"
"321\n"

#. type: Plain text
#: ../src/Tutorial/Intro.md:174
msgid ""
"Since every expression in Idris has an associated *type*, we might want to "
"inspect these as well:"
msgstr ""
"Idrisでの全ての式には *型* があるので、\n"
"型を調べたいですね。"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Intro.md:175
#, no-wrap
msgid ""
"Main> :t 2\n"
"2 : Integer\n"
msgstr ""
"Main> :t 2\n"
"2 : Integer\n"

#. type: Plain text
#: ../src/Tutorial/Intro.md:183
msgid ""
"Here `:t` is a command of the Idris REPL (it is not part of the Idris "
"programming language), and it is used to inspect the type of an expression."
msgstr ""
"ここで `:t` はIdris REPLのコマンド（プログラミング言語Idrisには含まれません）"
"です。\n"
"このコマンドは式の型を調べるのに使えます。"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Intro.md:184
#, no-wrap
msgid ""
"Main> :t 2 * 4\n"
"2 * 4 : Integer\n"
msgstr ""
"Main> :t 2 * 4\n"
"2 * 4 : Integer\n"

#. type: Plain text
#: ../src/Tutorial/Intro.md:199
msgid ""
"Whenever we perform calculations with integer literals without being "
"explicit about the types we want to use, Idris will use `Integer` as a "
"default. `Integer` is an arbitrary precision signed integer type. It is one "
"of the *primitive types* built into the language. Other primitives include "
"fixed precision signed and unsigned integral types (`Bits8`, `Bits16`, "
"`Bits32` `Bits64`, `Int8`, `Int16`, `Int32`, and `Int64`), double precision "
"(64 bit) floating point numbers (`Double`), unicode characters (`Char`) and "
"strings of unicode characters (`String`).  We will use many of these in due "
"time."
msgstr ""
"使いたい型を明示せずに整数リテラルの計算をすると、\n"
"Idrisはデフォルトで常に `Integer` を使います。\n"
"`Integer` は任意精度の符号付き整数型です。\n"
"`Integer` は言語に組込まれている *原始型* の1つです。\n"
"他の原始型には、\n"
"固定精度で符号付きないし符号なしの整数型 (`Bits8`, `Bits16`, `Bits32`, "
"`Bits64`, `Int8`, `Int16`, `Int32`, `Int64`)、\n"
"倍精度 (64 bit) 浮動小数点小数 (`Double`)、\n"
"Unicode文字 (`Char`)、\n"
"そしてUnicode文字の連なり (`String`) があります。\n"
"その時が来たら、これらの型の多くを使っていきます。"

#. type: Title ##
#: ../src/Tutorial/Intro.md:200
#, no-wrap
msgid "A First Idris Program"
msgstr "最初のIdrisプログラム"

#. type: Plain text
#: ../src/Tutorial/Intro.md:207
msgid ""
"We will often start up a REPL for tinkering with small parts of the Idris "
"language, for reading some documentation, or for inspecting the content of "
"an Idris module, but now we will write a minimal Idris program to get "
"started with the language. Here comes the mandatory *Hello World*:"
msgstr ""
"この入門ではIdris言語の一部分を触ってみるのにREPLを立ち上げることが多いで"
"す。\n"
"REPLでは文書を読んだり、Idrisのモジュールの中身を調べたりできます。\n"
"しかしまずは言語を学び始める上で最小のIdrisのプログラムを書いてみましょう。\n"
"なにはともあれ *Hello World* から。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Intro.md:208
#, no-wrap
msgid ""
"main : IO ()\n"
"main = putStrLn \"Hello World!\"\n"
msgstr ""
"main : IO ()\n"
"main = putStrLn \"Hello World!\"\n"

#. type: Plain text
#: ../src/Tutorial/Intro.md:216
msgid ""
"We will inspect the code above in some detail in a moment, but first we'd "
"like to compile and run it. From this project's root directory, run the "
"following:"
msgstr ""
"少ししたら上のコードをもうちょっと詳しく調べます。\n"
"でもまずはコンパイルして実行してみたいですね。\n"
"このプロジェクトのルートディレクトリで以下を実行してください。"

#. type: Fenced code block (sh)
#: ../src/Tutorial/Intro.md:216
#, no-wrap
msgid "pack -o hello exec src/Tutorial/Intro.md\n"
msgstr "pack -o hello exec src/Tutorial/Intro.md\n"

#. type: Plain text
#: ../src/Tutorial/Intro.md:224
msgid ""
"This will create executable `hello` in directory `build/exec`, which can be "
"invoked from the command-line like so (without the dollar prefix; this is "
"used here to distinguish the terminal command from its output):"
msgstr ""
"こうすることで実行可能ファイル `hello` がディレクトリ `build/exec` に作られま"
"す。\n"
"これはコマンドラインで次のようにして実行できます。\n"
"（行頭のドル記号の有無で端末のコマンドとその出力を区別します。）"

#. type: Fenced code block (sh)
#: ../src/Tutorial/Intro.md:225
#, no-wrap
msgid ""
"$ build/exec/hello\n"
"Hello World!\n"
msgstr ""
"$ build/exec/hello\n"
"Hello World!\n"

#. type: Plain text
#: ../src/Tutorial/Intro.md:238
#, no-wrap
msgid ""
"The pack program requires an `.ipkg` to be in scope (in the current\n"
"directory or one of its parent directories) from which\n"
"it will get other settings like the source directory to use\n"
"(`src` in our case). The optional `-o` option gives the name of the\n"
"executable to be generated. Pack comes up with a name of its own\n"
"it this is missing. Type `pack help` for a list\n"
"of available command-line options and commands, and `pack help <cmd>`\n"
"for getting help for a specific command.\n"
msgstr "packプログラムにはスコープ内（現在のディレクトリないし上位のディレクトリ）に`.ipkg`が必要で、そのファイルから使うソースディレクトリ（ここでは`src`）のような他の設定を取得してきます。`-o` オプションは生成される実行可能ファイルに名前を付けます。もしこのオプションがなければPackは自分で名前を出します。`pack help` とすると使えるコマンドラインオプションとコマンドが一覧になり、`pack help <コマンド>`とすると特定のコマンドについてのヘルプが得られます。\n"

#. type: Plain text
#: ../src/Tutorial/Intro.md:241
msgid ""
"As an alternative, you can also load this source file in a REPL session and "
"invoke function `main` from there:"
msgstr ""
"他の方法としては、ソースファイルをREPLセッションで読み込んで、\n"
"`main` 関数を呼び出すというのもあります。"

#. type: Fenced code block (sh)
#: ../src/Tutorial/Intro.md:242
#, no-wrap
msgid "pack repl src/Tutorial/Intro.md\n"
msgstr "pack repl src/Tutorial/Intro.md\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Intro.md:246
#, no-wrap
msgid ""
"Tutorial.Intro> :exec main\n"
"Hello World!\n"
msgstr ""
"Tutorial.Intro> :exec main\n"
"Hello World!\n"

#. type: Plain text
#: ../src/Tutorial/Intro.md:253
msgid ""
"Go ahead and try both ways of building and running function `main` on your "
"system!"
msgstr "両方のやり方を試してみて、システム上で `main` 関数を実行しましょう！"

#. type: Title ##
#: ../src/Tutorial/Intro.md:254
#, no-wrap
msgid "The Shape of an Idris Definition"
msgstr "Idrisの定義の形"

#. type: Plain text
#: ../src/Tutorial/Intro.md:258
msgid ""
"Now that we executed our first Idris program, we will talk a bit more about "
"the code we had to write to define it."
msgstr ""
"最初のIdrisプログラムを実行したところで、\n"
"定義する部分のコードについて話しましょう。"

#. type: Plain text
#: ../src/Tutorial/Intro.md:265
msgid ""
"A typical top level function in Idris consists of three things: The "
"function's name (`main` in our case), its type (`IO ()`)  plus its "
"implementation (`putStrLn \"Hello World\"`). It is easier to explain these "
"things with a couple of simple examples. Below, we define a top level "
"constant for the largest unsigned eight bit integer:"
msgstr ""
"Idrisでのよくある最上位で定義された関数は3つの部分から成り立ちます。\n"
"関数名（ここでは `main` です）、\n"
"関数の型 (`IO ()`)、\n"
"そして関数の実装 (`putStrLn \"Hello World\"`) です。\n"
"いくつかの簡単な例を出すとわかりやすいです。\n"
"以下では最上位の定数に最大の符号なし8ビット整数を定義しています。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Intro.md:266
#, no-wrap
msgid ""
"maxBits8 : Bits8\n"
"maxBits8 = 255\n"
msgstr ""
"maxBits8 : Bits8\n"
"maxBits8 = 255\n"

#. type: Plain text
#: ../src/Tutorial/Intro.md:280
msgid ""
"The first line can be read as: \"We'd like to declare (nullary)  function "
"`maxBits8`. It is of type `Bits8`\". This is called the *function "
"declaration*: We declare, that there shall be a function of the given name "
"and type. The second line reads: \"The result of invoking `maxBits8` should "
"be `255`.\" (As you can see, we can use integer literals for other integral "
"types than just `Integer`.) This is called the *function definition*: "
"Function `maxBits8` should behave as described here when being evaluated."
msgstr ""
"最初の行はこんな感じに読めます。\n"
"「（引数のない）関数 `maxBits8` を定義します。\n"
"型は `Bits8` です。」\n"
"これは *関数宣言* と呼ばれます。\n"
"与えられた名前と型を持つ関数があることを宣言するのです。\n"
"2行目はこんな感じに読めます。\n"
"「`maxBits8` を呼び出した結果は `255` です。」\n"
"（整数リテラルは `Integer` 以外の他の数値の型でも使えることが見てとれま"
"す。）\n"
"これは *関数定義* と呼ばれます。\n"
"`maxBits8` 関数は評価されるときにここに記述されたように振舞います。"

#. type: Plain text
#: ../src/Tutorial/Intro.md:283
msgid ""
"We can inspect this at the REPL. Load this source file into an Idris REPL "
"(as described above), and run the following tests."
msgstr ""
"この関数をREPLで調べることができます。\n"
"このソースファイルを（前述したように）Idris REPLに読み込んで、\n"
"以下を試しましょう。"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Intro.md:284
#, no-wrap
msgid ""
"Tutorial.Intro> maxBits8\n"
"255\n"
"Tutorial.Intro> :t maxBits8\n"
"Tutorial.Intro.maxBits8 : Bits8\n"
msgstr ""
"Tutorial.Intro> maxBits8\n"
"255\n"
"Tutorial.Intro> :t maxBits8\n"
"Tutorial.Intro.maxBits8 : Bits8\n"

#. type: Plain text
#: ../src/Tutorial/Intro.md:292
msgid "We can also use `maxBits8` as part of another expression:"
msgstr "`maxBits8` を他の式の一部として使うこともできます。"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Intro.md:293
#, no-wrap
msgid ""
"Tutorial.Intro> maxBits8 - 100\n"
"155\n"
msgstr ""
"Tutorial.Intro> maxBits8 - 100\n"
"155\n"

#. type: Plain text
#: ../src/Tutorial/Intro.md:300
msgid ""
"I called `maxBits8` a *nullary function*, which is just a fancy word for "
"*constant*. Let's write and test our first *real* function:"
msgstr ""
"私は `maxBits8` を *無引数関数* と呼びました。\n"
"無引数関数は *定数* のちょっと変わった呼び方です。\n"
"*真の* 関数を書いて試してみましょう。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Intro.md:301
#, no-wrap
msgid ""
"distanceToMax : Bits8 -> Bits8\n"
"distanceToMax n = maxBits8 - n\n"
msgstr ""
"distanceToMax : Bits8 -> Bits8\n"
"distanceToMax n = maxBits8 - n\n"

#. type: Plain text
#: ../src/Tutorial/Intro.md:313
#, no-wrap
msgid ""
"This introduces some new syntax and a new kind of type: Function\n"
"types. `distanceToMax : Bits8 -> Bits8` can be read as follows:\n"
"\"`distanceToMax` is a function of one argument of type `Bits8`, which\n"
"returns a result of type `Bits8`\". In the implementation, the argument\n"
"is given a local identifier `n`, which is then used in the\n"
"calculation on the right hand side. Again, go ahead and try this\n"
"function at the REPL:\n"
msgstr ""
"この例ではいくつかの新しい文法と新しい種類の型が紹介されています。\n"
"それは関数型です。\n"
"`distanceToMax : Bits8 -> Bits8` は次のように読み替えることができます。\n"
"「`distanceToMax` は関数で、型が `Bits8` な引数を1つ取って、\n"
"型が `Bits8` な結果を返します。」\n"
"実装では、引数がローカル変数 `n` として与えられています。\n"
"この変数は右側の計算に使われます。\n"
"再びREPLに戻ってこの関数を試しましょう。\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Intro.md:314
#, no-wrap
msgid ""
"Tutorial.Intro> distanceToMax 12\n"
"243\n"
"Tutorial.Intro> :t distanceToMax\n"
"Tutorial.Intro.distanceToMax : Bits8 -> Bits8\n"
"Tutorial.Intro> :t distanceToMax 12\n"
"distanceToMax 12 : Bits8\n"
msgstr ""
"Tutorial.Intro> distanceToMax 12\n"
"243\n"
"Tutorial.Intro> :t distanceToMax\n"
"Tutorial.Intro.distanceToMax : Bits8 -> Bits8\n"
"Tutorial.Intro> :t distanceToMax 12\n"
"distanceToMax 12 : Bits8\n"

#. type: Plain text
#: ../src/Tutorial/Intro.md:325
msgid ""
"As a final example, let's implement a function to calculate the square of an "
"integer:"
msgstr "最後の例として、整数の2乗を計算する関数を実装しましょう。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Intro.md:326
#, no-wrap
msgid ""
"square : Integer -> Integer\n"
"square n = n * n\n"
msgstr ""
"square : Integer -> Integer\n"
"square n = n * n\n"

#. type: Plain text
#: ../src/Tutorial/Intro.md:339
msgid ""
"We now learn a very important aspect of programming in Idris: Idris is a "
"*statically typed* programming language. We are not allowed to freely mix "
"types as we please. Doing so will result in an error message from the type "
"checker (which is part of the compilation process of Idris).  For instance, "
"if we try the following at the REPL, we will get a type error:"
msgstr ""
"ここでIdrisにおけるプログラミングのとても大切な側面を学びましょう。\n"
"Idrisは *静的型付け* プログラミング言語です。\n"
"好き勝手に型をごちゃ混ぜにすることはできません。\n"
"それをすると型検査器がエラーメッセージが出ます（型検査器はIdrisのコンパイル過"
"程の一部です）。\n"
"例えば、以下をREPLに打ち込むと、\n"
"型エラーが出ます。"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Intro.md:340
#, no-wrap
msgid ""
"Tutorial.Intro> square maxBits8\n"
"Error: ...\n"
msgstr ""
"Tutorial.Intro> square maxBits8\n"
"Error: ...\n"

#. type: Plain text
#: ../src/Tutorial/Intro.md:350
msgid ""
"The reason: `square` expects an argument of type `Integer`, but `maxBits8` "
"is of type `Bits8`. Many primitive types are interconvertible (sometimes "
"with the risk of loss of precision) using function `cast` (more on the "
"details later):"
msgstr ""
"その理由は、 `square` が `Integer` 型の引数を期待しているのに、\n"
"`maxBits8` は型が `Bits8` だからです。\n"
"多くの原始型は `cast` 関数（詳細は後述）を使って相互に変換できます（精度が落"
"ちる組み合わせもあります）。"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Intro.md:351
#, no-wrap
msgid ""
"Tutorial.Intro> square (cast maxBits8)\n"
"65025\n"
msgstr ""
"Tutorial.Intro> square (cast maxBits8)\n"
"65025\n"

#. type: Plain text
#: ../src/Tutorial/Intro.md:362
msgid ""
"Note, that in the example above the result is much larger that `maxBits8`. "
"The reason is, that `maxBits8` is first converted to an `Integer` of the "
"same value, which is then squared. If on the other hand we squared "
"`maxBits8` directly, the result would be truncated to still fit the valid "
"range of `Bits8`:"
msgstr ""
"上の例で、結果が `maxBits8` の型での上限よりかなり大きいですね。\n"
"なぜかというと、 `maxBits8` はまず同じ値の `Integer` に変換されて、\n"
"それから2乗されるからです。\n"
"一方でもし `maxBits8` を直接2乗したら、\n"
"結果は `Bits8` の正しい範囲に収まるように切り詰められます。"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Intro.md:363
#, no-wrap
msgid ""
"Tutorial.Intro> maxBits8 * maxBits8\n"
"1\n"
msgstr ""
"Tutorial.Intro> maxBits8 * maxBits8\n"
"1\n"

#. type: Title ##
#: ../src/Tutorial/Intro.md:368
#, no-wrap
msgid "Where to get Help"
msgstr "困ったときは"

#. type: Plain text
#: ../src/Tutorial/Intro.md:373
msgid ""
"There are several resources available online and in print, where you can "
"find help and documentation about the Idris programming language. Here is a "
"non-comprehensive list of them:"
msgstr ""
"オンラインや刊行物の形でいくつかの資料があります。\n"
"それらのプログラミング言語Idrisのドキュメントは役に立つでしょう。\n"
"全ては紹介しきれませんが、次のようなものがあります。"

#. type: Bullet: '* '
#: ../src/Tutorial/Intro.md:375
msgid ""
"[Type-Driven Development with Idris](https://www.manning.com/books/type-"
"driven-development-with-idris)"
msgstr ""
"[Type-Driven Development with Idris](https://www.manning.com/books/type-"
"driven-development-with-idris)"

#. type: Plain text
#: ../src/Tutorial/Intro.md:382
#, no-wrap
msgid ""
"  *The* Idris book! This describes in great detail\n"
"  the core concepts for using Idris and dependent types\n"
"  to write robust and concise code. It uses Idris 1 in\n"
"  its examples, so parts of it have to be slightly adjusted\n"
"  when using Idris 2. There is also a\n"
"  [list of required updates](https://idris2.readthedocs.io/en/latest/typedd/typedd.html).\n"
msgstr ""
"*唯一の* Idrisの書籍です！\n"
"堅牢で簡潔なコードを書くために、Idrisと依存型を使う上での核となる概念がとても詳しく書かれています。\n"
"例ではIdris 1が使われているので、\n"
"Idris 2で使うためには一部分を少しだけ調整する必要があります。\n"
"[更新が必要な箇所の一覧](https://idris2.readthedocs.io/en/latest/typedd/typedd.html)もあります。\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Intro.md:384
msgid ""
"[A Crash Course in Idris 2](https://idris2.readthedocs.io/en/latest/tutorial/"
"index.html)"
msgstr ""
"[A Crash Course in Idris 2](https://idris2.readthedocs.io/en/latest/tutorial/"
"index.html)"

#. type: Plain text
#: ../src/Tutorial/Intro.md:389
#, no-wrap
msgid ""
"  The official Idris 2 tutorial. A comprehensive but dense explanation of\n"
"  all features of Idris 2. I find this to be useful as a reference, and as such\n"
"  it is highly accessible. However, it is not an introduction to functional\n"
"  programming or type-driven development in general.\n"
msgstr ""
"公式のIdris 2入門です。\n"
"網羅的で密度の濃いIdris 2の特徴の説明があります。\n"
"広くアクセスできるため、筆者にとってはリファレンスとして重宝しています。\n"
"しかし、一般には関数型プログラミングや型駆動開発の導入ではありません。\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Intro.md:391
msgid "[The Idris 2 GitHub Repository](https://github.com/idris-lang/Idris2)"
msgstr "[Idris 2のGitHubリポジトリ](https://github.com/idris-lang/Idris2)"

#. type: Plain text
#: ../src/Tutorial/Intro.md:398
#, no-wrap
msgid ""
"  Look here for detailed installation instructions and some\n"
"  introductory material. There is also a [wiki](https://github.com/idris-lang/Idris2/wiki),\n"
"  where you can find a [list of editor plugins](https://github.com/idris-lang/Idris2/wiki/The-Idris-editor-experience),\n"
"  a [list of community libraries](https://github.com/idris-lang/Idris2/wiki/Libraries),\n"
"  a [list of external backends](https://github.com/idris-lang/Idris2/wiki/External-backends),\n"
"  and other useful information.\n"
msgstr ""
"ここにはインストール方法や導入資料があります。\n"
"[Wiki](https://github.com/idris-lang/Idris2/wiki)もあって、\n"
"[エディタのプラグインの一覧](https://github.com/idris-lang/Idris2/wiki/The-Idris-editor-experience)、\n"
"[コミュニティによるライブラリの一覧](https://github.com/idris-lang/Idris2/wiki/Libraries)、\n"
"[バックエンドの一覧](https://github.com/idris-lang/Idris2/wiki/External-backends)、\n"
"などの役に立つ情報が載っています。\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Intro.md:400
msgid "[The Idris 2 Discord Channel](https://discord.gg/UX68fDs2jc)"
msgstr "[Idris 2のDiscordチャンネル](https://discord.gg/UX68fDs2jc)"

#. type: Plain text
#: ../src/Tutorial/Intro.md:406
#, no-wrap
msgid ""
"  If you get stuck with a piece of code, want to ask about some\n"
"  obscure language feature, want to promote your new library,\n"
"  or want to just hang out with other Idris programmers, this\n"
"  is the place to go. The discord channel is pretty active and\n"
"  *very* friendly towards newcomers.\n"
msgstr ""
"コードの一部で詰まったり、\n"
"よくわからない言語の特徴について質問したいとき、\n"
"自分の新しいライブラリを喧伝したいとき、\n"
"あるいは他のIdrisプログラマと駄弁りたいときとかには、\n"
"こちらにお越しください。\n"
"Discordチャンネルはかなり活発で、\n"
"新参者に *とっても* 優しいです。\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Intro.md:408
msgid "The Idris REPL"
msgstr "IdrisのREPL"

#. type: Plain text
#: ../src/Tutorial/Intro.md:414
#, no-wrap
msgid ""
"  Finally, a lot of useful information can be provided by\n"
"  Idris itself. I tend to have at least one REPL session open all the\n"
"  time when programming in Idris. My editor (neovim) is set up\n"
"  to use the [language server for Idris 2](https://github.com/idris-community/idris2-lsp),\n"
"  which is incredibly useful. In the REPL,\n"
msgstr ""
"最後に、沢山の役に立つ情報はIdris自身から提供されます。\n"
"筆者はIdrisでプログラミングするときはずっと、最低でも1つのREPLセッションを立ち上げたままにしがちです。\n"
"私が使っているエディタ (neovim) には\n"
"[Idris2のlanguage server](https://github.com/idris-community/idris2-lsp)が設定されています。\n"
"idris2-lspは大変便利です。\n"
"REPLでは、\n"

#. type: Bullet: '  * '
#: ../src/Tutorial/Intro.md:431
msgid ""
"use `:t` to inspect the type of an expression or meta variable (hole): `:t "
"foldl`,"
msgstr ""
"`:t` で式やメタ変数（穴）の型を調べられます。\n"
"例えば `:t foldl` とします。"

#. type: Bullet: '  * '
#: ../src/Tutorial/Intro.md:431
msgid ""
"use `:ti` to inspect the type of a function including implicit arguments: `:"
"ti foldl`,"
msgstr ""
"`:ti` で暗黙の引数を含む関数の型を調べられます。\n"
"例えば `:ti foldl` とします。"

#. type: Bullet: '  * '
#: ../src/Tutorial/Intro.md:431
msgid "use `:m` to list all meta variables (holes) in scope,"
msgstr "`:m` でスコープ内の全てのメタ変数（穴）の一覧が出てきます。"

#. type: Bullet: '  * '
#: ../src/Tutorial/Intro.md:431
msgid ""
"use `:doc` to access the documentation of a top level function (`:doc the`), "
"a data type plus all its constructors and available hints (`:doc Bool`), a "
"language feature (`:doc case`, `:doc let`, `:doc interface`, `:doc record`, "
"or even `:doc ?`), or an interface (`:doc Uninhabited`),"
msgstr ""
"`:doc` でドキュメントにアクセスできます。\n"
"トップレベルの関数（`:doc the`）、\n"
"データ型とその型の構築子と使えるヒント（`:doc Bool`）、\n"
"言語の特徴（`:doc case`, `:doc let`, `:doc interface`, `:doc record`, `:doc ?"
"` まで）、\n"
"それからインターフェース（`:doc Uninhabited`）が対象です。"

#. type: Bullet: '  * '
#: ../src/Tutorial/Intro.md:431
msgid ""
"use `:module` to import a module from one of the available packages: `:"
"module Data.Vect`,"
msgstr ""
"`:module` で使えるパッケージの中からモジュールをインポートします。\n"
"例えば `:module Data.Vect` とします。"

#. type: Bullet: '  * '
#: ../src/Tutorial/Intro.md:431
msgid ""
"use `:browse` to list the names and types of all functions exported by a "
"loaded module: `:browse Data.Vect`,"
msgstr ""
"`:browse` で読み込むモジュールが提供している全ての関数の名前と型の一覧が出て"
"きます。\n"
"例えば `:browse Data.Vect` とします。"

#. type: Bullet: '  * '
#: ../src/Tutorial/Intro.md:431
msgid ""
"use `:help` to get a list of other commands plus a short description for "
"each."
msgstr "`:help` で他のコマンドとそれぞれの短い説明が一覧で表示されます。"

#. type: Title ##
#: ../src/Tutorial/Intro.md:432
#, no-wrap
msgid "Summary"
msgstr "まとめ"

#. type: Plain text
#: ../src/Tutorial/Intro.md:439
msgid ""
"In this introduction we learned about the most basic features of the Idris "
"programming language. We used the REPL to tinker with our ideas and inspect "
"the types of things in our code, and we used the Idris compiler to compile "
"an Idris source file to an executable."
msgstr ""
"この導入ではプログラミング言語Idrisの一番基本的なことを学びました。\n"
"REPLで考えていることを試したり、\n"
"コード中の型を調べたり、\n"
"IdrisのソースファイルをIdrisのコンパイラで実行可能ファイルにしたりしました。"

#. type: Plain text
#: ../src/Tutorial/Intro.md:443
msgid ""
"We also learned about the basic shape of a top level definition in Idris, "
"which always consists of an identifier (its name), a type, and an "
"implementation."
msgstr ""
"Idrisでの最上位での定義の仕方の基本的な形を学びました。\n"
"定義には、識別子（名前）、型、そして実装があるのでした。"

#. type: Plain text
#: ../src/Tutorial/Intro.md:450
msgid ""
"In the [next chapter](Functions1.md), we start programming in Idris for "
"real. We learn how to write our own pure functions, how functions compose, "
"and how we can treat functions just like other values and pass them around "
"as arguments to other functions."
msgstr ""
"[次の章](Functions1.md)では、\n"
"実際のIdrisでのプログラミングを始めます。\n"
"自分で純粋な関数を書くやりかたや、\n"
"関数を組み合わせる方法、\n"
"そして関数を他の値と同じように扱ったり他の関数の引数として渡したりする方法を"
"学びます。"
