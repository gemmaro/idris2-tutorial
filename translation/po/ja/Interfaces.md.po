# Japanese translations for PACKAGE package
# Copyright (C) 2022 Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# Automatically generated, 2022.
#
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2022-10-08 16:04+0900\n"
"PO-Revision-Date: 2022-08-17 09:36+0900\n"
"Last-Translator: Automatically generated\n"
"Language-Team: none\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#. type: Title ##
#: ../src/Appendices/Neovim.md:364 ../src/Tutorial/DPair.md:1191
#: ../src/Tutorial/DataTypes.md:1319 ../src/Tutorial/Dependent.md:872
#: ../src/Tutorial/Eq.md:1085 ../src/Tutorial/Folds.md:1051
#: ../src/Tutorial/Functions1.md:524 ../src/Tutorial/Functions2.md:924
#: ../src/Tutorial/Functor.md:1395 ../src/Tutorial/IO.md:1095
#: ../src/Tutorial/Interfaces.md:792 ../src/Tutorial/Predicates.md:1358
#: ../src/Tutorial/Traverse.md:1109
#, no-wrap
msgid "Conclusion"
msgstr "まとめ"

#. type: Plain text
#: ../src/Appendices/Neovim.md:374 ../src/Tutorial/DPair.md:1206
#: ../src/Tutorial/DataTypes.md:1368 ../src/Tutorial/Dependent.md:910
#: ../src/Tutorial/Eq.md:1098 ../src/Tutorial/Folds.md:1064
#: ../src/Tutorial/Functions1.md:583 ../src/Tutorial/Functions2.md:964
#: ../src/Tutorial/Functor.md:1427 ../src/Tutorial/IO.md:1125
#: ../src/Tutorial/Interfaces.md:821 ../src/Tutorial/Predicates.md:1369
#: ../src/Tutorial/Prim.md:1411 ../src/Tutorial/Traverse.md:1148
#, no-wrap
msgid ""
"<!-- vi: filetype=idris2\n"
"-->\n"
msgstr ""
"<!-- vi: filetype=idris2\n"
"-->\n"

#. type: Title ###
#: ../src/Tutorial/DPair.md:348 ../src/Tutorial/DataTypes.md:261
#: ../src/Tutorial/Dependent.md:444 ../src/Tutorial/Eq.md:279
#: ../src/Tutorial/Folds.md:373 ../src/Tutorial/Functor.md:381
#: ../src/Tutorial/IO.md:317 ../src/Tutorial/Interfaces.md:189
#: ../src/Tutorial/Predicates.md:305 ../src/Tutorial/Prim.md:448
#: ../src/Tutorial/Traverse.md:247
#, no-wrap
msgid "Exercises part 1"
msgstr "演習 その1"

#. type: Title ###
#: ../src/Tutorial/DPair.md:653 ../src/Tutorial/DataTypes.md:436
#: ../src/Tutorial/Dependent.md:623 ../src/Tutorial/Eq.md:555
#: ../src/Tutorial/Folds.md:668 ../src/Tutorial/Functor.md:962
#: ../src/Tutorial/IO.md:728 ../src/Tutorial/Interfaces.md:352
#: ../src/Tutorial/Predicates.md:672 ../src/Tutorial/Prim.md:712
#: ../src/Tutorial/Traverse.md:574
#, no-wrap
msgid "Exercises part 2"
msgstr "演習 その2"

#. type: Title ###
#: ../src/Tutorial/DPair.md:1128 ../src/Tutorial/DataTypes.md:742
#: ../src/Tutorial/Dependent.md:843 ../src/Tutorial/Eq.md:826
#: ../src/Tutorial/Folds.md:988 ../src/Tutorial/Functor.md:1232
#: ../src/Tutorial/IO.md:949 ../src/Tutorial/Interfaces.md:624
#: ../src/Tutorial/Predicates.md:1020 ../src/Tutorial/Prim.md:936
#: ../src/Tutorial/Traverse.md:1016
#, no-wrap
msgid "Exercises part 3"
msgstr "演習 その3"

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:1362 ../src/Tutorial/Dependent.md:904
#: ../src/Tutorial/Functions1.md:575 ../src/Tutorial/Functions2.md:954
#: ../src/Tutorial/IO.md:1118 ../src/Tutorial/Interfaces.md:813
#, no-wrap
msgid "What's next"
msgstr "お次は？"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:164 ../src/Tutorial/Functions1.md:227
#: ../src/Tutorial/Interfaces.md:504 ../src/Tutorial/Predicates.md:461
#: ../src/Tutorial/Prim.md:646
msgid "And at the REPL:"
msgstr "そしてREPLで次のようにします。"

#. type: Title #
#: ../src/Tutorial/Interfaces.md:1
#, no-wrap
msgid "Interfaces"
msgstr "インターフェース"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:9
msgid ""
"Function overloading - the definition of functions with the same name but "
"different implementations - is a concept found in many programming "
"languages. Idris natively supports overloading of functions: Two functions "
"with the same name can be defined in different modules or namespaces, and "
"Idris will try to disambiguate between these based on the types involved. "
"Here is an example:"
msgstr ""
"関数オーバーロード - つまり同名異実装な関数定義 - は多くのプログラミング言語"
"で見られる概念です。\n"
"Idrisには関数のオーバーロードが備わっています。\n"
"つまり、同名の2つの関数は異なるモジュールや名前空間で定義できますし、\n"
"型をもとに曖昧さを解消しようとします。\n"
"例はこちら。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Interfaces.md:10
#, no-wrap
msgid ""
"module Tutorial.Interfaces\n"
"\n"
"%default total\n"
"\n"
"namespace Bool\n"
"  export\n"
"  size : Bool -> Integer\n"
"  size True  = 1\n"
"  size False = 0\n"
"\n"
"namespace Integer\n"
"  export\n"
"  size : Integer -> Integer\n"
"  size = id\n"
"\n"
"namespace List\n"
"  export\n"
"  size : List a -> Integer\n"
"  size = cast . length\n"
msgstr ""
"module Tutorial.Interfaces\n"
"\n"
"%default total\n"
"\n"
"namespace Bool\n"
"  export\n"
"  size : Bool -> Integer\n"
"  size True  = 1\n"
"  size False = 0\n"
"\n"
"namespace Integer\n"
"  export\n"
"  size : Integer -> Integer\n"
"  size = id\n"
"\n"
"namespace List\n"
"  export\n"
"  size : List a -> Integer\n"
"  size = cast . length\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:35
msgid ""
"Here, we defined three different functions called `size`, each in its own "
"namespace. We can disambiguate between these by prefixing them with their "
"namespace:"
msgstr ""
"ここでは`size`という名前の互いに異なる関数をそれぞれの名前空間で定義しまし"
"た。\n"
"これらの曖昧さを解消するにはそれぞれの名前空間を前置すればよいです。"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Interfaces.md:36
#, no-wrap
msgid ""
"Tutorial.Interfaces> :t Bool.size\n"
"Tutorial.Interfaces.Bool.size : Bool -> Integer\n"
msgstr ""
"Tutorial.Interfaces> :t Bool.size\n"
"Tutorial.Interfaces.Bool.size : Bool -> Integer\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:42
msgid "However, this is usually not necessary:"
msgstr "しかし、大抵は必要ありません。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Interfaces.md:43
#, no-wrap
msgid ""
"mean : List Integer -> Integer\n"
"mean xs = sum xs `div` size xs\n"
msgstr ""
"mean : List Integer -> Integer\n"
"mean xs = sum xs `div` size xs\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:51
msgid ""
"As you can see, Idris can disambiguate between the different `size` "
"functions, since `xs` is of type `List Integer`, which unifies only with "
"`List a`, the argument type of `List.size`."
msgstr ""
"見てみるとIdrisは互いに異なる`size`関数の曖昧さを解消できていることがわかりま"
"す。\n"
"`xs`は型`List Integer`であり、この型は`List a`にのみ統合できるので、\n"
"`List a`が引数の型である`List.size`が選ばれます。"

#. type: Title ##
#: ../src/Tutorial/Interfaces.md:52
#, no-wrap
msgid "Interface Basics"
msgstr "インターフェースの基本"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:57
msgid ""
"While function overloading as described above works well, there are use "
"cases, where this form of overloaded functions leads to a lot of code "
"duplication."
msgstr ""
"関数オーバーロードは上述したようにいい感じに動くものの、\n"
"こうした関数オーバーロードの形式だと沢山のコードの重複に繋がるような使用例が"
"あります。"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:61
msgid ""
"As an example, consider a function `cmp` (short for *compare*, which is "
"already exported by the *Prelude*), for describing an ordering for the "
"values of type `String`:"
msgstr ""
"例として、関数`cmp`を考えてみましょう。\n"
"（*compare*を縮めたもので、既に*Prelude*から公開されています。）\n"
"この関数は型`String`の値の序列を表現するものとします。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Interfaces.md:62
#, no-wrap
msgid "cmp : String -> String -> Ordering\n"
msgstr "cmp : String -> String -> Ordering\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:70
msgid ""
"We'd also like to have similar functions for many other data types.  "
"Function overloading allows us to do just that, but `cmp` is not an isolated "
"piece of functionality. From it, we can derive functions like "
"`greaterThan'`, `lessThan'`, `minimum'`, `maximum'`, and many others:"
msgstr ""
"似たような関数が沢山の他のデータ型についても欲しいです。\n"
"これだけだったら関数オーバーロードでいいですが、\n"
"`cmp`の機能性ははそれだけに留まりません。\n"
"この関数があれば`greaterThan`, `lessThan`, `minimum`, `maximum`やその他諸々の"
"関数を導出できます。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Interfaces.md:71
#, no-wrap
msgid ""
"lessThan' : String -> String -> Bool\n"
"lessThan' s1 s2 = LT == cmp s1 s2\n"
"\n"
"greaterThan' : String -> String -> Bool\n"
"greaterThan' s1 s2 = GT == cmp s1 s2\n"
"\n"
"minimum' : String -> String -> String\n"
"minimum' s1 s2 =\n"
"  case cmp s1 s2 of\n"
"    LT => s1\n"
"    _  => s2\n"
"\n"
"maximum' : String -> String -> String\n"
"maximum' s1 s2 =\n"
"  case cmp s1 s2 of\n"
"    GT => s1\n"
"    _  => s2\n"
msgstr ""
"lessThan' : String -> String -> Bool\n"
"lessThan' s1 s2 = LT == cmp s1 s2\n"
"\n"
"greaterThan' : String -> String -> Bool\n"
"greaterThan' s1 s2 = GT == cmp s1 s2\n"
"\n"
"minimum' : String -> String -> String\n"
"minimum' s1 s2 =\n"
"  case cmp s1 s2 of\n"
"    LT => s1\n"
"    _  => s2\n"
"\n"
"maximum' : String -> String -> String\n"
"maximum' s1 s2 =\n"
"  case cmp s1 s2 of\n"
"    GT => s1\n"
"    _  => s2\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:94
msgid ""
"We'd need to implement all of these again for the other types with a `cmp` "
"function, and most if not all of these implementations would be identical to "
"the ones written above. That's a lot of code repetition."
msgstr ""
"これら全てを`cmp`関数を使って他の型について再実装しなくてはならず、\n"
"それにこれらの実装は、全てではないにしても、上に書いたものと同じになりま"
"す。\n"
"そうなると沢山のコードの重複になります。"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:99
msgid ""
"One way to solve this is to use higher-order functions.  For instance, we "
"could define function `minimumBy`, which takes a comparison function as its "
"first argument and returns the smaller of the two remaining arguments:"
msgstr ""
"1つの方法として高階関数を使うという手があります。\n"
"例えば、関数`minimumBy`を定義するとしましょう。\n"
"この関数は最初の引数に比較関数を取り、残りの2つの引数のうちより小さいほうを返"
"します。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Interfaces.md:100
#, no-wrap
msgid ""
"minimumBy : (a -> a -> Ordering) -> a -> a -> a\n"
"minimumBy f a1 a2 =\n"
"  case f a1 a2 of\n"
"    LT => a1\n"
"    _  => a2\n"
msgstr ""
"minimumBy : (a -> a -> Ordering) -> a -> a -> a\n"
"minimumBy f a1 a2 =\n"
"  case f a1 a2 of\n"
"    LT => a1\n"
"    _  => a2\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:114
msgid ""
"This solution is another proof of how higher-order functions allow us to "
"reduce code duplication. However, the need to explicitly pass around the "
"comparison function all the time can get tedious as well.  It would be nice, "
"if we could teach Idris to come up with such a function on its own."
msgstr ""
"この解決策は高階関数があればコードの重複を減らせることの傍証になっていま"
"す。\n"
"しかしながら、いつも比較関数を持ち回らなければいけないのは億劫です。\n"
"Idrisにこの例での比較関数のようなものを自分で思い出せるようにさせられたらいい"
"ですね。"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:116
msgid "Interfaces solve exactly this issue. Here's an example:"
msgstr ""
"インターフェースはまさにこの問題を解消するものです。\n"
"こちらが例です。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Interfaces.md:117
#, no-wrap
msgid ""
"interface Comp a where\n"
"  comp : a -> a -> Ordering\n"
"\n"
"implementation Comp Bits8 where\n"
"  comp = compare\n"
"\n"
"implementation Comp Bits16 where\n"
"  comp = compare\n"
msgstr ""
"interface Comp a where\n"
"  comp : a -> a -> Ordering\n"
"\n"
"implementation Comp Bits8 where\n"
"  comp = compare\n"
"\n"
"implementation Comp Bits16 where\n"
"  comp = compare\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:133
msgid ""
"The code above defines *interface* `Comp` providing function `comp` for "
"calculating the ordering for two values of a type `a`, followed by two "
"*implementations* of this interface for types `Bits8` and `Bits16`. Note, "
"that the `implementation` keyword is optional."
msgstr ""
"上記のコードは*インターフェース*`Comp`を定義し、\n"
"型`a`の2つの値の序列を計算するための関数`comp`を提供しています。\n"
"これにさらにこのインターフェースについての型`Bits8`と`Bits16`のための2つの*実"
"装*が続きます。\n"
"ただし`implementation`キーワードはあってもなくてもよいです。"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:137
msgid ""
"The `comp` implementations for `Bits8` and `Bits16` both use function "
"`compare`, which is part of a similar interface from the *Prelude* called "
"`Ord`."
msgstr ""
"`Bits8`と`Bits16`のための`comp`の実装両方で使われている関数`compare`は、\n"
"*Prelude*の似たようなインターフェースである`Ord`の一部です。"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:139
msgid "The next step is to look at the type of `comp` at the REPL:"
msgstr "次に`comp`の型をREPLで見てみます。"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Interfaces.md:140
#, no-wrap
msgid ""
"Tutorial.Interfaces> :t comp\n"
"Tutorial.Interfaces.comp : Comp a => a -> a -> Ordering\n"
msgstr ""
"Tutorial.Interfaces> :t comp\n"
"Tutorial.Interfaces.comp : Comp a => a -> a -> Ordering\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:154
#, no-wrap
msgid ""
"The interesting part in the type signature of `comp` is\n"
"the initial `Comp a =>` argument. Here, `Comp` is a *constraint* on\n"
"type parameter `a`. This signature can be read as:\n"
"\"For any type `a`, given an implementation\n"
"of interface `Comp` for `a`, we can compare two values\n"
"of type `a` and return an `Ordering` for these.\"\n"
"Whenever we invoke `comp`, we expect Idris to come up with a\n"
"value of type `Comp a` on its own, hence the new `=>` arrow.\n"
"If Idris fails to do so, it will answer with a type error.\n"
msgstr ""
"`comp`の型シグネチャの面白い部分は最初の引数`Comp a =>`です。\n"
"ここで`Comp`は型変数`a`の*制約*です。\n"
"このシグネチャはこんな感じに読めます。\n"
"「あらゆる型`a`、ただしインターフェース`Comp`の実装があるもの、\n"
"については型`a`の2つの値を比較でき、それらの`Ordering`を返す。」\n"
"`comp`をどんなもので呼び出そうとも、\n"
"Idris自ら`Comp a`であるような型の値を思い付いてくれます。\n"
"そう、新しい矢印`=>`があればね。\n"
"もしIdrisがこれに失敗するなら、それは型エラーです。\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:158
msgid ""
"We can now use `comp` in the implementations of related functions.  All we "
"have to do is to also prefix these derived functions with a `Comp` "
"constraint:"
msgstr ""
"これにて`comp`を関係する関数の実装に使えます。\n"
"やらなければいけないことはこれらの導出される関数に`Comp`制約を前置することだ"
"けです。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Interfaces.md:159
#, no-wrap
msgid ""
"lessThan : Comp a => a -> a -> Bool\n"
"lessThan s1 s2 = LT == comp s1 s2\n"
"\n"
"greaterThan : Comp a => a -> a -> Bool\n"
"greaterThan s1 s2 = GT == comp s1 s2\n"
"\n"
"minimum : Comp a => a -> a -> a\n"
"minimum s1 s2 =\n"
"  case comp s1 s2 of\n"
"    LT => s1\n"
"    _  => s2\n"
"\n"
"maximum : Comp a => a -> a -> a\n"
"maximum s1 s2 =\n"
"  case comp s1 s2 of\n"
"    GT => s1\n"
"    _  => s2\n"
msgstr ""
"lessThan : Comp a => a -> a -> Bool\n"
"lessThan s1 s2 = LT == comp s1 s2\n"
"\n"
"greaterThan : Comp a => a -> a -> Bool\n"
"greaterThan s1 s2 = GT == comp s1 s2\n"
"\n"
"minimum : Comp a => a -> a -> a\n"
"minimum s1 s2 =\n"
"  case comp s1 s2 of\n"
"    LT => s1\n"
"    _  => s2\n"
"\n"
"maximum : Comp a => a -> a -> a\n"
"maximum s1 s2 =\n"
"  case comp s1 s2 of\n"
"    GT => s1\n"
"    _  => s2\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:185
msgid ""
"Note, how the definition of `minimum` is almost identical to `minimumBy`. "
"The only difference being that in case of `minimumBy` we had to pass the "
"comparison function as an explicit argument, while for `minimum` it is "
"provided as part of the `Comp` implementation, which is passed around by "
"Idris for us."
msgstr ""
"`minimum`の定義は`minimumBy`と瓜二つですね。\n"
"強いて違うところを挙げるとすれば、\n"
"`minimumBy`の場合は比較関数を明示的な引数として渡さねばならないところ、\n"
"`minimum`は`Comp`の実装の一部で提供されているのでIdrisが代わりに渡してくれる"
"ことです。"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:188
msgid ""
"Thus, we have defined all these utility functions once and for all for every "
"type with an implementation of interface `Comp`."
msgstr ""
"したがってこれら全ての小間物的関数を一度定義してしまえば、\n"
"インターフェース`Comp`の実装がある全ての型に適用できます。"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:195
#, no-wrap
msgid ""
"1. Implement function `anyLarger`, which should return `True`,\n"
"if and only if a list of values contains at least one element larger\n"
"than a given reference value. Use interface `Comp` in your\n"
"implementation.\n"
msgstr ""
"1. 関数`anyLarger`を実装してください。\n"
"この関数は、値のリストが与えられた参照値より大きい要素を少なくとも1つ含んでいるときに限り`True`を返します。\n"
"インターフェース`Comp`を実装で使ってください。\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:200
#, no-wrap
msgid ""
"2. Implement function `allLarger`, which should return `True`,\n"
"if and only if a list of values contains *only* elements larger\n"
"than a given reference value. Note, that this is trivially true\n"
"for the empty list. Use interface `Comp` in your implementation.\n"
msgstr ""
"2. 関数`allLarger`を実装してください。\n"
"この関数は、値のリストが与えられた参照値より大きい要素*のみ*を含んでいるときに限り`True`を返します。\n"
"ここで、自明な場合である空リストについては真になります。\n"
"インターフェース`Comp`を実装で使ってください。\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:206
#, no-wrap
msgid ""
"3. Implement function `maxElem`, which tries to extract the\n"
"largest element from a list of values with a `Comp` implementation.\n"
"Likewise for `minElem`, which tries to extract the smallest element.\n"
"Note, that the possibility of the list being empty must be considered\n"
"when deciding on the output type.\n"
msgstr ""
"3. 関数`maxElem`を実装してください。\n"
"この関数は`Comp`の実装を使って値のリストから最も大きい要素を抽出しようとします。\n"
"`minElem`も同様にしてください。\n"
"この関数は最も小さい要素を抽出しようとするものです。\n"
"出力の型を決めるときは、リストが空になる可能性があることを考慮しなくてはいけませんよ。\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:210
#, no-wrap
msgid ""
"4. Define an interface `Concat` for values like lists or\n"
"strings, which can be concatenated. Provide implementations\n"
"for lists and strings.\n"
msgstr ""
"4. リストや文字列のような連結できる値のためのインターフェース`Concat`を定義してください。\n"
"リストと文字列向けの実装を提供してください。\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:215
#, no-wrap
msgid ""
"5. Implement function `concatList` for concatenating the\n"
"values in a list holding values with a `Concat` implementation.\n"
"Make sure to reflect the possibility of the list being empty in your\n"
"output type.\n"
msgstr ""
"5. `Concat`の実装が備わる値を持つリスト中の値を連結する関数`concatList`を実装してください。\n"
"リストが空になる可能性があることを出力の型に反映してくださいね。\n"

#. type: Title ##
#: ../src/Tutorial/Interfaces.md:216
#, no-wrap
msgid "More about Interfaces"
msgstr "もっとインターフェース"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:224
msgid ""
"In the last section, we learned about the very basics of interfaces: Why "
"they are useful and how to define and implement them.  In this section, we "
"will learn about some slightly advanced concepts: Extending interfaces, "
"interfaces with constraints, and default implementations."
msgstr ""
"先の節ではごく基本的なインターフェースを学びました。\n"
"なぜ便利なのか、そしてどのように定義し実装するのかについてです。\n"
"この節では僅かに発展的な概念を学びます。\n"
"それはインターフェースを拡張すること、制約付きのインターフェース、そして既定"
"実装です。"

#. type: Title ###
#: ../src/Tutorial/Interfaces.md:225
#, no-wrap
msgid "Extending Interfaces"
msgstr "インターフェースを拡張する"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:233
msgid ""
"Some interfaces form a kind of hierarchy. For instance, for the `Concat` "
"interface used in exercise 4, there might be a child interface called "
"`Empty`, for those types, which have a neutral element with relation to "
"concatenation.  In such a case, we make an implementation of `Concat` a "
"prerequisite for implementing `Empty`:"
msgstr ""
"階層を形成するインターフェースがあります。\n"
"例えば演習4で使った`Concat`インターフェースについては、\n"
"`Empty`という名前の子インターフェースがあってもいいでしょう。\n"
"このインターフェースを満たすような型には、連結の際に何の効果も生じない値があ"
"ります。\n"
"そのような場合、`Concat`の実装が`Empty`の実装の必要条件にできます。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Interfaces.md:234
#, no-wrap
msgid ""
"interface Concat a where\n"
"  concat : a -> a -> a\n"
"\n"
"implementation Concat String where\n"
"  concat = (++)\n"
"\n"
"interface Concat a => Empty a where\n"
"  empty : a\n"
"\n"
"implementation Empty String where\n"
"  empty = \"\"\n"
msgstr ""
"interface Concat a where\n"
"  concat : a -> a -> a\n"
"\n"
"implementation Concat String where\n"
"  concat = (++)\n"
"\n"
"interface Concat a => Empty a where\n"
"  empty : a\n"
"\n"
"implementation Empty String where\n"
"  empty = \"\"\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:254
#, no-wrap
msgid ""
"`Concat a => Empty a` should be read as: \"An implementation\n"
"of `Concat` for type `a` is a *prerequisite* for there being\n"
"an implementation of `Empty` for `a`.\"\n"
"But this also means that, whenever we have an implementation\n"
"of interface `Empty`, we *must* also have an implementation of `Concat`\n"
"and can invoke the corresponding functions:\n"
msgstr ""
"`Concat a => Empty a`はこのように読めます。\n"
"「`Concat`の型`a`のための実装は、`a`に対して`Empty`の実装をするための必要条件である。」\n"
"しかしこれは、インターフェース`Empty`の実装があるならば、常に`Concat`の実装が*なくてはならず*、\n"
"いつでも`Concat`にある関数を呼び出すことができる、という意味でもあるのです。\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Interfaces.md:255
#, no-wrap
msgid ""
"concatListE : Empty a => List a -> a\n"
"concatListE []        = empty\n"
"concatListE (x :: xs) = concat x (concatListE xs)\n"
msgstr ""
"concatListE : Empty a => List a -> a\n"
"concatListE []        = empty\n"
"concatListE (x :: xs) = concat x (concatListE xs)\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:264
msgid ""
"Note, how in the type of `concatListE` we only used an `Empty` constraint, "
"and how in the implementation we were still able to invoke both `empty` and "
"`concat`."
msgstr ""
"`concatListE`の型で`Empty`制約のみ使っているにも関わらず、\n"
"実装で`empty`と`concat`の両方を呼び出せていますね。"

#. type: Title ###
#: ../src/Tutorial/Interfaces.md:265
#, no-wrap
msgid "Constrained Implementations"
msgstr "制約付きの実装"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:273
msgid ""
"Sometimes, it is only possible to implement an interface for a generic type, "
"if its type parameters implement this interface as well. For instance, "
"implementing interface `Comp` for `Maybe a` makes sense only if type `a` "
"itself implements `Comp`. We can constrain interface implementations with "
"the same syntax we use for constrained functions:"
msgstr ""
"ときに、ある汎化型のインターフェースを実装できるのが、\n"
"その型変数がこのインターフェースを実装しているときだけ、ということがありま"
"す。\n"
"たとえば、インターフェース`Comp`を`Maybe a`に実装するのが可能なのは、\n"
"型`a`自体が`Comp`を実装しているときだけです。\n"
"インターフェースの実装に制約を課すのは、制約付きの関数で使ったのと同じ文法で"
"できます。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Interfaces.md:274
#, no-wrap
msgid ""
"implementation Comp a => Comp (Maybe a) where\n"
"  comp Nothing  Nothing  = EQ\n"
"  comp (Just _) Nothing  = GT\n"
"  comp Nothing  (Just _) = LT\n"
"  comp (Just x) (Just y) = comp x y\n"
msgstr ""
"implementation Comp a => Comp (Maybe a) where\n"
"  comp Nothing  Nothing  = EQ\n"
"  comp (Just _) Nothing  = GT\n"
"  comp Nothing  (Just _) = LT\n"
"  comp (Just x) (Just y) = comp x y\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:292
msgid ""
"This is not the same as extending an interface, although the syntax looks "
"very similar. Here, the constraint lies on a *type parameter* instead of the "
"full type.  The last line in the implementation of `Comp (Maybe a)` compares "
"the values stored in the two `Just`s. This is only possible, if there is a "
"`Comp` implementation for these values as well. Go ahead, and remove the "
"`Comp a` constraint from the above implementation. Learning to read and "
"understand Idris' type errors is important for fixing them."
msgstr ""
"これはインターフェースを拡張することとは同じではありません。\n"
"文法がよく似てはいますが。\n"
"制約は*型変数*に課されていて、全体の型ではないですね。\n"
"`Comp (Maybe a)`の実装の最後の行では2つの`Just`に格納された値を比較します。\n"
"これが可能となるのは、これらの値にも`Comp`の実装があるときだけです。\n"
"さあ、上記の実装から`Comp a`制約を消去してみましょう。\n"
"Idrisの型エラーを読み解くことは、修正を行う上で大事です。"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:295
msgid "The good thing is, that Idris will solve all these constraints for us:"
msgstr "幸いにもIdrisはこれら全ての制約を代わりに解いてくれます。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Interfaces.md:296
#, no-wrap
msgid ""
"maxTest : Maybe Bits8 -> Ordering\n"
"maxTest = comp (Just 12)\n"
msgstr ""
"maxTest : Maybe Bits8 -> Ordering\n"
"maxTest = comp (Just 12)\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:305
msgid ""
"Here, Idris tries to find an implementation for `Comp (Maybe Bits8)`.  In "
"order to do so, it needs an implementation for `Comp Bits8`.  Go ahead, and "
"replace `Bits8` in the type of `maxTest` with `Bits64`, and have a look at "
"the error message Idris produces."
msgstr ""
"ここでIdrisは`Comp (Maybe Bits8)`の実装を見つけ出そうとします。\n"
"そのためには`Comp Bits8`のための実装が必要です。\n"
"さあさあ`maxInt`の型にある`Bits8`を`Bits64`に変えてみましょう。\n"
"どんなエラー文言をIdrisが出すでしょうか。"

#. type: Title ###
#: ../src/Tutorial/Interfaces.md:306
#, no-wrap
msgid "Default Implementations"
msgstr "既定実装"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:320
msgid ""
"Sometimes, we'd like to pack several related functions in an interface to "
"allow programmers to implement each in the most efficient way, although they "
"*could* be implemented in terms of each other. For instance, consider an "
"interface `Equals` for comparing two values for equality, with functions "
"`eq` returning `True` if two values are equal and `neq` returning `True` if "
"they are not. Surely, we can implement `neq` in terms of `eq`, so most of "
"the time when implementing `Equals`, we will only implement the latter.  In "
"this case, we can give an implementation for `neq` already in the definition "
"of `Equals`:"
msgstr ""
"ときどき、いくつかの関係する関数を1つのインターフェースに収めて、\n"
"そのインターフェースにある関数を使うことが*できながらも*、\n"
"プログラマがそれぞれの関数をもっとも効率的に動くように実装できるようにしたい"
"ことがあります。\n"
"たとえば、2つの値の等値性で比較するインターフェース`Equals`を考えましょう。\n"
"このインターフェースには2つの値が等しいとき`True`を返す関数`eq`と、\n"
"等しくないときに`True`を返す`neq`があります。\n"
"もちろん`neq`は`eq`を使って実装できますし、\n"
"ほとんどの場合で`Equals`を実装するときは`eq`のみを実装すればよいでしょう。\n"
"この場合、`neq`の実装を`Equals`の定義中に含めてしまうことができます。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Interfaces.md:321
#, no-wrap
msgid ""
"interface Equals a where\n"
"  eq : a -> a -> Bool\n"
"\n"
"  neq : a -> a -> Bool\n"
"  neq a1 a2 = not (eq a1 a2)\n"
msgstr ""
"interface Equals a where\n"
"  eq : a -> a -> Bool\n"
"\n"
"  neq : a -> a -> Bool\n"
"  neq a1 a2 = not (eq a1 a2)\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:332
msgid ""
"If in an implementation of `Equals` we only implement `eq`, Idris will use "
"the default implementation for `neq` as shown above:"
msgstr ""
"`Equals`の実装で`eq`のみ実装した場合は、\n"
"Idrisは上記の`neq`の既定実装を使うことになります。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Interfaces.md:333
#, no-wrap
msgid ""
"Equals String where\n"
"  eq = (==)\n"
msgstr ""
"Equals String where\n"
"  eq = (==)\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:340
msgid ""
"If on the other hand we'd like to provide explicit implementations for both "
"functions, we can do so as well:"
msgstr "他方で両方の関数に陽に実装を提供したい場合も同様に可能です。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Interfaces.md:341
#, no-wrap
msgid ""
"Equals Bool where\n"
"  eq True True   = True\n"
"  eq False False = True\n"
"  eq _ _         = False\n"
"\n"
"  neq True  False = True\n"
"  neq False True  = True\n"
"  neq _ _         = False\n"
msgstr ""
"Equals Bool where\n"
"  eq True True   = True\n"
"  eq False False = True\n"
"  eq _ _         = False\n"
"\n"
"  neq True  False = True\n"
"  neq False True  = True\n"
"  neq _ _         = False\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:358
#, no-wrap
msgid ""
"1. Implement interfaces `Equals`, `Comp`, `Concat`, and\n"
"  `Empty` for pairs, constraining your implementations as necessary.\n"
"  (Note, that multiple constraints can be given sequentially like\n"
"  other function arguments: `Comp a => Comp b => Comp (a,b)`.)\n"
msgstr ""
"1. インターフェース`Equals`, `Comp`, `Concat`, `Empty`を対（2つ組タプル）に実装してください。\n"
"  実装では必要に応じて制約を課して構いません。\n"
"  （他の関数の引数と同様に、複数の制約を連続して課すことができます。\n"
"  例えば`Comp a => Comp b => Comp (a,b)`です。）\n"

#. type: Bullet: '2. '
#: ../src/Tutorial/Interfaces.md:361
msgid ""
"Below is an implementation of a binary tree. Implement interfaces `Equals` "
"and `Concat` for this type."
msgstr ""
"以下は2分木の実装です。\n"
"インターフェース`Equals`と`Concat`をこの型に実装してください。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Interfaces.md:362
#, no-wrap
msgid ""
"   data Tree : Type -> Type where\n"
"     Leaf : a -> Tree a\n"
"     Node : Tree a -> Tree a -> Tree a\n"
msgstr ""
"   data Tree : Type -> Type where\n"
"     Leaf : a -> Tree a\n"
"     Node : Tree a -> Tree a -> Tree a\n"

#. type: Title ##
#: ../src/Tutorial/Interfaces.md:368
#, no-wrap
msgid "Interfaces in the *Prelude*"
msgstr "*Prelude*にあるインターフェース"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:374
msgid ""
"The Idris *Prelude* provides several interfaces plus implementations that "
"are useful in almost every non-trivial program. I'll introduce the basic "
"ones here. The more advanced ones will be discussed in later chapters."
msgstr ""
"Idrisの*Prelude*はいくつかのインターフェースと実装を提供します。\n"
"これらはほぼ全てのある程度以上のプログラムで便利です。\n"
"基本的なものをここで紹介します。\n"
"より発展的なものは後の章でお話ししましょう。"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:378
msgid ""
"Most of these interfaces come with associated mathematical laws, and "
"implementations are assumed to adhere to these laws. These laws will be "
"given here as well."
msgstr ""
"これらのインターフェースのほとんどは数学的な法則に関連します。\n"
"そして、実装はこれらの実装に従うことになっています。\n"
"法則についてもここで触れます。"

#. type: Title ###
#: ../src/Tutorial/Interfaces.md:379
#, no-wrap
msgid "`Eq`"
msgstr "`Eq`"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:389
msgid ""
"Probably the most often used interface, `Eq` corresponds to interface "
"`Equals` we used above as an example. Instead of `eq` and `neq`, `Eq` "
"provides two operators `(==)` and `(/=)` for comparing two values of the "
"same type for being equal or not. Most of the data types defined in the "
"*Prelude* come with an implementation of `Eq`, and whenever programmers "
"define their own data types, `Eq` is typically one of the first interfaces "
"they implement."
msgstr ""
"おそらく最も使われているインターフェースは`Eq`でしょう。\n"
"これは前述の例で使ったインターフェース`Equal`に対応します。\n"
"`eq`と`neq`の代わりに、`Eq`は2つの演算子`(==)`と`(/=)`を提供し、\n"
"2つの同じ型の値について等しいか異なるかを比べられます。\n"
"*Prelude*で定義されているほとんどのデータ型は`Eq`の実装付きですし、\n"
"プログラマが自前のデータ型を作るときも最初に実装するインターフェースでしょ"
"う。"

#. type: Title ####
#: ../src/Tutorial/Interfaces.md:390
#, no-wrap
msgid "`Eq` Laws"
msgstr "`Eq`の法則"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:393
msgid "We expect the following laws to hold for all implementations of `Eq`:"
msgstr "`Eq`の全ての実装について以下の法則を満たすようにしてください。"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:396
#, no-wrap
msgid ""
"* `(==)` is *reflexive*: `x == x = True` for all `x`. This means, that\n"
"every value is equal to itself.\n"
msgstr ""
"* `(==)`は*反射的*です。\n"
"`x == x = True`が全ての`x`について成り立ちます。\n"
"つまり、全ての値はそれ自身と等しいです。\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:399
#, no-wrap
msgid ""
"* `(==)` is *symmetric*: `x == y = y == x` for all `x` and `y`.\n"
"This means, that the order of arguments passed to `(==)` does not matter.\n"
msgstr ""
"* `(==)`は*対称的*です。\n"
"`x == y = y == x`が全ての`x`と`y`について成り立ちます。\n"
"つまり、`(==)`の引数の順序は重要ではありません。\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:402
#, no-wrap
msgid ""
"* `(==)` is *transitive*: From `x == y = True` and `y == z = True` follows\n"
"`x == z = True`.\n"
msgstr ""
"* `(==)`は*推移的*です。\n"
"`x == y = True`と`y == z = True`から`x == z = True`が導かれます。\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:405
#, no-wrap
msgid ""
"* `(/=)` is the negation of `(==)`: `x == y = not (x /= y)`\n"
"for all `x` and `y`.\n"
msgstr "* `(/=)`は`(==)`の否定です。`x == y = not (x /= y)`が全ての`x`と`y`について成り立ちます。\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:410
msgid ""
"In theory, Idris has the power to verify these laws at compile time for many "
"non-primitive types. However, out of pragmatism this is not required when "
"implementing `Eq`, since writing such proofs can be quite involved."
msgstr ""
"理論上、Idrisにはこれらの法則を非原始型に対してコンパイル時に検証する能力があ"
"ります。\n"
"しかしながら、実用上`Eq`の実装には必要ではありません。\n"
"そのような証明を書くというのはちょっとしたハマりどころだからです。"

#. type: Title ###
#: ../src/Tutorial/Interfaces.md:411
#, no-wrap
msgid "`Ord`"
msgstr "`Ord`"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:419
#, no-wrap
msgid ""
"The pendant to `Comp` in the *Prelude* is interface `Ord`. In addition\n"
"to `compare`, which is identical to our own `comp` it provides comparison\n"
"operators `(>=)`, `(>)`, `(<=)`, and `(<)`, as well as utility functions\n"
"`max` and `min`. Unlike `Comp`, `Ord` extends `Eq`,\n"
"so whenever there is an `Ord` constraint, we also have access to operators\n"
"`(==)` and `(/=)` and related functions.\n"
msgstr ""
"*Prelude*版`Comp`として`Ord`があります。\n"
"自前の`comp`と等価な`compare`に加えて、\n"
"比較演算子`(>=)`, `(>)`, `(<=)`, `(<)`や小間物関数`max`と`min`を提供します。\n"
"`Comp`とは異なり、`Ord`は`Eq`を拡張します。\n"
"なので`Ord`制約がある場合は、常に演算子`(==)`および`(/=)`と関連する関数が使えます。\n"

#. type: Title ####
#: ../src/Tutorial/Interfaces.md:420
#, no-wrap
msgid "`Ord` Laws"
msgstr "`Ord`の法則"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:423
msgid "We expect the following laws to hold for all implementations of `Ord`:"
msgstr "`Ord`の全ての実装について以下の法則を満たすようにしてください。"

#. type: Bullet: '* '
#: ../src/Tutorial/Interfaces.md:433
msgid "`(<=)` is *reflexive* and *transitive*."
msgstr "`(<=)`は*反射的*で*推移的*です。"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:433
#, no-wrap
msgid ""
"* `(<=)` is *antisymmetric*: From `x <= y = True` and `y <= x = True`\n"
"follows `x == y = True`.\n"
"* `x <= y = y >= x`.\n"
"* `x < y = not (y <= x)`\n"
"* `x > y = not (y >= x)`\n"
"* `compare x y = EQ` => `x == y = True`\n"
"* `compare x y == GT = x > y`\n"
"* `compare x y == LT = x < y`\n"
msgstr ""
"* `(<=)`は*非対称的*です。\n"
"`x <= y = True`と`y <= x = True`から`x == y = True`が導かれます。\n"
"* `x <= y = y >= x`\n"
"* `x < y = not (y <= x)`\n"
"* `x > y = not (y >= x)`\n"
"* `compare x y = EQ` => `x == y = True`\n"
"* `compare x y == GT = x > y`\n"
"* `compare x y == LT = x < y`\n"

#. type: Title ###
#: ../src/Tutorial/Interfaces.md:434
#, no-wrap
msgid "`Semigroup` and `Monoid`"
msgstr "`Semigroup`と`Monoid`"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:439
#, no-wrap
msgid ""
"`Semigroup` is the pendant to our example interface `Concat`,\n"
"with operator `(<+>)` (also called *append*) corresponding\n"
"to function `concat`.\n"
msgstr ""
"`Semigroup`は例に出てきたインターフェース`Concat`のようなもので、\n"
"関数`concat`に対応する演算子`(<+>)`（*append*とも）を持ちます。\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:442
msgid ""
"Likewise, `Monoid` corresponds to `Empty`, with `neutral` corresponding to "
"`empty`."
msgstr ""
"同様に`Monoid`は`Empty`に対応するもので、`empty`に対応する`neutral`がありま"
"す。"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:449
msgid ""
"These are incredibly important interfaces, which can be used to combine two "
"or more values of a data type into a single value of the same type. Examples "
"include but are not limited to addition or multiplication of numeric types, "
"concatenation of sequences of data, or sequencing of computations."
msgstr ""
"これらは極めて重要なインターフェースで、\n"
"2つ以上のデータ型の値を単一の同じ型の値に結合するのに使えます。\n"
"前述の例にもありましたが数値型の和や積に留まらず、\n"
"連続するデータや連続する計算処理の結合にも使えます。"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:455
msgid ""
"As an example, consider a data type for representing distances in a "
"geometric application. We could just use `Double` for this, but that's not "
"very type safe. It would be better to use a single field record wrapping "
"values type `Double`, to give such values clear semantics:"
msgstr ""
"例として地理を扱うアプリケーションでの距離を表すデータ型を考えます。\n"
"単に`Double`を使うこともできますが、あまり型安全ではありません。\n"
"単一のフィールドを持つレコード型で`Double`型の値をくるむとよいでしょう。\n"
"値に明確な意味論が備わるためです。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Interfaces.md:456
#, no-wrap
msgid ""
"record Distance where\n"
"  constructor MkDistance\n"
"  meters : Double\n"
msgstr ""
"record Distance where\n"
"  constructor MkDistance\n"
"  meters : Double\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:465
msgid ""
"There is a natural way for combining two distances: We sum up the values "
"they hold. This immediately leads to an implementation of `Semigroup`:"
msgstr ""
"2つの距離を結合するには自然な方法があります。\n"
"それらが持つ値を加算すればよいのです。\n"
"そこで直ちに`Semigroup`の実装が導かれます。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Interfaces.md:466
#, no-wrap
msgid ""
"Semigroup Distance where\n"
"  x <+> y = MkDistance $ x.meters + y.meters\n"
msgstr ""
"Semigroup Distance where\n"
"  x <+> y = MkDistance $ x.meters + y.meters\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:474
msgid ""
"It is also immediately clear, that zero is the neutral element of this "
"operation: Adding zero to any value does not affect the value at all.  This "
"allows us to implement `Monoid` as well:"
msgstr ""
"これも直ちに明らかなことですが、\n"
"ゼロはこの操作での中立的な要素です。\n"
"ゼロを加算しても値には何ら影響がありません。\n"
"これにより`Monoid`も同様に実装できます。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Interfaces.md:475
#, no-wrap
msgid ""
"Monoid Distance where\n"
"  neutral = MkDistance 0\n"
msgstr ""
"Monoid Distance where\n"
"  neutral = MkDistance 0\n"

#. type: Title ####
#: ../src/Tutorial/Interfaces.md:480
#, no-wrap
msgid "`Semigroup` and `Monoid` Laws"
msgstr "`Semigroup`と`Monoid`の法則"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:484
msgid ""
"We expect the following laws to hold for all implementations of `Semigroup` "
"and `Monoid`:"
msgstr ""
"`Semigroup`と`Monoid`の全ての実装について以下の法則を満たすようにしてくださ"
"い。"

#. type: Bullet: '* '
#: ../src/Tutorial/Interfaces.md:489
msgid ""
"`(<+>)` is *associative*: `x <+> (y <+> z) = (x <+> y) <+> z`, for all "
"values `x`, `y`, and `z`."
msgstr ""
"`(<+>)`は結合的です。\n"
"`x <+> (y <+> z) = (x <+> y) <+> z`は全ての`x`, `y`, `z`の値について成り立ち"
"ます。"

#. type: Bullet: '* '
#: ../src/Tutorial/Interfaces.md:489
msgid ""
"`neutral` is the *neutral element* with relation to `(<+>)`: `neutral <+> x "
"= x <+> neutral = x`, for all `x`."
msgstr ""
"`neural`は`(<+>)`に関して*中立な要素*です。\n"
"`neural <+> x = x <+> neural = x`が全ての`x`について成り立ちます。"

#. type: Title ###
#: ../src/Tutorial/Interfaces.md:490
#, no-wrap
msgid "`Show`"
msgstr "`Show`"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:497
msgid ""
"The `Show` interface is mainly used for debugging purposes, and is supposed "
"to display values of a given type as a string, typically closely resembling "
"the Idris code used to create the value. This includes the proper wrapping "
"of arguments in parentheses where necessary. For instance, experiment with "
"the output of the following function at the REPL:"
msgstr ""
"`Show`インターフェースは主にデバッグ用途で使われ、\n"
"与えられた型の値を文字列として表示するためのものです。\n"
"典型的にはその値を作るIdrisのコードに近付けることが多いです。\n"
"その場合は必要に応じて括弧内に引数を適切にくるむことがあります。\n"
"例えば以下の関数の出力がどうなるかREPLでやってみてください。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Interfaces.md:498
#, no-wrap
msgid ""
"showExample : Maybe (Either String (List (Maybe Integer))) -> String\n"
"showExample = show\n"
msgstr ""
"showExample : Maybe (Either String (List (Maybe Integer))) -> String\n"
"showExample = show\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Interfaces.md:505
#, no-wrap
msgid ""
"Tutorial.Interfaces> showExample (Just (Right [Just 12, Nothing]))\n"
"\"Just (Right [Just 12, Nothing])\"\n"
msgstr ""
"Tutorial.Interfaces> showExample (Just (Right [Just 12, Nothing]))\n"
"\"Just (Right [Just 12, Nothing])\"\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:511
msgid "We will learn how to implement instances of `Show` in an exercise."
msgstr "`Show`のインスタンスを実装する方法は演習で学びましょう。"

#. type: Title ###
#: ../src/Tutorial/Interfaces.md:512
#, no-wrap
msgid "Overloaded Literals"
msgstr "オーバーロードされたリテラル"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:524
msgid ""
"Literal values in Idris, such as integer literals (`12001`), string literals "
"(`\"foo bar\"`), floating point literals (`12.112`), and character literals "
"(`'$'`) can be overloaded. This means, that we can create values of types "
"other than `String` from just a string literal. The exact workings of this "
"has to wait for another section, but for many common cases, it is sufficient "
"for a value to implement interfaces `FromString` (for using string "
"literals), `FromChar` (for using character literals), or `FromDouble` (for "
"using floating point literals).  The case of integer literals is special, "
"and will be discussed in the next section."
msgstr ""
"Idrisのリテラル値、例えば整数リテラル (`12001`)、\n"
"文字列リテラル (`\"foo bar\"`)、\n"
"浮動小数点数リテラル (`12.112`) 、そして文字リテラル (`'$'`) はオーバーロード"
"できます。\n"
"つまり、`String`ではない型の値を単なる文字列リテラルから作れるということで"
"す。\n"
"ちゃんとした仕組みは他の節まで待たなければいけませんが、\n"
"大体はインターフェース`FromString`（文字列リテラル用）や\n"
"`FromChar` （文字リテラル用）や`FromDouble`（浮動小数点リテラル用）を実装すれ"
"ば充分でしょう。\n"
"整数リテラルについては特殊なので次の節で詳述します。"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:531
msgid ""
"Here is an example of using `FromString`. Assume, we write an application "
"where users can identify themselves with a username and password. Both "
"consist of strings of characters, so it is pretty easy to confuse and mix up "
"the two things, although they clearly have very different semantics.  In "
"these cases, it is advisable to come up with new types for the two, "
"especially since getting these things wrong is a security concern."
msgstr ""
"`FromString`の使用例はこちらです。\n"
"アプリケーションを書いており、利用者が利用者名とパスワードで自身であることを"
"同定できるものだとします。\n"
"いずれも文字からなる文字列なので、\n"
"2つを混同してしまいがちです。\n"
"はっきりと異なる意味論を持つものではあるのですが。\n"
"この場合、これら2つのために新しい型を用意することが望ましいです。\n"
"特にこれらを取り違えたりなんかするとセキュリティ上の問題になりますから。"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:533
msgid "Here are three example record types to do this:"
msgstr "例としてレコード型を3つ用意しました。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Interfaces.md:534
#, no-wrap
msgid ""
"record UserName where\n"
"  constructor MkUserName\n"
"  name : String\n"
"\n"
"record Password where\n"
"  constructor MkPassword\n"
"  value : String\n"
"\n"
"record User where\n"
"  constructor MkUser\n"
"  name     : UserName\n"
"  password : Password\n"
msgstr ""
"record UserName where\n"
"  constructor MkUserName\n"
"  name : String\n"
"\n"
"record Password where\n"
"  constructor MkPassword\n"
"  value : String\n"
"\n"
"record User where\n"
"  constructor MkUser\n"
"  name     : UserName\n"
"  password : Password\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:551
msgid ""
"In order to create a value of type `User`, even for testing, we'd have to "
"wrap all strings using the given constructors:"
msgstr ""
"型`User`の値を作るには、試したいときであっても、\n"
"逐一文字列を構築子でくるむ必要があります。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Interfaces.md:552
#, no-wrap
msgid ""
"hock : User\n"
"hock = MkUser (MkUserName \"hock\") (MkPassword \"not telling\")\n"
msgstr ""
"hock : User\n"
"hock = MkUser (MkUserName \"hock\") (MkPassword \"not telling\")\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:560
msgid ""
"This is rather cumbersome, and some people might think this to be too high a "
"price to pay just for an increase in type safety (I'd tend to disagree).  "
"Luckily, we can get the convenience of string literals back very easily:"
msgstr ""
"これはわりとまどろっこしく、型安全性を増すには割に合わなさすぎると考える人も"
"いるでしょう。\n"
"（私はどちらかというと違いますが。）\n"
"幸運にも文字列リテラルの便利さをとても簡単に取り戻せます。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Interfaces.md:561
#, no-wrap
msgid ""
"FromString UserName where\n"
"  fromString = MkUserName\n"
"\n"
"FromString Password where\n"
"  fromString = MkPassword\n"
"\n"
"hock2 : User\n"
"hock2 = MkUser \"hock\" \"not telling\"\n"
msgstr ""
"FromString UserName where\n"
"  fromString = MkUserName\n"
"\n"
"FromString Password where\n"
"  fromString = MkPassword\n"
"\n"
"hock2 : User\n"
"hock2 = MkUser \"hock\" \"not telling\"\n"

#. type: Title ###
#: ../src/Tutorial/Interfaces.md:572
#, no-wrap
msgid "Numeric Interfaces"
msgstr "数的インターフェース"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:577
msgid ""
"The *Prelude* also exports several interfaces providing the usual arithmetic "
"operations. Below is a comprehensive list of the interfaces and the "
"functions each provides:"
msgstr ""
"*Prelude*はよくある代数操作を提供するインターフェースもいくつか公開していま"
"す。\n"
"以下はインターフェースと提供されている関数の網羅的な一覧です。"

#. type: Bullet: '* '
#: ../src/Tutorial/Interfaces.md:582
msgid "`Num`"
msgstr "`Num`"

#. type: Bullet: '  * '
#: ../src/Tutorial/Interfaces.md:582
msgid "`(+)` : Addition"
msgstr "`(+)`: 加算"

#. type: Bullet: '  * '
#: ../src/Tutorial/Interfaces.md:582
msgid "`(*)` : Multiplication"
msgstr "`(*)`: 乗算"

#. type: Bullet: '  * '
#: ../src/Tutorial/Interfaces.md:582
msgid "`fromInteger` : Overloaded integer literals"
msgstr "`fromInteger`: オーバーロードされた整数リテラル"

#. type: Bullet: '* '
#: ../src/Tutorial/Interfaces.md:586
msgid "`Neg`"
msgstr "`Neg`"

#. type: Bullet: '  * '
#: ../src/Tutorial/Interfaces.md:586
msgid "`negate` : Negation"
msgstr "`negate` : 正負反転"

#. type: Bullet: '  * '
#: ../src/Tutorial/Interfaces.md:586
msgid "`(-)` : Subtraction"
msgstr "`(-)`: 減算"

#. type: Bullet: '* '
#: ../src/Tutorial/Interfaces.md:590
msgid "`Integral`"
msgstr "整数"

#. type: Bullet: '  * '
#: ../src/Tutorial/Interfaces.md:590
msgid "`div` : Integer division"
msgstr "`div`: 整数の除算"

#. type: Bullet: '  * '
#: ../src/Tutorial/Interfaces.md:590
msgid "`mod` : Modulo operation"
msgstr "`mod` : 剰余演算"

#. type: Bullet: '* '
#: ../src/Tutorial/Interfaces.md:594
msgid "`Fractional`"
msgstr "`Fractional`"

#. type: Bullet: '  * '
#: ../src/Tutorial/Interfaces.md:594
msgid "`(/)` : Division"
msgstr "`(/)`: 除算"

#. type: Bullet: '  * '
#: ../src/Tutorial/Interfaces.md:594
msgid "`recip` : Calculates the reciprocal of a value"
msgstr "`recip` : 値の逆数を計算する"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:599
msgid ""
"As you can see: We need to implement interface `Num` to use integer literals "
"for a given type. In order to use negative integer literals like `-12`, we "
"also have to implement interface `Neg`."
msgstr ""
"ここで次のことがわかります。\n"
"所与の型に整数リテラルを使うのにはインターフェース`Num`を実装する必要がありま"
"す。\n"
"`-12`のような負数の整数リテラルを使うためにはインターフェース`Neg`も実装する"
"必要があります。"

#. type: Title ###
#: ../src/Tutorial/Interfaces.md:600
#, no-wrap
msgid "`Cast`"
msgstr "`Cast`"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:607
msgid ""
"The last interface we will quickly discuss in this section is `Cast`. It is "
"used to convert values of one type to values of another via function `cast`. "
"`Cast` is special, since it is parameterized over *two* type parameters "
"unlike the other interfaces we looked at so far, with only one type "
"parameter."
msgstr ""
"最後にこの節で手早く説明するインターフェースは`Cast`です。\n"
"ある型の値を他の型の値に関数`cast`で変換するというものです。\n"
"`Cast`は特別です。\n"
"なぜならこのインターフェースは*2つ*の型変数を引数に取りますが、\n"
"これまで見てきた他のインターフェースは型変数が1つしかないからです。"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:614
msgid ""
"So far, `Cast` is mainly used for interconversion between primitive types in "
"the standard libraries, especially numeric types. When you look at the "
"implementations exported from the *Prelude* (for instance, by invoking `:doc "
"Cast` at the REPL), you'll see that there are dozens of implementations for "
"most pairings of primitive types."
msgstr ""
"これまで`Cast`を主に標準ライブラリにある原始型の相互変換に使ってきました。\n"
"特に数値型です。\n"
"*Prelude*から公開されている実装を見てみると（例えば`:doc Cast`とREPLで呼び出"
"します）、\n"
"原始型のほとんどの対に関して沢山の実装があることがわかるでしょう。"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:623
msgid ""
"Although `Cast` would also be useful for other conversions (for going from "
"`Maybe` to `List` or for going from `Either e` to `Maybe`, for instance), "
"the *Prelude* and *base* seem not to introduce these consistently. For "
"instance, there are `Cast` implementations from going from `SnocList` to "
"`List` and vice versa, but not for going from `Vect n` to `List`, or for "
"going from `List1` to `List`, although these would be just as feasible."
msgstr ""
"`Cast`は他の変換にも便利ですが（`Maybe`から`List`であったり、\n"
"`Either e`から`Maybe`であったり）、\n"
"*Prelude*と*base*はそうした変換を一環して提供してはいないようです。\n"
"例として`Cast`の実装として`SnocList`から`List`とその逆のものがありますが、\n"
"`Vect n`から`List`へ、あるいは`Vect n`から`List`への実装はありません。\n"
"そうした実装も可能ではあるのですが。"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:629
msgid ""
"These exercises are meant to make you comfortable with implementing "
"interfaces for your own data types, as you will have to do so regularly when "
"writing Idris code."
msgstr ""
"ここにある演習は流暢に自前のデータ型のためのインターフェースが実装できるよう"
"になることを意図しています。\n"
"Idrisのコードを書くときはしばしば必要になることですから。"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:635
msgid ""
"While it is immediately clear why interfaces like `Eq`, `Ord`, or `Num` are "
"useful, the usability of `Semigroup` and `Monoid` may be harder to "
"appreciate at first.  Therefore, there are several exercises where you'll "
"implement different instances for these."
msgstr ""
"`Eq`, `Ord`, `Num`のようなインターフェースが便利な理由は直ちに明らかです"
"が、\n"
"一方で`Semigroup`と`Monoid`の便利さは最初は実感しにくいかもしれません。\n"
"したがって演習の中にはいくつかの異なるインスタンスについて実装するものがあり"
"ます。"

#. type: Bullet: '1. '
#: ../src/Tutorial/Interfaces.md:639
msgid ""
"Define a record type `Complex` for complex numbers, by pairing two values of "
"type `Double`.  Implement interfaces `Eq`, `Num`, `Neg`, and `Fractional` "
"for `Complex`."
msgstr ""
"レコード型`Complex`を複素数について定義してください。\n"
"型`Double`の値2つを対にします。\n"
"`Eq`, `Num`, `Neg`、そして`Fractional`を`Complex`に実装してください。"

#. type: Bullet: '2. '
#: ../src/Tutorial/Interfaces.md:643
msgid ""
"Implement interface `Show` for `Complex`. Have a look at data type `Prec` "
"and function `showPrec` and how these are used in the *Prelude* to implement "
"instances for `Either` and `Maybe`."
msgstr ""
"`Show`を`Complex`に実装してください。\n"
"データ型`Prec`と関数`showPrec`を調べて、\n"
"*Prelude*で`Either`や`Maybe`のインスタンスを実装するためにどのようにこれらが"
"使われているのか見てみましょう。"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:647
#, no-wrap
msgid ""
"   Verify the correct behavior of your implementation by wrapping\n"
"   a value of type `Complex` in a `Just` and `show` the result at\n"
"   the REPL.\n"
msgstr ""
"   書いた実装が正しい振舞いになっていることを確かめるために、\n"
"   REPLで型`Complex`の値を`Just`でくるんで`show`してみましょう。\n"

#. type: Bullet: '3. '
#: ../src/Tutorial/Interfaces.md:649
msgid "Consider the following wrapper for optional values:"
msgstr "あってもなくてもよい値の、以下の梱包について考えてみましょう。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Interfaces.md:650
#, no-wrap
msgid ""
"   record First a where\n"
"     constructor MkFirst\n"
"     value : Maybe a\n"
msgstr ""
"   record First a where\n"
"     constructor MkFirst\n"
"     value : Maybe a\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:660
#, no-wrap
msgid ""
"   Implement interfaces `Eq`, `Ord`, `Show`, `FromString`, `FromChar`, `FromDouble`,\n"
"   `Num`, `Neg`, `Integral`, and `Fractional` for `First a`. All of these will require\n"
"   corresponding constraints on type parameter `a`. Consider implementing and\n"
"   using the following utility functions where they make sense:\n"
msgstr ""
"   インターフェース`Eq`, `Ord`, `Show`, `FromString`, `FromChar`, `FromDouble`,\n"
"   `Num`, `Neg`, `Integral`, `Fractional`を`First a`に実装してください。\n"
"   これらは全て型変数`a`に対応する制約が必要になるでしょう。\n"
"   必要に応じて、以下の小間物関数を実装したのち使ってください。\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Interfaces.md:661
#, no-wrap
msgid ""
"   pureFirst : a -> First a\n"
"\n"
"   mapFirst : (a -> b) -> First a -> First b\n"
"\n"
"   mapFirst2 : (a -> b -> c) -> First a -> First b -> First c\n"
msgstr ""
"   pureFirst : a -> First a\n"
"\n"
"   mapFirst : (a -> b) -> First a -> First b\n"
"\n"
"   mapFirst2 : (a -> b -> c) -> First a -> First b -> First c\n"

#. type: Bullet: '4. '
#: ../src/Tutorial/Interfaces.md:673
msgid ""
"Implement interfaces `Semigroup` and `Monoid` for `First a` in such a way, "
"that `(<+>)` will return the first non-nothing argument and `neutral` is the "
"corresponding neutral element. There must be no constraints on type "
"parameter `a` in these implementations."
msgstr ""
"同様にインターフェース`Semigroup`と`Monoid`を`First a`に実装してください。\n"
"`(<+>)`は最初の非空な引数を返します。\n"
"また、`neutral`は対応する中立要素です。\n"
"これらの実装では型変数`a`に制約があってはいけません。"

#. type: Bullet: '5. '
#: ../src/Tutorial/Interfaces.md:676
msgid ""
"Repeat exercises 3 and 4 for record `Last`. The `Semigroup` implementation "
"should return the last non-nothing value."
msgstr ""
"問題3と4をレコード`Last`に改めて行ってください。\n"
"`Semigroup`の実装は最後の非空な値を返します。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Interfaces.md:677
#, no-wrap
msgid ""
"   record Last a where\n"
"     constructor MkLast\n"
"     value : Maybe a\n"
msgstr ""
"   record Last a where\n"
"     constructor MkLast\n"
"     value : Maybe a\n"

#. type: Bullet: '6. '
#: ../src/Tutorial/Interfaces.md:687
msgid ""
"Function `foldMap` allows us to map a function returning a `Monoid` over a "
"list of values and accumulate the result using `(<+>)` at the same time.  "
"This is a very powerful way to accumulate the values stored in a list.  Use "
"`foldMap` and `Last` to extract the last element (if any) from a list."
msgstr ""
"関数`foldMap`は関数を順番に写して`Monoid`を返します。\n"
"値のリストを巡回しつつ`(<+>)`で結果を積み重ねます。\n"
"これはリストに格納された値を集積するとても強力な方法です。\n"
"`foldMap`と`Last`でリストから最後の要素を（もしあれば）取り出してください。"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:692
#, no-wrap
msgid ""
"   Note, that the type of `foldMap` is more general and not specialized\n"
"   to lists only. It works also for `Maybe`, `Either` and other container\n"
"   types we haven't looked at so far. We will learn about\n"
"   interface `Foldable` in a later section.\n"
msgstr ""
"   ここで`foldMap`の型はより一般的でリストのみが専門ではありません。\n"
"   `Maybe`や`Either`やその他のまだ見ぬ荷車型に対しても動きます。\n"
"   後の節でインターフェース`Foldable`を学びましょう。\n"

#. type: Bullet: '7. '
#: ../src/Tutorial/Interfaces.md:694
msgid "Consider record wrappers `Any` and `All` for boolean values:"
msgstr "真偽値の値のレコード梱包`Any`と`All`を考えます。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Interfaces.md:695
#, no-wrap
msgid ""
"   record Any where\n"
"     constructor MkAny\n"
"     any : Bool\n"
"\n"
"   record All where\n"
"     constructor MkAll\n"
"     all : Bool\n"
msgstr ""
"   record Any where\n"
"     constructor MkAny\n"
"     any : Bool\n"
"\n"
"   record All where\n"
"     constructor MkAll\n"
"     all : Bool\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:708
#, no-wrap
msgid ""
"   Implement `Semigroup` and `Monoid` for `Any`, so that the result of\n"
"   `(<+>)` is `True`, if and only if at least one of the arguments is `True`.\n"
"   Make sure that `neutral` is indeed the neutral element for this operation.\n"
msgstr ""
"   `Semigroup`と`Monoid`を`Any`に実装してください。\n"
"   ただし`(<+>)`の結果は、少なくとも1つの引数が`True`であるときにのみ`True`です。\n"
"   `neural`はもちろんこの操作において中立な要素になるようにしてくださいね。\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:712
#, no-wrap
msgid ""
"   Likewise, implement `Semigroup` and `Monoid` for `All`, so that the result of\n"
"   `(<+>)` is `True`, if and only if both of the arguments are `True`.\n"
"   Make sure that `neutral` is indeed the neutral element for this operation.\n"
msgstr ""
"   同様に`Semigroup`と`Monoid`を`All`に実装してください。\n"
"   `(<+>)`の結果は、両方の引数が`True`のときにのみ`True`であるようにしてください。\n"
"   `neural`はもちろんこの操作において中立な要素になるようにしてくださいね。\n"

#. type: Bullet: '8. '
#: ../src/Tutorial/Interfaces.md:715
msgid ""
"Implement functions `anyElem` and `allElems` using `foldMap` and `Any` or "
"`All`, respectively:"
msgstr ""
"関数`anyElem`と`allElems`を、`foldMap`と`Any`ないし`All`を使って実装してくだ"
"さい。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Interfaces.md:716
#, no-wrap
msgid ""
"   -- True, if the predicate holds for at least one element\n"
"   anyElem : (a -> Bool) -> List a -> Bool\n"
"\n"
"   -- True, if the predicate holds for all elements\n"
"   allElems : (a -> Bool) -> List a -> Bool\n"
msgstr ""
"   -- 命題が少なくとも1つの要素について満たされているとき真\n"
"   anyElem : (a -> Bool) -> List a -> Bool\n"
"\n"
"   -- 命題が全ての要素について満たされているとき真\n"
"   allElems : (a -> Bool) -> List a -> Bool\n"

#. type: Bullet: '9. '
#: ../src/Tutorial/Interfaces.md:726
msgid ""
"Record wrappers `Sum` and `Product` are mainly used to hold numeric types."
msgstr "レコード梱包`Sum`と`Product`は主に数値型を保持するのに使われます。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Interfaces.md:727
#, no-wrap
msgid ""
"   record Sum a where\n"
"     constructor MkSum\n"
"     value : a\n"
"\n"
"   record Product a where\n"
"     constructor MkProduct\n"
"     value : a\n"
msgstr ""
"   record Sum a where\n"
"     constructor MkSum\n"
"     value : a\n"
"\n"
"   record Product a where\n"
"     constructor MkProduct\n"
"     value : a\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:739
#, no-wrap
msgid ""
"   Given an implementation of `Num a`, implement `Semigroup (Sum a)`\n"
"   and `Monoid (Sum a)`, so that `(<+>)` corresponds to addition.\n"
msgstr ""
"   `Num a`の実装があったとして、`Semigroup (Sum a)`と`Monoid (Sum a)`を実装してください。\n"
"   ただし`(<+>)`は加算に対応します。\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:742
#, no-wrap
msgid ""
"   Likewise, implement `Semigroup (Product a)` and `Monoid (Product a)`,\n"
"   so that `(<+>)` corresponds to multiplication.\n"
msgstr ""
"   同様に`Semigroup (Product a)`と`Monoid (Product a)`を実装してください。\n"
"   ただし`(<+>)`は乗算に対応します。\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:745
#, no-wrap
msgid ""
"   When implementing `neutral`, remember that you can use integer\n"
"   literals when working with numeric types.\n"
msgstr "   `neutral`を実装する際は、数値型を扱うときは整数リテラルが使えることを思い出してください。\n"

#. type: Bullet: '10. '
#: ../src/Tutorial/Interfaces.md:748
msgid ""
"Implement `sumList` and `productList` by using `foldMap` together with the "
"wrappers from Exercise 9:"
msgstr ""
"`sumList`と`productList`を実装してください。\n"
"`foldMap`とともに演習9の梱包を使ってください。"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:751
#, no-wrap
msgid ""
"    ```idris\n"
"    sumList : Num a => List a -> a\n"
msgstr ""
"    ```idris\n"
"    sumList : Num a => List a -> a\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:754
#, no-wrap
msgid ""
"    productList : Num a => List a -> a\n"
"    ```\n"
msgstr ""
"    productList : Num a => List a -> a\n"
"    ```\n"

#. type: Bullet: '11. '
#: ../src/Tutorial/Interfaces.md:760
msgid ""
"To appreciate the power and versatility of `foldMap`, after solving "
"exercises 6 to 10 (or by loading `Solutions.Inderfaces` in a REPL session), "
"run the following at the REPL, which will - in a single list traversal! - "
"calculate the first and last element of the list as well as the sum and "
"product of all values."
msgstr ""
"`foldMap`の強力さと多芸さを享受するために、\n"
"演習6から10までを解いたあとに（もしくはREPLで`Solutions.Interfaces`をロードし"
"てもよいです）、\n"
"以下をREPLで実行してください。\n"
"これは、たった1回の巡回で！、リストの最初と最後の要素と全ての値の和と積を計算"
"しています。"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:765
#, no-wrap
msgid ""
"    ```repl\n"
"    > foldMap (\\x => (pureFirst x, pureLast x, MkSum x, MkProduct x)) [3,7,4,12]\n"
"    (MkFirst (Just 3), (MkLast (Just 12), (MkSum 26, MkProduct 1008)))\n"
"    ```\n"
msgstr ""
"    ```repl\n"
"    > foldMap (\\x => (pureFirst x, pureLast x, MkSum x, MkProduct x)) [3,7,4,12]\n"
"    (MkFirst (Just 3), (MkLast (Just 12), (MkSum 26, MkProduct 1008)))\n"
"    ```\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:772
#, no-wrap
msgid ""
"    Note, that there are also `Semigroup` implementations for\n"
"    types with an `Ord` implementation, which will return\n"
"    the smaller or larger of two values. In case of types\n"
"    with an absolute minimum or maximum (for instance, 0 for\n"
"    natural numbers, or 0 and 255 for `Bits8`), these can even\n"
"    be extended to `Monoid`.\n"
msgstr ""
"   `Ord`の実装付きの型のための`Semigroup`の実装もあります。\n"
"   この実装は2つの値のうちより小さいかより大きいほうを返します。\n"
"   決まった最小値や最大値がある型の場合（例えば自然数の0や、`Bits8`の0と255）、\n"
"   これらについてもまた`Monoid`に拡張できます。\n"

#. type: Bullet: '12. '
#: ../src/Tutorial/Interfaces.md:778
msgid ""
"In an earlier exercise, you implemented a data type representing chemical "
"elements and wrote a function for calculating their atomic masses. Define a "
"new single field record type for representing atomic masses, and implement "
"interfaces `Eq`, `Ord`, `Show`, `FromDouble`, `Semigroup`, and `Monoid` for "
"this."
msgstr ""
"以前の演習で化学の元素を表現するデータ型を実装し、\n"
"化学の体積を計算する関数を書きました。\n"
"新しく原子の体積を表現する単一フィールドレコード型を定義して、\n"
"インターフェース`Eq`, `Ord`, `Show`, `FromDouble`, `Semigroup`, `Monoid`をこ"
"の型に実装してください。"

#. type: Bullet: '13. '
#: ../src/Tutorial/Interfaces.md:782
msgid ""
"Use the new data type from exercise 12 to calculate the atomic mass of an "
"element and compute the molecular mass of a molecule given by its formula."
msgstr ""
"演習12の新しいデータ型を使って原子の原子質量を算出し、\n"
"分子式で与えられる分子の分子質量を計算してください。"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:785
#, no-wrap
msgid ""
"    Hint: With a suitable utility function, you can use `foldMap`\n"
"    once again for this.\n"
msgstr "   解決の糸口：相応しい小間物関数があれば、ここでも`foldMap`が使えます。\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:791
msgid ""
"Final notes: If you are new to functional programming, make sure to give "
"your implementations of exercises 6 to 10 a try at the REPL.  Note, how we "
"can implement all of these functions with a minimal amount of code and how, "
"as shown in exercise 11, these behaviors can be combined in a single list "
"traversal."
msgstr ""
"最後の註釈：もし関数型プログラミングが初めてであれば、\n"
"演習6から10の実装をREPLで確かめてみてください。\n"
"これら全ての関数を最小限の量のコードでどのように実装できたか、\n"
"そして演習11で見たように1回のリストの巡回においてこれらの振舞いをどのように組"
"み合わせられたか、\n"
"を思い返しましょう。"

#. type: Bullet: '* '
#: ../src/Tutorial/Interfaces.md:807
msgid ""
"Interfaces allow us to implement the same function with different behavior "
"for different types."
msgstr ""
"インターフェースのおかげで、異なる型で異なる振舞いをする同じ関数を実装できま"
"す。"

#. type: Bullet: '* '
#: ../src/Tutorial/Interfaces.md:807
msgid ""
"Functions taking one or more interface implementations as arguments are "
"called *constrained functions*."
msgstr ""
"1つ以上のインターフェースの実装を引数に取る関数は*制約付き関数*と呼ばれます。"

#. type: Bullet: '* '
#: ../src/Tutorial/Interfaces.md:807
msgid ""
"Interfaces can be organized hierarchically by *extending* other interfaces."
msgstr ""
"インターフェースは他のインターフェースを*拡張*することで階層的に組織付けられ"
"ます。"

#. type: Bullet: '* '
#: ../src/Tutorial/Interfaces.md:807
msgid ""
"Interfaces implementations can themselves be *constrained* requiring other "
"implementations to be available."
msgstr ""
"インターフェースの実装は、それ自体が他の実装を必要とする*制約*が課されること"
"があります。"

#. type: Bullet: '* '
#: ../src/Tutorial/Interfaces.md:807
msgid ""
"Interface functions can be given a *default implementation*, which can be "
"overridden by implementers, for instance for reasons of efficiency."
msgstr ""
"インターフェースの関数には*既定実装*を与えられます。\n"
"この実装は実装者によって上書きできます。\n"
"例えば効率性の理由などからです。"

#. type: Bullet: '* '
#: ../src/Tutorial/Interfaces.md:807
msgid ""
"Certain interfaces allow us to use literal values such as string or integer "
"literals for our own data types."
msgstr ""
"いくつかのインターフェースがあれば、\n"
"文字列や整数といったリテラルのリテラル値を自前のデータ型に使えます。"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:812
msgid ""
"Note, that I did not yet tell the whole story about literal values in this "
"section. More details for using literals with types that accept only a "
"restricted set of values can be found in the chapter about [primitives](Prim."
"md)."
msgstr ""
"ただ、この節ではリテラル値の一部始終はまだお話ししていません。\n"
"限られた値の集合のみを受け付ける型にリテラルを使うことに関するもっと詳しい話"
"は、\n"
"[原始型](Prim.md)についての章にあります。"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:819
msgid ""
"In the [next chapter](Functions2.md), we have a closer look at functions and "
"their types. We will learn about named arguments, implicit arguments, and "
"erased arguments as well as some constructors for implementing more complex "
"functions."
msgstr ""
"[次の章](Functions2.md)では関数とその型にさらに迫ります。\n"
"名前付き引数、暗黙の引数、引数消去に加え、\n"
"より複雑な関数を実装するためのいくつかの構築子について学びます。"
