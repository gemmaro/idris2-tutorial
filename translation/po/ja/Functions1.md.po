# Japanese translations for Functional Programming in Idris 2
# Copyright (c) 2021-2023, Stefan Höck.
# Copyright (C) 2022, 2023 gemmaro <gemmaro.dev@gmail.com>.
# This file is distributed under the same license as the Functional Programming in Idris 2.
#
msgid ""
msgstr ""
"Project-Id-Version: Functional Programming in Idris 2\n"
"POT-Creation-Date: 2023-04-09 22:52+0900\n"
"PO-Revision-Date: 2023-06-29 23:32+0900\n"
"Last-Translator: gemmaro <gemmaro.dev@gmail.com>\n"
"Language-Team: none\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#. type: Title ##
#: ../src/Appendices/Neovim.md:364 ../src/Appendices/Install.md:102
#: ../src/Appendices/Projects.md:878 ../src/Tutorial/DPair.md:1191
#: ../src/Tutorial/DataTypes.md:1319 ../src/Tutorial/Dependent.md:872
#: ../src/Tutorial/Eq.md:1085 ../src/Tutorial/Folds.md:1051
#: ../src/Tutorial/Functions1.md:524 ../src/Tutorial/Functions2.md:924
#: ../src/Tutorial/Functor.md:1395 ../src/Tutorial/IO.md:1095
#: ../src/Tutorial/Interfaces.md:792 ../src/Tutorial/Predicates.md:1358
#: ../src/Tutorial/Traverse.md:1109
#, no-wrap
msgid "Conclusion"
msgstr "まとめ"

#. type: Plain text
#: ../src/Appendices/Neovim.md:374 ../src/Appendices/Projects.md:890
#: ../src/Tutorial/DPair.md:1206 ../src/Tutorial/DataTypes.md:1368
#: ../src/Tutorial/Dependent.md:910 ../src/Tutorial/Eq.md:1100
#: ../src/Tutorial/Folds.md:1064 ../src/Tutorial/Functions1.md:583
#: ../src/Tutorial/Functions2.md:964 ../src/Tutorial/Functor.md:1427
#: ../src/Tutorial/IO.md:1125 ../src/Tutorial/Interfaces.md:821
#: ../src/Tutorial/Intro.md:453 ../src/Tutorial/Predicates.md:1371
#: ../src/Tutorial/Prim.md:1411 ../src/Tutorial/Traverse.md:1148
#, no-wrap
msgid ""
"<!-- vi: filetype=idris2:syntax=markdown\n"
"-->\n"
msgstr ""
"<!-- vi: filetype=idris2:syntax=markdown\n"
"-->\n"

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:1362 ../src/Tutorial/Dependent.md:904
#: ../src/Tutorial/Functions1.md:575 ../src/Tutorial/Functions2.md:954
#: ../src/Tutorial/IO.md:1118 ../src/Tutorial/Interfaces.md:813
#, no-wrap
msgid "What's next"
msgstr "お次は？"

#. type: Title #
#: ../src/Tutorial/Functions1.md:1
#, no-wrap
msgid "Functions Part 1"
msgstr "関数 その1"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:12
msgid ""
"Idris is a *functional* programming language. This means, that functions are "
"its main form of abstraction (unlike for instance in an object oriented "
"language like Java, where *objects* and *classes* are the main form of "
"abstraction). It also means that we expect Idris to make it very easy for us "
"to compose and combine functions to create new functions. In fact, in Idris "
"functions are *first class*: Functions can take other functions as arguments "
"and can return functions as their results."
msgstr ""
"Idrisは*関数型*プログラミング言語です。\n"
"つまり、関数は抽象化の主な形式です（例えばJavaのようなオブジェクト指向言語と"
"は違います。\n"
"オブジェクト指向言語では*オブジェクト*や*クラス*が主な抽象化の形式です）。\n"
"また、関数型であるということから、Idrisでは関数を構成・結合して新しい関数を作"
"るのがとても簡単だということがわかります。\n"
"実際、Idrisの関数は*第一級*です。\n"
"関数は他の関数を引数に取ることができますし、関数の結果として関数を返すことも"
"できます。"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:16
msgid ""
"We already learned about the basic shape of top level function declarations "
"in Idris in the [introduction](Intro.md), so we will continue from what we "
"learned there."
msgstr ""
"[導入](Intro.md)でIdrisにおける最上位での関数宣言の基本形を学んできたので、そ"
"こまでで学んできたことから続きをやりましょう。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions1.md:17
#, no-wrap
msgid "module Tutorial.Functions1\n"
msgstr "module Tutorial.Functions1\n"

#. type: Title ##
#: ../src/Tutorial/Functions1.md:21
#, no-wrap
msgid "Functions with more than one Argument"
msgstr "1つ以上の引数を持つ関数"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:28
msgid ""
"Let's implement a function, which checks if its three `Integer` arguments "
"form a [Pythagorean triple](https://en.wikipedia.org/wiki/"
"Pythagorean_triple).  We get to use a new operator for this: `==`, the "
"equality operator."
msgstr ""
"ある関数を実装してみましょう。\n"
"ここでは3つの `Integer` 型の引数が\n"
"[ピタゴラスの三つ組（訳註：ピタゴラスの定理を満たす3つの整数）](https://en."
"wikipedia.org/wiki/Pythagorean_triple)\n"
"になっているかを検査するものとします。\n"
"このために新しい演算子 `==` を使います。\n"
"相等性のための演算子です。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions1.md:29
#, no-wrap
msgid ""
"isTriple : Integer -> Integer -> Integer -> Bool\n"
"isTriple x y z = x * x + y * y == z * z\n"
msgstr ""
"isTriple : Integer -> Integer -> Integer -> Bool\n"
"isTriple x y z = x * x + y * y == z * z\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:36
msgid ""
"Let's give this a spin at the REPL before we talk a bit about the types:"
msgstr ""
"この演算子の型について軽く話しますが、\n"
"その前にREPLで動かしてみましょう。"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions1.md:37
#, no-wrap
msgid ""
"Tutorial.Functions1> isTriple 1 2 3\n"
"False\n"
"Tutorial.Functions1> isTriple 3 4 5\n"
"True\n"
msgstr ""
"Tutorial.Functions1> isTriple 1 2 3\n"
"False\n"
"Tutorial.Functions1> isTriple 3 4 5\n"
"True\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:49
#, no-wrap
msgid ""
"As can be seen from this example, the type of a function\n"
"of several arguments consists just of a sequence\n"
"of argument types (also called *input types*)\n"
"chained by function arrows (`->`), which\n"
"is terminated by an output type (`Bool` in this case).\n"
msgstr ""
"この例からわかるように、\n"
"複数の引数を持つ関数の型は、\n"
"引数の型（*入力の型*とも言います）の連なりが関数の矢印 (`->`) で繋がっており、\n"
"出力の型（この場合 `Bool` です）で終わるようになっています。\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:61
msgid ""
"The implementation looks a bit like a mathematical equation: We list the "
"arguments on the left hand side of `=` and describe the computation(s) to "
"perform with them on the right hand side. Function implementations in "
"functional programming languages often have this more mathematical look "
"compared to implementations in imperative languages, which often describe "
"not *what* to compute, but *how* to compute it by describing an algorithm as "
"a sequence of imperative statements. We will later see that this imperative "
"style is also available in Idris, but whenever possible we prefer the "
"declarative style."
msgstr ""
"この実装は数学的な等式にちょっと似ています。\n"
"`=` の左側に引数のリストを書き、右側でこれの引数を使った計算を記述するので"
"す。\n"
"関数型プログラミング言語での関数の実装は、手続き型言語での実装に比べてより数"
"学的です。\n"
"関数型プログラミング言語では*何を*計算するのかを記述しますが、手続き型言語で"
"は手続き文の連なりとしてのアルゴリズムによって*どのように*計算するのかを記述"
"します。\n"
"あとでIdrisでもこのような手続き的な書き方ができることを見ていきますが、できる"
"なら宣言的な書き方のほうがいいですね。"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:68
msgid ""
"As can be seen in the REPL example, functions can be invoked by passing the "
"arguments separated by whitespace. No parentheses are necessary unless one "
"of the expressions we pass as the function's arguments contains itself "
"additional whitespace.  This comes in very handy when we apply functions "
"only partially (see later in this chapter)."
msgstr ""
"REPLでの実行例からわかるように、関数は空白区切りの引数を渡すことで呼び出せま"
"す。\n"
"基本的に括弧は必要ありません。\n"
"ただし、ある引数が既に空白を含む関数とその引数であった場合、その引数は括弧で"
"くくります。\n"
"この空白区切りの書き方ができることで、部分的に関数を適用するのがとても楽にな"
"ります（この章で後述します）。"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:74
msgid ""
"Note that, unlike `Integer` or `Bits8`, `Bool` is not a primitive data type "
"built into the Idris language but just a custom data type that you could "
"have written yourself. We will learn more about declaring new data types in "
"the next chapter."
msgstr ""
"また実は `Integer` や `Bits8` とは違って、`Bool` はIdris言語に組込まれた原始"
"的なデータ型ではなく、自前で書けるただの独自データ型なのです。\n"
"新しいデータ型を宣言することについては次の章で学びましょう。"

#. type: Title ##
#: ../src/Tutorial/Functions1.md:75
#, no-wrap
msgid "Function Composition"
msgstr "関数結合"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:79
msgid ""
"Functions can be combined in several ways, the most direct probably being "
"the dot operator:"
msgstr ""
"関数は幾つかのやり方で組み合わせられます。\n"
"最も直接的なのは恐らくドット演算子でしょう。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions1.md:80
#, no-wrap
msgid ""
"square : Integer -> Integer\n"
"square n = n * n\n"
"\n"
"times2 : Integer -> Integer\n"
"times2 n = 2 * n\n"
"\n"
"squareTimes2 : Integer -> Integer\n"
"squareTimes2 = times2 . square\n"
msgstr ""
"square : Integer -> Integer\n"
"square n = n * n\n"
"\n"
"times2 : Integer -> Integer\n"
"times2 n = 2 * n\n"
"\n"
"squareTimes2 : Integer -> Integer\n"
"squareTimes2 = times2 . square\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:92
msgid "Give this a try at the REPL! Does it do what you'd expect?"
msgstr ""
"REPLで試してみてくださいね。\n"
"予想した通りになりましたか。"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:95
msgid ""
"We could have implemented `squareTimes2` without using the dot operator as "
"follows:"
msgstr ""
"以下のようにドット演算子を使わずに `squareTimes2` を実装することもできます。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions1.md:96
#, no-wrap
msgid ""
"squareTimes2' : Integer -> Integer\n"
"squareTimes2' n = times2 (square n)\n"
msgstr ""
"squareTimes2' : Integer -> Integer\n"
"squareTimes2' n = times2 (square n)\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:105
#, no-wrap
msgid ""
"It is important to note, that functions chained by the dot\n"
"operator are invoked from right to left: `times2 . square`\n"
"is the same as `\\n => times2 (square n)` and not\n"
"`\\n => square (times2 n)`.\n"
msgstr ""
"大事なことですが、\n"
"ドット演算子で連鎖している関数は右から左に実行されます。\n"
"`times2 . square` は `\\n => times2 (square n)` と同じですが、\n"
"`\\n => square (times2 n)` ではありません。\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:108
msgid ""
"We can conveniently chain several functions using the dot operator to write "
"more complex functions:"
msgstr ""
"幾つかの関数をドット演算子を使って連鎖させて、もっと複雑な関数を簡便に書くこ"
"とができます。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions1.md:109
#, no-wrap
msgid ""
"dotChain : Integer -> String\n"
"dotChain = reverse . show . square . square . times2 . times2\n"
msgstr ""
"dotChain : Integer -> String\n"
"dotChain = reverse . show . square . square . times2 . times2\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:119
msgid ""
"This will first multiply the argument by four, then square it twice before "
"converting it to a string (`show`) and reversing the resulting `String` "
"(functions `show` and `reverse` are part of the Idris *Prelude* and as such "
"are available in every Idris program)."
msgstr ""
"この関数はまず引数を4倍して、\n"
"2回平方を取って、\n"
"文字列に変換して (`show`)、\n"
"そして `String` を逆向きにします（関数 `show`, `reverse` はIdrisの *Prelude* "
"の一部に含まれているので、\n"
"全てのIdrisのプログラムから使えます）。"

#. type: Title ##
#: ../src/Tutorial/Functions1.md:120
#, no-wrap
msgid "Higher-order Functions"
msgstr "高階関数"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:126
msgid ""
"Functions can take other functions as arguments. This is an incredibly "
"powerful concept and we can go crazy with this very easily. But for sanity's "
"sake, we'll start slowly:"
msgstr ""
"関数は他の関数を引数に取れます。\n"
"これは非常に強力な概念で、\n"
"それ故におかしなことになりやすくもあります。\n"
"とはいえ正気を保つために、まずはゆっくり進みましょう。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions1.md:127
#, no-wrap
msgid ""
"isEven : Integer -> Bool\n"
"isEven n = mod n 2 == 0\n"
"\n"
"testSquare : (Integer -> Bool) -> Integer -> Bool\n"
"testSquare fun n = fun (square n)\n"
msgstr ""
"isEven : Integer -> Bool\n"
"isEven n = mod n 2 == 0\n"
"\n"
"testSquare : (Integer -> Bool) -> Integer -> Bool\n"
"testSquare fun n = fun (square n)\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:142
msgid ""
"First `isEven` uses the `mod` function to check, whether an integer is "
"divisible by two. But the interesting function is `testSquare`. It takes two "
"arguments: The first argument is of type *function from `Integer` to "
"`Bool`*, and the second of type `Integer`. This second argument is squared "
"before being passed to the first argument. Again, give this a go at the REPL:"
msgstr ""
"まず`isEven`は`mod`関数を使った検査をしています。\n"
"検査の内容は整数が2で割れるかどうかです。\n"
"しかし、興味深い関数は`testSquare`のほうです。\n"
"この関数は2つの引数を取ります。\n"
"1つ目の引数は*`Integer`から`Bool`への関数*であり、2つ目の引数は`Integer`型で"
"す。\n"
"この2つ目の引数は最初の引数に渡される前に平方を取られます。\n"
"これもREPLでやってみましょう。"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions1.md:143
#, no-wrap
msgid ""
"Tutorial.Functions1> testSquare isEven 12\n"
"True\n"
msgstr ""
"Tutorial.Functions1> testSquare isEven 12\n"
"True\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:154
msgid ""
"Take your time to understand what's going on here. We pass function `isEven` "
"as an argument to `testSquare`. The second argument is an integer, which "
"will first be squared and then passed to `isEven`. While this is not very "
"interesting, we will see lots of use cases for passing functions as "
"arguments to other functions."
msgstr ""
"時間を取って何が起こっているのか理解しましょう。\n"
"ここでは`testSquare`に関数`isEven`を引数として渡しています。\n"
"2つ目の引数は整数で、平方を取られた後に`isEven`に渡されます。\n"
"これはあまり面白くない例かもしれませんが、以降は関数を引数として他の関数に渡"
"す沢山の活用例を目にするでしょう。"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:157
msgid ""
"I said above, we could go crazy pretty easily.  Consider for instance the "
"following example:"
msgstr ""
"前に述べたように、簡単におかしなことになりがちです。\n"
"例えば次の例を考えてみましょう。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions1.md:158
#, no-wrap
msgid ""
"twice : (Integer -> Integer) -> Integer -> Integer\n"
"twice f n = f (f n)\n"
msgstr ""
"twice : (Integer -> Integer) -> Integer -> Integer\n"
"twice f n = f (f n)\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:164 ../src/Tutorial/Functions1.md:227
#: ../src/Tutorial/Interfaces.md:504 ../src/Tutorial/Predicates.md:461
#: ../src/Tutorial/Prim.md:646
msgid "And at the REPL:"
msgstr "そしてREPLで次のようにします。"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions1.md:165
#, no-wrap
msgid ""
"Tutorial.Functions1> twice square 2\n"
"16\n"
"Tutorial.Functions1> (twice . twice) square 2\n"
"65536\n"
"Tutorial.Functions1> (twice . twice . twice . twice) square 2\n"
"*** huge number ***\n"
msgstr ""
"Tutorial.Functions1> twice square 2\n"
"16\n"
"Tutorial.Functions1> (twice . twice) square 2\n"
"65536\n"
"Tutorial.Functions1> (twice . twice . twice . twice) square 2\n"
"*** 巨大な数字 ***\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:177
msgid ""
"You might be surprised about this behavior, so we'll try and break it down. "
"The following two expressions are identical in their behavior:"
msgstr ""
"この結果にはびっくりしたかもしれません。\n"
"なので解きほぐしていきましょう。\n"
"以下の2つの式は挙動について等価です。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions1.md:178
#, no-wrap
msgid ""
"expr1 : Integer -> Integer\n"
"expr1 = (twice . twice . twice . twice) square\n"
"\n"
"expr2 : Integer -> Integer\n"
"expr2 = twice (twice (twice (twice square)))\n"
msgstr ""
"expr1 : Integer -> Integer\n"
"expr1 = (twice . twice . twice . twice) square\n"
"\n"
"expr2 : Integer -> Integer\n"
"expr2 = twice (twice (twice (twice square)))\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:194
msgid ""
"So, `square` raises its argument to the 2nd power, `twice square` raises it "
"to its 4th power (by invoking `square` twice in succession), `twice (twice "
"square)` raises it to its 16th power (by invoking `twice square` twice in "
"succession), and so on, until `twice (twice (twice (twice square)))` raises "
"it to its 65536th power resulting in an impressively huge result."
msgstr ""
"つまり、 `square` は引数を2乗します。\n"
"`twice square` は（`square` を2回連続で呼び出すので）4乗します。\n"
"`twice (twice square)` は（`twice square` を2回連続で呼び出すので）16乗しま"
"す。\n"
"そんな感じで続くと、\n"
"`twice (twice (twice (twice square)))` は65536乗することとなり、\n"
"度肝を抜くほど巨大な結果になるのです。"

#. type: Title ##
#: ../src/Tutorial/Functions1.md:195
#, no-wrap
msgid "Currying"
msgstr "カリー化"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:201
msgid ""
"Once we start using higher-order functions, the concept of partial function "
"application (also called *currying* after mathematician and logician Haskell "
"Curry) becomes very important."
msgstr ""
"ひとたび高階関数を使いはじめると、\n"
"部分関数適用（またの名を *カリー化* と呼びます。数学者であり論理学者でもあっ"
"たHaskell Curryに因みます）はとても大切な概念となります。"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:203
msgid "Load this file in a REPL session and try the following:"
msgstr "このファイルをREPLセッションに読み込んで以下を試してみましょう。"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions1.md:204
#, no-wrap
msgid ""
"Tutorial.Functions1> :t testSquare isEven\n"
"testSquare isEven : Integer -> Bool\n"
"Tutorial.Functions1> :t isTriple 1\n"
"isTriple 1 : Integer -> Integer -> Bool\n"
"Tutorial.Functions1> :t isTriple 1 2\n"
"isTriple 1 2 : Integer -> Bool\n"
msgstr ""
"Tutorial.Functions1> :t testSquare isEven\n"
"testSquare isEven : Integer -> Bool\n"
"Tutorial.Functions1> :t isTriple 1\n"
"isTriple 1 : Integer -> Integer -> Bool\n"
"Tutorial.Functions1> :t isTriple 1 2\n"
"isTriple 1 2 : Integer -> Bool\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:220
#, no-wrap
msgid ""
"Note, how in Idris we can partially apply a function\n"
"with more than one argument and as a result get a new function\n"
"back. For instance, `isTriple 1` applies argument `1` to function\n"
"`isTriple` and as a result returns a new function of\n"
"type `Integer -> Integer -> Bool`. We can even\n"
"use the result of such a partially applied function in\n"
"a new top level definition:\n"
msgstr ""
"注目すべき点は、Idrisでは1つ以上の引数に部分的に関数を適用すると、結果として新しい関数が返ってくるところです。\n"
"例えば、`isTriple 1`は引数1が関数`isTriple`にあてがわれており、結果として型が`Integer -> Integer -> Bool`な新しい関数が返ってきています。\n"
"このような部分的に適用された関数を新しく最上位の定義に使うことさえできます。\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions1.md:221
#, no-wrap
msgid ""
"partialExample : Integer -> Bool\n"
"partialExample = isTriple 3 4\n"
msgstr ""
"partialExample : Integer -> Bool\n"
"partialExample = isTriple 3 4\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions1.md:228
#, no-wrap
msgid ""
"Tutorial.Functions1> partialExample 5\n"
"True\n"
msgstr ""
"Tutorial.Functions1> partialExample 5\n"
"True\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:236
msgid ""
"We already used partial function application in our `twice` examples above "
"to get some impressive results with very little code."
msgstr ""
"既に`twice`の例でも部分関数適用を使いましたし、そこではとても小さなコードで驚"
"くような結果が得られたのでした。"

#. type: Title ##
#: ../src/Tutorial/Functions1.md:237
#, no-wrap
msgid "Anonymous Functions"
msgstr "匿名関数"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:245
msgid ""
"Sometimes we'd like to pass a small custom function to a higher-order "
"function without bothering to write a top level definition. For instance, in "
"the following example, function `someTest` is very specific and probably not "
"very useful in general, but we'd still like to pass it to higher-order "
"function `testSquare`:"
msgstr ""
"ときどき、最上位の定義を書くことなしに、小さな自前の関数を高階関数に渡したい"
"ときがあります。\n"
"例えば、以下の関数`someTest`はとても局所的な用途であり、一般的にはあまり有用"
"ではないのですが、とはいえ`testSquare`高階関数に渡したいのだとします。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions1.md:246
#, no-wrap
msgid ""
"someTest : Integer -> Bool\n"
"someTest n = n >= 3 || n <= 10\n"
msgstr ""
"someTest : Integer -> Bool\n"
"someTest n = n >= 3 || n <= 10\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:252
msgid "Here's, how to pass it to `testSquare`:"
msgstr "`testSquare` に渡すとこうなります。"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions1.md:253
#, no-wrap
msgid ""
"Tutorial.Functions1> testSquare someTest 100\n"
"True\n"
msgstr ""
"Tutorial.Functions1> testSquare someTest 100\n"
"True\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:260
msgid ""
"Instead of defining and using `someTest`, we can use an anonymous function:"
msgstr ""
"`someTest` を定義して使う代わりに、\n"
"匿名関数を使うことができます。"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions1.md:261
#, no-wrap
msgid ""
"Tutorial.Functions1> testSquare (\\n => n >= 3 || n <= 10) 100\n"
"True\n"
msgstr ""
"Tutorial.Functions1> testSquare (\\n => n >= 3 || n <= 10) 100\n"
"True\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:277
#, no-wrap
msgid ""
"Anonymous functions are sometimes also called *lambdas* (from\n"
"[lambda calculus](https://en.wikipedia.org/wiki/Lambda_calculus)),\n"
"and the backslash is chosen since it resembles the Greek\n"
"letter *lambda*. The `\\n =>` syntax introduces a new anonymous\n"
"function of one argument called `n`, the implementation of\n"
"which is on the right hand side of the function arrow.\n"
"Like other top level functions, lambdas can have more\n"
"than one arguments, separated by commas: `\\x,y => x * x + y`.\n"
"When we pass lambdas as arguments to higher-order functions,\n"
"they typically need to be wrapped in parentheses or separated\n"
"by the dollar operator `($)` (see the next section about this).\n"
msgstr ""
"匿名関数はときどき *ラムダ式* とも呼ばれます（ラムダ式は[ラムダ計算](https://en.wikipedia.org/wiki/Lambda_calculus)から来ています）。\n"
"バックスラッシュが使われていますが、これはギリシャ文字の *lambda* に似ているためです。\n"
"`\\n =>` という文法により、1つの引数 `n` を取る新しい匿名関数が導入され、関数の矢印の右側にその実装があります。\n"
"他の最上位の関数と同様に、ラムダ式は1つ以上の引数を取ることができ、引数はコンマ区切りです。\n"
"ラムダ式を高階関数の引数に渡したいときは大抵、括弧で括ったりドル演算子 `($)` で区切ったりする必要があります（ドル演算子は次の節を参照してください）。\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:280
msgid ""
"Note that, in a lambda, arguments are not annotated with types, so Idris has "
"to be able to infer them from the current context."
msgstr ""
"注意すべき点として、\n"
"ラムダ式では引数は型で註釈することができないということです。\n"
"なので、Idrisがそこでの文脈から型を推論できるようでないといけません。"

#. type: Title ##
#: ../src/Tutorial/Functions1.md:281
#, no-wrap
msgid "Operators"
msgstr "演算子"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:288
msgid ""
"In Idris, infix operators like `.`, `*` or `+` are not built into the "
"language, but are just regular Idris function with some special support for "
"using them in infix notation.  When we don't use operators in infix "
"notation, we have to wrap them in parentheses."
msgstr ""
"`.`や`*`や`+`のようなIdrisの中置演算子は言語に組込まれてはいません。\n"
"これらの演算子は通常のIdrisの関数に、中置記法で使うための特別なサポートがいく"
"らか付いたものです。\n"
"演算子を中置記法で使わないときは、括弧で包まねばなりません。"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:291
#, no-wrap
msgid ""
"As an example, let us define a custom operator for sequencing\n"
"functions of type `Bits8 -> Bits8`:\n"
msgstr "例として、型が `Bits8 -> Bits8` の関数を連ねる自前の演算子を定義してみましょう。\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions1.md:292
#, no-wrap
msgid ""
"infixr 4 >>>\n"
"\n"
"(>>>) : (Bits8 -> Bits8) -> (Bits8 -> Bits8) -> Bits8 -> Bits8\n"
"f1 >>> f2 = f2 . f1\n"
"\n"
"foo : Bits8 -> Bits8\n"
"foo n = 2 * n + 3\n"
"\n"
"test : Bits8 -> Bits8\n"
"test = foo >>> foo >>> foo >>> foo\n"
msgstr ""
"infixr 4 >>>\n"
"\n"
"(>>>) : (Bits8 -> Bits8) -> (Bits8 -> Bits8) -> Bits8 -> Bits8\n"
"f1 >>> f2 = f2 . f1\n"
"\n"
"foo : Bits8 -> Bits8\n"
"foo n = 2 * n + 3\n"
"\n"
"test : Bits8 -> Bits8\n"
"test = foo >>> foo >>> foo >>> foo\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:311
#, no-wrap
msgid ""
"In addition to declaring and defining the operator\n"
"itself, we also have to specify its fixity: `infixr 4 >>>` means,\n"
"that `(>>>)` associates to the right (meaning, that\n"
"`f >>> g >>> h` is to be interpreted as `f >>> (g >>> h)`)\n"
"with a priority of `4`. You can also have a look at the fixity\n"
"of operators exported by the *Prelude* in the REPL:\n"
msgstr ""
"演算子自体を宣言・定義することに加えて、結合の向きを指定せねばなりません。\n"
"`infixr 4 >>>`は、`(>>>)`が右結合（つまり`f >>> g >>> h`は`f >>> (g >>> h)`として解釈されます）で優先度4であることを意味します。\n"
"*Prelude* から公開されている演算子の結合についてREPLで見ることができます。\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions1.md:312
#, no-wrap
msgid ""
"Tutorial.Functions1> :doc (.)\n"
"Prelude.. : (b -> c) -> (a -> b) -> a -> c\n"
"  Function composition.\n"
"  Totality: total\n"
"  Fixity Declaration: infixr operator, level 9\n"
msgstr ""
"Tutorial.Functions1> :doc (.)\n"
"Prelude.. : (b -> c) -> (a -> b) -> a -> c\n"
"  Function composition.\n"
"  Totality: total\n"
"  Fixity Declaration: infixr operator, level 9\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:325
msgid ""
"When you mix infix operators in an expression, those with a higher priority "
"bind more tightly. For instance, `(+)` is left associated with a priority of "
"8, while `(*)` is left associated with a priority of 9. Hence, `a * b + c` "
"is the same as `(a * b) + c` instead of `a * (b + c)`."
msgstr ""
"式で複数の演算子が混在するような場合は、より高い優先度を持つ演算子がより強く"
"結び付きます。\n"
"例えば`(+)` は左結合で優先度が8、`(*)` は左結合で優先度が9です。\n"
"したがって `a * b + c` は `a * (b + c)` ではなく、`(a * b) + c` と同じです。"

#. type: Title ###
#: ../src/Tutorial/Functions1.md:326
#, no-wrap
msgid "Operator Sections"
msgstr "演算子節"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:332
msgid ""
"Operators can be partially applied just like regular functions. In this "
"case, the whole expression has to be wrapped in parentheses and is called an "
"*operator section*. Here are two examples:"
msgstr ""
"演算子は通常の関数と同様に部分適用できます。\n"
"このとき、全体の式は括弧に包まれている必要があります。\n"
"そしてこの式を *演算子節* と呼びます。\n"
"2つ例を挙げます。"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions1.md:333
#, no-wrap
msgid ""
"Tutorial.Functions1> testSquare (< 10) 5\n"
"False\n"
"Tutorial.Functions1> testSquare (10 <) 5\n"
"True\n"
msgstr ""
"Tutorial.Functions1> testSquare (< 10) 5\n"
"False\n"
"Tutorial.Functions1> testSquare (10 <) 5\n"
"True\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:344
#, no-wrap
msgid ""
"As you can see, there is a difference between `(< 10)`\n"
"and `(10 <)`. The first tests, whether its argument is\n"
"less than 10, the second, whether 10 is less than its\n"
"argument.\n"
msgstr ""
"例を見ての通り`(< 10)` と `(10 <)` には違いがあります。\n"
"前者は引数が10より小さいかの検査で、後者は10が引数より小さいかの検査です。\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:348
msgid ""
"One exception where operator sections will not work is with the *minus* "
"operator `(-)`. Here is an example to demonstrate this:"
msgstr ""
"演算子節がうまくいかない1つの例外は*負符号*演算子`(-)`です。\n"
"以下はこのことを実演する例です。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions1.md:349
#, no-wrap
msgid ""
"applyToTen : (Integer -> Integer) -> Integer\n"
"applyToTen f = f 10\n"
msgstr ""
"applyToTen : (Integer -> Integer) -> Integer\n"
"applyToTen f = f 10\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:357
msgid ""
"This is just a higher-order function applying the number ten to its function "
"argument. This works very well in the following example:"
msgstr ""
"これは単に数字の10を関数の引数として、高階関数を適用しているだけです。\n"
"以下の例では実にうまくいきます。"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions1.md:358
#, no-wrap
msgid ""
"Tutorial.Functions1> applyToTen (* 2)\n"
"20\n"
msgstr ""
"Tutorial.Functions1> applyToTen (* 2)\n"
"20\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:365
msgid "However, if we want to subtract five from ten, the following will fail:"
msgstr "しかし、10から5を引こうとすると以下のように失敗します。"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions1.md:366
#, no-wrap
msgid ""
"Tutorial.Functions1> applyToTen (- 5)\n"
"Error: Can't find an implementation for Num (Integer -> Integer).\n"
"\n"
"(Interactive):1:12--1:17\n"
" 1 | applyToTen (- 5)\n"
msgstr ""
"Tutorial.Functions1> applyToTen (- 5)\n"
"Error: Can't find an implementation for Num (Integer -> Integer).\n"
"\n"
"(Interactive):1:12--1:17\n"
" 1 | applyToTen (- 5)\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:377
msgid ""
"The problem here is, that Idris treats `- 5` as an integer literal instead "
"of an operator section. In this special case, we therefore have to use an "
"anonymous function instead:"
msgstr ""
"ここでの問題は、Idrisが`- 5`を演算子節ではなく整数の直値として扱うということ"
"です。\n"
"この特別な場合においては、代わりに匿名関数を使わねばなりません。"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions1.md:378
#, no-wrap
msgid ""
"Tutorial.Functions1> applyToTen (\\x => x - 5)\n"
"5\n"
msgstr ""
"Tutorial.Functions1> applyToTen (\\x => x - 5)\n"
"5\n"

#. type: Title ###
#: ../src/Tutorial/Functions1.md:383
#, no-wrap
msgid "Infix Notation for Non-Operators"
msgstr "演算子ではない関数のための中置記法"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:390
msgid ""
"In Idris, it is possible to use infix notation for regular binary functions, "
"by wrapping them in backticks.  It is even possible to define a precedence "
"(fixity) for these and use them in operator sections, just like regular "
"operators:"
msgstr ""
"Idrisでは通常の2引数関数も、バッククォートに包むことで中置記法することができ"
"ます。\n"
"優先度（と結合の向き）を定義して、ちょうど通常の演算子のように演算子節で使う"
"こともできます。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions1.md:391
#, no-wrap
msgid ""
"infixl 8 `plus`\n"
"\n"
"infixl 9 `mult`\n"
"\n"
"plus : Integer -> Integer -> Integer\n"
"plus = (+)\n"
"\n"
"mult : Integer -> Integer -> Integer\n"
"mult = (*)\n"
"\n"
"arithTest : Integer\n"
"arithTest = 5 `plus` 10 `mult` 12\n"
"\n"
"arithTest' : Integer\n"
"arithTest' = 5 + 10 * 12\n"
msgstr ""
"infixl 8 `plus`\n"
"\n"
"infixl 9 `mult`\n"
"\n"
"plus : Integer -> Integer -> Integer\n"
"plus = (+)\n"
"\n"
"mult : Integer -> Integer -> Integer\n"
"mult = (*)\n"
"\n"
"arithTest : Integer\n"
"arithTest = 5 `plus` 10 `mult` 12\n"
"\n"
"arithTest' : Integer\n"
"arithTest' = 5 + 10 * 12\n"

#. type: Title ###
#: ../src/Tutorial/Functions1.md:409
#, no-wrap
msgid "Operators exported by the *Prelude*"
msgstr "*Prelude* から公開されている演算子"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:419
msgid ""
"Here is a list of important operators exported by the *Prelude*.  Most of "
"these are *constrained*, that is they work only for types implementing a "
"certain *interface*. Don't worry about this right now. We will learn about "
"interfaces in due time, and the operators behave as they intuitively "
"should.  For instance, addition and multiplication work for all numeric "
"types, comparison operators work for almost all types in the *Prelude* with "
"the exception of functions."
msgstr ""
"以下は*Prelude*から公開されている重要な演算子の一覧です。\n"
"これらのうちほとんどは*制約付き*のものです。\n"
"制約付きというのは、特定の*インターフェース*を実装した型に対してのみ使える、"
"ということです。\n"
"今は心配しなくて大丈夫です。\n"
"その時が来たらインターフェースについて学びましょう。\n"
"インターフェースを知らずとも、演算子は直感的に振舞うことでしょう。\n"
"例えば加算と乗算は全ての数値型に対してはたらきますし、比較演算子は*Prelude*の"
"関数以外のほぼ全ての型に対してはたらきます。"

#. type: Bullet: '* '
#: ../src/Tutorial/Functions1.md:429
msgid "`(.)`: Function composition"
msgstr "`(.)`: 関数結合"

#. type: Bullet: '* '
#: ../src/Tutorial/Functions1.md:429
msgid "`(+)`: Addition"
msgstr "`(+)`: 加算"

#. type: Bullet: '* '
#: ../src/Tutorial/Functions1.md:429
msgid "`(*)`: Multiplication"
msgstr "`(*)`: 乗算"

#. type: Bullet: '* '
#: ../src/Tutorial/Functions1.md:429
msgid "`(-)`: Subtraction"
msgstr "`(-)`: 減算"

#. type: Bullet: '* '
#: ../src/Tutorial/Functions1.md:429
msgid "`(/)`: Division"
msgstr "`(/)`: 除算"

#. type: Bullet: '* '
#: ../src/Tutorial/Functions1.md:429
msgid "`(==)` : True, if two values are equal"
msgstr "`(==)` : 2つの値が等しいとき真"

#. type: Bullet: '* '
#: ../src/Tutorial/Functions1.md:429
msgid "`(/=)` : True, if two values are not equal"
msgstr "`(/=)` : 2つの値が異なるとき真"

#. type: Bullet: '* '
#: ../src/Tutorial/Functions1.md:429
msgid "`(<=)`, `(>=)`, `(<)`, and `(>)` : Comparison operators"
msgstr "`(<=)`, `(>=)`, `(<)`, `(>)` : 比較演算子"

#. type: Bullet: '* '
#: ../src/Tutorial/Functions1.md:429
msgid "`($)`: Function application"
msgstr "`($)`: 関数適用"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:440
msgid ""
"The most special of the above is the last one. It has a priority of 0, so "
"all other operators bind more tightly.  In addition, function application "
"binds more tightly, so this can be used to reduce the number of parentheses "
"required. For instance, instead of writing `isTriple 3 4 (2 + 3 * 1)` we can "
"write `isTriple 3 4 $ 2 + 3 * 1`, which is exactly the same. Sometimes, this "
"helps readability, sometimes, it doesn't. The important thing to remember is "
"that `fun $ x y` is just the same as `fun (x y)`."
msgstr ""
"上記のうち最も特別なのは最後の演算子です。\n"
"優先度が0なので、それ以外の演算子の方が強く結び付きます。\n"
"加えて、関数適用はそれよりさらに強く結び付くので、この演算子によって必要な括"
"弧の数を減らすことができます。\n"
"例えば、`isTriple 3 4 (2 + 3 * 1)`と書くところを、`isTriple 3 4 $ 2 + 3 * 1`"
"とできますが、全く同じ意味です。\n"
"この演算子で可読性が上がることもあれば、下がることもあります。\n"
"覚えておくべきことは、`fun $ x y`が`fun (x y)`と同じであるということです。"

#. type: Title ###
#: ../src/Tutorial/Functions1.md:441 ../src/Tutorial/Functions2.md:339
#, no-wrap
msgid "Exercises"
msgstr "演習"

#. type: Bullet: '1. '
#: ../src/Tutorial/Functions1.md:450
msgid ""
"Reimplement functions `testSquare` and `twice` by using the dot operator and "
"dropping the second arguments (have a look at the implementation of "
"`squareTimes2` to get an idea where this should lead you). This highly "
"concise way of writing function implementations is sometimes called *point-"
"free style* and is often the preferred way of writing small utility "
"functions."
msgstr ""
"ドット演算子を使い、2つ目の引数を省くことで、関数 `testSquare` と `twice` を"
"実装し直してください（`squareTimes2` の実装を見れば方針が見えてきます）。\n"
"このかなり簡潔な関数の実装の書き方はしばしば*ポイントフリー形式*と呼ばれ、"
"ユーティリティ関数を書くときによく好まれます。"

#. type: Bullet: '2. '
#: ../src/Tutorial/Functions1.md:453
msgid ""
"Declare and implement function `isOdd` by combining functions `isEven` from "
"above and `not` (from the Idris *Prelude*). Use point-free style."
msgstr ""
"前述の関数`isEven`と`not`（Idrisの*Prelude*由来）を組み合わせて`isOdd`を宣"
"言・実装してください。\n"
"ただしポイントフリー形式を使ってください。"

#. type: Bullet: '3. '
#: ../src/Tutorial/Functions1.md:456
msgid ""
"Declare and implement function `isSquareOf`, which checks whether its first "
"`Integer` argument is the square of the second argument."
msgstr ""
"`isSquareOf` 関数を宣言・定義してください。\n"
"この関数は最初の `Integer` な引数が2つ目の引数の平方であるか検査します。"

#. type: Bullet: '4. '
#: ../src/Tutorial/Functions1.md:460
msgid ""
"Declare and implement function `isSmall`, which checks whether its `Integer` "
"argument is less than or equal to 100. Use one of the comparison operators "
"`<=` or `>=` in your implementation."
msgstr ""
"関数 `isSmall` を宣言・実装してください。\n"
"この関数は `Integer` な引数が100以下かどうか検査します。\n"
"実装では比較演算子 `<=` または `>=` を使ってください。"

#. type: Bullet: '5. '
#: ../src/Tutorial/Functions1.md:465
msgid ""
"Declare and implement function `absIsSmall`, which checks whether the "
"absolute value of its `Integer` argument is less than or equal to 100.  Use "
"functions `isSmall` and `abs` (from the Idris *Prelude*) in your "
"implementation, which should be in point-free style."
msgstr ""
"関数`absIsSmall`を宣言・定義してください。\n"
"この関数は`Integer`な引数の絶対値を取ったものが100以下かどうか検査します。\n"
"実装では関数`isSmall`と`abs`（Idrisの*Prelude*由来）を使ってください。\n"
"また、ポイントフリー形式を使ってください。"

#. type: Bullet: '6. '
#: ../src/Tutorial/Functions1.md:471
msgid ""
"In this slightly extended exercise we are going to implement some utilities "
"for working with `Integer` predicates (functions from `Integer` to `Bool`). "
"Implement the following higher-order functions (use boolean operators `&&`, "
"`||`, and function `not` in your implementations):"
msgstr ""
"ちょっと発展的な演習として、`Integer`に関する命題を扱うユーティリティを実装し"
"ていきます（ここでの命題とは、`Integer`を取って`Bool`を返す関数です）。\n"
"以下の高階関数を実装してください（実装では真偽値演算子`&&`、`||`と関数`not`を"
"使ってください）。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions1.md:472
#, no-wrap
msgid ""
"   -- return true, if and only if both predicates hold\n"
"   and : (Integer -> Bool) -> (Integer -> Bool) -> Integer -> Bool\n"
"\n"
"   -- return true, if and only if at least one predicate holds\n"
"   or : (Integer -> Bool) -> (Integer -> Bool) -> Integer -> Bool\n"
"\n"
"   -- return true, if the predicate does not hold\n"
"   negate : (Integer -> Bool) -> Integer -> Bool\n"
msgstr ""
"   -- 両方の命題が満たされているときに限り真\n"
"   and : (Integer -> Bool) -> (Integer -> Bool) -> Integer -> Bool\n"
"\n"
"   -- 少なくとも一方の命題が満たされているときに限り真\n"
"   or : (Integer -> Bool) -> (Integer -> Bool) -> Integer -> Bool\n"
"\n"
"   -- 命題が満たされないときに真\n"
"   negate : (Integer -> Bool) -> Integer -> Bool\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:487
#, no-wrap
msgid ""
"   After solving this exercise, give it a go in the REPL. In the\n"
"   example below, we use binary function `and` in infix notation\n"
"   by wrapping it in backticks. This is just a syntactic convenience\n"
"   to make certain function applications more readable:\n"
msgstr ""
"   この演習を解いたら、REPLを立ち上げてください。\n"
"   以下の例では2引数関数 `and` をバッククォートで包んだ中置記法にして使っています。\n"
"   これは単に文法的に便利だからで、こうすることで関数適用がより読みやすくなることがあります。\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions1.md:488
#, no-wrap
msgid ""
"   Tutorial.Functions1> negate (isSmall `and` isOdd) 73\n"
"   False\n"
msgstr ""
"   Tutorial.Functions1> negate (isSmall `and` isOdd) 73\n"
"   False\n"

#. type: Bullet: '7. '
#: ../src/Tutorial/Functions1.md:500
msgid ""
"As explained above, Idris allows us to define our own infix operators.  Even "
"better, Idris supports *overloading* of function names, that is, two "
"functions or operators can have the same name, but different types and "
"implementations.  Idris will make use of the types to distinguish between "
"equally named operators and functions."
msgstr ""
"前述したように、Idrisでは自前の中置演算子を定義できます。\n"
"さらにいいことにIdrisでは関数名の *オーバーロード* ができます。\n"
"というのは、2つ以上の関数や演算子が違う型と実装を持ちつつ同じ名前にできるとい"
"うことです。\n"
"Idrisは同名の演算子と関数を型で見分けます。"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:504
#, no-wrap
msgid ""
"   This allows us, to reimplement functions `and`, `or`, and `negate`\n"
"   from Exercise 6 by using the existing operator and function\n"
"   names from boolean algebra:\n"
msgstr "   これにより、真偽値計算での既存の演算子と関数の名前を使いつつ、演習6から関数`and`、`or`、`negate`を実装し直すことができます。\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions1.md:505
#, no-wrap
msgid ""
"   -- return true, if and only if both predicates hold\n"
"   (&&) : (Integer -> Bool) -> (Integer -> Bool) -> Integer -> Bool\n"
"   x && y = and x y\n"
"\n"
"   -- return true, if and only if at least one predicate holds\n"
"   (||) : (Integer -> Bool) -> (Integer -> Bool) -> Integer -> Bool\n"
"\n"
"   -- return true, if the predicate does not hold\n"
"   not : (Integer -> Bool) -> Integer -> Bool\n"
msgstr ""
"   -- 両方の命題が満たされているときに限り真\n"
"   (&&) : (Integer -> Bool) -> (Integer -> Bool) -> Integer -> Bool\n"
"   x && y = and x y\n"
"\n"
"   -- 少なくとも1つの命題が満たされているときに限り真\n"
"   (||) : (Integer -> Bool) -> (Integer -> Bool) -> Integer -> Bool\n"
"\n"
"   -- 命題が満たされていないとき真\n"
"   not : (Integer -> Bool) -> Integer -> Bool\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:518
#, no-wrap
msgid "   Implement the other two functions and test them at the REPL:\n"
msgstr "   残りの2つの関数 `(||)` と `not` を実装してREPLで試してください。\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions1.md:519
#, no-wrap
msgid ""
"   Tutorial.Functions1> not (isSmall && isOdd) 73\n"
"   False\n"
msgstr ""
"   Tutorial.Functions1> not (isSmall && isOdd) 73\n"
"   False\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:527
msgid "What we learned in this chapter:"
msgstr "この章で学んだことは以下です。"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:530
#, no-wrap
msgid ""
"* A function in Idris can take an arbitrary number of arguments,\n"
"separated by `->` in the function's type.\n"
msgstr ""
"Idrisの関数は幾つでも引数を取ることができます。\n"
"引数は関数の型で、`->`で区切られています。\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:534
#, no-wrap
msgid ""
"* Functions can be combined\n"
"sequentially using the dot operator, which leads to highly\n"
"concise code.\n"
msgstr ""
"* ドット演算子を連続して使うことで関数を組み合わせることができます。\n"
"こうすることでかなり簡潔なコードになります。\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:539
#, no-wrap
msgid ""
"* Functions can be partially applied by passing them fewer\n"
"arguments than they expect. The result is a new function\n"
"expecting the remaining arguments. This technique is called\n"
"*currying*.\n"
msgstr ""
"* 関数が期待するより少ない引数を渡すことで、\n"
"関数の部分適用ができます。\n"
"部分適用の結果は残りの引数を期待する新しい関数になります。\n"
"この技法は *カリー化* と呼ばれます。\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:543
#, no-wrap
msgid ""
"* Functions can be passed as arguments to other functions, which\n"
"allows us to easily combine small coding units to create\n"
"more complex behavior.\n"
msgstr ""
"* 関数は他の関数の引数に渡すことができます。\n"
"これにより、小さなコードの部品を組み合わせることで、より複雑な挙動を簡単に生み出すことができます。\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:547
#, no-wrap
msgid ""
"* We can pass anonymous functions (*lambdas*) to higher-order\n"
"functions, if writing a corresponding top level\n"
"function would be too cumbersome.\n"
msgstr ""
"* 匿名関数（*ラムダ式*）を高階関数に渡すことができます。\n"
"匿名関数は、これに対応する最上位の関数を書くのがまどろっこしいときに使います。\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:551
#, no-wrap
msgid ""
"* Idris allows us to define our own infix operators. These\n"
"have to be written in parentheses unless they are being used\n"
"in infix notation.\n"
msgstr ""
"* Idrisでは自前の中置演算子を定義することができます。\n"
"中置記法で使われないときは、中置演算子は括弧の中に書く必要があります。\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:556
#, no-wrap
msgid ""
"* Infix operators can also be partially applied. These *operator sections*\n"
"have to be wrapped in parentheses, and the position of the\n"
"argument determines, whether it is used as the operator's first\n"
"or second argument.\n"
msgstr ""
"* 中置演算子は部分適用することもできます。\n"
"  この*演算子節*は括弧で包まれていなければいけません。\n"
"  そして、演算子節での引数の位置は、演算子の引数として1番目か2番目のどちらに使われるかを決めます。\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:560
#, no-wrap
msgid ""
"* Idris supports name overloading: Functions can have the same\n"
"names but different implementations. Idris will decide, which function\n"
"to used based to the types involved.\n"
msgstr ""
"* Idrisでは名前のオーバーロードができます。\n"
"  関数は同名でありつつ違う実装を持つことができます。\n"
"  Idrisはどちらの関数を使うべきかを型から決めます。\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:567
msgid ""
"Please note, that function and operator names in a module must be unique. In "
"order to define two functions with the same name, they have to be declared "
"in distinct modules. If Idris is not able to decide, which of the two "
"functions to use, we can help name resolution by prefixing a function with "
"(a part of) its *namespace*:"
msgstr ""
"注意したいことは、\n"
"1つのモジュール内の関数と演算子の名前は一意であるということです。\n"
"同じ名前の2つの関数を定義するには、\n"
"別々のモジュールで宣言する必要があります。\n"
"Idrisがどちらを使うべきか判断できないときは、\n"
"関数に（部分的にでも） *名前空間* を前置することで、名前解決できるようになり"
"ます。"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions1.md:568
#, no-wrap
msgid ""
"Tutorial.Functions1> :t Prelude.not\n"
"Prelude.not : Bool -> Bool\n"
"Tutorial.Functions1> :t Functions1.not\n"
"Tutorial.Functions1.not : (Integer -> Bool) -> (Integer -> Bool) -> Integer -> Bool\n"
msgstr ""
"Tutorial.Functions1> :t Prelude.not\n"
"Prelude.not : Bool -> Bool\n"
"Tutorial.Functions1> :t Functions1.not\n"
"Tutorial.Functions1.not : (Integer -> Bool) -> (Integer -> Bool) -> Integer -> Bool\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:581
msgid ""
"In the [next section](DataTypes.md), we will learn how to define our own "
"data types and how to construct and deconstruct values of these new types. "
"We will also learn about generic types and functions."
msgstr ""
"[次節](DataTypes.md)では、\n"
"自前のデータ型を定義する方法と、\n"
"この新しい型の値を構築したり分解したりする方法を学びます。\n"
"汎化型と汎化関数についても学びます。"
