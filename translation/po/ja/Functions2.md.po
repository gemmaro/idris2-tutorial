# Japanese translations for FUnctional Programming in Idris 2
# Copyright (c) 2021-2023, Stefan Höck.
# Copyright (C) 2022, 2023 gemmaro <gemmaro.dev@gmail.com>.
# This file is distributed under the same license as the Functional Programming in Idris 2.
#
msgid ""
msgstr ""
"Project-Id-Version: Functional Programming in Idris 2\n"
"POT-Creation-Date: 2023-04-09 22:52+0900\n"
"PO-Revision-Date: 2023-05-07 22:22+0900\n"
"Last-Translator: gemmaro <gemmaro.dev@gmail.com>\n"
"Language-Team: none\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#. type: Title ##
#: ../src/Appendices/Neovim.md:364 ../src/Appendices/Install.md:102
#: ../src/Appendices/Projects.md:878 ../src/Tutorial/DPair.md:1191
#: ../src/Tutorial/DataTypes.md:1319 ../src/Tutorial/Dependent.md:872
#: ../src/Tutorial/Eq.md:1085 ../src/Tutorial/Folds.md:1051
#: ../src/Tutorial/Functions1.md:524 ../src/Tutorial/Functions2.md:924
#: ../src/Tutorial/Functor.md:1395 ../src/Tutorial/IO.md:1095
#: ../src/Tutorial/Interfaces.md:792 ../src/Tutorial/Predicates.md:1358
#: ../src/Tutorial/Traverse.md:1109
#, no-wrap
msgid "Conclusion"
msgstr "まとめ"

#. type: Plain text
#: ../src/Appendices/Neovim.md:374 ../src/Appendices/Projects.md:890
#: ../src/Tutorial/DPair.md:1206 ../src/Tutorial/DataTypes.md:1368
#: ../src/Tutorial/Dependent.md:910 ../src/Tutorial/Eq.md:1100
#: ../src/Tutorial/Folds.md:1064 ../src/Tutorial/Functions1.md:583
#: ../src/Tutorial/Functions2.md:964 ../src/Tutorial/Functor.md:1427
#: ../src/Tutorial/IO.md:1125 ../src/Tutorial/Interfaces.md:821
#: ../src/Tutorial/Intro.md:453 ../src/Tutorial/Predicates.md:1371
#: ../src/Tutorial/Prim.md:1411 ../src/Tutorial/Traverse.md:1148
#, no-wrap
msgid ""
"<!-- vi: filetype=idris2:syntax=markdown\n"
"-->\n"
msgstr ""
"<!-- vi: filetype=idris2:syntax=markdown\n"
"-->\n"

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:1362 ../src/Tutorial/Dependent.md:904
#: ../src/Tutorial/Functions1.md:575 ../src/Tutorial/Functions2.md:954
#: ../src/Tutorial/IO.md:1118 ../src/Tutorial/Interfaces.md:813
#, no-wrap
msgid "What's next"
msgstr "お次は？"

#. type: Title ###
#: ../src/Tutorial/Functions1.md:441 ../src/Tutorial/Functions2.md:339
#, no-wrap
msgid "Exercises"
msgstr "演習"

#. type: Title #
#: ../src/Tutorial/Functions2.md:1
#, no-wrap
msgid "Functions Part 2"
msgstr "関数 その2"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:9
msgid ""
"So far, we learned about the core features of the Idris language, which it "
"has in common with several other pure, strongly typed programming languages "
"like Haskell: (Higher-order) Functions, algebraic data types, pattern "
"matching, parametric polymorphism (generic types and functions), and ad hoc "
"polymorphism (interfaces and constrained functions)."
msgstr ""
"これまでIdris言語の核となる特徴について学びました。Haskellのような他の純粋で"
"強く型付けされたプログラミング言語と共通点があります。（高階）関数、代数的"
"データ型、パターン照合、パラメトリック多相（汎化型と汎化関数）、そしてアド"
"ホック多相（インターフェースと制約付き関数）がそうです。"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:15
msgid ""
"In this chapter, we start to dissect Idris functions and their types for "
"real. We learn about implicit arguments, named arguments, as well as erasure "
"and quantities. But first, we'll look at `let` bindings and `where` blocks, "
"which help us implement functions too complex to fit on a single line of "
"code. Let's get started!"
msgstr ""
"この章ではIdrisの実践上の関数とその型を解剖し始めます。\n"
"暗黙引数、名前付き引数、そして型消去と数量的型を学びます。\n"
"しかしまずは`let`束縛と`where`ブロックを見ていきます。\n"
"これらのおかげで、複雑すぎて単一行のコードに収まりきらない関数も、\n"
"実装することができるようになります。\n"
"始めましょう！"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:16
#, no-wrap
msgid ""
"module Tutorial.Functions2\n"
"\n"
"%default total\n"
msgstr ""
"module Tutorial.Functions2\n"
"\n"
"%default total\n"

#. type: Title ##
#: ../src/Tutorial/Functions2.md:22
#, no-wrap
msgid "Let Bindings and Local Definitions"
msgstr "let束縛と局所定義"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:31
msgid ""
"The functions we looked at so far were simple enough to be implemented "
"directly via pattern matching without the need of additional auxiliary "
"functions or variables. This is not always the case, and there are two "
"important language constructs for introducing and reusing new local "
"variables and functions. We'll look at these in two case studies."
msgstr ""
"これまで見てきた関数はパターン照合で直接実装できる程度には単純なものでし"
"た。\n"
"追加の付属関数ないし変数を必要としませんでした。\n"
"いつもこういうわけではなくて、\n"
"新しい局所変数と局所関数を導入したり再利用したりするための、\n"
"2つの大事な言語的構築要素があります。\n"
"これらを2つの事例の観察から見ていきましょう。"

#. type: Title ###
#: ../src/Tutorial/Functions2.md:32
#, no-wrap
msgid "Use Case 1: Arithmetic Mean and Standard Deviation"
msgstr "使用例1：算術平均と標準偏差"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:37
msgid ""
"In this example, we'd like to calculate the arithmetic mean and the standard "
"deviation of a list of floating point values.  There are several things we "
"need to consider."
msgstr ""
"この例では算術平均と標準偏差を浮動小数点数値のリストから計算することを考えま"
"す。"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:41
msgid ""
"First, we need a function for calculating the sum of a list of numeric "
"values. The *Prelude* exports function `sum` for this:"
msgstr ""
"まず総和を数値のリストから計算する関数が必要です。\n"
"*Prelude*はこのための関数`sum`を公開しています。"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions2.md:42
#, no-wrap
msgid ""
"Main> :t sum\n"
"Prelude.sum : Num a => Foldable t => t a -> a\n"
msgstr ""
"Main> :t sum\n"
"Prelude.sum : Num a => Foldable t => t a -> a\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:51
msgid ""
"This is - of course - similar to `sumList` from Exercise 10 of the [last "
"section](Interfaces.md), but generalized to all container types with a "
"`Foldable` implementation. We will learn about interface `Foldable` in a "
"later section."
msgstr ""
"これは、もちろんのこと、[直前の節](Interfaces.md)の演習10での`sumList`に似た"
"ものです。\n"
"しかし`Foldable`の実装がある全ての積載型に汎化されています。\n"
"インターフェース`Foldable`については後の節で学びましょう。"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:62
msgid ""
"In order to also calculate the variance, we need to convert every value in "
"the list to a new value, as we have to subtract the mean from every value in "
"the list and square the result. In the previous section's exercises, we "
"defined function `mapList` for this. The *Prelude* - of course - already "
"exports a similar function called `map`, which is again more general and "
"works also like our `mapMaybe` for `Maybe` and `mapEither` for `Either e`. "
"Here's its type:"
msgstr ""
"分散を計算するためにはリストの全ての値を新しい値に計算する必要もあります。\n"
"なぜならリスト中の全ての値から平均を引いて結果を平方する必要があるからで"
"す。\n"
"前の節の演習でこのための関数`mapList`を定義しました。\n"
"*Prelude*は、当然、既に似たような関数`map`を公開しています。\n"
"これもまたより汎用的で自前の`Maybe`のための`mapMaybe`や`Either e`のための"
"`mapEither`としても動きます。\n"
"以下が型です。"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions2.md:63
#, no-wrap
msgid ""
"Main> :t map\n"
"Prelude.map : Functor f => (a -> b) -> f a -> f b\n"
msgstr ""
"Main> :t map\n"
"Prelude.map : Functor f => (a -> b) -> f a -> f b\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:70
msgid "Interface `Functor` is another one we'll talk about in a later section."
msgstr "インターフェース`Functor`についても後の節でお話しします。"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:73
msgid ""
"Finally, we need a way to calculate the length of a list of values. We use "
"function `length` for this:"
msgstr ""
"最後に値のリストの長さを計算する方法が必要です。\n"
"これには関数`length`を使います。"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions2.md:74
#, no-wrap
msgid ""
"Main> :t List.length\n"
"Prelude.List.length : List a -> Nat\n"
msgstr ""
"Main> :t List.length\n"
"Prelude.List.length : List a -> Nat\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:87
#, no-wrap
msgid ""
"Here, `Nat` is the type of natural numbers\n"
"(unbounded, unsigned integers). `Nat` is actually not a primitive data\n"
"type but a sum type defined in the *Prelude* with\n"
"data constructors `Z : Nat` (for zero)\n"
"and `S : Nat -> Nat` (for successor). It might seem highly inefficient\n"
"to define natural numbers this way, but the Idris compiler\n"
"treats these and several other *number-like* types specially, and\n"
"replaces them with primitive integers during code generation.\n"
msgstr ""
"ここで`Nat`は自然数型です。\n"
"（範囲がなく、符号なしです。）\n"
"`Nat`は実のところ原始的なデータ型ではなくて、\n"
"*Prelude*で定義された直和型で、\n"
"データ構築子`Z : Nat`（ゼロ）と`S : Nat -> Nat`（それ以上）からなります。\n"
"自然数をこうして定義するのはかなり非効率に思えますが、\n"
"Idrisはこうしたものといくつかの他の*数のような*型を特別に扱い、\n"
"コード生成の段階で原始的な整数に置き換えます。\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:93
msgid ""
"We are now ready to give the implementation of `mean` a go.  Since this is "
"Idris, and we care about clear semantics, we will quickly define a custom "
"record type instead of just returning a tuple of `Double`s. This makes it "
"clearer, which floating point number corresponds to which statistic entity:"
msgstr ""
"これで`mean`の実装を与えられるようになります。\n"
"これはIdrisであり、明白な意味論に気をつけているので、\n"
"単に`Double`のタプルを返すのではなく、ささっと自前のレコード型を定義しま"
"す。\n"
"こうすることでより明白になるのは、どちらの小数点数がどちらの統計的な実態に対"
"応するのかということです。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:94
#, no-wrap
msgid ""
"square : Double -> Double\n"
"square n = n * n\n"
"\n"
"record Stats where\n"
"  constructor MkStats\n"
"  mean      : Double\n"
"  variance  : Double\n"
"  deviation : Double\n"
"\n"
"stats : List Double -> Stats\n"
"stats xs =\n"
"  let len      := cast (length xs)\n"
"      mean     := sum xs / len\n"
"      variance := sum (map (\\x => square (x - mean)) xs) / len\n"
"   in MkStats mean variance (sqrt variance)\n"
msgstr ""
"square : Double -> Double\n"
"square n = n * n\n"
"\n"
"record Stats where\n"
"  constructor MkStats\n"
"  mean      : Double\n"
"  variance  : Double\n"
"  deviation : Double\n"
"\n"
"stats : List Double -> Stats\n"
"stats xs =\n"
"  let len      := cast (length xs)\n"
"      mean     := sum xs / len\n"
"      variance := sum (map (\\x => square (x - mean)) xs) / len\n"
"   in MkStats mean variance (sqrt variance)\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:113
msgid "As usual, we first try this at the REPL:"
msgstr "いつも通り、まずはREPLで試してみます。"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions2.md:114
#, no-wrap
msgid ""
"Tutorial.Functions2> stats [2,4,4,4,5,5,7,9]\n"
"MkStats 5.0 4.0 2.0\n"
msgstr ""
"Tutorial.Functions2> stats [2,4,4,4,5,5,7,9]\n"
"MkStats 5.0 4.0 2.0\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:133
msgid ""
"Seems to work, so let's digest this step by step.  We introduce several new "
"local variables (`len`, `mean`, and `variance`), which all will be used more "
"than once in the remainder of the implementation. To do so, we use a `let` "
"binding. This consists of the `let` keyword, followed by one or more "
"variable assignments, followed by the final expression, which has to be "
"prefixed by `in`. Note, that whitespace is significant again: We need to "
"properly align the three variable names. Go ahead, and try out what happens "
"if you remove a space in front of `mean` or `variance`.  Note also, that the "
"alignment of assignment operators `:=` is optional. I do this, since I "
"thinks it helps readability."
msgstr ""
"動いているようなので1つずつ紐解いていきましょう。\n"
"いくつかの局所変数 (`len`, `mean`, `variance`) を導入し、\n"
"それら全ては実装の残りの部分で1度以上使われます。\n"
"これには`let`束縛を使います。\n"
"順に、`let`キーワード、1つ以上の変数代入が続き、最後の式には`in`が後置してい"
"なければいけません。\n"
"空白はここでも重要ですよ。\n"
"3つの変数名は適切に整列していなくてはいけません。\n"
"さあ、`mean`や`variance`の前の空白を削除すると何が起こるのかやってみましょ"
"う。\n"
"ただし、代入演算子`:=`は整列していなくても大丈夫です。\n"
"こうしたのは可読性がよくなると思っているからです。"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:149
msgid ""
"Let's also quickly look at the different variables and their types. `len` is "
"the length of the list cast to a `Double`, since this is what's needed later "
"on, where we divide other values of type `Double` by the length. Idris is "
"very strict about this: We are not allowed to mix up numeric types without "
"explicit casts. Please note, that in this case Idris is able to *infer* the "
"type of `len` from the surrounding context. `mean` is straight forward: We "
"`sum` up the values stored in the list and divide by the list's length. "
"`variance` is the most involved of the three: We map each item in the list "
"to a new value using an anonymous function to subtract the mean and square "
"the result. We then sum up the new terms and divide again by the number of "
"values."
msgstr ""
"それぞれの変数とその型についてもさくっと見ていきましょう。\n"
"`len`はリストの長さで、のちのちのために`Double`に嵌め込まれています。\n"
"というのは、`Double`な他の値を長さで割ることになるからです。\n"
"Idrisはこうしたことに大変厳格です。\n"
"明示的な嵌め込みなくして、数値型を混在させることはできません。\n"
"注意していただきたいのは、この場合はIdrisが`len`の型を周囲の文脈から*推論*す"
"ることができているということです。\n"
"`mean`は直感的です。\n"
"リストに保管された値を`sum`で合計し、リストの長さで割っています。\n"
"`variance`は3つの中でもっとも込み入っています。\n"
"リストのそれぞれの要素について、\n"
"匿名関数を使って平均を引いたのちに、その平方を取っています。\n"
"そうしてできた値を合計し、再度値の数で割ります。"

#. type: Title ###
#: ../src/Tutorial/Functions2.md:150
#, no-wrap
msgid "Use Case 2: Simulating a Simple Web Server"
msgstr "使用例2：簡素なWebサーバを模擬する"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:156
msgid ""
"In the second use case, we are going to write a slightly larger application. "
"This should give you an idea about how to design data types and functions "
"around some business logic you'd like to implement."
msgstr ""
"2つ目の使用例ではもうちょっと大きいアプリケーションを書いていきます。\n"
"実装したいビジネスロジックに対して、データ型と関数をどのように設計すればよい"
"かを考えられるようになるでしょう。"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:161
msgid ""
"Assume we run a music streaming web server, where users can buy whole albums "
"and listen to them online. We'd like to simulate a user connecting to the "
"server and getting access to one of the albums they bought."
msgstr ""
"音楽配信webサーバを稼動させているのだとします。\n"
"そこでは利用者はアルバム一式を買ってオンラインで聴くことができます。\n"
"サーバに接続して購入したアルバムの1つにアクセスする利用者を模擬したいところで"
"す。"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:163
msgid "We first define a bunch of record types:"
msgstr "まず沢山のレコード型を定義します。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:164
#, no-wrap
msgid ""
"record Artist where\n"
"  constructor MkArtist\n"
"  name : String\n"
"\n"
"record Album where\n"
"  constructor MkAlbum\n"
"  name   : String\n"
"  artist : Artist\n"
"\n"
"record Email where\n"
"  constructor MkEmail\n"
"  value : String\n"
"\n"
"record Password where\n"
"  constructor MkPassword\n"
"  value : String\n"
"\n"
"record User where\n"
"  constructor MkUser\n"
"  name     : String\n"
"  email    : Email\n"
"  password : Password\n"
"  albums   : List Album\n"
msgstr ""
"record Artist where\n"
"  constructor MkArtist\n"
"  name : String\n"
"\n"
"record Album where\n"
"  constructor MkAlbum\n"
"  name   : String\n"
"  artist : Artist\n"
"\n"
"record Email where\n"
"  constructor MkEmail\n"
"  value : String\n"
"\n"
"record Password where\n"
"  constructor MkPassword\n"
"  value : String\n"
"\n"
"record User where\n"
"  constructor MkUser\n"
"  name     : String\n"
"  email    : Email\n"
"  password : Password\n"
"  albums   : List Album\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:202
msgid ""
"Most of these should be self-explanatory. Note, however, that in several "
"cases (`Email`, `Artist`, `Password`) we wrap a single value in a new record "
"type. Of course, we *could* have used the unwrapped `String` type instead, "
"but we'd have ended up with many `String` fields, which can be hard to "
"disambiguate.  In order not to confuse an email string with a password "
"string, it can therefore be helpful to wrap both of them in a new record "
"type to drastically increase type safety at the cost of having to "
"reimplement some interfaces.  Utility function `on` from the *Prelude* is "
"very useful for this. Don't forget to inspect its type at the REPL, and try "
"to understand what's going on here."
msgstr ""
"これらはほぼ見ればわかります。\n"
"ただし、いくつかのレコード型（`Email`, `Artist`, `Password`）で単一の値を新し"
"いレコード型で梱包しているところに注目です。\n"
"当然、剥き出しの`String`型を代わりに使うことも*できはします*が、\n"
"そうすると最終的に`String`のフィールドが沢山あることになるため、\n"
"見分けがつきにくくなるかもしれません。\n"
"Eメールの文字列とパスワードの文字列を混同するなんてことがないように、\n"
"両方を新しいレコード型で梱包しておくと助けになります。\n"
"いくつかのインターフェースを再実装しなければいけない負担と引き換えに、型安全"
"性を劇的に高めますから。\n"
"*Prelude*由来の小間物関数`on`はこうしたとき大変役に立ちます。\n"
"型をREPLで調べて、何をするものなのか理解するのをお忘れなく。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:203
#, no-wrap
msgid ""
"Eq Artist where (==) = (==) `on` name\n"
"\n"
"Eq Email where (==) = (==) `on` value\n"
"\n"
"Eq Password where (==) = (==) `on` value\n"
"\n"
"Eq Album where (==) = (==) `on` \\a => (a.name, a.artist)\n"
msgstr ""
"Eq Artist where (==) = (==) `on` name\n"
"\n"
"Eq Email where (==) = (==) `on` value\n"
"\n"
"Eq Password where (==) = (==) `on` value\n"
"\n"
"Eq Album where (==) = (==) `on` \\a => (a.name, a.artist)\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:216
msgid ""
"In case of `Album`, we wrap the two fields of the record in a `Pair`, which "
"already comes with an implementation of `Eq`.  This allows us to again use "
"function `on`, which is very convenient."
msgstr ""
"`Album`の場合、レコードの2つのフィールドを`Pair`で梱包しています。\n"
"`Pair`には既に`Eq`の実装が付属しています。\n"
"なのでここでも関数`on`を使います。\n"
"とっても便利。"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:219
msgid ""
"Next, we have to define the data types representing server requests and "
"responses:"
msgstr "次に、サーバへの要求とサーバからの応答を表現するデータ型を定義します。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:220
#, no-wrap
msgid ""
"record Credentials where\n"
"  constructor MkCredentials\n"
"  email    : Email\n"
"  password : Password\n"
"\n"
"record Request where\n"
"  constructor MkRequest\n"
"  credentials : Credentials\n"
"  album       : Album\n"
"\n"
"data Response : Type where\n"
"  UnknownUser     : Email -> Response\n"
"  InvalidPassword : Response\n"
"  AccessDenied    : Email -> Album -> Response\n"
"  Success         : Album -> Response\n"
msgstr ""
"record Credentials where\n"
"  constructor MkCredentials\n"
"  email    : Email\n"
"  password : Password\n"
"\n"
"record Request where\n"
"  constructor MkRequest\n"
"  credentials : Credentials\n"
"  album       : Album\n"
"\n"
"data Response : Type where\n"
"  UnknownUser     : Email -> Response\n"
"  InvalidPassword : Response\n"
"  AccessDenied    : Email -> Album -> Response\n"
"  Success         : Album -> Response\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:243
msgid ""
"For server responses, we use a custom sum type encoding the possible "
"outcomes of a client request. In practice, the `Success` case would return "
"some kind of connection to start the actual album stream, but we just wrap "
"up the album we found to simulate this behavior."
msgstr ""
"サーバの応答については、自前の直和型を使って、顧客の要求に対するありうる出力"
"を符号化します。\n"
"実践の場では、`Success`のときには実際にアルバム配信を開始するための何らかの接"
"続を返すのでしょうが、\n"
"この振舞いを模擬するために、ここでは単に見付かったアルバムを梱包することにし"
"ます。"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:248
msgid ""
"We can now go ahead and simulate the handling of a request at the server. To "
"emulate our user data base, a simple list of users will do. Here's the type "
"of the function we'd like to implement:"
msgstr ""
"これで準備万端、サーバへの要求の制御を模擬できます。\n"
"利用者のデータベースを真似るには、利用者のリストがあれば事足ります。\n"
"こちらが実装したい関数の型です。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:249
#, no-wrap
msgid ""
"DB : Type\n"
"DB = List User\n"
"\n"
"handleRequest : DB -> Request -> Response\n"
msgstr ""
"DB : Type\n"
"DB = List User\n"
"\n"
"handleRequest : DB -> Request -> Response\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:265
msgid ""
"Note, how we defined a short alias for `List User` called `DB`.  This is "
"often useful to make lengthy type signatures more readable and communicate "
"the meaning of a type in the given context. However, this will *not* "
"introduce a new type, nor will it increase type safety: `DB` is *identical* "
"to `List User`, and as such, a value of type `DB` can be used wherever a "
"`List User` is expected and vice versa. In more complex programs it is "
"therefore usually preferable to define new types by wrapping values in "
"single-field records."
msgstr ""
"`DB`という名前で`List User`に短い別名を定義しましたね。\n"
"長めの型処方をより読みやすく、そこでの文脈に即した型の意味を教えてくれるもの"
"にするために、こうしておくと役に立つことがよくあります。\n"
"しかし、これはけして新しい型を導入して*いない*ので、\n"
"型安全性を増すこともありません。\n"
"`DB`と`List User`は*同一*であり、額面通りの意味で型`DB`の値は`List User`の値"
"が入るよう場所ならどこでも使えますし、逆もまた然りです。\n"
"したがって、より複雑なプログラムではたいてい単一フィールドレコードに値をくる"
"んで新しい型を定義するほうが好ましいです。"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:274
msgid ""
"The implementation will proceed as follows: It will first try and lookup a "
"`User` by is email address in the data base. If this is successful, it will "
"compare the provided password with the user's actual password. If the two "
"match, it will lookup the requested album in the user's list of albums.  If "
"all of these steps succeed, the result will be an `Album` wrapped in a "
"`Success`. If any of the steps fails, the result will describe exactly what "
"went wrong."
msgstr ""
"この関数の実装での処理は以下のように進行します。\n"
"まずEメールアドレスでデータベースから`User`を見付けだそうとします。\n"
"もしこれが成功したら、与えられたパスワードと利用者の実際のパスワードと比較し"
"ます。\n"
"もし2つが一致したら、利用者のアルバムのリストから要求されたアルバムを見付けだ"
"します。\n"
"もしこれらの過程の全てが成功したら、結果は`Success`にくるまれた`Album`になり"
"ます。\n"
"もしどれか1つでも過程が失敗したら、正確に何が起こったのかを表現する結果を返し"
"ます。"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:276
msgid "Here's a possible implementation:"
msgstr "考えられる実装はこちらです。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:277
#, no-wrap
msgid ""
"handleRequest db (MkRequest (MkCredentials email pw) album) =\n"
"  case lookupUser db of\n"
"    Just (MkUser _ _ password albums)  =>\n"
"      if password == pw then lookupAlbum albums else InvalidPassword\n"
"\n"
"    Nothing => UnknownUser email\n"
"\n"
"  where lookupUser : List User -> Maybe User\n"
"        lookupUser []        = Nothing\n"
"        lookupUser (x :: xs) =\n"
"          if x.email == email then Just x else lookupUser xs\n"
"\n"
"        lookupAlbum : List Album -> Response\n"
"        lookupAlbum []        = AccessDenied email album\n"
"        lookupAlbum (x :: xs) =\n"
"          if x == album then Success album else lookupAlbum xs\n"
msgstr ""
"handleRequest db (MkRequest (MkCredentials email pw) album) =\n"
"  case lookupUser db of\n"
"    Just (MkUser _ _ password albums)  =>\n"
"      if password == pw then lookupAlbum albums else InvalidPassword\n"
"\n"
"    Nothing => UnknownUser email\n"
"\n"
"  where lookupUser : List User -> Maybe User\n"
"        lookupUser []        = Nothing\n"
"        lookupUser (x :: xs) =\n"
"          if x.email == email then Just x else lookupUser xs\n"
"\n"
"        lookupAlbum : List Album -> Response\n"
"        lookupAlbum []        = AccessDenied email album\n"
"        lookupAlbum (x :: xs) =\n"
"          if x == album then Success album else lookupAlbum xs\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:305
msgid ""
"I'd like to point out several things in this example. First, note how we can "
"extract values from nested records in a single pattern match.  Second, we "
"defined two *local* functions in a `where` block: `lookupUser`, and "
"`lookupAlbum`. Both of these have access to all variables in the surrounding "
"scope. For instance, `lookupUser` uses the `album` variable from the pattern "
"match in the implementation's first line. Likewise, `lookupAlbum` makes use "
"of the `album` variable."
msgstr ""
"この例にあるいくつかの点について指摘したいと思います。\n"
"まず、1回のパターン照合で入れ子のレコードから値を抽出することができます。\n"
"2つ目に2つの*局所*関数を`where`ブロック内に定義しました。\n"
"`lookupUser`と`lookupAlbum`です。\n"
"両方の関数は囲まれたスコープにある全ての変数にアクセスできます。\n"
"例えば`lookupUser`は実装の最初の行にあるパターン照合から`album`変数を使いま"
"す。\n"
"同様に`lookupAlbum`も`album`変数を使用します。"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:310
msgid ""
"A `where` block introduces new local definitions, accessible only from the "
"surrounding scope and from other functions defined later in the same `where` "
"block. These need to be explicitly typed and indented by the same amount of "
"whitespace."
msgstr ""
"`where`ブロックは新しい局所定義を導入し、\n"
"`where`がある周囲のスコープと同じ`where`ブロックにある後に定義された他の関数"
"からのみ、\n"
"この定義にアクセスできます。\n"
"これらの定義は明示的に型付けされ同量の空白で字下げされていなければいけませ"
"ん。"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:318
msgid ""
"Local definitions can also be introduce *before* a function's implementation "
"by using the `let` keyword. This usage of `let` is not to be confused with "
"*let bindings* described above, which are used to bind and reuse the results "
"of intermediate computations. Below is how we could have implemented "
"`handleRequest` with local definitions introduced by the `let` keyword. "
"Again, all definitions have to be properly typed and indented:"
msgstr ""
"局所定義は`let`キーワードを用いて関数の実装の*前*で導入しても構いません。\n"
"この`let`の使用法は前述した*let束縛*と混同しないようにしてください。\n"
"let束縛は一時的な計算の結果を束縛して再利用するものでした。\n"
"以下では`handleRequest`を`let`キーワードにより導入された局所定義でどのように"
"実装できるかを示しています。\n"
"繰り返しますが、全ての定義は適切に型付けされ、字下げされている必要がありま"
"す。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:319
#, no-wrap
msgid ""
"handleRequest' : DB -> Request -> Response\n"
"handleRequest' db (MkRequest (MkCredentials email pw) album) =\n"
"  let lookupUser : List User -> Maybe User\n"
"      lookupUser []        = Nothing\n"
"      lookupUser (x :: xs) =\n"
"        if x.email == email then Just x else lookupUser xs\n"
"\n"
"      lookupAlbum : List Album -> Response\n"
"      lookupAlbum []        = AccessDenied email album\n"
"      lookupAlbum (x :: xs) =\n"
"        if x == album then Success album else lookupAlbum xs\n"
"\n"
"   in case lookupUser db of\n"
"        Just (MkUser _ _ password albums)  =>\n"
"          if password == pw then lookupAlbum albums else InvalidPassword\n"
"\n"
"        Nothing => UnknownUser email\n"
msgstr ""
"handleRequest' : DB -> Request -> Response\n"
"handleRequest' db (MkRequest (MkCredentials email pw) album) =\n"
"  let lookupUser : List User -> Maybe User\n"
"      lookupUser []        = Nothing\n"
"      lookupUser (x :: xs) =\n"
"        if x.email == email then Just x else lookupUser xs\n"
"\n"
"      lookupAlbum : List Album -> Response\n"
"      lookupAlbum []        = AccessDenied email album\n"
"      lookupAlbum (x :: xs) =\n"
"        if x == album then Success album else lookupAlbum xs\n"
"\n"
"   in case lookupUser db of\n"
"        Just (MkUser _ _ password albums)  =>\n"
"          if password == pw then lookupAlbum albums else InvalidPassword\n"
"\n"
"        Nothing => UnknownUser email\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:345
msgid ""
"The exercises in this section are supposed to increase you experience in "
"writing purely functional code. In some cases it might be useful to use "
"`let` expressions or `where` blocks, but this will not always be required."
msgstr ""
"この節の演習で純粋関数型のコードを書く経験値が上がるでしょう。\n"
"場合によっては`let`式や`where`ブロックを使うと便利かもしれませんが、\n"
"いつも必要というわけではありません。"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:350
msgid ""
"Exercise 3 is again of utmost importance. `traverseList` is a specialized "
"version of the more general `traverse`, one of the most powerful and "
"versatile functions available in the *Prelude* (check out its type!)."
msgstr ""
"演習3はまたもや最重要です。\n"
"`traverseList`はより汎用的な`traverse`の特殊版です。\n"
"`traverse`は最も強力で多芸な関数の1つで、*Prelude*にあります（型を確認しま"
"しょう！）。"

#. type: Bullet: '1. '
#: ../src/Tutorial/Functions2.md:355
msgid ""
"Module `Data.List` in *base* exports functions `find` and `elem`.  Inspect "
"their types and use these in the implementation of `handleRequest`. This "
"should allow you to completely get rid of the `where` block."
msgstr ""
"*base*のモジュール`Data.List`は関数`find`と`elemBy`を公開しています。\n"
"型を調べた上で、`handleRequest`の実装で使ってください。\n"
"これで完全に`where`ブロックを排除できます。"

#. type: Bullet: '2. '
#: ../src/Tutorial/Functions2.md:365
msgid ""
"Define an enumeration type listing the four [nucleobases](https://en."
"wikipedia.org/wiki/Nucleobase)  occurring in DNA strands. Define also a type "
"alias `DNA` for lists of nucleobases.  Declare and implement function "
"`readBase` for converting a single character (type `Char`) to a nucleobase.  "
"You can use character literals in your implementation like so: `'A'`, `'a'`. "
"Note, that this function might fail, so adjust the result type accordingly."
msgstr ""
"DND鎖に表れる4つの[核酸塩基](https://en.wikipedia.org/wiki/Nucleobase)をリス"
"トにした列挙型を定義してください。\n"
"核酸塩基のリストについて、型別称`DNA`も定義してください。\n"
"単一文字（型`Char`）を核酸塩基に変換する関数`readBase`を宣言・実装してくださ"
"い。\n"
"実装では`'A'`, `'a'`のように文字リテラルが使えます。\n"
"この関数は失敗するかもしれないので、\n"
"結果の型をそれにしたがって調整してください。"

#. type: Bullet: '3. '
#: ../src/Tutorial/Functions2.md:371
msgid ""
"Implement the following function, which tries to convert all values in a "
"list with a function, which might fail. The result should be a `Just` "
"holding the list of converted values in unmodified order, if and only if "
"every single conversion was successful."
msgstr ""
"次の関数を実装してください。\n"
"リスト中の全ての値を関数で変換しようとするものです。\n"
"ただし、関数は失敗するかもしれません。\n"
"全ての変換が成功したときに限って、\n"
"結果は同じ順序で変換後の値のリストが入った`Just`になります。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:372
#, no-wrap
msgid "   traverseList : (a -> Maybe b) -> List a -> Maybe (List b)\n"
msgstr "   traverseList : (a -> Maybe b) -> List a -> Maybe (List b)\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:378
#, no-wrap
msgid ""
"   You can verify, that the function behaves correctly with\n"
"   the following test: `traverseList Just [1,2,3] = Just [1,2,3]`.\n"
msgstr ""
"   関数が正しく振る舞うことを以下の検査で確かめられます。\n"
"   `traverseList Just [1,2,3] = Just [1,2,3]`\n"

#. type: Bullet: '4. '
#: ../src/Tutorial/Functions2.md:382
msgid ""
"Implement function `readDNA : String -> Maybe DNA` using the functions and "
"types defined in exercises 2 and 3.  You will also need function `unpack` "
"from the *Prelude*."
msgstr ""
"演習2と3で定義した関数と型を使って、関数`readDNA : String -> Maybe DNA`を実装"
"してください。\n"
"*Prelude*の関数*unpack*も要ることでしょう。"

#. type: Bullet: '5. '
#: ../src/Tutorial/Functions2.md:385
msgid ""
"Implement function `complement : DNA -> DNA` to calculate the complement of "
"a strand of DNA."
msgstr "DNA鎖の転写を計算する関数`complement : DNA -> DNA`を実装してください。"

#. type: Title ##
#: ../src/Tutorial/Functions2.md:386
#, no-wrap
msgid "The Truth about Function Arguments"
msgstr "関数引数の真実"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:390
msgid ""
"So far, when we defined a top level function, it looked something like the "
"following:"
msgstr "ここまで、最上位で定義された関数は以下のような見た目をしていました。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:391
#, no-wrap
msgid ""
"zipEitherWith : (a -> b -> c) -> Either e a -> Either e b -> Either e c\n"
"zipEitherWith f (Right va) (Right vb) = Right (f va vb)\n"
"zipEitherWith f (Left e)   _          = Left e\n"
"zipEitherWith f _          (Left e)   = Left e\n"
msgstr ""
"zipEitherWith : (a -> b -> c) -> Either e a -> Either e b -> Either e c\n"
"zipEitherWith f (Right va) (Right vb) = Right (f va vb)\n"
"zipEitherWith f (Left e)   _          = Left e\n"
"zipEitherWith f _          (Left e)   = Left e\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:401
msgid ""
"Function `zipEitherWith` is a generic higher-order function combining the "
"values stored in two `Either`s via a binary function. If either of the "
"`Either` arguments is a `Left`, the result is also a `Left`."
msgstr ""
"関数`zipEitherWith`は汎化高階関数で、2つの`Either`に保管された値を2引数関数を"
"介して結合します。\n"
"どちらかの`Either`引数が`Left`なら、結果もまた`Left`です。"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:407
msgid ""
"This is a *generic function* with *type parameters* `a`, `b`, `c`, and `e`.  "
"However, there is a more verbose type for `zipEitherWith`, which is visible "
"in the REPL when entering `:ti zipEitherWith` (the `i` here tells Idris to "
"include `implicit` arguments). You will get a type similar to this:"
msgstr ""
"これは*汎化関数*で*型変数*`a`, `b`, `c`, `e`を取ります。\n"
"しかし、もっと冗長な型が`zipEitherWith`にはあります。\n"
"この型はREPLで見ることができ、`:ti zipEitherWith`と入力すればよいです（ここで"
"`i`はIdrisが`implicit`（訳註：暗黙の）引数を含めるようにという意味です）。\n"
"こんな感じの型になります。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:408
#, no-wrap
msgid ""
"zipEitherWith' :  {0 a : Type}\n"
"               -> {0 b : Type}\n"
"               -> {0 c : Type}\n"
"               -> {0 e : Type}\n"
"               -> (a -> b -> c)\n"
"               -> Either e a\n"
"               -> Either e b\n"
"               -> Either e c\n"
msgstr ""
"zipEitherWith' :  {0 a : Type}\n"
"               -> {0 b : Type}\n"
"               -> {0 c : Type}\n"
"               -> {0 e : Type}\n"
"               -> (a -> b -> c)\n"
"               -> Either e a\n"
"               -> Either e b\n"
"               -> Either e c\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:421
msgid ""
"In order to understand what's going on here, we will have to talk about "
"named arguments, implicit arguments, and quantities."
msgstr ""
"何が起こっているのかを理解するには、\n"
"名前付き引数、暗黙引数、そして数量子についてお話しせねばなりません。"

#. type: Title ###
#: ../src/Tutorial/Functions2.md:422
#, no-wrap
msgid "Named Arguments"
msgstr "名前付き引数"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:425
msgid "In a function type, we can give each argument a name. Like so:"
msgstr ""
"関数の型ではそれぞれの引数に名前を付けられます。\n"
"こんな感じ。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:426
#, no-wrap
msgid ""
"fromMaybe : (deflt : a) -> (ma : Maybe a) -> a\n"
"fromMaybe deflt Nothing = deflt\n"
"fromMaybe _    (Just x) = x\n"
msgstr ""
"fromMaybe : (deflt : a) -> (ma : Maybe a) -> a\n"
"fromMaybe deflt Nothing = deflt\n"
"fromMaybe _    (Just x) = x\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:439
msgid ""
"Here, the first argument is given name `deflt`, the second `ma`. These names "
"can be reused in a function's implementation, as was done for `deflt`, but "
"this is not mandatory: We are free to use different names in the "
"implementation. There are several reasons, why we'd choose to name our "
"arguments: It can serve as documentation, but it also allows us to pass the "
"arguments to a function in arbitrary order when using the following syntax:"
msgstr ""
"ここで最初の引数は`deflt`と名付けられており、2つ目のほうは`ma`です。\n"
"これらの名前は関数の実装で再利用することができ、\n"
"実際に`deflt`がそうなっています。\n"
"でもこれは必須ではありません。\n"
"実装で違う名前を使うことも自由です。\n"
"なぜ引数のための名前を選ぶのかということには、いくつかの理由があります。\n"
"名前はドキュメントとして機能しますが、\n"
"加えて以下の構文を使うときは任意の順序で関数に引数を渡せます。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:440
#, no-wrap
msgid ""
"extractBool : Maybe Bool -> Bool\n"
"extractBool v = fromMaybe { ma = v, deflt = False }\n"
msgstr ""
"extractBool : Maybe Bool -> Bool\n"
"extractBool v = fromMaybe { ma = v, deflt = False }\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:446
msgid "Or even :"
msgstr "さらに言えば以下です。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:447
#, no-wrap
msgid ""
"extractBool2 : Maybe Bool -> Bool\n"
"extractBool2 = fromMaybe { deflt = False }\n"
msgstr ""
"extractBool2 : Maybe Bool -> Bool\n"
"extractBool2 = fromMaybe { deflt = False }\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:454
msgid ""
"The arguments in a record's constructor are automatically named in "
"accordance with the field names:"
msgstr ""
"レコード構築子内の引数はフィールド名にしたがって自動的に名付けられます。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:455
#, no-wrap
msgid ""
"record Dragon where\n"
"  constructor MkDragon\n"
"  name      : String\n"
"  strength  : Nat\n"
"  hitPoints : Int16\n"
"\n"
"gorgar : Dragon\n"
"gorgar = MkDragon { strength = 150, name = \"Gorgar\", hitPoints = 10000 }\n"
msgstr ""
"record Dragon where\n"
"  constructor MkDragon\n"
"  name      : String\n"
"  strength  : Nat\n"
"  hitPoints : Int16\n"
"\n"
"gorgar : Dragon\n"
"gorgar = MkDragon { strength = 150, name = \"Gorgar\", hitPoints = 10000 }\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:471
msgid ""
"For the use cases described above, named arguments are merely a convenience "
"and completely optional. However, Idris is a *dependently typed* programming "
"language: Types can be calculated from and depend on values. For instance, "
"the *result type* of a function can *depend* on the *value* of one of its "
"arguments. Here's a contrived example:"
msgstr ""
"上で述べた使用例では、名前付き引数は単に便利というだけで完全にあってもなくて"
"もよいものでした。\n"
"しかし、Idrisは*依存型*プログラミング言語です。\n"
"つまり、型は値から計算することができ、型は値に依存することができます。\n"
"たとえば、関数の*結果の型*はその引数のうちの1つの*値*に*依存*するようにできま"
"す。\n"
"以下はわざとらしい例です。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:472
#, no-wrap
msgid ""
"IntOrString : Bool -> Type\n"
"IntOrString True  = Integer\n"
"IntOrString False = String\n"
"\n"
"intOrString : (v : Bool) -> IntOrString v\n"
"intOrString False = \"I'm a String\"\n"
"intOrString True  = 1000\n"
msgstr ""
"IntOrString : Bool -> Type\n"
"IntOrString True  = Integer\n"
"IntOrString False = String\n"
"\n"
"intOrString : (v : Bool) -> IntOrString v\n"
"intOrString False = \"I'm a String\"\n"
"intOrString True  = 1000\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:489
msgid ""
"If you see such a thing for the first time, it can be hard to understand "
"what's going on here. First, function `IntOrString` computes a `Type` from a "
"`Bool` value: If the argument is `True`, it returns type `Integer`, if the "
"argument is `False` it returns `String`. We use this to calculate the return "
"type of function `intOrString` based on its boolean argument `v`: If `v` is "
"`True`, the return type is (in accordance with `IntOrString True = Integer`) "
"`Integer`, otherwise it is `String`."
msgstr ""
"初めてこれを見ると、何が起こっているのか理解しにくいことでしょう。\n"
"まず、関数`IntOrString`は`Type`を`Bool`値から算出します。\n"
"引数が`True`なら返る型は`Integer`で、引数が`False`なら`String`が返ります。\n"
"これを、真偽値引数`v`に基づいて、関数`intOrString`の返却型を計算するのに使っ"
"ています。\n"
"`v`が`True`なら返却型は`Integer`で（`IntOrString True = Integer`に従っていま"
"す）、そうでなければ`String`です。"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:493
msgid ""
"Note, how in the type signature of `intOrString`, we *must* give the "
"argument of type `Bool` a name (`v`) in order to reference it in the result "
"type `IntOrString v`."
msgstr ""
"ここで、`intOrString`の型処方では型`Bool`の引数に名前(`v`)を与える*必要*があ"
"りますね。\n"
"返却型`IntOrString v`で参照するためです。"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:500
msgid ""
"You might wonder at this moment, why this is useful and why we would ever "
"want to define a function with such a strange type. We will see lots of very "
"useful examples in due time! For now, suffice to say that in order to "
"express dependent function types, we need to name at least some of the "
"function's arguments and refer to them by name in the types of other "
"arguments."
msgstr ""
"今の時点では、どうしてこれが便利なのか、どうしてまたそんな妙な型の関数を定義"
"したくなるものか、と怪訝に思われるかもしれません。\n"
"来たるべき時に、とても有用な例を沢山見ていきましょう！\n"
"依存型の関数の型を表現するために、\n"
"少なくともいくつかの関数の引数に名前を付けたり、\n"
"他の引数の型で名付けた引数の名前を参照したりする必要があるのだ、\n"
"ということが伝われば充分です。"

#. type: Title ###
#: ../src/Tutorial/Functions2.md:501
#, no-wrap
msgid "Implicit Arguments"
msgstr "暗黙引数"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:509
msgid ""
"Implicit arguments are arguments, the values of which the compiler should "
"infer and fill in for us automatically. For instance, in the following "
"function signature, we expect the compiler to infer the value of type "
"parameter `a` automatically from the types of the other arguments (ignore "
"the 0 quantity for the moment; I'll explain it in the next subsection):"
msgstr ""
"暗黙引数とは、\n"
"コンパイラが推論して自動的に記入してくれるような値の引数を指します。\n"
"たとえば、以下の関数処方では、コンパイラが型変数`a`の値を他の引数の型から自動"
"的に推定してくれるようになっています。\n"
"（0数量子はここでは無視してください。\n"
"次の小節で説明します。）"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:510
#, no-wrap
msgid ""
"maybeToEither : {0 a : Type} -> Maybe a -> Either String a\n"
"maybeToEither Nothing  = Left \"Nope\"\n"
"maybeToEither (Just x) = Right x\n"
"\n"
"-- Please remember, that the above is\n"
"-- equivalent to the following:\n"
"maybeToEither' : Maybe a -> Either String a\n"
"maybeToEither' Nothing  = Left \"Nope\"\n"
"maybeToEither' (Just x) = Right x\n"
msgstr ""
"maybeToEither : {0 a : Type} -> Maybe a -> Either String a\n"
"maybeToEither Nothing  = Left \"Nope\"\n"
"maybeToEither (Just x) = Right x\n"
"\n"
"-- Please remember, that the above is\n"
"-- equivalent to the following:\n"
"maybeToEither' : Maybe a -> Either String a\n"
"maybeToEither' Nothing  = Left \"Nope\"\n"
"maybeToEither' (Just x) = Right x\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:527
msgid ""
"As you can see, implicit arguments are wrapped in curly braces, unlike "
"explicit named arguments, which are wrapped in parentheses.  Inferring the "
"value of an implicit argument is not always possible.  For instance, if we "
"enter the following at the REPL, Idris will fail with an error:"
msgstr ""
"見てとれるように、暗黙引数は波括弧に囲まれており、明示的な名前付き引数とは違"
"います。\n"
"名前付き引数では丸括弧に囲まれていたのでした。\n"
"暗黙引数の値を推論することはいつもできるわけではありません。\n"
"たとえば、以下をREPLに入力すると、Idrisはエラーを出して実行に失敗します。"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions2.md:528
#, no-wrap
msgid ""
"Tutorial.Functions2> show (maybeToEither Nothing)\n"
"Error: Can't find an implementation for Show (Either String ?a).\n"
msgstr ""
"Tutorial.Functions2> show (maybeToEither Nothing)\n"
"Error: Can't find an implementation for Show (Either String ?a).\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:540
msgid ""
"Idris is unable to find an implementation of `Show (Either String a)` "
"without knowing what `a` actually is.  Note the question mark in front of "
"the type parameter: `?a`.  If this happens, there are several ways to help "
"the type checker.  We could, for instance, pass a value for the implicit "
"argument explicitly. Here's the syntax to do this:"
msgstr ""
"Idrisは`a`が実際に何であるかを知らずに`Show (Either String a)`の実装を見つけ"
"ることはできません。\n"
"型変数の前の疑問符がありますね。\n"
"`?a`となっています。\n"
"こうなったら型検査器を手助けする方法がいくつかあります。\n"
"たとえば暗黙引数に値を明示的に渡すことができます。\n"
"以下がそうするための構文です。"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions2.md:541
#, no-wrap
msgid ""
"Tutorial.Functions2> show (maybeToEither {a = Int8} Nothing)\n"
"\"Left \"Nope\"\"\n"
msgstr ""
"Tutorial.Functions2> show (maybeToEither {a = Int8} Nothing)\n"
"\"Left \"Nope\"\"\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:549
msgid ""
"As you can see, we use the same syntax as shown above for explicit named "
"arguments and the two forms of argument passing can be mixed."
msgstr ""
"見てとれるように明示的な名前付き引数のところで前に見たのと同じ文法を使ってい"
"ます。\n"
"また、2種の引数の渡し方は混在させられます。"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:552
msgid ""
"We could also specify the type of the whole expression using utility "
"function `the` from the *Prelude*:"
msgstr ""
"*Prelude*由来の小間物関数`the`を使って、全体の式の型を指定することもできま"
"す。"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions2.md:553
#, no-wrap
msgid ""
"Tutorial.Functions2> show (the (Either String Int8) (maybeToEither Nothing))\n"
"\"Left \"Nope\"\"\n"
msgstr ""
"Tutorial.Functions2> show (the (Either String Int8) (maybeToEither Nothing))\n"
"\"Left \"Nope\"\"\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:559
msgid "It is instructive to have a look at the type of `the`:"
msgstr "`the`の型を見てみるとわかりやすいです。"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions2.md:560
#, no-wrap
msgid ""
"Tutorial.Functions2> :ti the\n"
"Prelude.the : (0 a : Type) -> a -> a\n"
msgstr ""
"Tutorial.Functions2> :ti the\n"
"Prelude.the : (0 a : Type) -> a -> a\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:566
msgid "Compare this with the identity function `id`:"
msgstr "小間物関数`id`と比較してみましょう。"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions2.md:567
#, no-wrap
msgid ""
"Tutorial.Functions2> :ti id\n"
"Prelude.id : {0 a : Type} -> a -> a\n"
msgstr ""
"Tutorial.Functions2> :ti id\n"
"Prelude.id : {0 a : Type} -> a -> a\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:581
msgid ""
"The only difference between the two: In case of `the`, the type parameter "
"`a` is an *explicit* argument, while in case of `id`, it is an *implicit* "
"argument. Although the two functions have almost identical types (and "
"implementations!), they serve quite different purposes: `the` is used to "
"help type inference, while `id` is used whenever we'd like to return an "
"argument without modifying it at all (which, in the presence of higher-order "
"functions, happens surprisingly often)."
msgstr ""
"唯一の2つの違いはというと、\n"
"`the`の場合型変数`a`が*明示的な*引数であるのに対し、\n"
"`id`の場合*暗黙の*引数であることです。\n"
"2つの関数はほぼ同じ型（と実装！）であるにも関わらず、\n"
"かなり異なる目的で使われます。\n"
"`the`は型推論を助けるために使われますが、\n"
"`id`は引数を全く変更することなしに返したいようなときに使います。\n"
"（`id`は高階関数があるときは驚くほどよく使います。）"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:585
msgid ""
"Both ways to improve type inference shown above are used quite often, and "
"must be understood by Idris programmers."
msgstr ""
"上で見た型推論を向上する両方の手段はかなりよく使います。\n"
"Idrisのプログラマは理解しておく必要があります。"

#. type: Title ###
#: ../src/Tutorial/Functions2.md:586
#, no-wrap
msgid "Multiplicities"
msgstr "多重度"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:593
msgid ""
"Finally, we need to talk about the zero multiplicity, which appeared in "
"several of the type signatures in this section. Idris 2, unlike its "
"predecessor Idris 1, is based on a core language called *quantitative type "
"theory* (QTT): Every variable in Idris 2 is associated with one of three "
"possible multiplicities:"
msgstr ""
"最後にゼロ多重度について話さねばなりません。\n"
"ゼロ多重度は本節の型処方でちらほら出ていました。\n"
"Idris 2は前作のIdris 1とは異なり、*数量的型理論* (quantitative type theory; "
"QTT) と呼ばれる中核言語に基づいています。\n"
"つまり、Idris 2での全ての変数には以下の3つの多重度のうち1つが関係するのです。"

#. type: Bullet: '* '
#: ../src/Tutorial/Functions2.md:598
msgid "`0`, meaning that the variable is *erased* at runtime."
msgstr "`0`、これは変数が実行時に*消去*されるという意味です。"

#. type: Bullet: '* '
#: ../src/Tutorial/Functions2.md:598
msgid "`1`, meaning that the variable is used *exactly once* at runtime."
msgstr "`1`、これは変数が実行時に*ちょうど1回だけ*使われるという意味です。"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:598
#, no-wrap
msgid ""
"* *Unrestricted* (the default), meaning that the variable is used\n"
"   an arbitrary number of times at runtime.\n"
msgstr "* *制限なし*（既定値）、これは変数が実行時に際限なく使えるという意味です。\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:604
msgid ""
"We will not talk about the most complex of the three, multiplicity `1`, "
"here.  We are, however, often interested in multiplicity `0`: A variable "
"with multiplicity `0` is only relevant at *compile time*. It will not make "
"any appearance at runtime, and the computation of such a variable will never "
"affect a program's runtime performance."
msgstr ""
"3つの中で最も複雑な多重度`1`についてはここでは触れません。\n"
"しかし、多重度`0`はよく着目されます。\n"
"多重度`0`の変数は*コンパイル時*のみに関係があります。\n"
"実行時には姿を見せず、その変数の計算はプログラムの実行時効率に何ら影響があり"
"ません。"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:609
msgid ""
"In the type signature of `maybeToEither` we see that type parameter `a` has "
"multiplicity `0`, and will therefore be erased and is only relevant at "
"compile time, while the `Maybe a` argument has *unrestricted* multiplicity."
msgstr ""
"`maybeToEither`の型処方では型変数`a`が多重度`0`を持っていましたが、\n"
"それはつまり型変数が消去されコンパイル時にのみ関係するということなのです。\n"
"一方で`Maybe a`引数は*制限なし*多重度です。"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:613
msgid ""
"It is also possible to annotate explicit arguments with multiplicities, in "
"which case the argument must again be put in parentheses. For an example, "
"look again at the type signature of `the`."
msgstr ""
"明示的に引数に多重度を註釈することもできます。\n"
"その場合ここでも引数は括弧内になくてはいけません。\n"
"例えば`the`の型処方をもう一度見てみてください。"

#. type: Title ###
#: ../src/Tutorial/Functions2.md:614
#, no-wrap
msgid "Underscores"
msgstr "下線文字"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:623
msgid ""
"It is often desirable, to only write as little code as necessary and let "
"Idris figure out the rest.  We have already learned about one such occasion: "
"Catch-all patterns.  If a variable in a pattern match is not used on the "
"right hand side, we can't just drop it, as this would make it impossible for "
"Idris, which of several arguments we were planning to drop, but we can use "
"an underscore as a placeholder instead:"
msgstr ""
"必要最小限のコードだけを書いて、残りをIdrisに調べさせたいことはよくありま"
"す。\n"
"既にそのような状況について学びました。\n"
"全部堰き止めるパターンです。\n"
"パターン照合の変数が右側で使われなければ、\n"
"単に省略するだけということはできないものの（複数の引数のうちどれを省くつもり"
"なのかをIdrisが推定できません）、\n"
"代わりに下線文字で場所取りをすることができます。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:624
#, no-wrap
msgid ""
"isRight : Either a b -> Bool\n"
"isRight (Right _) = True\n"
"isRight _         = False\n"
msgstr ""
"isRight : Either a b -> Bool\n"
"isRight (Right _) = True\n"
"isRight _         = False\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:633
msgid ""
"But when we look at the type signature of `isRight`, we will note that type "
"parameters `a` and `b` are also only used once, and are therefore of no "
"importance. Let's get rid of them:"
msgstr ""
"しかし`isRight`の型処方を見れば、型変数`a`と`b`も1度のみ使われており、\n"
"したがって特に重要ではないことに気付きます。\n"
"型変数を省きましょう。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:634
#, no-wrap
msgid ""
"isRight' : Either _ _ -> Bool\n"
"isRight' (Right _) = True\n"
"isRight' _         = False\n"
msgstr ""
"isRight' : Either _ _ -> Bool\n"
"isRight' (Right _) = True\n"
"isRight' _         = False\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:645
#, no-wrap
msgid ""
"In the detailed type signature of `zipEitherWith`, it should\n"
"be obvious for Idris that the implicit arguments are of type `Type`.\n"
"After all, all of them are later on applied to the `Either` type\n"
"constructor, which is of type `Type -> Type -> Type`. Let's get rid\n"
"of them:\n"
msgstr ""
"`zipEitherWith`の詳細な型処方では、Idrisにとって暗黙引数が型`Type`なことは明らかでしょう。\n"
"とどのつまり、全部あとで`Either`型構築子に適用されるのです。\n"
"この型構築子は型が`Type -> Type -> Type`です。\n"
"省いてみましょう。\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:646
#, no-wrap
msgid ""
"zipEitherWith'' :  {0 a : _}\n"
"                -> {0 b : _}\n"
"                -> {0 c : _}\n"
"                -> {0 e : _}\n"
"                -> (a -> b -> c)\n"
"                -> Either e a\n"
"                -> Either e b\n"
"                -> Either e c\n"
msgstr ""
"zipEitherWith'' :  {0 a : _}\n"
"                -> {0 b : _}\n"
"                -> {0 c : _}\n"
"                -> {0 e : _}\n"
"                -> (a -> b -> c)\n"
"                -> Either e a\n"
"                -> Either e b\n"
"                -> Either e c\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:658
msgid "Consider the following contrived example:"
msgstr "以下のわざとらしい例について考えましょう。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:659
#, no-wrap
msgid ""
"foo : Integer -> String\n"
"foo n = show (the (Either String Integer) (Right n))\n"
msgstr ""
"foo : Integer -> String\n"
"foo n = show (the (Either String Integer) (Right n))\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:669
msgid ""
"Since we wrap an `Integer` in a `Right`, it is obvious that the second "
"argument in `Either String Integer` is `Integer`. Only the `String` argument "
"can't be inferred by Idris. Even better, the `Either` itself is obvious! "
"Let's get rid of the unnecessary noise:"
msgstr ""
"`Integer`を`Right`の中にくるんでいるので、\n"
"`Either String Integer`の2つ目の引数が`Integer`であることは自明です。\n"
"`String`だけIdrisは推論できません。\n"
"さらにいいことに`Either`自体も明らかなのです！\n"
"不必要な雑音を消しましょう。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:670
#, no-wrap
msgid ""
"foo' : Integer -> String\n"
"foo' n = show (the (_ String _) (Right n))\n"
msgstr ""
"foo' : Integer -> String\n"
"foo' n = show (the (_ String _) (Right n))\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:680
msgid ""
"Please note, that using underscores as in `foo'` is not always desirable, as "
"it can quite drastically obfuscate the written code. Always use a syntactic "
"convenience to make code more readable, and not to show people how clever "
"you are."
msgstr ""
"注意していただきたいのは、`foo`でのように下線文字を使うことはいつも望ましいも"
"のとは限らないということです。\n"
"書かれたコードをかなり劇的に朧気なものにしてしまいかねないからです。\n"
"文法的に便利なものを使うのは常にコードを読みやすくするためにし、\n"
"人々にあなたの賢さを誇示しないようにしましょう。"

#. type: Title ##
#: ../src/Tutorial/Functions2.md:681
#, no-wrap
msgid "Programming with Holes"
msgstr "穴開きプログラミング"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:696
msgid ""
"Solved all the exercises so far? Got angry at the type checker for always "
"complaining and never being really helpful? It's time to change that. Idris "
"comes with several highly useful interactive editing features. Sometimes, "
"the compiler is able to implement complete functions for us (if the types "
"are specific enough). Even if that's not possible, there's an incredibly "
"useful and important feature, which can help us when the types are getting "
"too complicated: Holes.  Holes are variables, the names of which are "
"prefixed with a question mark.  We can use them as placeholders whenever we "
"plan to implement a piece of functionality at a later time. In addition, "
"their types and the types and quantities of all other variables in scope can "
"be inspected at the REPL (or in your editor, if you setup the necessary "
"plugin).  Let's see them holes in action."
msgstr ""
"ここまでの演習を全部解いてきましたか。\n"
"型検査器にいつも小言をくらっていて本当は役に立っていないと腹を立てているで"
"しょうか。\n"
"今それが変わります。\n"
"Idrisにはいくつかの大変役に立つ対話的な編集機能が備わっています。\n"
"（型が充分に特定のものであれば）時々コンパイラは完全な関数を実装できることが"
"あります。\n"
"それができない場合であっても、非常に有用で重要な特徴がIdrisにはあります。\n"
"型が複雑になりすぎたときに手助けしてくれるもの、それが穴開きです。\n"
"穴開きは変数で、変数名は疑問符が前に付きます。\n"
"あとで機能の一部を実装するつもりの場所であればどこにでも、穴開きを仮置場とし"
"て使えます。\n"
"加えて穴開きの型と穴開きのスコープにある他の全ての変数の型と数量子をREPLで"
"（あるいは必要なプラグインが設定できていればエディタで）調べることができま"
"す。\n"
"穴開きを実際に見てみましょう。"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:704
msgid ""
"Remember the `traverseList` example from an Exercise earlier in this "
"section? If this was your first encounter with applicative list traversals, "
"this might have been a nasty bit of work. Well, let's just make it a wee bit "
"harder still. We'd like to implement the same piece of functionality for "
"functions returning `Either e`, where `e` is a type with a `Semigroup` "
"implementation, and we'd like to accumulate the values in all `Left`s we "
"meet along the way."
msgstr ""
"本節の前のほうの演習の`traverseList`の例を覚えていますか。\n"
"初めて適用的リスト巡回に出喰わしたのだとしたら、仕組みがちょっと腑に落ちな"
"かったかもしれません。\n"
"そうですね、もう少しつぶさに見てみることにしましょう。\n"
"`Either e`を返す同じ機能の関数を実装することを考えます。\n"
"ここで`e`は`Semigroup`の実装を持つ型であり、\n"
"巡回の道中にある`Left`の全ての値を積み重ねます。"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:706
msgid "Here's the type of the function:"
msgstr "以下が関数の型です。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:707
#, no-wrap
msgid ""
"traverseEither :  Semigroup e\n"
"               => (a -> Either e b)\n"
"               -> List a\n"
"               -> Either e (List b)\n"
msgstr ""
"traverseEither :  Semigroup e\n"
"               => (a -> Either e b)\n"
"               -> List a\n"
"               -> Either e (List b)\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:718
msgid ""
"Now, in order to follow along, you might want to start your own Idris source "
"file, load it into a REPL session and adjust the code as described here. The "
"first thing we'll do, is write a skeleton implementation with a hole on the "
"right hand side:"
msgstr ""
"さて、読み進めていくにあたって、読者のみなさんは自分でIdrisのソースファイルを"
"書き始めてREPLセッションに読み込まれるとよいでしょう。\n"
"コードはこちらで記述されている内容にしたがって調整していきます。\n"
"最初にすることは右側に穴開きの実装の骨組を書くことです。"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions2.md:719
#, no-wrap
msgid "traverseEither fun as = ?impl\n"
msgstr "traverseEither fun as = ?impl\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:725
msgid ""
"When you now go to the REPL and reload the file using command `:r`, you can "
"enter `:m` to list all the *metavariables*:"
msgstr ""
"そうしたらREPLに向かい、コマンド`:r`を使ってファイルを再読み込みします。\n"
"そして`:m`とすれば全ての*メタ変数*が列挙されます。"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions2.md:726
#, no-wrap
msgid ""
"Tutorial.Functions2> :m\n"
"1 hole:\n"
"  Tutorial.Functions2.impl : Either e (List b)\n"
msgstr ""
"Tutorial.Functions2> :m\n"
"1 hole:\n"
"  Tutorial.Functions2.impl : Either e (List b)\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:734
msgid ""
"Next, we'd like to display the hole's type (including all variables in the "
"surrounding context plus their types):"
msgstr ""
"次は穴の型を表示したいところです。\n"
"（加えて周囲の文脈にある全ての変数とその型も。）"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions2.md:735
#, no-wrap
msgid ""
"Tutorial.Functions2> :t impl\n"
" 0 b : Type\n"
" 0 a : Type\n"
" 0 e : Type\n"
"   as : List a\n"
"   fun : a -> Either e b\n"
"------------------------------\n"
"impl : Either e (List b)\n"
msgstr ""
"Tutorial.Functions2> :t impl\n"
" 0 b : Type\n"
" 0 a : Type\n"
" 0 e : Type\n"
"   as : List a\n"
"   fun : a -> Either e b\n"
"------------------------------\n"
"impl : Either e (List b)\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:750
msgid ""
"So, we have some erased type parameters (`a`, `b`, and `e`), a value of type "
"`List a` called `as`, and a function from `a` to `Either e b` called `fun`. "
"Our goal is to come up with a value of type `Either a (List b)`."
msgstr ""
"というわけで、消去された型変数 (`a`, `b`, `e`)、\n"
"型`List a`の`as`という名前の値、\n"
"そして`a`から`Either e b`への関数で名前が`fun`のものがあります。\n"
"目標は型`Either a (List b)`の値を思い付くことです。"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:754
msgid ""
"We *could* just return a `Right []`, but that only make sense if our input "
"list is indeed the empty list. We therefore should start with a pattern "
"match on the list:"
msgstr ""
"単に`Right []`を返すことも*できなくはない*のですが、\n"
"それは入力のリストがまさしく空リストのときのみ当てはまります。\n"
"したがってリストに関してパターン照合するところから始めるとよいでしょう。"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions2.md:755
#, no-wrap
msgid ""
"traverseEither fun []        = ?impl_0\n"
"traverseEither fun (x :: xs) = ?impl_1\n"
msgstr ""
"traverseEither fun []        = ?impl_0\n"
"traverseEither fun (x :: xs) = ?impl_1\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:762
msgid ""
"The result is two holes, which must be given distinct names. When inspecting "
"`impl_0`, we get the following result:"
msgstr ""
"結果は2つの穴で、\n"
"それぞれ別の名前でなくてはいけません。\n"
"`impl_0`を調べると以下の結果になります。"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions2.md:763
#, no-wrap
msgid ""
"Tutorial.Functions2> :t impl_0\n"
" 0 b : Type\n"
" 0 a : Type\n"
" 0 e : Type\n"
"   fun : a -> Either e b\n"
"------------------------------\n"
"impl_0 : Either e (List b)\n"
msgstr ""
"Tutorial.Functions2> :t impl_0\n"
" 0 b : Type\n"
" 0 a : Type\n"
" 0 e : Type\n"
"   fun : a -> Either e b\n"
"------------------------------\n"
"impl_0 : Either e (List b)\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:779
msgid ""
"Now, this is an interesting situation. We are supposed to come up with a "
"value of type `Either e (List b)` with nothing to work with. We know nothing "
"about `a`, so we can't provide an argument with which to invoke `fun`.  "
"Likewise, we know nothing about `e` or `b` either, so we can't produce any "
"values of these either. The *only* option we have is to replace `impl_0` "
"with an empty list wrapped in a `Right`:"
msgstr ""
"さあ、ここが面白いところです。\n"
"何にも手を付けることなく型`Either e (List b)`の値を思い付かなければいけませ"
"ん。\n"
"`a`については何も知らないので、その値を`fun`を呼び出すための引数に渡せないの"
"です。\n"
"同様に`e`や`b`についても全然わからないため、\n"
"これらの値はいずれも生み出すことができません。\n"
"取るべき*唯一の*選択肢は`impl_0`を`Right`でくるまれた空リストで置き換えること"
"です。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:780
#, no-wrap
msgid "traverseEither fun []        = Right []\n"
msgstr "traverseEither fun []        = Right []\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:786
msgid ""
"The non-empty case is of course slightly more involved. Here's the context "
"of `?impl_1`:"
msgstr ""
"非空の場合はもちろんこれより少しだけ込み入っています。\n"
"以下が`?impl_1`の文脈です。"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions2.md:787
#, no-wrap
msgid ""
"Tutorial.Functions2> :t impl_1\n"
" 0 b : Type\n"
" 0 a : Type\n"
" 0 e : Type\n"
"   x : a\n"
"   xs : List a\n"
"   fun : a -> Either e b\n"
"------------------------------\n"
"impl_1 : Either e (List b)\n"
msgstr ""
"Tutorial.Functions2> :t impl_1\n"
" 0 b : Type\n"
" 0 a : Type\n"
" 0 e : Type\n"
"   x : a\n"
"   xs : List a\n"
"   fun : a -> Either e b\n"
"------------------------------\n"
"impl_1 : Either e (List b)\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:810
msgid ""
"Since `x` is of type `a`, we can either use it as an argument to `fun` or "
"drop and ignore it. `xs`, on the other hand, is the remainder of the list of "
"type `List a`. We could again drop it or process it further by invoking "
"`traverseEither` recursively. Since the goal is to try and convert *all* "
"values, we should drop neither. Since in case of two `Left`s we are supposed "
"to accumulate the values, we eventually need to run both computations anyway "
"(invoking `fun`, and recursively calling `traverseEither`). We therefore can "
"do both at the same time and analyze the results in a single pattern match "
"by wrapping both in a `Pair`:"
msgstr ""
"`x`は型が`a`であるため、\n"
"`fun`の引数に使ったり、\n"
"無視してしまったりできます。\n"
"他方で`xs`はリストの残り部分で型が`List a`です。\n"
"これも使わずにおいたり`traverseEither`をさらに再帰的に呼び出したりできま"
"す。\n"
"目標は*全ての*値を変換しようとすることですから、いずれも欠かせないことになり"
"ます。\n"
"2つが`Left`な場合は値を積み重ねなければいけないため、\n"
"何にせよ結局は両方の計算をする必要があります。\n"
"（`fun`を実行し、そして再帰的に`traverseEither`を呼び出します。）\n"
"したがって両方を同時に行い、\n"
"`Pair`に両方をくるむことで1つのパターン照合により結果を分析できます。"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions2.md:811
#, no-wrap
msgid ""
"traverseEither fun (x :: xs) =\n"
"  case (fun x, traverseEither fun xs) of\n"
"   p => ?impl_2\n"
msgstr ""
"traverseEither fun (x :: xs) =\n"
"  case (fun x, traverseEither fun xs) of\n"
"   p => ?impl_2\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:818
msgid "Once again, we inspect the context:"
msgstr "もう一度文脈を調べます。"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions2.md:819
#, no-wrap
msgid ""
"Tutorial.Functions2> :t impl_2\n"
" 0 b : Type\n"
" 0 a : Type\n"
" 0 e : Type\n"
"   xs : List a\n"
"   fun : a -> Either e b\n"
"   x : a\n"
"   p : (Either e b, Either e (List b))\n"
"------------------------------\n"
"impl_2 : Either e (List b)\n"
msgstr ""
"Tutorial.Functions2> :t impl_2\n"
" 0 b : Type\n"
" 0 a : Type\n"
" 0 e : Type\n"
"   xs : List a\n"
"   fun : a -> Either e b\n"
"   x : a\n"
"   p : (Either e b, Either e (List b))\n"
"------------------------------\n"
"impl_2 : Either e (List b)\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:834
msgid ""
"We'll definitely need to pattern match on pair `p` next to figure out, which "
"of the two computations succeeded:"
msgstr ""
"間違いなく実装の解明には対`p`をパターン照合する必要があります。\n"
"この対は2つの計算が成功したかを表します。"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions2.md:835
#, no-wrap
msgid ""
"traverseEither fun (x :: xs) =\n"
"  case (fun x, traverseEither fun xs) of\n"
"    (Left y, Left z)   => ?impl_6\n"
"    (Left y, Right _)  => ?impl_7\n"
"    (Right _, Left z)  => ?impl_8\n"
"    (Right y, Right z) => ?impl_9\n"
msgstr ""
"traverseEither fun (x :: xs) =\n"
"  case (fun x, traverseEither fun xs) of\n"
"    (Left y, Left z)   => ?impl_6\n"
"    (Left y, Right _)  => ?impl_7\n"
"    (Right _, Left z)  => ?impl_8\n"
"    (Right y, Right z) => ?impl_9\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:847
msgid ""
"At this point we might have forgotten what we actually wanted to do (at "
"least to me, this happens annoyingly often), so we'll just quickly check "
"what our goal is:"
msgstr ""
"この時点で実際何をしたかったのかお忘れかもしれません。\n"
"（少なくとも私は、厄介なことにこうしたことがよくあります。）\n"
"なので目標をさくっと確認しましょう。"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions2.md:848
#, no-wrap
msgid ""
"Tutorial.Functions2> :t impl_6\n"
" 0 b : Type\n"
" 0 a : Type\n"
" 0 e : Type\n"
"   xs : List a\n"
"   fun : a -> Either e b\n"
"   x : a\n"
"   y : e\n"
"   z : e\n"
"------------------------------\n"
"impl_6 : Either e (List b)\n"
msgstr ""
"Tutorial.Functions2> :t impl_6\n"
" 0 b : Type\n"
" 0 a : Type\n"
" 0 e : Type\n"
"   xs : List a\n"
"   fun : a -> Either e b\n"
"   x : a\n"
"   y : e\n"
"   z : e\n"
"------------------------------\n"
"impl_6 : Either e (List b)\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:868
msgid ""
"So, we are still looking for a value of type `Either e (List b)`, and we "
"have two values of type `e` in scope. According to the spec we want to "
"accumulate these using `e`s `Semigroup` implementation.  We can proceed for "
"the other cases in a similar manner, remembering that we should return a "
"`Right`, if and only if all conversions where successful:"
msgstr ""
"つまり、ここでも型`Either e (List b)`の値を追い求めており、\n"
"範疇には型`e`の2つの値があります。\n"
"仕様にしたがうと`e`の`Semigroup`実装を使って積み重ねたいところです。\n"
"他の場合も同様のやり方で進めることができます。\n"
"全ての変換が成功したときに限って`Right`を返す、ということを記憶に留めつつ。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:869
#, no-wrap
msgid ""
"traverseEither fun (x :: xs) =\n"
"  case (fun x, traverseEither fun xs) of\n"
"    (Left y, Left z)   => Left (y <+> z)\n"
"    (Left y, Right _)  => Left y\n"
"    (Right _, Left z)  => Left z\n"
"    (Right y, Right z) => Right (y :: z)\n"
msgstr ""
"traverseEither fun (x :: xs) =\n"
"  case (fun x, traverseEither fun xs) of\n"
"    (Left y, Left z)   => Left (y <+> z)\n"
"    (Left y, Right _)  => Left y\n"
"    (Right _, Left z)  => Left z\n"
"    (Right y, Right z) => Right (y :: z)\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:879
msgid "To reap the fruits of our labour, let's show off with a small example:"
msgstr "これまでの労働の成果をものにするために、小さな例をお見せします。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:880
#, no-wrap
msgid ""
"data Nucleobase = Adenine | Cytosine | Guanine | Thymine\n"
"\n"
"readNucleobase : Char -> Either (List String) Nucleobase\n"
"readNucleobase 'A' = Right Adenine\n"
"readNucleobase 'C' = Right Cytosine\n"
"readNucleobase 'G' = Right Guanine\n"
"readNucleobase 'T' = Right Thymine\n"
"readNucleobase c   = Left [\"Unknown nucleobase: \" ++ show c]\n"
"\n"
"DNA : Type\n"
"DNA = List Nucleobase\n"
"\n"
"readDNA : String -> Either (List String) DNA\n"
"readDNA = traverseEither readNucleobase . unpack\n"
msgstr ""
"data Nucleobase = Adenine | Cytosine | Guanine | Thymine\n"
"\n"
"readNucleobase : Char -> Either (List String) Nucleobase\n"
"readNucleobase 'A' = Right Adenine\n"
"readNucleobase 'C' = Right Cytosine\n"
"readNucleobase 'G' = Right Guanine\n"
"readNucleobase 'T' = Right Thymine\n"
"readNucleobase c   = Left [\"Unknown nucleobase: \" ++ show c]\n"
"\n"
"DNA : Type\n"
"DNA = List Nucleobase\n"
"\n"
"readDNA : String -> Either (List String) DNA\n"
"readDNA = traverseEither readNucleobase . unpack\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:898
msgid "Let's try this at the REPL:"
msgstr "REPLで試してみましょう。"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions2.md:899
#, no-wrap
msgid ""
"Tutorial.Functions2> readDNA \"CGTTA\"\n"
"Right [Cytosine, Guanine, Thymine, Thymine, Adenine]\n"
"Tutorial.Functions2> readDNA \"CGFTAQ\"\n"
"Left [\"Unknown nucleobase: 'F'\", \"Unknown nucleobase: 'Q'\"]\n"
msgstr ""
"Tutorial.Functions2> readDNA \"CGTTA\"\n"
"Right [Cytosine, Guanine, Thymine, Thymine, Adenine]\n"
"Tutorial.Functions2> readDNA \"CGFTAQ\"\n"
"Left [\"Unknown nucleobase: 'F'\", \"Unknown nucleobase: 'Q'\"]\n"

#. type: Title ###
#: ../src/Tutorial/Functions2.md:906
#, no-wrap
msgid "Interactive Editing"
msgstr "対話的編集"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:916
msgid ""
"There are plugins available for several editors and programming "
"environments, which facilitate interacting with the Idris compiler when "
"implementing your functions.  One editor, which is well supported in the "
"Idris community, is Neovim. Since I am a Neovim user myself, I added some "
"examples of what's possible to the [appendix](../Appendices/Neovim.md). Now "
"would be a good time to start using the utilities discussed there."
msgstr ""
"いくつかのエディタやプログラミング環境ではプラグインが入手でき、\n"
"関数を実装するときにIdrisコンパイラとのやり取りを手助けしてくれます。\n"
"Idrisコミュニティでよく保証されているエディタの1つはNeovimです。\n"
"私自身Neovim利用者なので、\n"
"[補遺](../Appendices/Neovim.md)にどんなことができるのかについて幾つかの例を加"
"えました。\n"
"そろそろそちらで記載した実用品を使い始めていい頃合いです。"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:923
msgid ""
"If you use a different editor, probably with less support for the Idris "
"programming language, you should at the very least have a REPL session open "
"all the time, where the source file you are currently working on is loaded. "
"This allows you to introduce new metavariables and inspect their types and "
"context as you develop your code."
msgstr ""
"他のエディタを使っているなら、\n"
"Idrisプログラミング言語をするにはやや保証が薄いかもしれませんが、\n"
"少なくとも常時REPLセッションを開いておくべきです。\n"
"このセッションでは現在取り組んでいるソースファイルを読み込んでおきます。\n"
"こうすればコードを開発しつつ新しいメタ変数を導入しその方と文脈を調べられま"
"す。"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:929
msgid ""
"We again covered a lot of ground in this section. I can't stress enough that "
"you should get yourselves accustomed to programming with holes and let the "
"type checker help you figure out what to do next."
msgstr ""
"繰り返しになりますが本節では様々な領域の話題を述べました。\n"
"どんなに強調しても足りませんが、ぜひ穴開きのあるプログラミングに体を慣らし"
"て、型検査器に次何をすればよいのかを教えてもらうようにしましょう。"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:932
#, no-wrap
msgid ""
"* When in need of local utility functions, consider defining them\n"
"as local definitions in a *where block*.\n"
msgstr ""
"* 局所小間物関数が必要なときは、\n"
"  *whereブロック*中の局所定義に書くことを検討してください。\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Functions2.md:934
msgid "Use *let expressions* to define and reuse local variables."
msgstr "*let式*を使って局所変数を定義・再利用してください。"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:938
#, no-wrap
msgid ""
"* Function arguments can be given a name, which can serve as documentation,\n"
"can be used to pass arguments in any order, and is used to refer to\n"
"them in dependent types.\n"
msgstr ""
"* 関数の引数には名前を付けられます。\n"
"  こうすればドキュメントとして残すことができ、\n"
"  好きな順序で引数を渡すのに使え、\n"
"  そして依存型で参照するのに使えます。\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:942
#, no-wrap
msgid ""
"* Implicit arguments are wrapped in curly braces. The compiler is\n"
"supposed to infer them from the context. If that's not possible,\n"
"they can be passed explicitly as other named arguments.\n"
msgstr ""
"* 暗黙引数は波括弧にくるまれます。\n"
"  コンパイラは文脈から型推論できなくてはいけません。\n"
"  それができないときは、明示的に他の名前付き引数として渡すことができます。\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:945
#, no-wrap
msgid ""
"* Whenever possible, Idris adds implicit erased arguments for all\n"
"type parameters automatically.\n"
msgstr "* 可能なときはできるだけIdrisは自動的に全ての型変数について暗黙の消去済み引数を加えようとします。\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:948
#, no-wrap
msgid ""
"* Quantities allow us to track how often a function argument is\n"
"used. Quantity 0 means, the argument is erased at runtime.\n"
msgstr ""
"* 数量子はどのくらいの頻度で関数の引数が使われるのかを追跡することができます。\n"
"  数量子0は引数が実行時に消去されることを意味します。\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:953
#, no-wrap
msgid ""
"* Use *holes* as placeholders for pieces of code you plan to fill\n"
"in at a later time. Use the REPL (or your editor) to inspect\n"
"the types of holes together with the names, types, and quantities of all\n"
"variables in their context.\n"
msgstr ""
"* *穴*をあとで埋める予定のコード片の場所取りに使ってください。\n"
"  REPL（もしくはエディタ）を使って、穴の型とその文脈にある全ての変数の名前、型、数量子を調べてください。\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:962
msgid ""
"In the [next chapter](Dependent.md)  we'll start using dependent types to "
"help us write provably correct code.  Having a good understanding of how to "
"read Idris' type signatures will be of paramount importance there. Whenever "
"you feel lost, add one or more holes and inspect their context to decide "
"what to do next."
msgstr ""
"[次節](Dependent.md)では依存型を使い始め、証明的に正しいコードを書くのに使い"
"ます。\n"
"Idrisの型処方の読み方をよく理解しておくことは、そこでは最重要となります。\n"
"道を見失ったように感じたら、いくつか穴を加えてみてその文脈を調べ、次何をすべ"
"きかを決めましょう。"
