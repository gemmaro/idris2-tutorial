# Japanese translations for Functional Programming in Idris 2
# Copyright (c) 2021-2023, Stefan Höck.
# COpyright (C) 2023 gemmaro <gemmaro.dev@gmail.com>
# This file is distributed under the same license as the Functional Programming in Idris 2.
#
msgid ""
msgstr ""
"Project-Id-Version: Functional Programming in Idris 2\n"
"POT-Creation-Date: 2023-03-21 09:33+0900\n"
"PO-Revision-Date: 2023-04-09 23:15+0900\n"
"Last-Translator: gemmaro <gemmaro.dev@gmail.com>\n"
"Language-Team: none\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#. type: Title ##
#: ../src/Appendices/Neovim.md:364 ../src/Appendices/Install.md:102
#: ../src/Appendices/Projects.md:878 ../src/Tutorial/DPair.md:1191
#: ../src/Tutorial/DataTypes.md:1319 ../src/Tutorial/Dependent.md:872
#: ../src/Tutorial/Eq.md:1085 ../src/Tutorial/Folds.md:1051
#: ../src/Tutorial/Functions1.md:524 ../src/Tutorial/Functions2.md:924
#: ../src/Tutorial/Functor.md:1395 ../src/Tutorial/IO.md:1095
#: ../src/Tutorial/Interfaces.md:792 ../src/Tutorial/Predicates.md:1358
#: ../src/Tutorial/Traverse.md:1109
#, no-wrap
msgid "Conclusion"
msgstr "まとめ"

#. type: Plain text
#: ../src/Appendices/Neovim.md:374 ../src/Appendices/Projects.md:890
#: ../src/Tutorial/DPair.md:1206 ../src/Tutorial/DataTypes.md:1368
#: ../src/Tutorial/Dependent.md:910 ../src/Tutorial/Eq.md:1100
#: ../src/Tutorial/Folds.md:1064 ../src/Tutorial/Functions1.md:583
#: ../src/Tutorial/Functions2.md:964 ../src/Tutorial/Functor.md:1427
#: ../src/Tutorial/IO.md:1125 ../src/Tutorial/Interfaces.md:821
#: ../src/Tutorial/Intro.md:453 ../src/Tutorial/Predicates.md:1371
#: ../src/Tutorial/Prim.md:1411 ../src/Tutorial/Traverse.md:1148
#, no-wrap
msgid ""
"<!-- vi: filetype=idris2:syntax=markdown\n"
"-->\n"
msgstr ""
"<!-- vi: filetype=idris2:syntax=markdown\n"
"-->\n"

#. type: Title #
#: ../src/Appendices/Projects.md:1
#, no-wrap
msgid "Structuring Idris Projects"
msgstr "Idrisのプロジェクトを構築する"

#. type: Plain text
#: ../src/Appendices/Projects.md:7
msgid ""
"In this section I'm going to show how to organize, install, and depend on "
"larger Idris projects. We will have a look at Idris packages, the module "
"system, visibility of types and functions, writing comments and doc strings, "
"and using pack for managing our libraries."
msgstr ""
"この節ではより大きなIdrisのプロジェクトを、組織立て、インストールし、依存先に"
"する方法をお見せしていきます。Idrisのパッケージ、モジュールシステム、型と関数"
"の可視性、コメントとドキュメント文字列を書くこと、ライブラリの管理にpackを使"
"うことについて一望します。"

#. type: Plain text
#: ../src/Appendices/Projects.md:15
msgid ""
"This section should be useful for all readers who have already written a bit "
"of Idris code. We will not do any fancy type level wizardry in here, but "
"I'll demonstrate several concepts using `failing` code blocks, which you "
"might not have seen before.  This rather new addition to the language allows "
"us to write code that is expected to fail during elaboration (type "
"checking). For instance:"
msgstr ""
"この節は既に少しでもIdrisのコードを書いたことがある全読者にとって役に立つこと"
"でしょう。ここではあまり型水準の魔法を扱いませんが、`failing`コードブロックを"
"使っていくつかの概念を実演します。このブロックはこれまでに見たことがないかも"
"しれません。この比較的新しい言語への追加要素は推敲（型検査）の最中に失敗する"
"ことが期待されるものです。例えば次の通りです。"

#. type: Fenced code block (repl)
#: ../src/Appendices/Projects.md:16
#, no-wrap
msgid ""
"failing \"Can't find an implementation for FromString Bits8.\"\n"
"  ohno : Bits8\n"
"  ohno = \"Oh no!\"\n"
msgstr ""
"failing \"Can't find an implementation for FromString Bits8.\"\n"
"  ohno : Bits8\n"
"  ohno = \"Oh no!\"\n"

#. type: Plain text
#: ../src/Appendices/Projects.md:25
msgid ""
"As part of a failing block, we can give a substring of the compiler's error "
"message for documentation purposes and to make sure the block fails with the "
"expected error."
msgstr ""
"ドキュメンテーションの目的で失敗ブロックの一部としてコンパイラのエラー文言の"
"部分文字列を与えることができ、ブロックが期待されたエラーで失敗することを確か"
"められます。"

#. type: Title ##
#: ../src/Appendices/Projects.md:26
#, no-wrap
msgid "Modules"
msgstr "モジュール"

#. type: Plain text
#: ../src/Appendices/Projects.md:30
msgid ""
"Every Idris source file defines a *module*, typically starting with a module "
"header like the one below:"
msgstr ""
"全てのIdrisのソースファイルには*module*が定義されています。ファイルは大抵、以"
"下のようなモジュールヘッダから始まります。"

#. type: Fenced code block (idris)
#: ../src/Appendices/Projects.md:31
#, no-wrap
msgid "module Appendices.Projects\n"
msgstr "module Appendices.Projects\n"

#. type: Plain text
#: ../src/Appendices/Projects.md:39
msgid ""
"A module's name consists of several upper case identifiers separated by "
"dots, which must reflect the path of the `.idr` file where the module is "
"stored. For instance, this module is stored in file `Appendices/Projects."
"md`, so the module's name is `Appendices.Projects`."
msgstr ""
"モジュール名はドットで区切られたいくつかの大文字始まりの識別子からなります。"
"この識別子の並びはモジュールが保管されている`.idr`ファイルのパスを反映したも"
"のでなければなりません。例えばこのモジュールは`Appendices.Projects.md`に保管"
"されているので、モジュール名は`Appendices.Projects`です。"

#. type: Plain text
#: ../src/Appendices/Projects.md:46
msgid ""
"\"But wait!\", I hear you say, \"What about the parent folder(s) of "
"`Appendices`? Why aren't those part of the module's name?\" In order to "
"understand this, we must talk about the concept of the *source directory*. "
"The source directory is where Idris is looking for source files. It defaults "
"to the directory, from which the Idris executable is run. For instance, when "
"in folder `src` of this project, you can open this source file like so:"
msgstr ""
"「でもちょっと待ってください」と言う声が聞こえます。「`Appendices`の親フォル"
"ダについてはどうなんですか。どうして親フォルダはモジュール名の一部にならない"
"のでしょう。」これを理解するには*ソースディレクトリ*の概念についてお話ししな"
"ければなりません。ソースディレクトリはIdrisがソースファイルを探す場所のことで"
"す。既定ではIdrisの実行ファイルが走っているところのディレクトリです。例えばこ"
"のプロジェクトの`src`フォルダにいるとき、このソースファイルを次のように開くこ"
"とができます。"

#. type: Fenced code block (sh)
#: ../src/Appendices/Projects.md:47
#, no-wrap
msgid "idris2 Appendices/Projects.md\n"
msgstr "idris2 Appendices/Projects.md\n"

#. type: Plain text
#: ../src/Appendices/Projects.md:53
msgid ""
"This will not work, however, if you try the same thing from this project's "
"root folder:"
msgstr ""
"しかし同じことをプロジェクトのルートフォルダからしようとすると動きません。"

#. type: Fenced code block (sh)
#: ../src/Appendices/Projects.md:54
#, no-wrap
msgid ""
"$ idris2 src/Appendices/Projects.md\n"
"...\n"
"Error: Module name Appendices.Projects does not match file name \"src/Appendices/Projects.md\"\n"
"...\n"
msgstr ""
"$ idris2 src/Appendices/Projects.md\n"
"...\n"
"Error: Module name Appendices.Projects does not match file name \"src/Appendices/Projects.md\"\n"
"...\n"

#. type: Plain text
#: ../src/Appendices/Projects.md:68
msgid ""
"So, which folder names to include in a module name depends on the parent "
"folder we consider to be our source directory. It is common practice to name "
"the source directory `src`, although this is not mandatory (as I said above, "
"the default is actually the directory, from which we run Idris). It is "
"possible to change the source directory with the `--source-dir` command-line "
"option. The following works from within this project's root directory:"
msgstr ""
"ですから、モジュール名にどのフォルダ名が含まれるのかは、ソースディレクトリと"
"見做す親ディレクトリに依るのです。慣習としてはソースディレクトリを`src`と名付"
"けますが、これは必須ではありません（上で述べたように既定では実際はIdrisを走ら"
"せるディレクトリになります）。`--source-dir`コマンドラインオプションを使って"
"ソースディレクトリを変えることができます。以下はこのプロジェクトのルートディ"
"レクトリ中で動きます。"

#. type: Fenced code block (sh)
#: ../src/Appendices/Projects.md:69
#, no-wrap
msgid "idris2 --source-dir src src/Appendices/Projects.md\n"
msgstr "idris2 --source-dir src src/Appendices/Projects.md\n"

#. type: Plain text
#: ../src/Appendices/Projects.md:75
msgid ""
"And the following would work from a parent directory (assuming this tutorial "
"is stored in folder `tutorial`):"
msgstr ""
"そして以下は親ディレクトリから動きます（この入門書が`tutorial`フォルダに保管"
"されていることを前提としています）。"

#. type: Fenced code block (sh)
#: ../src/Appendices/Projects.md:76
#, no-wrap
msgid "idris2 --source-dir tutorial/src tutorial/src/Appendices/Projects.md\n"
msgstr "idris2 --source-dir tutorial/src tutorial/src/Appendices/Projects.md\n"

#. type: Plain text
#: ../src/Appendices/Projects.md:84
msgid ""
"Most of the time, however, you will specify an `.ipkg` file for your project "
"(see later in this section) and define the source directory there. "
"Afterwards, you can use pack (instead of the `idris2` executable) to start "
"REPL sessions and load your source files."
msgstr ""
"しかしほとんどの場合、プロジェクトに`.ipkg`ファイルを指定し（この節の後のほう"
"を参照）そのファイルでソースディレクトリを定義することでしょう。その後で"
"（`idris2`実行ファイルの代わりに）packを使ってREPLセッションを開始しソース"
"ファイルを読み込むことができます。"

#. type: Title ###
#: ../src/Appendices/Projects.md:85
#, no-wrap
msgid "Module Imports"
msgstr "モジュールのインポート"

#. type: Plain text
#: ../src/Appendices/Projects.md:91
msgid ""
"You often need to import functions and data types from other modules when "
"writing Idris code. This can be done with an `import` statement. Here are "
"several examples showing how these might look like:"
msgstr ""
"Idrisのコードを書く際は、関数とデータ型をインポートする必要が出てくることがよ"
"くあります。これは`import`文でできます。以下の数例でどんな見た目をしているの"
"かお見せします。"

#. type: Fenced code block (idris)
#: ../src/Appendices/Projects.md:92
#, no-wrap
msgid ""
"import Data.String\n"
"import Data.List\n"
"import Text.CSV\n"
"import public Appendices.Neovim\n"
"import Data.Vect as V\n"
"import public Data.List1 as L\n"
msgstr ""
"import Data.String\n"
"import Data.List\n"
"import Text.CSV\n"
"import public Appendices.Neovim\n"
"import Data.Vect as V\n"
"import public Data.List1 as L\n"

#. type: Plain text
#: ../src/Appendices/Projects.md:104
msgid ""
"The first two lines import modules from another *package* (we will learn "
"about packages below): `Data.List` from the *base* package, which will be "
"installed as part of your Idris installation."
msgstr ""
"最初の2行は別の*パッケージ*（パッケージについては後で学びます）からモジュール"
"をインポートしています。`Data.List`は*base*パッケージ由来で、このパッケージは"
"Idrisのインストール時にその一部としてインストールされたものです。"

#. type: Plain text
#: ../src/Appendices/Projects.md:108
msgid ""
"The second line imports module `Text.CSV` from within our own source "
"directory `src`. It is always possible to import modules that are part of "
"the same source directory as the file we are working on."
msgstr ""
"2行目は自分のソースディレクトリ`src`中からモジュール`Text.CSV`をインポートし"
"ています。作業しているファイルと同じソースディレクトリの一部にあるモジュール"
"をインポートするのはいつでもできます。"

# TODO: the lot via a single catch-all module で最後のピリオドが抜けているようです。
#. type: Plain text
#: ../src/Appendices/Projects.md:122
msgid ""
"The third line imports module `Appendices.Neovim`, again from our own source "
"directory. Note, however, that this `import` statement comes with an "
"additional `public` keyword. This allows us to *re-export* a module, so that "
"it is available from within other modules in addition to the current module: "
"If another module imports `Appendices.Projects`, module `Appendices.Neovim` "
"will be imported as well without the need of an additional `import` "
"statement. This is useful when we split some complex functionality across "
"different modules and want to import the lot via a single catch-all module "
"See module `Control.Monad.State` in *base* for an example. You can look at "
"the Idris sources on GitHub or locally after cloning the [Idris2 project]"
"(https://github.com/idris-lang/Idris2).  The base library can be found in "
"the `libs/base` subfolder."
msgstr ""
"3行目ではモジュール`Appendices.Neovim`をインポートしています。これも自分の"
"ソースディレクトリからです。ただしこの`import`文は`public`キーワードが追加さ"
"れていますね。こうするとモジュールを*再輸出*することができ、現在のモジュール"
"に加えて他のモジュールの中でも使えるようになります。別のモジュールが"
"`Appendices.Projects`をインポートした場合、これ以上`import`文を書かなくてもモ"
"ジュール`Appendices.Neovim`がインポートされるのです。この機能は複雑な機能を違"
"うモジュールに分割しておいて、1つに全部まとめるモジュールにインポートするとき"
"に便利です。例として*base*の`Control.Monad.State`を参照してください。Idrisの"
"ソースは[Idris2プロジェクト](https://github.com/idris-lang/Idris2)をGitHub上"
"かクローンしてきてから見ることができます。baseライブラリは`libs/base`サブフォ"
"ルダにあります。"

#. type: Plain text
#: ../src/Appendices/Projects.md:127
msgid ""
"It often happens that in order to make use of functions from some module `A` "
"we also require utilities from another module `B`, so `A` should re-export "
"`B`. For instance, `Data.Vect` in *base* re-exports `Data.Fin`, because the "
"latter is often required when working with vectors."
msgstr ""
"モジュール`A`の関数を使うために別のモジュール`B`のユーティリティが必要なこと"
"はよく起こるので、そうした場合は`A`は`B`を再輸出すべきです。例えば*base*の"
"`Data.Vect`は`Data.Fin`を再輸出しますが、これは`Data.Fin`がベクタを扱うときに"
"よく必要になるからです。"

#. type: Plain text
#: ../src/Appendices/Projects.md:132
msgid ""
"The fourth line imports module `Data.Vect`, giving it a new name `V`, to be "
"used as a shorter prefix. If you often need to disambiguate identifiers by "
"prefixing them with a module's name, this can help making your code more "
"concise:"
msgstr ""
"4行目はモジュール`Data.Vect`をインポートし、新しい名前`V`を与えています。この"
"名前はより短い接頭辞として使えます。よくモジュール名を前置して識別子の曖昧解"
"決をする必要がある場合は、こうすることでコードをより簡潔にする助けになりま"
"す。"

#. type: Fenced code block (idris)
#: ../src/Appendices/Projects.md:133
#, no-wrap
msgid ""
"vectSum : Nat\n"
"vectSum = sum $ V.fromList [1..10]\n"
msgstr ""
"vectSum : Nat\n"
"vectSum = sum $ V.fromList [1..10]\n"

#. type: Plain text
#: ../src/Appendices/Projects.md:143
msgid ""
"Finally, on the fifth line we publicly import a module and give it a new "
"name. This name will then be the one seen when we transitively import `Data."
"List1` via `Appendices.Projects`. To see this, start a REPL session (after "
"type checking the tutorial)  without loading a source file from this "
"project's root folder:"
msgstr ""
"最後に5行目はモジュールを公に輸入して新しい名前を与えています。そうするとこの"
"名前は`Appendices.Projects`を介して`Data.List1`を推移的にインポートしたときの"
"ものになります。これを見てみるために（入門書を型検査したあとで）REPLセッショ"
"ンを始めましょう。ただしこのプロジェクトのルートディレクトリからソースファイ"
"ルを読み込みません。"

#. type: Fenced code block (sh)
#: ../src/Appendices/Projects.md:144
#, no-wrap
msgid ""
"pack typecheck tutorial\n"
"pack repl\n"
msgstr ""
"pack typecheck tutorial\n"
"pack repl\n"

#. type: Plain text
#: ../src/Appendices/Projects.md:151
msgid ""
"Now load module `Appendices.Projects` and checkout the type of `singleton`:"
msgstr ""
"そしてモジュール`Appendices.Projects`を読み込んで`singleton`の型を確認しま"
"す。"

#. type: Fenced code block (repl)
#: ../src/Appendices/Projects.md:152
#, no-wrap
msgid ""
"Main> :module Appendices.Projects\n"
"Imported module Appendices.Projects\n"
"Main> :t singleton\n"
"Data.String.singleton : Char -> String\n"
"Data.List.singleton : a -> List a\n"
"L.singleton : a -> List1 a\n"
msgstr ""
"Main> :module Appendices.Projects\n"
"Imported module Appendices.Projects\n"
"Main> :t singleton\n"
"Data.String.singleton : Char -> String\n"
"Data.List.singleton : a -> List a\n"
"L.singleton : a -> List1 a\n"

#. type: Plain text
#: ../src/Appendices/Projects.md:164
msgid ""
"As you can see, the `List1` version of `singleton` is now prefixed with `L` "
"instead of `Data.List1`. It is still possible to use the \"official\" "
"prefix, though:"
msgstr ""
"見ての通り`singleton`の`List1`版が`Data.List1`ではなく`L`で前置されています。"
"ただ「公式の」接頭辞を使うことも可能のままです。"

#. type: Fenced code block (repl)
#: ../src/Appendices/Projects.md:165
#, no-wrap
msgid ""
"Main> List1.singleton 12\n"
"12 ::: []\n"
"Main> L.singleton 12\n"
"12 ::: []\n"
msgstr ""
"Main> List1.singleton 12\n"
"12 ::: []\n"
"Main> L.singleton 12\n"
"12 ::: []\n"

#. type: Title ###
#: ../src/Appendices/Projects.md:172
#, no-wrap
msgid "Namespaces"
msgstr "名前空間"

#. type: Plain text
#: ../src/Appendices/Projects.md:182
msgid ""
"At times, we want to define several functions or data types with the same "
"name in a single module. Idris does not allow this, because every name must "
"be unique in its *namespace*, and the namespace of a module is just the "
"fully qualified module name.  However, it is possible to define additional "
"namespaces within a module by using the `namespace` keyword followed by the "
"name of the namespace. All functions which should belong to this namespace "
"must then be indented by the same amount of whitespace."
msgstr ""
"時折、1つのモジュール中に同じ名前を持つ関数やデータ型を複数定義したいときがあ"
"ります。Idrisはこれを許しませんが、それは全ての名前が*名前空間*で一意でなけれ"
"ばならないからです。そしてモジュールの名前空間は単なる完全に修飾されたモ"
"ジュール名です。しかし`namespace`キーワードとそれに続く名前空間名を使うことで"
"モジュール中に追加で名前空間を定義することは可能です。この名前空間に属する全"
"ての関数は同量の空白で字下げされなければなりません。"

#. type: Plain text
#: ../src/Appendices/Projects.md:184
msgid "Here's an example:"
msgstr "以下は例です。"

#. type: Fenced code block (idris)
#: ../src/Appendices/Projects.md:185
#, no-wrap
msgid ""
"data HList : List Type -> Type where\n"
"  Nil  : HList []\n"
"  (::) : (v : t) -> (vs : HList ts) -> HList (t :: ts)\n"
"\n"
"head : HList (t :: ts) -> t\n"
"head (v :: _) = v\n"
"\n"
"tail : HList (t :: ts) -> HList ts\n"
"tail (_ :: vs) = vs\n"
"\n"
"namespace HVect\n"
"  public export\n"
"  data HVect : Vect n Type -> Type where\n"
"    Nil  : HVect []\n"
"    (::) : (v : t) -> (vs : HVect ts) -> HVect (t :: ts)\n"
"\n"
"  public export\n"
"  head : HVect (t :: ts) -> t\n"
"  head (v :: _) = v\n"
"\n"
"  public export\n"
"  tail : HVect (t :: ts) -> HVect ts\n"
"  tail (_ :: vs) = vs\n"
msgstr ""
"data HList : List Type -> Type where\n"
"  Nil  : HList []\n"
"  (::) : (v : t) -> (vs : HList ts) -> HList (t :: ts)\n"
"\n"
"head : HList (t :: ts) -> t\n"
"head (v :: _) = v\n"
"\n"
"tail : HList (t :: ts) -> HList ts\n"
"tail (_ :: vs) = vs\n"
"\n"
"namespace HVect\n"
"  public export\n"
"  data HVect : Vect n Type -> Type where\n"
"    Nil  : HVect []\n"
"    (::) : (v : t) -> (vs : HVect ts) -> HVect (t :: ts)\n"
"\n"
"  public export\n"
"  head : HVect (t :: ts) -> t\n"
"  head (v :: _) = v\n"
"\n"
"  public export\n"
"  tail : HVect (t :: ts) -> HVect ts\n"
"  tail (_ :: vs) = vs\n"

#. type: Plain text
#: ../src/Appendices/Projects.md:222
msgid ""
"Function names `HVect.head` and `HVect.tail` as well as constructors `HVect."
"Nil` and `HVect.(::)` would clash with functions and constructors of the "
"same names from the outer namespace (`Appendices.Projects`), so we had to "
"put them in their own namespace. In order to be able to use them from "
"outside their namespace, they need to be exported (see the section on "
"visibility below). In case we need to disambiguate between these names, we "
"can prefix them with part of their namespace. For instance, the following "
"fails with a disambiguation error, because there are several functions "
"called `head` in scope and it is not clear from `head`'s argument (some data "
"type supporting list syntax, of which again several are in scope), which "
"version we want:"
msgstr ""
"関数名`HVect.head`と`HVect.tail`及び構築子`HVect.Nil`と`HVect.(::)`は外側の名"
"前空間 (`Appendices.Projects`) にある同名の関数と構築子と衝突するので、専用の"
"名前空間に置かなくてはなりません。名前空間の外側から使えるようにするには輸出"
"する必要があります（以下の可視性の節を参照）。これらの名前の曖昧解決をする必"
"要があるときは、名前に名前空間の一部を前置すればよいです。例えば以下は曖昧解"
"決エラーで失敗しますが、それはスコープで`head`という名前の関数が複数あって、"
"`head`の引数（リストの構文に対応している型があり、それもスコープに複数あるの"
"です）からはどのバージョンを使いたいのかが明らかにならないからです。"

#. type: Fenced code block (idris)
#: ../src/Appendices/Projects.md:223
#, no-wrap
msgid ""
"failing \"Ambiguous elaboration.\"\n"
"  whatHead : Nat\n"
"  whatHead = head [12,\"foo\"]\n"
msgstr ""
"failing \"Ambiguous elaboration.\"\n"
"  whatHead : Nat\n"
"  whatHead = head [12,\"foo\"]\n"

#. type: Plain text
#: ../src/Appendices/Projects.md:232
msgid ""
"By prefixing `head` with part of its namespace, we can resolve both "
"ambiguities. It is now immediately clear, that `[12,\"foo\"]` must be an "
"`HVect`, because that's the type of `HVect.head`'s argument:"
msgstr ""
"`head`に名前空間の一部を前置することで両方の曖昧性を解決をすることができま"
"す。これで`[12,\"foo\"]`が`HVect`でなければいけないことが直ちに明らかになりま"
"した。それが`HVect.head`の引数の型だからです。"

#. type: Fenced code block (idris)
#: ../src/Appendices/Projects.md:233
#, no-wrap
msgid ""
"thisHead : Nat\n"
"thisHead = HVect.head [12,\"foo\"]\n"
msgstr ""
"thisHead : Nat\n"
"thisHead = HVect.head [12,\"foo\"]\n"

#. type: Plain text
#: ../src/Appendices/Projects.md:240
msgid ""
"In the following subsection I'll make use of namespaces to demonstrate the "
"principles of visibility."
msgstr "以下の副節では可視性の原理を実演するために名前空間を活用していきます。"

#. type: Title ###
#: ../src/Appendices/Projects.md:241
#, no-wrap
msgid "Visibility"
msgstr "可視性"

#. type: Plain text
#: ../src/Appendices/Projects.md:248
msgid ""
"In order to use functions and data types outside of the module or namespace "
"they were defined in, we need to change their *visibility*. The default "
"visibility is `private`: Such a function or data type is not visible from "
"outside its module or namespace:"
msgstr ""
"関数やデータ型を定義されているモジュールや名前空間の外で使うためには、*可視性"
"*を変える必要があります。既定の可視性は`private`です。この可視性の関数やデー"
"タ型はモジュールや名前空間の外側からは見えません。"

#. type: Fenced code block (idris)
#: ../src/Appendices/Projects.md:249
#, no-wrap
msgid ""
"namespace Foo\n"
"  foo : Nat\n"
"  foo = 12\n"
"\n"
"failing \"Name Appendices.Projects.Foo.foo is private.\"\n"
"  bar : Nat\n"
"  bar = 2 * foo\n"
msgstr ""
"namespace Foo\n"
"  foo : Nat\n"
"  foo = 12\n"
"\n"
"failing \"Name Appendices.Projects.Foo.foo is private.\"\n"
"  bar : Nat\n"
"  bar = 2 * foo\n"

#. type: Plain text
#: ../src/Appendices/Projects.md:261
msgid "To make a function visible, annotate it with the `export` keyword:"
msgstr "関数が見えるようにするには`export`キーワードを註釈します。"

#. type: Fenced code block (idris)
#: ../src/Appendices/Projects.md:262
#, no-wrap
msgid ""
"namespace Square\n"
"  export\n"
"  square : Num a => a -> a\n"
"  square v = v * v\n"
msgstr ""
"namespace Square\n"
"  export\n"
"  square : Num a => a -> a\n"
"  square v = v * v\n"

#. type: Plain text
#: ../src/Appendices/Projects.md:271
msgid ""
"This will allow us to invoke function `square` from within other modules or "
"namespaces (after importing `Appendices.Projects`):"
msgstr ""
"こうすると（`Appendices.Projects`を輸入した後に）他のモジュールや名前空間内で"
"関数`square`を呼び出すことができます。"

#. type: Fenced code block (idris)
#: ../src/Appendices/Projects.md:272
#, no-wrap
msgid ""
"OneHundred : Bits8\n"
"OneHundred = square 10\n"
msgstr ""
"OneHundred : Bits8\n"
"OneHundred = square 10\n"

#. type: Plain text
#: ../src/Appendices/Projects.md:279
msgid ""
"However, the *implementation* of `square` will not be exported, so `square` "
"will not reduce during elaboration:"
msgstr ""
"しかし`square`の*実装*は輸出されないため、`square`は推敲の際に簡約されませ"
"ん。"

#. type: Fenced code block (idris)
#: ../src/Appendices/Projects.md:280
#, no-wrap
msgid ""
"failing \"Can't solve constraint between: 100 and square 10.\"\n"
"  checkOneHundred : OneHundred === 100\n"
"  checkOneHundred = Refl\n"
msgstr ""
"failing \"Can't solve constraint between: 100 and square 10.\"\n"
"  checkOneHundred : OneHundred === 100\n"
"  checkOneHundred = Refl\n"

#. type: Plain text
#: ../src/Appendices/Projects.md:287
msgid "For this to work, we need to *publicly export* `square`:"
msgstr "これが動くようにするには`square`を*公に輸出*する必要があります。"

#. type: Fenced code block (idris)
#: ../src/Appendices/Projects.md:288
#, no-wrap
msgid ""
"namespace SquarePub\n"
"  public export\n"
"  squarePub : Num a => a -> a\n"
"  squarePub v = v * v\n"
"\n"
"OneHundredAgain : Bits8\n"
"OneHundredAgain = squarePub 10\n"
"\n"
"checkOneHundredAgain : OneHundredAgain === 100\n"
"checkOneHundredAgain = Refl\n"
msgstr ""
"namespace SquarePub\n"
"  public export\n"
"  squarePub : Num a => a -> a\n"
"  squarePub v = v * v\n"
"\n"
"OneHundredAgain : Bits8\n"
"OneHundredAgain = squarePub 10\n"
"\n"
"checkOneHundredAgain : OneHundredAgain === 100\n"
"checkOneHundredAgain = Refl\n"

# Such function'sは誤植？
#. type: Plain text
#: ../src/Appendices/Projects.md:306
msgid ""
"Therefore, if you need a function to reduce during elaboration, annotate it "
"with `public export` instead of `export`.  This is especially important if "
"you use a function to compute a type. Such function's *must* reduce during "
"elaboration, otherwise they are completely useless:"
msgstr ""
"したがって遂行中に簡約する関数が必要なときは`export`ではなく`public export`を"
"註釈してください。型を計算する関数を使っている場合はとくに大切です。そうした"
"関数は推敲中の簡約が*必須*であり、公に輸出しないと完全に役に立ちません。"

#. type: Fenced code block (idris)
#: ../src/Appendices/Projects.md:307
#, no-wrap
msgid ""
"namespace Stupid\n"
"  export\n"
"  0 NatOrString : Type\n"
"  NatOrString = Either String Nat\n"
"\n"
"failing \"Can't solve constraint between: Either String ?b and NatOrString.\"\n"
"  natOrString : NatOrString\n"
"  natOrString = Left \"foo\"\n"
msgstr ""
"namespace Stupid\n"
"  export\n"
"  0 NatOrString : Type\n"
"  NatOrString = Either String Nat\n"
"\n"
"failing \"Can't solve constraint between: Either String ?b and NatOrString.\"\n"
"  natOrString : NatOrString\n"
"  natOrString = Left \"foo\"\n"

#. type: Plain text
#: ../src/Appendices/Projects.md:319
msgid "If we publicly export our type alias, everything type checks fine:"
msgstr "型別称を公に輸出すると全型検査が正常になります。"

#. type: Fenced code block (idris)
#: ../src/Appendices/Projects.md:320
#, no-wrap
msgid ""
"namespace Better\n"
"  public export\n"
"  0 NatOrString : Type\n"
"  NatOrString = Either String Nat\n"
"\n"
"natOrString : Better.NatOrString\n"
"natOrString = Left \"bar\"\n"
msgstr ""
"namespace Better\n"
"  public export\n"
"  0 NatOrString : Type\n"
"  NatOrString = Either String Nat\n"
"\n"
"natOrString : Better.NatOrString\n"
"natOrString = Left \"bar\"\n"

#. type: Title ###
#: ../src/Appendices/Projects.md:330
#, no-wrap
msgid "Visibility of Data Types"
msgstr "データ型の可視性"

#. type: Plain text
#: ../src/Appendices/Projects.md:337
msgid ""
"Visibility of data types behaves slightly differently. If set to `private` "
"(the default), neither the *type constructor* nor the *data constructors* "
"are visible outside of the namespace they where defined in. If annotated "
"with `export`, the type constructor is exported but not the data "
"constructors:"
msgstr ""
"データ型の可視性は僅かに異なった挙動をします。`private`（既定）に設定されてい"
"る場合、定義されている名前空間の外側では*型構築子*も*データ構築子*も見えませ"
"ん。`export`と註釈が付いていれば型構築子は輸出されますがデータ構築子は輸出さ"
"れません。"

#. type: Fenced code block (idris)
#: ../src/Appendices/Projects.md:338
#, no-wrap
msgid ""
"namespace Export\n"
"  export\n"
"  data Foo : Type where\n"
"    Foo1 : String -> Foo\n"
"    Foo2 : Nat -> Foo\n"
"\n"
"  export\n"
"  mkFoo1 : String -> Export.Foo\n"
"  mkFoo1 = Foo1\n"
"\n"
"foo1 : Export.Foo\n"
"foo1 = mkFoo1 \"foo\"\n"
msgstr ""
"namespace Export\n"
"  export\n"
"  data Foo : Type where\n"
"    Foo1 : String -> Foo\n"
"    Foo2 : Nat -> Foo\n"
"\n"
"  export\n"
"  mkFoo1 : String -> Export.Foo\n"
"  mkFoo1 = Foo1\n"
"\n"
"foo1 : Export.Foo\n"
"foo1 = mkFoo1 \"foo\"\n"

#. type: Plain text
#: ../src/Appendices/Projects.md:357
msgid ""
"As you can see, we can use the type `Foo` as well as function `mkFoo1` "
"outside of namespace `Export`. However, we cannot use the `Foo1` constructor "
"to create a value of type `Foo` directly:"
msgstr ""
"見ての通り型`Foo`と関数`mkFoo1`を名前空間`Export`の外側で使えています。しかし"
"`Foo1`構築子を使って直接型`Foo`の値を作ることはできません。"

#. type: Fenced code block (idris)
#: ../src/Appendices/Projects.md:358
#, no-wrap
msgid ""
"failing \"Export.Foo1 is private.\"\n"
"  foo : Export.Foo\n"
"  foo = Foo1 \"foo\"\n"
msgstr ""
"failing \"Export.Foo1 is private.\"\n"
"  foo : Export.Foo\n"
"  foo = Foo1 \"foo\"\n"

#. type: Plain text
#: ../src/Appendices/Projects.md:365
msgid "This changes when we publicly export the data type:"
msgstr "公にデータ型を輸出すると状況は変わります。"

#. type: Fenced code block (idris)
#: ../src/Appendices/Projects.md:366
#, no-wrap
msgid ""
"namespace PublicExport\n"
"  public export\n"
"  data Foo : Type where\n"
"    Foo1 : String -> PublicExport.Foo\n"
"    Foo2 : Nat -> PublicExport.Foo\n"
"\n"
"foo2 : PublicExport.Foo\n"
"foo2 = Foo2 12\n"
msgstr ""
"namespace PublicExport\n"
"  public export\n"
"  data Foo : Type where\n"
"    Foo1 : String -> PublicExport.Foo\n"
"    Foo2 : Nat -> PublicExport.Foo\n"
"\n"
"foo2 : PublicExport.Foo\n"
"foo2 = Foo2 12\n"

#. type: Plain text
#: ../src/Appendices/Projects.md:381
msgid ""
"The same goes for interfaces: If they are publicly exported, the interface "
"(a type constructor) plus all its functions are exported and you can write "
"implementations outside the namespace where they where defined:"
msgstr ""
"インターフェースについても同じことが言えます。公に公開されている場合、イン"
"ターフェース（型構築子）に加えて全ての関数が輸出され、それらの関数が定義され"
"ている名前空間の外側で実装を書くことができます。"

#. type: Fenced code block (idris)
#: ../src/Appendices/Projects.md:382
#, no-wrap
msgid ""
"namespace PEI\n"
"  public export\n"
"  interface Sized a where\n"
"    size : a -> Nat\n"
"\n"
"Sized Nat where size = id\n"
"\n"
"sumSizes : Foldable t => Sized a => t a -> Nat\n"
"sumSizes = foldl (\\n,e => n + size e) 0\n"
msgstr ""
"namespace PEI\n"
"  public export\n"
"  interface Sized a where\n"
"    size : a -> Nat\n"
"\n"
"Sized Nat where size = id\n"
"\n"
"sumSizes : Foldable t => Sized a => t a -> Nat\n"
"sumSizes = foldl (\\n,e => n + size e) 0\n"

#. type: Plain text
#: ../src/Appendices/Projects.md:397
msgid ""
"If they are not publicly exported, you will not be able to write "
"implementations outside the namespace they were defined in (but you can "
"still use the type and its functions in your code):"
msgstr ""
"公に公開されていなければ、メンバー関数が定義されている名前空間の外側では実装"
"を書くことができません（しかし型と関数についてはコードで使うことができま"
"す）。"

#. type: Fenced code block (idris)
#: ../src/Appendices/Projects.md:398
#, no-wrap
msgid ""
"namespace EI\n"
"  export\n"
"  interface Empty a where\n"
"    empty : a -> Bool\n"
"\n"
"  export\n"
"  Empty (List a) where\n"
"    empty [] = True\n"
"    empty _  = False\n"
"\n"
"failing\n"
"  Empty Nat where\n"
"    empty Z = True\n"
"    empty (S _) = False\n"
"\n"
"nonEmpty : Empty a => a -> Bool\n"
"nonEmpty = not . empty\n"
msgstr ""
"namespace EI\n"
"  export\n"
"  interface Empty a where\n"
"    empty : a -> Bool\n"
"\n"
"  export\n"
"  Empty (List a) where\n"
"    empty [] = True\n"
"    empty _  = False\n"
"\n"
"failing\n"
"  Empty Nat where\n"
"    empty Z = True\n"
"    empty (S _) = False\n"
"\n"
"nonEmpty : Empty a => a -> Bool\n"
"nonEmpty = not . empty\n"

#. type: Title ###
#: ../src/Appendices/Projects.md:418
#, no-wrap
msgid "Child Namespaces"
msgstr "子名前空間"

#. type: Plain text
#: ../src/Appendices/Projects.md:424
msgid ""
"Sometimes, it is necessary to access a private function in another module or "
"namespace. This is possible from within child namespaces (for want of a "
"better name): Modules and namespaces sharing the parent module's or "
"namespace's prefix. For instance:"
msgstr ""
"時には別のモジュールや名前空間にあるプライベート関数にアクセスする必要があり"
"ます。これは子名前空間（もっと良い名前があるといいのですが）の内側から可能で"
"す。モジュールと名前空間は親モジュールまたは親名前空間の接頭辞を共有します。"
"例えば次の通りです。"

#. type: Fenced code block (idris)
#: ../src/Appendices/Projects.md:425
#, no-wrap
msgid ""
"namespace Inner\n"
"  testEmpty : Bool\n"
"  testEmpty = nonEmpty (the (List Nat) [12])\n"
msgstr ""
"namespace Inner\n"
"  testEmpty : Bool\n"
"  testEmpty = nonEmpty (the (List Nat) [12])\n"

#. type: Plain text
#: ../src/Appendices/Projects.md:441
msgid ""
"As you can see, we can access function `nonEmpty` from within namespace "
"`Appendices.Projects.Inner`, although it is a private function of module "
"`Appendices.Projects`. This is even possible for modules: If we were to "
"write a module `Data.List.Magic`, we'd have access to private utility "
"functions defined in module `Data.List` in *base*. Actually, I did just that "
"and added module `Data.List.Magic` demonstrating this quirk of the Idris "
"module system (go have a look!).  In general, this is a rather hacky way to "
"work around visibility constraints, but it can be useful at times."
msgstr ""
"見ての通り、`nonEmpty`はモジュール`Appendices.Projects`のプライベート関数です"
"が、名前空間`Appendices.Projects.Inner`からは関数にアクセスできています。これ"
"はモジュールについても可能です。仮にモジュール`Data.List.Magic`を書いたら、"
"*base*のモジュール`Data.List`に定義されたプライベートの補助関数にアクセスする"
"ことができるでしょう。事実、このIdrisのモジュールシステムの妙な癖を実演するモ"
"ジュール`Data.List.Magic`を加えたところです（見に行ってください）。一般にこれ"
"はどちらかと言えばハック的な可視性の制約を迂回する方法ですが、場合によっては"
"役に立つこともあります。"

#. type: Title ##
#: ../src/Appendices/Projects.md:442
#, no-wrap
msgid "Parameter Blocks"
msgstr "引数ブロック"

#. type: Plain text
#: ../src/Appendices/Projects.md:450
msgid ""
"In this subsection, we are going to have a look at a language construct "
"called a `parameters` block, which enables us to share a set of common read-"
"only arguments (parameters)  across several functions, thus allowing us to "
"write more concise function signatures. I'm going to demonstrate their "
"usability with a small example program."
msgstr ""
"この副節では`parameters`ブロックという言語の構成要素を眺めていきたいと思いま"
"す。これにより複数の関数に共通する読取専用の引数（パラメータ）の集合を分配す"
"ることができ、したがってより簡潔な関数の処方を書くことができます。小さなプロ"
"グラムの例でどのように使うことができるか実演していきます。"

#. type: Plain text
#: ../src/Appendices/Projects.md:457
msgid ""
"The most basic way to make some piece of external information available to a "
"function is by passing it as an additional argument. In object-orientied "
"programming, this principle is sometimes called [dependency injection]"
"(https://en.wikipedia.org/wiki/Dependency_injection), and a lot of fuss is "
"being made about it, and whole libraries and frameworks have been built "
"around it."
msgstr ""
"外部の情報を関数で使えるようにする一番基本的な方法は追加の引数として渡すこと"
"です。オブジェクト指向プログラミングではこの原理は時に[依存性の注入](https://"
"en.wikipedia.org/wiki/Dependency_injection)と呼ばれて人口に膾炙しており、オブ"
"ジェクト指向のライブラリやフレームワークはこれに基づいて構築されています。"

#. type: Plain text
#: ../src/Appendices/Projects.md:467
msgid ""
"In functional programming, we can be perfectly relaxed about all of this: "
"Need access to some configuration data for your application? Pass it as an "
"additional argument to your functions. Want to use some local mutable state? "
"Pass the corresponding `IORef` as an additional argument to your functions. "
"This is both highly efficient and incredibly simple. The only drawback it "
"has: It can blow up our function signatures. There is even a monad for "
"abstracting over this concept, called the `Reader` monad. It can be found in "
"module `Control.Monad.Reader`, in the base library."
msgstr ""
"関数型プログラミングではこうしたことからは完全に一歩身を引いていられます。ア"
"プリケーションから何らかの設定データにアクセスする必要がありますか。関数に追"
"加の引数を渡してください。ローカルな可変状態を使いたいですか。関数に追加の引"
"数として対応する`IORef`を渡してください。引数に渡すことはかなり効率的で非常に"
"単純です。唯一の欠点は、関数の処方を振り出しに戻してしまうことです。この考え"
"方を抽象化するためのモナドさえあり、`Reader`モナドと呼ばれます。baseライブラ"
"リの`Control.Monad.Reader`モジュールにあります。"

#. type: Plain text
#: ../src/Appendices/Projects.md:471
msgid ""
"In Idris, however, there is an even simpler approach: We can use proof "
"search with auto implicit arguments for dependency injection. Here's some "
"example code:"
msgstr ""
"しかしIdrisではもっと簡単な方法があります。依存性の注入のために証明検索と自動"
"暗黙引数が使えるのです。以下はそうしたコード例です。"

#. type: Fenced code block (idris)
#: ../src/Appendices/Projects.md:472
#, no-wrap
msgid ""
"data Error : Type where\n"
"  NoNat  : String -> Error\n"
"  NoBool : String -> Error\n"
"\n"
"record Console where\n"
"  constructor MkConsole\n"
"  read : IO String\n"
"  put  : String -> IO ()\n"
"\n"
"record ErrorHandler where\n"
"  constructor MkHandler\n"
"  handle : Error -> IO ()\n"
"\n"
"getCount' : (h : ErrorHandler) => (c : Console) => IO Nat\n"
"getCount' = do\n"
"  str <- c.read\n"
"  case parsePositive str of\n"
"    Nothing => h.handle (NoNat str) $> 0\n"
"    Just n  => pure n\n"
"\n"
"getText' : (h : ErrorHandler) => (c : Console) => (n : Nat) -> IO (Vect n String)\n"
"getText' n = sequence $ replicate n c.read\n"
"\n"
"prog' : ErrorHandler => (c : Console) => IO ()\n"
"prog' = do\n"
"  c.put \"Please enter the number of lines to read.\"\n"
"  n  <- getCount'\n"
"  c.put \"Please enter \\{show n} lines of text.\"\n"
"  ls <- getText' n\n"
"  c.put \"Read \\{show n} lines and \\{show . sum $ map length ls} characters.\"\n"
msgstr ""
"data Error : Type where\n"
"  NoNat  : String -> Error\n"
"  NoBool : String -> Error\n"
"\n"
"record Console where\n"
"  constructor MkConsole\n"
"  read : IO String\n"
"  put  : String -> IO ()\n"
"\n"
"record ErrorHandler where\n"
"  constructor MkHandler\n"
"  handle : Error -> IO ()\n"
"\n"
"getCount' : (h : ErrorHandler) => (c : Console) => IO Nat\n"
"getCount' = do\n"
"  str <- c.read\n"
"  case parsePositive str of\n"
"    Nothing => h.handle (NoNat str) $> 0\n"
"    Just n  => pure n\n"
"\n"
"getText' : (h : ErrorHandler) => (c : Console) => (n : Nat) -> IO (Vect n String)\n"
"getText' n = sequence $ replicate n c.read\n"
"\n"
"prog' : ErrorHandler => (c : Console) => IO ()\n"
"prog' = do\n"
"  c.put \"Please enter the number of lines to read.\"\n"
"  n  <- getCount'\n"
"  c.put \"Please enter \\{show n} lines of text.\"\n"
"  ls <- getText' n\n"
"  c.put \"Read \\{show n} lines and \\{show . sum $ map length ls} characters.\"\n"

#. type: Plain text
#: ../src/Appendices/Projects.md:520
msgid ""
"The example program reads input from and prints output to some `Console` "
"type, the implementation of which is left to the caller of the function. "
"This is a typical example of dependency injection: Our `IO` actions know "
"nothing about how to read and write lines of text (they do, for instance, "
"not invoke `putStrLn` or `getLine` directly), but rely on an external "
"*object* to handle these tasks for us. This allows us to use a simple *mock "
"object* during testing, while using - for instance - two file handles or "
"data base connections when running the application for real. These are "
"typical techniques often found in object-oriented programming, and in fact, "
"this example emulates typical object-oriented patterns in a purely "
"functional programming language: A type like `Console` can be viewed as a "
"*class* providing pieces of functionality (*methods* `read` and `put`), and "
"a value of type `Console` can be viewed as an *object* of this class, on "
"which we can invoke those methods."
msgstr ""
"プログラムの例は何らかの`Console`型から入力を読み、また出力を印字します。この"
"型の実装は関数の呼び出し側に委ねられています。これは典型的な依存性の注入の例"
"になっています。`IO`アクションはテキストの数行をどう読み書きしたらいいのかを"
"知りませんが（例えば直接`putStrLn`や`getLine`を呼び出したりはしません）、外部"
"の*オブジェクト*によってこうしたタスクを扱ってくれます。これにより例えばテス"
"ト時に単純な*モックオブジェクト*を使い、実際のアプリケーションを走らせるとき"
"は、2つのファイル制御子やデータベース接続を使うことができます。オブジェクト指"
"向プログラミングでよく見られる典型的な技法が存在し、事実、この例は典型的なオ"
"ブジェクト指向のパターンを純粋に関数型プログラミング言語でエミュレートしたも"
"のになります。`Console`のような型は機能（*メソッド*`read`および`put`）を提供"
"する*クラス*として見ることができ、型`Console`の値はこのクラスの*オブジェクト*"
"として見ることができます。その値はこれらのメソッドを呼び出すことができます。"

#. type: Plain text
#: ../src/Appendices/Projects.md:525
msgid ""
"The same goes for error handling: Our error handler could just silently "
"ignore any error that occurs, or it could print it to `stderr` and write it "
"to a log file at the same time. Whatever it does, our functions need not "
"care."
msgstr ""
"エラー制御についても同じことが言えます。エラー制御子を、どんなエラーが起こっ"
"ても静かに無視するようにさせることができますし、`stderr`に印字しつつ同時にロ"
"グファイルに書き込むようにすることもできます。どんなことが起ころうと関数は意"
"に介しません。"

# TODO: parameterはparametersの間違いかもしれません
#. type: Plain text
#: ../src/Appendices/Projects.md:536
msgid ""
"Note, however, that even in this very simple example we already introduced "
"two additional function arguments, and we can easily see how in a real-world "
"application we might need many more of those and how this would quickly blow "
"up our function signatures.  Luckily, there is a very clean and simple "
"solution to this in Idris: `parameter` blocks. These allow us to specify "
"lists of *parameters* (unchanging function arguments) shared by all "
"functions listed inside the block. These arguments need then no longer be "
"listed with each function, thus decluttering our function signatures.  "
"Here's the example from above in a parameter block:"
msgstr ""
"しかしこのとても単純な例であっても既に追加の関数引数を導入していますよね。そ"
"して実世界のアプリケーションともなるとより多くの引数が必要になるでしょうし、"
"関数の処方が膨れ上がってしまうことは容易に想像が付きます。朗報ですが、Idrisに"
"はこのためのとても明快で単純な解決法があります。`parameters`ブロックです。こ"
"のブロックではブロック内に挙げられた全ての関数で共通する（関数の引数を変えな"
"い）*引数*のリストを指定することができます。そうすればこうした引数はそれぞれ"
"の関数でリストにする必要はなく、もう関数の処方を散らかしてしまうこともありま"
"せん。以下は上の例で引数ブロックを使ったものです。"

#. type: Fenced code block (idris)
#: ../src/Appendices/Projects.md:537
#, no-wrap
msgid ""
"parameters {auto c : Console} {auto h : ErrorHandler}\n"
"  getCount : IO Nat\n"
"  getCount = do\n"
"    str <- c.read\n"
"    case parsePositive str of\n"
"      Nothing => h.handle (NoNat str) $> 0\n"
"      Just n  => pure n\n"
"\n"
"  getText : (n : Nat) -> IO (Vect n String)\n"
"  getText n = sequence $ replicate n c.read\n"
"\n"
"  prog : IO ()\n"
"  prog = do\n"
"    c.put \"Please enter the number of lines to read.\"\n"
"    n  <- getCount\n"
"    c.put \"Please enter \\{show n} lines of text.\"\n"
"    ls <- getText n\n"
"    c.put \"Read \\{show n} lines and \\{show . sum $ map length ls} characters.\"\n"
msgstr ""
"parameters {auto c : Console} {auto h : ErrorHandler}\n"
"  getCount : IO Nat\n"
"  getCount = do\n"
"    str <- c.read\n"
"    case parsePositive str of\n"
"      Nothing => h.handle (NoNat str) $> 0\n"
"      Just n  => pure n\n"
"\n"
"  getText : (n : Nat) -> IO (Vect n String)\n"
"  getText n = sequence $ replicate n c.read\n"
"\n"
"  prog : IO ()\n"
"  prog = do\n"
"    c.put \"Please enter the number of lines to read.\"\n"
"    n  <- getCount\n"
"    c.put \"Please enter \\{show n} lines of text.\"\n"
"    ls <- getText n\n"
"    c.put \"Read \\{show n} lines and \\{show . sum $ map length ls} characters.\"\n"

#. type: Plain text
#: ../src/Appendices/Projects.md:564
msgid ""
"We are free to list arbitrary arguments (implicit, explicit, auto-implicit, "
"named and unnamed) of any quantity as the parameters in a `parameters` "
"block, but it works best with implicit and auto implicit arguments. Explicit "
"arguments will have to be passed explicitly to functions in a parameter "
"block, even when invoking them from other parameter blocks with the same "
"explicit argument. This can be rather confusing."
msgstr ""
"`parameters`ブロック中の引数としていくらでも（暗黙子、明示子、自動暗黙子、名"
"前付き、名前なしのような）任意の引数を自由に挙げることができますが、一番のは"
"たらきを見せるのは暗黙子と自動暗黙子の引数のときです。明示引数は引数ブロック"
"で関数に明示的に渡さねばならず、同じ明示引数を持つ他の引数ブロックから呼び出"
"すときもそうなります。これはむしろ紛らわしくなりえます。"

#. type: Plain text
#: ../src/Appendices/Projects.md:568
msgid ""
"To complete this example, here is a main function for running the program. "
"Note, how we explicitly assemble the `Console` and `ErrorHandler` to be used "
"when invoking `prog`."
msgstr ""
"この例を締め括るにあたって、以下はプログラムを走らせるメイン関数です。`prog`"
"を呼び出すときに`Console`と`ErrorHandler`を明示的に組み合わせて使われていると"
"ころに注目してください。"

#. type: Fenced code block (idris)
#: ../src/Appendices/Projects.md:569
#, no-wrap
msgid ""
"main : IO ()\n"
"main =\n"
"  let cons := MkConsole (trim <$> getLine) putStrLn\n"
"      err  := MkHandler (const $ putStrLn \"It didn't work\")\n"
"   in prog\n"
msgstr ""
"main : IO ()\n"
"main =\n"
"  let cons := MkConsole (trim <$> getLine) putStrLn\n"
"      err  := MkHandler (const $ putStrLn \"It didn't work\")\n"
"   in prog\n"

#. type: Plain text
#: ../src/Appendices/Projects.md:580
msgid ""
"Dependency injection via auto-implicit arguments is only one possible "
"application of parameter blocks. They are useful in general whenever we have "
"repeating argument lists for several functions."
msgstr ""
"自動暗黙引数を介した依存性の注入は引数ブロックがなしえる実例の1つに過ぎませ"
"ん。このブロックは複数の関数で繰り返し登場する引数のリストがあるときは常に一"
"般に有用です。"

#. type: Title ##
#: ../src/Appendices/Projects.md:581
#, no-wrap
msgid "Documentation"
msgstr "ドキュメンテーション"

#. type: Plain text
#: ../src/Appendices/Projects.md:588
msgid ""
"Documentation is key. Be it for other programmers using a library we wrote, "
"or for people (including our future selves) trying to understand our code, "
"it is important to annotate our code with comments explaining non-trivial "
"implementation details and docstrings describing the intent and "
"functionality of exported data types and functions."
msgstr ""
"ドキュメンテーションは鍵です。自分が書いたライブラリを使う他のプログラマや"
"コードを理解しようとする人々（将来の自分自身を含む）のためのものであって、非"
"自明な実装の詳細を説明するコメントや輸出されたデータ型と関数の意図と機能を記"
"述するドキュメント文字列でコードに註釈を付けることは大事です。"

#. type: Title ###
#: ../src/Appendices/Projects.md:589
#, no-wrap
msgid "Comments"
msgstr "コメント"

#. type: Plain text
#: ../src/Appendices/Projects.md:593
msgid ""
"Writing a comment in an Idris source file is as simple as adding some text "
"after two hyphens:"
msgstr ""
"Idrisのソースファイルにコメントを書くには、単に2つのハイフンに続けてテキスト"
"を書き加えるだけです。"

#. type: Fenced code block (idris)
#: ../src/Appendices/Projects.md:594
#, no-wrap
msgid ""
"-- this is a truly boring comment\n"
"boring : Bits8 -> Bits8\n"
"boring a = a -- probably I should just use `id` from the Prelude\n"
msgstr ""
"-- これは全き退屈なコメント\n"
"boring : Bits8 -> Bits8\n"
"boring a = a -- 恐らく単にPreludeの`id`を使うべき\n"

#. type: Plain text
#: ../src/Appendices/Projects.md:603
msgid ""
"Whenever a line contains two hyphens that are not part of a string literal, "
"the remainder of the line will be interpreted as a comment by Idris."
msgstr ""
"文字列表記の一部でない2つのハイフンを含む行は皆、ハイフン以降の部分がIdrisに"
"よってコメントとして解釈されます。"

#. type: Plain text
#: ../src/Appendices/Projects.md:606
msgid ""
"It is also possible to write multiline comments using delimiters `{-` and `-}"
"`:"
msgstr "仕切り`{-`及び`-}`を使って複数行コメントを書くこともできます。"

#. type: Fenced code block (idris)
#: ../src/Appendices/Projects.md:607
#, no-wrap
msgid ""
"{-\n"
"  This is a multiline comment. It can be used to comment\n"
"  out whole blocks of code, for instance if we get several\n"
"  type errors in a larger source file.\n"
"-}\n"
msgstr ""
"{-\n"
"  これは複数行コメントです。\n"
"  コードのブロック全体をコメントアウトするのに使えます。\n"
"  例えば比較的大きなファイルで複数の型エラーがあったときとかです。\n"
"-}\n"

#. type: Title ###
#: ../src/Appendices/Projects.md:615
#, no-wrap
msgid "Doc Strings"
msgstr "ドキュメント文字列"

#. type: Plain text
#: ../src/Appendices/Projects.md:621
msgid ""
"While comments are targeted at programmers reading and trying to understand "
"our source code, doc strings provide documentation for exported functions "
"and data types, explaining their intent and behavior to others."
msgstr ""
"コメントはソースコードを読んで理解しようとするプログラマを対象にするものです"
"が、ドキュメント文字列は輸出される関数とデータ型にドキュメンテーションを提供"
"するもので、他者にその意図や挙動を説明するためのものです。"

#. type: Plain text
#: ../src/Appendices/Projects.md:623
msgid "Here's and example of a documented function:"
msgstr "以下はドキュメントが付いた関数の例です。"

#. type: Fenced code block (idris)
#: ../src/Appendices/Projects.md:624
#, no-wrap
msgid ""
"||| Tries to extract the first two elements from the beginning\n"
"||| of a list.\n"
"|||\n"
"||| Returns a pair of values wrapped in a `Just` if the list has\n"
"||| two elements or more. Returns `Nothing` if the list has fewer\n"
"||| than two elements.\n"
"export\n"
"firstTwo : List a -> Maybe (a,a)\n"
"firstTwo (x :: y :: _) = Just (x,y)\n"
"firstTwo _             = Nothing\n"
msgstr ""
"||| リストの先頭から最初の2要素を取り出そうとします。\n"
"|||\n"
"||| リストに2つ以上の要素があれば値の対を`Just`に包んで返します。\n"
"||| リストが2要素より少なければ`Nothing`を返します。\n"
"export\n"
"firstTwo : List a -> Maybe (a,a)\n"
"firstTwo (x :: y :: _) = Just (x,y)\n"
"firstTwo _             = Nothing\n"

#. type: Plain text
#: ../src/Appendices/Projects.md:638
msgid "We can view a doc string at the REPL:"
msgstr "REPLでドキュメント文字列を眺めることができます。"

#. type: Fenced code block (repl)
#: ../src/Appendices/Projects.md:639
#, no-wrap
msgid ""
"Appendices.Projects> :doc firstTwo\n"
"Appendices.Projects.firstTwo : List a -> Maybe (a,a)\n"
"  Tries to extract the first two elements from the beginning\n"
"  of a list.\n"
"\n"
"  Returns a pair of values wrapped in a `Just` if the list has\n"
"  two elements or more. Returns `Nothing` if the list has fewer\n"
"  than two elements.\n"
"  Visibility: export\n"
msgstr ""
"Appendices.Projects> :doc firstTwo\n"
"Appendices.Projects.firstTwo : List a -> Maybe (a,a)\n"
"  Tries to extract the first two elements from the beginning\n"
"  of a list.\n"
"\n"
"  Returns a pair of values wrapped in a `Just` if the list has\n"
"  two elements or more. Returns `Nothing` if the list has fewer\n"
"  than two elements.\n"
"  Visibility: export\n"

#. type: Plain text
#: ../src/Appendices/Projects.md:653
msgid "We can document data types and their constructors in a similar manner:"
msgstr "データ型やその構築子も似たような風にドキュメントを書けます。"

# TODO: index -> indexed
#. type: Fenced code block (idris)
#: ../src/Appendices/Projects.md:654
#, no-wrap
msgid ""
"||| A binary tree index by the number of values it holds.\n"
"|||\n"
"||| @param `n` : Number of values stored in the `Tree`\n"
"||| @param `a` : Type of values stored in the `Tree`\n"
"public export\n"
"data Tree : (n : Nat) -> (a : Type) -> Type where\n"
"  ||| A single value stored at the leaf of a binary tree.\n"
"  Leaf   : (v : a) -> Tree 1 a\n"
"\n"
"  ||| A branch unifying two subtrees.\n"
"  Branch : Tree m a -> Tree n a -> Tree (m + n) a\n"
msgstr ""
"||| 保管されている値の数で指標付けられた二分木\n"
"|||\n"
"||| @param `n` : `Tree`に保管されている値の数\n"
"||| @param `a` : `Tree`で保管されている値の型\n"
"public export\n"
"data Tree : (n : Nat) -> (a : Type) -> Type where\n"
"  ||| 二分木の葉に保管されている単一の値\n"
"  Leaf   : (v : a) -> Tree 1 a\n"
"\n"
"  ||| 2つの部分木を結わえる分枝\n"
"  Branch : Tree m a -> Tree n a -> Tree (m + n) a\n"

# TODO: this generatesはthat generatesの誤植？
#. type: Plain text
#: ../src/Appendices/Projects.md:670
msgid "Go ahead and have a look at the doc strings this generates at the REPL."
msgstr "さあ、これにより生成されたドキュメント文字列をREPLで見てみましょう。"

#. type: Plain text
#: ../src/Appendices/Projects.md:678
msgid ""
"Documenting our code is very important. You will realize this, once you try "
"to understand other people's code, or when you come back to a non-trivial "
"piece of source code you wrote yourself a couple of months a ago and since "
"then haven't looked at. If it is not well documented, this can be an "
"unpleasant experience. Idris provides us with the tools necessary to "
"document and annotate our code, so should take our time and do so. It is "
"time well spent."
msgstr ""
"コードにドキュメントを書くことは大変重要です。これに気付くのは、ひとたび他の"
"人のコードを理解しようとしたり、自分でそれなりの規模のコードを書いたのち数カ"
"月間触れない状態が続いたあとに読み返したりするときです。充分にドキュメント化"
"されていないと、気の晴れないことになるかもしれません。Idrisではコードにドキュ"
"メントを書いたり註釈を付けたりするのに必要なツールが提供されているので、そう"
"いったことをする時間は取るべきです。ドキュメントを書くことは愉快なことです。"

#. type: Title ##
#: ../src/Appendices/Projects.md:679
#, no-wrap
msgid "Packages"
msgstr "パッケージ"

#. type: Plain text
#: ../src/Appendices/Projects.md:686
msgid ""
"Idris packages allow us to assemble several modules into a logical unit and "
"make them available to other Idris projects by *installing* the packages. In "
"this section, we are going to learn about the structure of an Idris package "
"and how to depend on other packages in our projects."
msgstr ""
"Idrisのパッケージがあると複数のモジュールを1つの論理的な単位にまとめて、パッ"
"ケージを*インストール*することによって他のIdrisのプロジェクトから使えるように"
"することができます。この節ではIdrisのパッケージの構造とプロジェクトで他のパッ"
"ケージに依存する方法について学んでいきます。"

#. type: Title ###
#: ../src/Appendices/Projects.md:687
#, no-wrap
msgid "The `.ipkg` File"
msgstr "`.ipkg`ファイル"

#. type: Plain text
#: ../src/Appendices/Projects.md:693
msgid ""
"At the heart of an Idris package lies its `.ipkg` file, which is usually but "
"not necessarily stored at a project's root directory.  For instance, for "
"this Idris tutorial, there is file `tutorial.ipkg` at the tutorial's root "
"directory."
msgstr ""
"Idrisのパッケージの核心は`.ipkg`ファイルにあります。このファイルは大抵プロ"
"ジェクトのルートディレクトリに保管されますが、必須ではありません。例えばこの"
"Idrisの入門書では、入門書のルートディレクトリに`tutorial.ipkg`ファイルがあり"
"ます。"

#. type: Plain text
#: ../src/Appendices/Projects.md:699
msgid ""
"An `.ipkg` file consists of several key-value pairs (most of them optional), "
"the most important of which I'll describe here. By far the easiest way to "
"setup a new Idris project is by letting pack or Idris itself do it for you. "
"Just run"
msgstr ""
"`.ipkg`ファイルは複数のキーバリュー対（ほとんどがオプション）から構成され、そ"
"のうち重要なものをここに記述していきます。今のところ新しいIdrisのプロジェクト"
"を立ち上げる最も簡単な方法はpackまたはIdris自体を使うことです。以下を走らせる"
"だけです。"

#. type: Fenced code block (sh)
#: ../src/Appendices/Projects.md:700
#, no-wrap
msgid "pack new lib pkgname\n"
msgstr "pack new lib pkgname\n"

#. type: Plain text
#: ../src/Appendices/Projects.md:705
msgid "to create the skeleton of a new library or"
msgstr "上記は新しいライブラリの骨子をつくります。あるいは"

#. type: Fenced code block (sh)
#: ../src/Appendices/Projects.md:706
#, no-wrap
msgid "pack new bin appname\n"
msgstr "pack new bin appname\n"

#. type: Plain text
#: ../src/Appendices/Projects.md:713
msgid ""
"to setup a new application. In addition to creating a new directory plus a "
"suitable `.ipkg` file, these commands will also add a `pack.toml` file, "
"which we will discuss further below."
msgstr ""
"とすると新しいアプリケーションを立ち上げます。新しいディレクトリと相応しい`."
"ipkg`ファイルを作るのに加えて、これらのコマンドは`pack.toml`ファイルも追加し"
"ます。このファイルについて詳しくは後述します。"

#. type: Title ###
#: ../src/Appendices/Projects.md:714
#, no-wrap
msgid "Dependencies"
msgstr "依存関係"

#. type: Plain text
#: ../src/Appendices/Projects.md:721
msgid ""
"One of the most important aspects of an `.ipkg` file is listing the packages "
"the library depends on in the `depends` field. Here is an example from the "
"[*hedgehog* package](https://github.com/stefan-hoeck/idris2-hedgehog), a "
"framework for writing property tests in Idris:"
msgstr ""
"`.ipkg`ファイルの最重要の側面の1つは、`depends`フィールドにライブラリが依存す"
"るパッケージを一覧にすることです。以下は[*hedgehog*パッケージ](https://"
"github.com/stefan-hoeck/idris2-hedgehog)からの例です。このパッケージはIdrisで"
"性質テストを書くための枠組みです。"

#. type: Fenced code block (ipkg)
#: ../src/Appendices/Projects.md:722
#, no-wrap
msgid ""
"depends    = base         >= 0.5.1\n"
"           , contrib      >= 0.5.1\n"
"           , elab-util    >= 0.5.0\n"
"           , pretty-show  >= 0.5.0\n"
"           , sop          >= 0.5.0\n"
msgstr ""
"depends    = base         >= 0.5.1\n"
"           , contrib      >= 0.5.1\n"
"           , elab-util    >= 0.5.0\n"
"           , pretty-show  >= 0.5.0\n"
"           , sop          >= 0.5.0\n"

#. type: Plain text
#: ../src/Appendices/Projects.md:745
msgid ""
"As you can see, *hedgehog* depends on *base* and *contrib*, both of which "
"are part of every Idris installation, but also on [*elab-util*](https://"
"github.com/stefan-hoeck/idris2-elab-util), a library of utilities for "
"writing elaborator scripts (a powerful technique for creating Idris "
"declarations by writing Idris code; it comes with its own lengthy tutorial "
"if you are interested), [*sop*](https://github.com/stefan-hoeck/idris2-sop), "
"a library for generically deriving interface implementations via a *sum of "
"products* representation (this is a useful thing you might want to check out "
"some day), and [*pretty-show*](https://github.com/stefan-hoeck/idris2-pretty-"
"show), a library for pretty printing Idris values (*hedgehog* makes use of "
"this in case a test fails)."
msgstr ""
"見ての通り*hedgehog*は*base*と*contrib*に依存しており、両方ともIdrisのインス"
"トールに含まれる一部です。しかし[*elab-util*](https://github.com/stefan-"
"hoeck/idris2-elab-util)という推敲スクリプトを書くためのユーティリティライブラ"
"リ（Idrisのコードを書くことによってIdrisの宣言を作る強力な技法です。ご興味が"
"あれば分量のある入門書があるのでどうぞ）、[*sop*](https://github.com/stefan-"
"hoeck/idris2-sop)という*積和*表現を介してインターフェースの実装を一般的に導出"
"するライブラリ（便利なものでいつの日にか確認したくなるでしょう）、[*pretty-"
"show*](https://github.com/stefan-hoeck/idris2-pretty-show)というIdrisの値を綺"
"麗に印字するためのライブラリ（*hedgehog*はこれをテストが失敗した場合に活用し"
"ています）にも依存しています。"

#. type: Plain text
#: ../src/Appendices/Projects.md:752
msgid ""
"So, before you actually can use *hedgehog* to write some property tests for "
"your own project, you will need to install the packages it depends on before "
"installing *hedgehog* itself. Since this can be tedious to do manually, it "
"is best let a package manager like pack handle this task for you."
msgstr ""
"なので自分のプロジェクトで性質テストを書くのに実際に*hedgehog*を使えるように"
"なるまでには、*hedgehog*自体をインストールする前にそれに依存するパッケージを"
"インストールする必要があるでしょう。こうしたことを手作業でするのは億劫なので"
"packのようなパッケージ管理に対応してもらうのが一番です。"

#. type: Title ####
#: ../src/Appendices/Projects.md:753
#, no-wrap
msgid "Dependency Versions"
msgstr "依存関係のバージョン"

#. type: Plain text
#: ../src/Appendices/Projects.md:760
msgid ""
"You might want to specify a certain version (or a range)  Idris should use "
"for your dependencies. This might be useful if you have several versions of "
"the same package installed and not all of them are compatible with your "
"project.  Here are several examples:"
msgstr ""
"Idrisが依存関係に使うべきバージョンを特定のもの（あるいは範囲）に指定したいこ"
"とがあるでしょう。この指定ができると、同じパッケージの複数のバージョンがイン"
"ストールされていて、全部が全部プロジェクトと互換性があるわけではないようなと"
"きに、役に立つことでしょう。以下にいくつかの例を示します。"

#. type: Fenced code block (ipkg)
#: ../src/Appendices/Projects.md:761
#, no-wrap
msgid ""
"depends    = base         == 0.5.1\n"
"           , contrib      == 0.5.1\n"
"           , elab-util    >= 0.5.0\n"
"           , pretty-show\n"
"           , sop          >= 0.5.0 && < 0.6.0\n"
msgstr ""
"depends    = base         == 0.5.1\n"
"           , contrib      == 0.5.1\n"
"           , elab-util    >= 0.5.0\n"
"           , pretty-show\n"
"           , sop          >= 0.5.0 && < 0.6.0\n"

#. type: Plain text
#: ../src/Appendices/Projects.md:776
msgid ""
"This will look for packages *base* and *contrib* of exactly the given "
"version, package *elab-util* of a version greater than or equal to `0.5.0`, "
"package *pretty-show* of any version, and package *sop* of a version in the "
"given range. In all cases, if several installed versions of a package match "
"the specified range, the latest version will be used."
msgstr ""
"このようにすると、パッケージ*base*と*contrib*は厳密に与えられたバージョンを、"
"パッケージ*elab-util*は`0.5.0`以上のバージョンを、パッケージ*pretty-show*はど"
"んなバージョンも、パッケージ*sop*は与えられた範囲内のバージョンを、それぞれ探"
"し出すことになります。全ての場合において、指定された範囲に合致するパッケージ"
"のインストールされたバージョンが複数ある場合、最新版が使用されます。"

#. type: Plain text
#: ../src/Appendices/Projects.md:780
msgid ""
"In order to make use of this for your own packages, every `.ipkg` file "
"should give the package's name and current version:"
msgstr ""
"自分のパッケージでこの依存関係の指定が使えるようにするためには、`.ipkg`ファイ"
"ルには必ずパッケージ名と現在のバージョンを与えるべきです。"

#. type: Fenced code block (ipkg)
#: ../src/Appendices/Projects.md:781
#, no-wrap
msgid ""
"package tutorial\n"
"\n"
"version    = 0.1.0\n"
msgstr ""
"package tutorial\n"
"\n"
"version    = 0.1.0\n"

#. type: Plain text
#: ../src/Appendices/Projects.md:792
msgid ""
"As I'll show below, package versions play a much less crucial role when "
"using pack and its curated package collection. But even then you might want "
"to consider restricting the versions of packages you accept in order to make "
"sure you catch any braking changes introduced upstream."
msgstr ""
"後述するようにpackと厳選されたパッケージコレクションを使う際はあまりパッケー"
"ジのバージョンは大事な役割を持ちません。しかしそれでも最前線で導入された破壊"
"的な変更を確実に察知できるようにするために、パッケージのバージョンを制限する"
"ことを検討したいこともあるでしょう。"

#. type: Title ###
#: ../src/Appendices/Projects.md:793
#, no-wrap
msgid "Library Modules"
msgstr "ライブラリのモジュール"

#. type: Plain text
#: ../src/Appendices/Projects.md:806
msgid ""
"Many if not most Idris packages available on GitHub are programming "
"*libraries*: They implement some piece of functionality and make it "
"available to all projects depending on the given package. This is unlike "
"Idris *applications*, which are supposed to be compiled to an executable "
"that can then be run on your computer. The Idris project itself provides "
"both: The Idris compiler application, which we use to type check and build "
"other Idris libraries and applications, and several libraries like "
"*prelude*, *base*, and *contrib*, which provide basic data types and "
"functions useful in most Idris projects."
msgstr ""
"GitHubで入手できるIdrisのパッケージはほとんどでないとしてもその多くがプログラ"
"ミング用の*ライブラリ*です。これらのライブラリは何らかの機能を実装していて、"
"与えられたパッケージに依存する全てのプロジェクトで使うことができるものです。"
"これはIdrisの*アプリケーション*とは違います。アプリケーションは実行ファイルに"
"コンパイルしてコンピュータで走らせられるもののはずです。Idrisのプロジェクト自"
"体は両方を提供しています。1つはIdrisのコンパイラのアプリケーションで、Idrisの"
"ライブラリとアプリケーションを型検査してビルドするのに使います。もう1つは"
"*prelude*、*base*、*contrib*のようないくつかのライブラリで、ほとんどのIdrisの"
"プロジェクトで便利な基本的なデータ型と関数を提供します。"

#. type: Plain text
#: ../src/Appendices/Projects.md:810
msgid ""
"In order to type check and install the modules you wrote in a library, you "
"must list them in the `.ipkg` file's `modules` field.  Here is an excerpt "
"from the *sop* package:"
msgstr ""
"ライブラリで書いたモジュールを型検査してインストールするためには、`.ipkg`ファ"
"イルの`modules`フィールドにそれらを列挙しなければなりません。以下は*sop*パッ"
"ケージからの抜粋です。"

#. type: Fenced code block (ipkg)
#: ../src/Appendices/Projects.md:811
#, no-wrap
msgid ""
"modules = Data.Lazy\n"
"        , Data.SOP\n"
"        , Data.SOP.Interfaces\n"
"        , Data.SOP.NP\n"
"        , Data.SOP.NS\n"
"        , Data.SOP.POP\n"
"        , Data.SOP.SOP\n"
"        , Data.SOP.Utils\n"
msgstr ""
"modules = Data.Lazy\n"
"        , Data.SOP\n"
"        , Data.SOP.Interfaces\n"
"        , Data.SOP.NP\n"
"        , Data.SOP.NS\n"
"        , Data.SOP.POP\n"
"        , Data.SOP.SOP\n"
"        , Data.SOP.Utils\n"

#. type: Plain text
#: ../src/Appendices/Projects.md:824
msgid ""
"Modules missing from this list will *not* be installed and hence will not be "
"available for other packages depending on the sop library."
msgstr ""
"この一覧に欠けているモジュールはインストール*されず*、そのためsopライブラリに"
"依存する別のパッケージからは決して利用できません。"

#. type: Title ###
#: ../src/Appendices/Projects.md:825
#, no-wrap
msgid "Pack and its curated Collection of Packages"
msgstr "packと厳選されたパッケージのコレクション"

#. type: Plain text
#: ../src/Appendices/Projects.md:833
msgid ""
"When the dependency graph of your project is getting large and complex, that "
"is, when your project depends on many libraries, which themselves depend on "
"yet other libraries, it can happen that two packages depend both on "
"different - and, possibly, incompatible - versions of a third package.  This "
"situation can be nigh to impossible to resolve, and can lead to a lot of "
"frustration when working with conflicting libraries."
msgstr ""
"プロジェウトの依存関係グラフがより大きく複雑なものになってきたとき、つまりプ"
"ロジェクトが多くのライブラリに依存していて、そのライブラリもまた他のライブラ"
"リに依存しているとき、2つのパッケージが両方とも、第三のパッケージの異なる……そ"
"して非互換の可能性がある……バージョンに依存しているということは起こりえます。"
"この状況は解決することが不可能に近いことがあり、競合するライブラリに対処する"
"際はかなりいらいらすることになりかねません。"

#. type: Plain text
#: ../src/Appendices/Projects.md:841
msgid ""
"It is therefore the philosophy of the pack project to avoid such a situation "
"from the very beginning by making use of *curated package collections*. A "
"pack collection consists of a specific Git commit of the Idris compiler and "
"a set of packages, again each at a specific Git commit, all of which have "
"been tested to work well and without issues together. You can see a list of "
"packages available to pack [here](https://github.com/stefan-hoeck/idris2-"
"pack-db/blob/main/STATUS.md)."
msgstr ""
"したがってpackプロジェクトの考え方として、そのような状況を避けるために、初め"
"から*厳選されたパッケージコレクション*を活用することとしています。packのコレ"
"クションはIdrisのコンパイラとパッケージの集まりからなるGitのコミットから構成"
"されており、それぞれのGitのコミットについて、コレクション中の全てのものが一緒"
"に使っても正常に動作し問題がないことを検査されているのです。packで使えるパッ"
"ケージの一覧は[here](https://github.com/stefan-hoeck/idris2-pack-db/blob/"
"main/STATUS.md)で見ることができます。"

#. type: Plain text
#: ../src/Appendices/Projects.md:852
msgid ""
"Whenever a project you are working on depends on one of the libraries listed "
"in pack's package collection, pack will automatically install it and all of "
"its dependencies for you. However, you might also want to depend on a "
"library that is not yet part of pack's collection. In that case, you must "
"specify the library in question in one of your `pack.toml` files - the "
"global one found at `$HOME/.pack/user/pack.toml`, or one local to your "
"current project or one of its parent directories (if any).  There, you can "
"either specify a dependency local to your system or a Git project (local or "
"remote). An example for each is shown below:"
msgstr ""
"作業しているプロジェクトがpackのパッケージコレクションの一覧にあるライブラリ"
"の1つに依存しているなら、packは自動的にそのライブラリとその依存関係インストー"
"ルしてくれます。しかしpackのコレクションにまだ含まれていないライブラリへの依"
"存関係を作りたいこともあるでしょう。その場合問題のライブラリをどこかの`pack."
"toml`ファイルに指定しなければなりません。このファイルは、大域的なものだと`"
"$HOME/.pack/user/pack.toml`にあり、ローカルなものは現在のプロジェクトや（もし"
"あれば）その親ディレクトリのどこかにあるものです。そのファイルでは、システム"
"上またはGitのプロジェクト（ローカルまたはリモート）にある依存関係を指定するこ"
"とができます。それぞれについての例は以下の通りです。"

#. type: Fenced code block (toml)
#: ../src/Appendices/Projects.md:853
#, no-wrap
msgid ""
"[custom.all.foo]\n"
"type = \"local\"\n"
"path = \"/path/to/foo\"\n"
"ipkg = \"foo.ipkg\"\n"
"\n"
"[custom.all.bar]\n"
"type   = \"github\"\n"
"url    = \"https://github.com/me/bar\"\n"
"commit = \"latest:main\"\n"
"ipkg   = \"bar.ipkg\"\n"
msgstr ""
"[custom.all.foo]\n"
"type = \"local\"\n"
"path = \"/path/to/foo\"\n"
"ipkg = \"foo.ipkg\"\n"
"\n"
"[custom.all.bar]\n"
"type   = \"github\"\n"
"url    = \"https://github.com/me/bar\"\n"
"commit = \"latest:main\"\n"
"ipkg   = \"bar.ipkg\"\n"

#. type: Plain text
#: ../src/Appendices/Projects.md:872
msgid ""
"As you can see, in both cases you have to specify where the project can be "
"found as well as the name and location of its `.ipkg` file. In case of a Git "
"project, you also need to tell pack the commit it should use.  In the "
"example above, we want to use the latest commit from the `main` branch. We "
"can use `pack fetch` to fetch and store the currently latest commit hash."
msgstr ""
"見ての通り両方の場合について、プロジェクトがどこで見つかるかということと、`."
"ipkg`ファイルの名前と場所を指定せねばなりません。Gitのプロジェクトの場合、使"
"うコミットをpackに伝える必要があります。上の例では`main`ブランチの最新コミッ"
"トを使いたいとしています。`pack fetch`を使って現在の最新コミットのハッシュを"
"格納することができます。"

#. type: Plain text
#: ../src/Appendices/Projects.md:877
msgid ""
"Entries like the ones given above are all that is needed to add support to "
"custom libraries to pack. You can now list these libraries as dependencies "
"in your own project's `.ipkg` file and pack will automatically install them "
"for you."
msgstr ""
"上で与えられているような項目が、packに独自のライブラリの対応を追加するのに必"
"要なことの全てです。これで自分のプロジェクトの`.ipkg`ファイルに依存関係として"
"これらのライブラリを挙げることができ、packはそれらの依存関係を自動的にインス"
"トールしてくれます。"

#. type: Plain text
#: ../src/Appendices/Projects.md:888
msgid ""
"This concludes our section about structuring Idris projects. We have learned "
"about several types of code blocks - `failing` blocks for showing that a "
"piece of code fails to elaborate, `namespace`s for having overloaded names "
"in the same source file, and parameter blocks for sharing lists of "
"parameters between functions - and how to group several source files into an "
"Idris library or application. Finally, we learned how to include external "
"libraries in an Idris project and how to use pack to help us keep track of "
"these dependencies."
msgstr ""
"Idrisのプロジェクトを構築することについての節を締め括ります。いくつかの種類の"
"コードブロックについて学んできました。`failing`ブロックは推敲でコード片が失敗"
"することを示すものであり、`namespace`には同じソースファイル中でオーバーロード"
"された名前があり、引数ブロックは複数の関数で引数のリストを共有するものでし"
"た。そしていくつかのソースファイルを1つのIdrisのライブラリやアプリケーション"
"にまとめる方法についても学びました。最後に、Idrisのプロジェクトに外部のライブ"
"ラリを含める方法とこうした依存関係をpackに管理してもらうための方法を学びまし"
"た。"
