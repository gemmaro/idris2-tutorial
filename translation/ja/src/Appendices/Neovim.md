# 対話的編集をNeovimで

Idrisには多岐にわたる機能があり、
プログラム中の値や式の型を対話的に分析したり、
実装の骨子、ときには与えられた型に基づいて全体のプログラムさえも、書き込んだりしてくれます。
これらの対話的な編集機能はそれぞれのエディタのプラグインを介して使うことができます。
筆者はNeovim利用者なので自分の設定のうちIdrisに関係する部分をここで詳細に述べます。

Neovimでこれら全ての機能を走らせるために必要な主要素は
[idris2-lsp](https://github.com/idris-community/idris2-lsp)
プロジェクトで提供されている実行プログラムです。
この実行プログラムは内部でIdrisのコンパイラAPI (application programming interface) を活用して
編集中のソースコードの構文や型を検査することができます。
idris2-lspはlanguage server protocol (LSP) を介してNeovimと通信しています。
この通信は[idris2-nvim](https://github.com/ShinKage/idris2-nvim)プラグインを通じて立ち上がります。

このチュートリアルで見ていきますが、`idris2-lsp`実行プログラムは構文と型の検査を行えるようにするだけではなく、
追加の対話的編集機能も備えています。
最後にIdrisコンパイラAPIはIdrisのソースコードの意味論的彩色をサポートしています。
つまり、識別子やキーワードの彩色は、
言語の構文に基づくだけではなく（これは*構文彩色*であり、
あらゆる現代的なプログラミング環境やエディタにあるであろう機能です）、
その*意味論*にも基づいているのです。
例えば関数実装の局所変数と最上位関数の名前は、
どちらも構文的にはただの識別子ですが、それぞれ違うように彩色されます。

```idris
module Appendices.Neovim

import Data.Vect

%default total
```

## 立ち上げ

Neovimでの対話的なIdrisの編集方法を全部活用するには、
少なくとも以下のツールがインストールされている必要があります。

* 新しめのバージョンのNeovim（バージョン0.5以降）
* 新しめのバージョンのIdrisコンパイラ（最低でもバージョン0.5.1）
* IdrisコンパイラのAPI
* [idris2-lsp](https://github.com/idris-community/idris2-lsp)パッケージ
* 以下のNeovimプラグイン
  * [idris2-nvim](https://github.com/ShinKage/idris2-nvim)
  * [nvim-lspconfig](https://github.com/neovim/nvim-lspconfig)

`idris2-lsp`プロジェクトにはIdris 2や標準ライブラリ、コンパイラAPIのインストール方法の詳細な説明があります。
この説明に従い、コンパイラと`idris2-lsp`実行プログラムが協調するようにしてください。

Neovimが初めてであれば、`resources`フォルダにある`init.vim`ファイルを使うとよいかもしれません。
その場合必要なNeovimプラグインは既に含まれていますが、
[vim-plug](https://github.com/junegunn/vim-plug)というプラグイン管理をインストールする必要があります。
そのあとで自分の`iniv.vim`ファイルに`resources/init.vim`の全部または一部をコピーしてください（Neovim内で`:help
init.vim`とするとどこでこのファイルを見付けられるのかがわかります）。
`init.vim`ファイルを設定したあとはNeovimを再起動し
`:PlugUpdate`を走らせて必要なプラグインをインストールしてください。

## よくある作業の流れ

使える対話的編集機能を試すために、*Prelude*からいくらかのユーティリティを実装し直していきます。
進めるにあたって既に[導入](../Tutorial/Intro.md)、[関数 その1](../Tutorial/Function1.md)、
そして少なくとも[代数的データ型](../Tutorial/DataTypes.md)の一部を進めているとよいです。
さもないとここで起こっていることが理解しづらいでしょう。

始める前に注意しておきますが、
ソースファイルを編集してディスクに変更を書き込んでいなかったら、
このチュートリアルでお見せするコマンドやアクションは正しく動かないかもしれません。
したがって、ここに載っていることがうまくいかなかったら、
最初に試すことは現在のファイルをささっと保存する (`:w`) ことです。

真偽値の否定から始めましょう。

```idris
negate1 : Bool -> Bool
```

Idrisのコードを書くときにつきものなのは「型第一」という真言に従うことです。
何らかの機能の一部をどのように実装すればよいかのアイディアがもうあるかもしれませんが、
それでも実装を書き始められる前に正確な型を提供する必要があります。
つまり、Idrisでプログラミングするときは
頭の中でアルゴリズムの実装と関連する型について同時に帳尻を合わせなくてはいけず、
両方ともどこまでも複雑になりうるものなのです。
それでも実装からやります？
覚えておいてほしいのですが、
Idrisは私達と同じように少なくとも関数実装の現在の文脈で使える変数とその型の多くを知っているので、
全部自分で試す代わりに道しるべを乞うとよいでしょう。

で、話を続けるために、Idrisに関数本体の骨子について尋ねます。
通常の編集モードで`negate`が宣言されている行にカーソルを持っていき、
`<LocalLeader>a`を素早く連続で入力してください。
`<LocalLeader>`は特別なキーで`init.vim`ファイル中で指定することができます。
`resources`フォルダの`init.vim`を使っていたら、
コンマ文字 (`,`) に設定されています。
その場合上のコマンドは、コンマとそのすぐあとに小文字の "a" が続きます。
Neovimで`:help leader`と`:help localleader`もご参照ください。

Idrisは以下のような実装の骨子を生成するでしょう。

```idris
negate2 : Bool -> Bool
negate2 x = ?negate2_rhs
```

左側に`x`という名前の新しい変数が導入され、右側にはIdrisが*メタ変数*（*虫食い*とも呼ばれます）を加えましたね。
後者は疑問符が前置された識別子です。
関数のこの部分をあとで実装するつもりがあることを、Idrisに合図しているのです。
虫食いの素晴しいところは、その上に*かざして*型や周囲の文脈の値の型を調べられることです。
そうするにはカーソルを虫食いの識別子の上に置いて通常モードで`K`（大文字）を入力します。
これでポップアップが開いて、カーソルの下の変数の型に加え、周囲の文脈の変数の型と数量子が表示されます。
この表示された情報を分離した窓に移すこともできます。
`<LocalLeader>so`と入力すると、この窓を開きつつ、カーソルをかざしたままになります。
情報が新しい窓に現れますが、これには意味論的彩色される利点もあります。
`<LocalLeader>sc`と入力するとこの窓を閉じて元に戻ります。
さあ、`?negate2_rhs`の型と文脈を見てみましょう。

Idrisのほとんどの関数は1つ以上の引数についてのパターン照合によって実装されています。
Idrisは全ての原始的でないデータ型のデータ構築子を知っており、
その通りにパターン照合を書いてくれます。
（この工程は*場合分割*とも呼ばれます。）
カーソルを`negate2`の実装の骨子中にある`x`の上に移動させて、
通常モードで`<LocalLeader>c`を入力してください。
結果は以下のようになるでしょう。

```idris
negate3 : Bool -> Bool
negate3 False = ?negate3_rhs_0
negate3 True = ?negate3_rhs_1
```

見ての通りIdrisは右側のそれぞれの場合に虫食いを挿入しました。
再度それぞれの型を調べることもできますし、直接適切な実装で置き換えることもできます。

これが対話的編集の（筆者にとっての）中核の機能への入口だという結論になります。
メタ変数にかざし、関数の実装の骨子を加え、場合分割する（これはcaseブロックと入れ子のパターン照合でも動きます）。
これらを*今*この瞬間から使い始めるべきです！

## 式検索

時々Idrisが充分関係する型について知っていて、自力で関数の実装を思い付けることがあります。
例えば*Prelude*の関数`either`を実装してみましょう。
型を与えたあと、実装の骨子をつくり、`Either`引数で場合分割すると、
以下のようなものに行き着きます。

```idris
either2 : (a -> c) -> (b -> c) -> Either a b -> c
either2 f g (Left x) = ?either2_rhs_0
either2 f g (Right x) = ?either2_rhs_1
```

Idrisは自力で2つのメタ変数の式を思い付くことができますが、
これは型が充分に限定されているからです。
カーソルをメタ変数の1つの上に移動させ、
通常モードで`<LocalLeader>o`を入力してください。
すると可能な式の骨子（今回の場合は1つのみ）が得られ、
この中から合うものを選べます（もしくは`q`で中断）。

以下は別の例で、関数`maybe`を実装し直したものです。
`?maybe2_rhs1`で式検索を走らせるともっと選択肢が多くなります。

```idris
maybe2 : b -> (a -> b) -> Maybe a -> b
maybe2 x f Nothing = x
maybe2 x f (Just y) = ?maybe2_rhs_1
```

Idrisは時々関数の型に基づいて完全な関数の実装を思い付けることもあります。
これが実際にうまくいくのは型検査を満足する可能な実装が充分に少なくなければいけません。
例として以下は関数`zipWith`のベクタ用のものです。
ベクタについてまだ聞いたことがないかもしれませんが、
これは[依存型](../Tutorial/Dependent.md)についての章で紹介されます。
それでも式検索の効果を確認するために試してみることはできます。
`zipWithV`を宣言している行にカーソルを移動させ、
`<LocalLeader>gd`を入力して最初の選択肢を選ぶ、それだけです。
こうすると自動的に場合分割と実装を含む関数全体が生成されます。

```idris
zipWithV : (a -> b -> c) -> Vect n a -> Vect n b -> Vect n c
```

式検索は充分に特化された型のときにのみうまくいきます。
今がそのときだと思ったら、
`<LocalLeader>o`をメタ変数の上で走らせるか、
`<LocalLeader>gd`を関数制限の上で試してみるか、
どちらかをぜひやってみてください。

## もっとコードアクション

他にもコードの一部を生成することができるショートカットがあり、
そのうち2つをここで述べます。

1つ目として、通常モードのときにメタ変数上で`<LocalLeader>mc`を入力することで新しいcaseブロックを加えられます。
例えば以下は代数的データ型についての章の中の演習で登場する`filterList`の実装の一部です。
ここまで辿り着くのに、Idrisに実装の骨子の生成、
場合分割、最初のメタ変数での式検索をしてもらったところです。

```idris
filterList : (a -> Bool) -> List a -> List a
filterList f [] = []
filterList f (x :: xs) = ?filterList_rhs_1
```

次に`x`を`f`に適用した結果をパターン照合しなければいけません。
カーソルをメタ変数`?filterList_rhs_1`の上に持っていき、
通常モードで`<LocalLeader>mc`と入力すれば、
Idrisは新しいcaseブロックを導入してくれます。
それから、まず式 (`f x`) をcaseブロックで使えるように与えて、
次にcaseブロック中の新しい変数上で場合分割して実装を続けられます。
これにより以下のような実装になります。
（ただし字下げは修正せねばなりませんでしたが。）

```idris
filterList2 : (a -> Bool) -> List a -> List a
filterList2 f [] = []
filterList2 f (x :: xs) = case f x of
  False => ?filterList2_rhs_2
  True => ?filterList2_rhs_3
```

時々、作業中の実装からユーティリティ関数を取り出したいことがあります。
例えばこれは、コードについての証明を書くときに、よく便利だったり果ては必要だったりします（[命題の等価性](../Tutorial/Eq.md)や[前提条件](../Tutorial/Predicates.md)などの章を見てください）。
そうするためにはカーソルをメタ変数の上に移動させて`<LocalLeader>ml`と入力すればできます。
以下の例の`?whatNow`で試してみてください（これは通常のIdrisのソースファイルのほうが、
私がこのチュートリアルで使用している文芸的ファイルよりもうまくいくでしょう）。

```idris
traverseEither : (a -> Either e b) -> List a -> Either e (List b)
traverseEither f [] = Right []
traverseEither f (x :: xs) = ?whatNow x xs f (f x) (traverseEither f xs)
```

Idrisは`?whatNow`の型と名前を持つ新しい関数宣言を作ります。
作られた関数は現在スコープにある全ての変数を引数として取ります。
また、`traverseEither`中の虫食いをこの新しい関数の呼び出しで置き換えます。
大抵はその後に手ずから不要な引数を削除しなければいけないでしょう。
こうすると以下の版に行き着きます。

```idris
whatNow2 : Either e b -> Either e (List b) -> Either e (List b)

traverseEither2 : (a -> Either e b) -> List a -> Either e (List b)
traverseEither2 f [] = Right []
traverseEither2 f (x :: xs) = whatNow2 (f x) (traverseEither f xs)
```

## 情報を得る

`idris2-lsp`実行プログラムと介在する`idris2-nvim`プラグインがサポートしているのは、
上で述べたコードアクションだけではありません。
以下は他の機能の非網羅的な一覧です。
それぞれをこのソースファイルの中で試してみてください。

* 識別子や演算子の上にいるとき通常モードで`K`と打つと（もしあれば）型と名前空間が出ます。
  メタ変数の場合は現在の文脈も型と数量子とともに表示されます。
  （数量子は[関数 その2](../Tutorial/Functions2.md)で説明されます。）
  ポップアップが好きでなければ、`<LocalLeader>so`とすると代わりに新しい窓が開き、
  この情報が意味論的彩色されて表示されます。
* 通常モードで、関数、演算子、データ構築子、型構築子の上にいるとき`gd`と打つと、その定義に飛びます。
  外部モジュールの場合、これは対象のモジュールがソースコードと一緒にインストールされているときにのみ機能します。
  （ソースコードのインストールには`idris2 --install-with-src`コマンドを使います。）
* `<LocalLeader>mm`と打つと、ポップアップ窓を開いて現在のモジュール中の全てのメタ変数を一覧にします。
  カーソルを項目の上に置いて`<Enter>`を押せばその場所に飛ぶことができます。
* `<LocalLeader>mn` (`<LocalLeader>mp`) と打つと現在のモジュール中の次（前）のメタ変数に飛びます。
* `<LocalLeader>br`と打つとポップアップが開き、そこに名前空間を入力できます。
  そうするとIdrisはポップアップ窓の中にその名前空間から輸出されている全ての関数（とその型）を出し、
  項目のうち1つの上でエンターを押すと関数の定義に飛ぶことができます。
  なお、モジュールは現在のソースファイルでインポートされていなくてはいけません。
* `<LocalLeader>x`と打つと、ポップアップが開いてREPLコマンドやIdrisの式を入力でき、
  プラグインはREPLからの応答で返信します。
  この導入書の主部にあるREPLの例については、いつでもNeovimからこのショートカットをで試すことができますよ。
* `<LocalLeader><LocalLeader>e`と打つと現在の行からのエラー文言をポップアップ窓に表示します。
  これはエラー文言が1行に収まらないほどに長すぎるときに大変便利です。
  同様に`<LocalLeader><LocalLeader>el`は新しい窓で現在のバッファからの全てのエラー文言を一覧にします。
  エラー文言を選択して`<Enter>`を押すとその出自に飛ぶことができます。

他のユースケースや例は`idris2-nvim`プラグインのGitHubのページで記述されており、
そちらで記述されているように設定に含められます。

## `%name`プラグマ

Idrisに`<LocalLeader>a`で実装の骨子を尋ねたり`<LocalLeader>c`で場合分割したりしたとき、Idrisは導入する新しい変数にどの名前を使うべきかを決めなくてはなりません。
もしこの変数が既に事前に定義された名前（関数の処方、レコードフィールド、名前付きのデータ構築子の引数）だったら、その名前が使われるでしょうが、そうでないときは既定で`x`、`y`、`z`や他の文字を使います。
この既定の挙動は変えることができ、どんなデータ型についてもそのような状況で使うべき名前の一覧を指定することができます。

例えば以下です。

```idris
data Element = H | He | C | N | O | F | Ne

%name Element e,f
```

そしてIdrisはこの型の変数名を自分で思い付かなければいけないときに、
この名前（この名前に続いて適宜増加させた整数を後置します）を使います。
例えば以下はお試しの関数で、定義の骨子を加えたものです。

```idris
test : Element -> Element -> Element -> Element -> Element -> Element
test e f e1 f1 e2 = ?test_rhs
```

## まとめ

`idris2-lsp`実行プログラムと`idris2-nvim`エディタプラグインを備えたNeovimは、Idrisでのプログラミングをする際に対話的編集のための豊富なユーティリティを提供します。
似た機能は別のエディタで利用できるので、読者の選んだエディタでどんなことができるのか[Idris 2
Discordチャンネル](https://discord.gg/UX68fDs2jc)で気軽に尋ねてください。

<!-- vi: filetype=idris2:syntax=markdown
-->
