# 導入

Idris 2 入門へようこそ。
ここではプログラミング言語 Idris 2 のできるだけ多くの側面を扱ってみることにします。
ここにある全ての `.md` ファイルは文芸的 Idris ファイルです。
つまり、Markdownで書かれていて（だから `.md` で終わります）、
Idris のコードブロックを混じえつつ GitHub で綺麗に表示され、
そして Idris のコンパイラで型検査とビルドができます（これについては後述）。
ただし、通常の Idris のソースファイルは `.idr` で終わりますし、
ここで私がやっているようにコードよりも地の文をかなり多く書かない限り、
そのファイルの種類を使うものです。
この入門のあとに、
いくつかの演習問題を解くことになりますが、
解答は `src/Solutions` サブフォルダにあります。
そこでは通常の `.idr` ファイルにしています。

始める前にシステムにIdrisコンパイラがインストールされていることを確かめてください。
この入門全体を通じて、*pack*パッケージ管理をインストールし[こちら](../Appendices/Install.md)に解説されているようにパッケージの骨組を準備していることを前提とします。
何らかの別の方法でインストールしたIdrisコンパイラ単体で読み進めることも確かにできますが、REPLセッションを始めたり実行ファイルをビルドしたりするには調整が必要となるでしょう。

あらゆる Idris のソースファイルにおいて、モジュール名といくらかの必要となるインポートから始まるのが典型で、本稿も例外ではありません。

```idris
module Tutorial.Intro
```

モジュール名はドットで区切られた識別子の連なりからなっており、
フォルダの構造とモジュールファイル名を反映したものでなくてはいけません。

## プログラミング言語Idrisについて

Idrisは *純粋* で *依存型* で *全域* な *関数型* プログラミング言語です。
この節でこれらの形容詞について簡単に説明します。

### 関数型プログラミング

関数型プログラミング言語では、関数は第一級の構築子です。
というのは、関数は変数に代入することができますし、他の関数の引数に渡すことができますし、そして関数の結果として返すこともできます。
オブジェクト指向プログラミング言語などとは異なり、関数型プログラミングでは、抽象化が主に関数の形式で行われます。
つまり、プロジェクトのいくつかの箇所で共通するパターンや（ほぼ）同じコードを見つけたときは、いつでも該当のコードをたった一度だけ書けばいいように抽象化を試みるのです。
これには、その挙動を実装する1つ以上の新しい関数を導入します。
そうするにあたっては、できる限り関数が様々なことをこなせるよう、可能な限り一般化されたものになるようにします。

関数型プログラミング言語では関数の演算に着目しますが、
これは古典的な手続き型言語とは違います。
手続き型言語では文の実行に着目していました。

### 純粋関数型プログラミング

純粋関数型プログラミング言語は、
関数型プログラミング言語に重要な保証がついたものです。
その保証とは、関数が副作用を持たないことで、
例えばファイルへの書き込みや大域状態の変更を行いません。
関数は引数から結果を計算するもので、
他の純粋な関数を呼び出すかもしれませんが、
*その他には何も呼び出しません*。
その結果として、
同じ入力があったとすると、
*常に* 同じ出力を生成することになります。
この性質は[参照透過性](https://en.wikipedia.org/wiki/Referential_transparency)として知られています。

純粋な関数にはいくつかの利点があります。

* 複数の入力の引数と期待値を指定することにより、簡単に関数をテストできます。
  使用する値は乱択して生成することもできます。

* 関数はスレッド安全です。
  なぜなら大域状態を変更しないからです。
  そして、並列実行される計算でも自由に使えます。

純粋な関数にももちろん欠点があります。

* 純粋関数だけでは、効率良く実装することが困難なアルゴリズムがあります。

* 実際に何かを *する* プログラム（何らかの観測可能な効果を伴う）を書くのにひと工夫いることです。
  でも、確実にできます。

### 依存型

Idrisは強力かつ静的に型付けされたプログラミング言語です。つまり、あらゆるIdrisの式には
*型*（例えば整数、文字列のリスト、真偽値、整数から真偽値への関数など）があり、型はコンパイル時に検証されます。この時点でプログラミングにおいてよくあるエラーを排除できます。

例えば、もしある関数が `String` 型（unicode文字の連なりで、 `"Hello123"` など）
の引数を期待しているとすれば、
この関数を `Integer` 型で呼び出すと *型エラー* になります。
そして、Idrisのコンパイラはそのような型付けできていないプログラムから
実行可能プログラムを生成しません。

*静的に型付け*されていることはIdrisコンパイラが*コンパイル時*、つまり走らせられる実行可能ファイルを生成する前に型エラーを捕捉できるということです。
この対極にあるのが*動的に型付け*されたPythonのような言語で、こちらはエラーを*実行時*、つまりプログラムが実行されているときに確認します。
走らせられるプログラムができあがる前に、できる限り多くの型エラーを捕捉することが静的型付け言語の思想です。

さらに言えば、Idrisは*依存型*です。
この依存型というものは、プログラミング言語界隈では最も特徴的な性質の1つです。
Idrisでは型が第一級です。
つまり、型は関数の引数に渡せますし、関数は計算結果として型を返すことができます。
さらにさらに、型は他の*値*に*依存*することもできます。
このことが何を意味するのか、そしてなぜこれが信じられないほど役に立つのかということを、その時が来たときに探っていきましょう。

### 全域関数

*全域*な関数は純粋な関数である必要があります。
つまり全ての取り得る入力について有限の計算過程を経て期待された返却型の値を返すことが保証されています。
全域関数は例外や無限ループで失敗することは決してありませんが、結果を計算するのにいつまでも長い時間が掛かる可能性があります。

Idrisには全域性検査器が組込まれています。この検査器により、書いた関数が証明によって全域であることを検証することができます。Idrisにおける全域性はオプションで有効にするものです。一般に、任意のコンピュータプログラムの全域性の判定は決定不能です（[停止性問題](https://en.wikipedia.org/wiki/Halting_problem)も参照のこと）。しかし、関数に
`total` キーワードの註釈を付けた場合、全域性検査器がその関数をたしかに全域かどうか検証できなければ、Idrisは型エラーとして失敗させます。

## REPLを使う

Idrisには便利なREPL（*Read Evaluate Print
Loop*の頭字語）があります。REPLではちょっとしたアイディアをもとにいじってみたり、書いたばかりのコードで素早く実験したりできます。REPLセッションを始めるためには、以下のコマンドを端末で実行します。

```repl
pack repl
```

そうしたら、Idrisがコマンドを受け付けるようになります。

```repl
     ____    __     _         ___
    /  _/___/ /____(_)____   |__ \
    / // __  / ___/ / ___/   __/ /     Version 0.5.1-3c532ea35
  _/ // /_/ / /  / (__  )   / __/      https://www.idris-lang.org
 /___/\__,_/_/  /_/____/   /____/      Type :? for help

Welcome to Idris 2.  Enjoy yourself!
Main>
```

簡単な計算式を入力してみましょう。
Idrisは式を *評価* して結果を表示します。

```repl
Main> 2 * 4
8
Main> 3 * (7 + 100)
321
```

Idrisでの全ての式には *型* があるので、
型を調べたいですね。

```repl
Main> :t 2
2 : Integer
```

ここで`:t`はIdrisのREPLのコマンド（プログラミング言語Idrisには含まれません）です。
このコマンドは式の型を調べるのに使えます。

```repl
Main> :t 2 * 4
2 * 4 : Integer
```

使いたい型を明示せずに整数リテラルの計算をすると、
Idrisはデフォルトで常に `Integer` を使います。
`Integer` は任意精度の符号付き整数型です。
`Integer` は言語に組込まれている *原始型* の1つです。
他の原始型には、
固定精度で符号付きないし符号なしの整数型 (`Bits8`, `Bits16`, `Bits32`, `Bits64`, `Int8`,
`Int16`, `Int32`, `Int64`)、
倍精度 (64 bit) 浮動小数点小数 (`Double`)、
Unicode文字 (`Char`)、
そしてUnicode文字の連なり (`String`) があります。
その時が来たら、これらの型の多くを使っていきます。

## 最初のIdrisプログラム

この入門ではIdris言語の一部分に触れてみる上でREPLを立ち上げることが多いです。
REPLではドキュメントを読んだり、Idrisのモジュールの中身を調べたりできます。
しかしまずは言語を学び始める上で最小のIdrisのプログラムを書いてみましょう。
なにはともあれ *Hello World* から。

```idris
main : IO ()
main = putStrLn "Hello World!"
```

少ししたら上のコードをもうちょっと詳しく調べます。
でもまずはコンパイルして実行してみたいですね。
このプロジェクトのルートディレクトリで以下を実行してください。
```sh
pack -o hello exec src/Tutorial/Intro.md
```

こうすることで実行可能ファイル `hello` がディレクトリ `build/exec` に作られます。
これはコマンドラインで次のようにして実行できます。
（行頭のドル記号の有無で端末のコマンドとその出力を区別します。）

```sh
$ build/exec/hello
Hello World!
```

packプログラムにはスコープ内（現在のディレクトリないし上位のディレクトリ）に`.ipkg`が必要で、そのファイルから使うソースディレクトリ（ここでは`src`）のような他の設定を取得してきます。
`-o`オプションは生成される実行可能ファイルに名前を付けます。
もしこのオプションがなければPackは自分で名前を出します。
`pack help`とすると、使えるコマンドラインオプションとコマンドが一覧になり、`pack help <コマンド>`とすると特定のコマンドについてのヘルプが得られます。

他の方法としては、ソースファイルをREPLセッションで読み込んで、
`main` 関数を呼び出すというのもあります。

```sh
pack repl src/Tutorial/Intro.md
```

```repl
Tutorial.Intro> :exec main
Hello World!
```

両方のやり方を試してみて、システム上で `main` 関数を実行しましょう！

## Idrisの定義の形

最初のIdrisプログラムを実行したところで、
定義する部分のコードについて話しましょう。

Idrisにおいて最上位で定義された関数は大抵3つの部分から成り立ちます。
関数名（ここでは`main`）、関数の型 (`IO ()`)、そして関数の実装 (`putStrLn "Hello World"`) です。
いくつかの簡単な例を出すとわかりやすいです。
以下では最上位の定数に最大の符号なし8ビット整数を定義しています。

```idris
maxBits8 : Bits8
maxBits8 = 255
```

最初の行は「（引数のない）関数`maxBits8`を定義する。
型は`Bits8`である」のように読めます。
これは*関数宣言*と呼ばれます。
与えられた名前と型を持つ関数があることを宣言するのです。
2行目は「`maxBits8`を呼び出した結果は`255`である」のように読めます（整数リテラルは`Integer`以外の他の数値の型でも使えることが見てとれます）。
これは*関数定義*と呼ばれます。
`maxBits8`関数は評価されるときにここに記述されたように振舞います。

この関数をREPLで調べることができます。
このソースファイルを（前述したように）IdrisのREPLに読み込んで、以下を試しましょう。

```repl
Tutorial.Intro> maxBits8
255
Tutorial.Intro> :t maxBits8
Tutorial.Intro.maxBits8 : Bits8
```

`maxBits8` を他の式の一部として使うこともできます。

```repl
Tutorial.Intro> maxBits8 - 100
155
```

私は`maxBits8`を*無引数関数*と呼びました。
無引数関数は*定数*のちょっと変わった呼び方です。
*正真正銘の*関数を書いて試してみましょう。

```idris
distanceToMax : Bits8 -> Bits8
distanceToMax n = maxBits8 - n
```

この例ではいくつかの新しい文法と新しい種類の型が紹介されています。
それは関数型です。
`distanceToMax : Bits8 -> Bits8`は、「`distanceToMax`は関数で、型が`Bits8`な引数を1つ取って、型が`Bits8`な結果を返す」と読み替えられます。
実装では、引数が局所変数`n`として与えられています。
この変数は右側の計算に使われます。
再びREPLに戻ってこの関数を試しましょう。

```repl
Tutorial.Intro> distanceToMax 12
243
Tutorial.Intro> :t distanceToMax
Tutorial.Intro.distanceToMax : Bits8 -> Bits8
Tutorial.Intro> :t distanceToMax 12
distanceToMax 12 : Bits8
```

最後の例として、整数の2乗を計算する関数を実装しましょう。

```idris
square : Integer -> Integer
square n = n * n
```

ここでIdrisにおけるプログラミングのとても大切な側面を学びましょう。
Idrisは *静的型付け* プログラミング言語です。
好き勝手に型をごちゃ混ぜにすることはできません。
それをすると型検査器がエラー文言を出します（型検査器はIdrisのコンパイル過程の一部です）。
例えば、以下をREPLに打ち込むと、
型エラーが出ます。

```repl
Tutorial.Intro> square maxBits8
Error: ...
```

その理由は、 `square` が `Integer` 型の引数を期待しているのに、
`maxBits8` は型が `Bits8` だからです。
多くの原始型は `cast` 関数（詳細は後述）を使って相互に変換できます（精度が落ちる組み合わせもあります）。

```repl
Tutorial.Intro> square (cast maxBits8)
65025
```

上の例で、結果が `maxBits8` の型での上限よりかなり大きいですね。
なぜかというと、 `maxBits8` はまず同じ値の `Integer` に変換されて、
それから2乗されるからです。
一方でもし `maxBits8` を直接2乗したら、
結果は `Bits8` の正しい範囲に収まるように切り詰められます。

```repl
Tutorial.Intro> maxBits8 * maxBits8
1
```

## 困ったときは

オンラインや刊行物の形でいくつかの資料があります。
それらのプログラミング言語Idrisのドキュメントは役に立つでしょう。
全ては紹介しきれませんが、次のようなものがあります。

* [Type-Driven Development with
  Idris](https://www.manning.com/books/type-driven-development-with-idris)

  *唯一の* Idrisの書籍です！
  堅牢で簡潔なコードを書くために、Idrisと依存型を使う上での核となる概念がとても詳しく書かれています。
  例ではIdris 1が使われているので、Idris 2で使うためには一部分を少しだけ調整する必要があります。
  [更新が必要な箇所の一覧](https://idris2.readthedocs.io/en/latest/typedd/typedd.html)もあります。

* [A Crash Course in Idris
  2](https://idris2.readthedocs.io/en/latest/tutorial/index.html)

  公式のIdris 2入門です。
  網羅的で密度の濃いIdris 2の特徴の説明があります。
  広くアクセスできるため、筆者にとっては参考情報として重宝しています。
  しかし、一般には関数型プログラミングや型駆動開発の導入ではありません。

* [Idris 2のGitHubリポジトリ](https://github.com/idris-lang/Idris2)

  ここにはインストール方法や導入資料があります。
  [Wiki](https://github.com/idris-lang/Idris2/wiki)もあって、[エディタのプラグインの一覧](https://github.com/idris-lang/Idris2/wiki/The-Idris-editor-experience)、[コミュニティによるライブラリの一覧](https://github.com/idris-lang/Idris2/wiki/Libraries)、[バックエンドの一覧](https://github.com/idris-lang/Idris2/wiki/External-backends)、などの役に立つ情報が載っています。

* [Idris 2のDiscordチャンネル](https://discord.gg/UX68fDs2jc)

  コードの一部で詰まったり、よくわからない言語の特徴について質問したいとき、自分の新しいライブラリを宣伝したいとき、あるいは他のIdrisプログラマと駄弁りたいときとかには、こちらにお越しください。
  Discordチャンネルはかなり活発で、新参者に *とっても* 優しいです。

* IdrisのREPL

  最後に、沢山の役に立つ情報はIdris自身から提供されます。
  筆者はIdrisでプログラミングするときはずっと、最低でも1つのREPLセッションを立ち上げたままにしがちです。
  私が使っているエディタ (neovim) には[Idris2のlanguage server](https://github.com/idris-community/idris2-lsp)が設定されています。
  idris2-lspは大変便利です。
  REPLでは、

  * `:t`で式やメタ変数（穴開き）の型を調べられます。
    例えば`:t foldl`とします。
  * `:ti`で暗黙の引数を含む関数の型を調べられます。
    例えば`:ti foldl`とします。
  * `:m`で、スコープ内の全てのメタ変数（穴開き）の一覧が出てきます。
  * `:doc`でドキュメントにアクセスできます。
    最上位の関数（`:doc the`）、データ型とその型の構築子と使えるヒント（`:doc Bool`）、言語の特徴（`:doc case`,
    `:doc let`, `:doc interface`, `:doc record`, `:doc ?`
    まで）、それからインターフェース（`:doc Uninhabited`）が対象です。
  * `:module`で、使えるパッケージの中からモジュールをインポートします。
    例えば`:module Data.Vect`とします。
  * `:browse`で、読み込むモジュールが提供している全ての関数の名前と型の一覧が出てきます。
    例えば`:browse Data.Vect`とします。
  * `:help`で、他のコマンドとそれぞれの短い説明が一覧で表示されます。

## まとめ

この導入ではプログラミング言語Idrisの一番基本的なことを学びました。
REPLで考えていることを試したり、
コード中の型を調べたり、
IdrisのソースファイルをIdrisのコンパイラで実行可能ファイルにしたりしました。

Idrisでの最上位での定義の仕方の基本的な形を学びました。
定義には、識別子（名前）、型、そして実装があるのでした。

### お次は？

[次の章](Functions1.md)では、実際にIdrisでのプログラミングを始めます。
自分で純粋な関数を書く方法や、関数を組み合わせる方法、そして関数を他の値と同じように扱ったり他の関数の引数として渡したりする方法を学びます。

<!-- vi: filetype=idris2:syntax=markdown
-->
