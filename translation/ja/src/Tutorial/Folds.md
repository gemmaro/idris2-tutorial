# 再帰と畳み込み

この章では*容器型*を扱う際の典型的な計算について迫ります。
容器型とは`List`、`Maybe`、あるいは`Identity`といった引数を取るデータ型で、
引数の型の値をゼロ個以上保有するものです。
これらの機能は再帰に根差しているため、一般的な再帰についての議論、
特に重要な最適化技法としての末尾再帰の議論から始めます。
この部にあるほとんどの再帰関数はリスト上の純粋な繰り返しを記述します。

再帰関数というものはその全域性が決定しづらいものなので、
次に全域性検査器を軽く見ていきます。
そして、いつ関数の全域性の承諾が拒まれるのか、そんなときどうすればよいのかについて学びます。

最後に再帰関数においてよくある様式を見ていきます。
最初の部分から始まり、最終的には容器型を消費する新しいインターフェース`Foldable`を導入します。

```idris
module Tutorial.Folds

import Data.List1
import Data.Maybe
import Data.Vect
import Debug.Trace

%default total
```

## 再帰

この節で一般的な再帰と特に末尾再帰に迫ります。

再帰関数とは、何らかの中断条件（*既定場合*と呼ばれます）が満たされる手前まで、
自分自身を呼び出してタスクや計算を繰り返す関数です。
注意していただきたいのですが、再帰関数が全域性を確証しづらくするものだということです。
*網羅的*な（パターン照合で全ての可能な場合を押さえているような）非再帰関数は、
他の全域関数を呼び出すときだけ、自動的に全域になります。

以下は再帰関数の一例です。
同じ値でもって、与えられた長さのリストを生成します。

```idris
replicateList : Nat -> a -> List a
replicateList 0     _ = []
replicateList (S k) x = x :: replicateList k x
```

見てみると（このモジュールの一番上に`%default total`がありますが）この関数は全域であることが証明されています。
`Nat`引数がそれぞれの再帰呼び出しで*厳密に小さく*なることを、
そして関数が最終的に終わりに向かう*はず*だということを、
Idrisは確証しています。
もちろん同じことを`Vect`についても行えますが、
こちらについては結果のベクタの長さが与えられた自然数に合致することさえ示すことができます。

```idris
replicateVect : (n : Nat) -> a -> Vect n a
replicateVect 0     _ = []
replicateVect (S k) x = x :: replicateVect k x
```

よく再帰を使って`List`や`Vect`のようなデータ型の値を*つくり*ますが、
そのような値を*消費*するときにも再帰は使います。
例えば以下はリストの長さを計算する関数です。

```idris
len : List a -> Nat
len []        = 0
len (_ :: xs) = 1 + len xs
```

またもやIdrisは`len`が全域であると確証できますが、
これは再帰場合に渡したリストが元のリスト引数より厳密に小さくなるためです。

しかしいつ再帰関数は非全域なのでしょうか。
こちらがその一例です。
以下の関数は与えられた生成関数 (`gen`) が`Nothing`を返す手前まで値の並びをつくります。
（汎化型`s`の）*状態*値や次の状態とともに値を計算するための`gen`の使われかたに注目してください。

```idris
covering
unfold : (gen : s -> Maybe (s,a)) -> s -> List a
unfold gen vs = case gen vs of
  Just (vs',va) => va :: unfold gen vs'
  Nothing       => []
```

`unfold`については、任意の引数が既定場合に向かっていくかどうか、Idrisは確証できません。
したがって当然`unfold`が全域であると認めることを拒みます。
そしてもちろん以下の関数は無尽蔵のリストを生成します。
（ですからどうかこれをREPLで調べようとしないでください。
そうしてしまうとコンピュータの全てのメモリを消費してしまうでしょうから。）

```idris
fiboHelper : (Nat,Nat) -> ((Nat,Nat),Nat)
fiboHelper (f0,f1) = ((f1, f0 + f1), f0)

covering
fibonacci : List Nat
fibonacci = unfold (Just . fiboHelper) (1,1)
```

安全に（終端のある）フィボナッチ数の並びをつくるためには、
終端となる過程の数のあとに関数が並びの生成を停止することが確実でなくてはいけません。
例えばリストの長さを制限すればよいです。

```idris
unfoldTot : Nat -> (gen : s -> Maybe (s,a)) -> s -> List a
unfoldTot 0     _   _  = []
unfoldTot (S k) gen vs = case gen vs of
  Just (vs',va) => va :: unfoldTot k gen vs'
  Nothing       => []

fibonacciN : Nat -> List Nat
fibonacciN n = unfoldTot n (Just . fiboHelper) (1,1)
```

### 呼び出しスタック

末尾再帰がどんなものか実演するためには、以下の`main`関数が要ります。

```idris
main : IO ()
main = printLn . len $ replicateList 10000 10
```

[Node.js](https://nodejs.org/en/)がシステムにインストールされていれば、
以下の実験をやってみることができます。
Idrisの既定の*Chez Schema*バックエンドの代わりに*Node.js*バックエンドを使ってこのモジュールをコンパイルして走らせてください。
実行するには結果的に得られるJavaScriptソースファイルをNode.jsバイナリで走らせます。

```sh
idris2 --cg node -o test.js --find-ipkg -src/Tutorial/Folds.md
node build/exec/test.js
```

Node.jsは以下のエラー文言と長々としたスタックトレース`RangeError: Maximum call stack size
exceeded`とともに失敗するでしょう。
ここで何が起こっているのでしょうか。
全域なことが証明されているのに、どうして`main`が例外で落ちることがありえるのでしょうか。

まず覚えておいてほしいことは、関数が全域であるということの意味は、
その関数が最終的に有限の時間量で与えられた型の値を生成することですが、
それは*コンピュータメモリのような充分な資源あってこそです*。
ここで`main`は充分なリソースを与えられていませんでしたが、
これはNode.jsが呼び出しスタックにとても小さい量での上限を設けているからです。
*呼び出しスタック*はスタックのデータ構造（先入れ後出し）のように考えられます。
この構造では入れ子の関数呼び出しが置かれます。
再帰関数の場合、スタックの大きさは再帰関数呼び出しのたびに1つ増えます。
ここでの`main`関数の場合、長さ10,000のリストを作って消費しているので、
コールスタックは呼び出される前に少なくとも10,000個の関数呼び出しを保有しており、
そこからスタックの大きさは減少に転じていきます。
これがNode.jsのスタックの大きさ上限を遥かに越えてしまっているので、オーバーフローエラーになったのです。

さて、この問題をどのように回避するかの解法を見る前に、
これがIdrisのJavaScriptバックエンドを使うときに、とても深刻でありつつも、
バグの温床を抑えていることを覚えておいてください。
Idrisでは`for`や`while`の繰返しのような制御構造を使うことができず、
反復計算を記述するためには*常に*再帰を使わざるを得ないのです。
幸運にも（あるいは「不運にも」と言うべきでしょうか、
というのもこの問題は既に全ての深刻性について対処されているためです）、
Schemeバックエンドにはこの問題を抱えておらず、
それはスタックの大きさ上限が遥かに大きく、
呼び出しスタックのオーバーフローを防ぐためにあらゆる類の内部的な最適化を施すためです。

### 末尾再帰

再帰関数の中には*末尾再帰*であると言われるものがありますが、
これは全ての再帰呼び出しが*末尾位置*で起こるときに指します。
末尾位置とは（部分）式中の最後の関数です。
例えば以下の`len`のバージョンは末尾再帰です。

```idris
lenOnto : Nat -> List a -> Nat
lenOnto k []        = k
lenOnto k (_ :: xs) = lenOnto (k + 1) xs
```

これを前に定義した`len`と比較してください。
`len`では最後の関数呼び出しが演算子`(+)`の呼び出しであり、
再帰呼び出しは引数のうちの1つで起こっていました。

```repl
len (_ :: xs) = 1 + len xs
```

`lenOnto`から余分な`Nat`引数をなくし、`len`の末尾再帰版を実装するための小間物として使えます。

```idris
lenTR : List a -> Nat
lenTR = lenOnto 0
```

これは末尾再帰関数を書くときによくある様式です。
つまり、追加の関数引数を中間結果に累積するために追加するのが典型的です。
この引数はそれぞれの再帰呼び出しで明示的に渡されます。
例えば以下は`replicateList`の末尾再帰版です。

```idris
replicateListTR : Nat -> a -> List a
replicateListTR n v = go Nil n
  where go : List a -> Nat -> List a
        go xs 0     = xs
        go xs (S k) = go (v :: xs) k
```

末尾再帰関数の大きな利点は、Idrisコンパイラによって効率的で命令的な、
すなわち*スタック安全*な繰返しに簡単に変換できることです。
再帰関数呼び出しは呼び出しスタックに加えられ*ません*ので、
悪夢のようなスタックオーバーフローエラーを避けられるのです。

```idris
main1 : IO ()
main1 = printLn . lenTR $ replicateListTR 10000 10
```

改めてを*Node.js*バックエンドを使って`main1`を走らせます。
今回は僅かに異なる構文を使って`main`以外の関数を実行しています。
（いいですか。ドル記号の前置は端末のコマンドとその結果を区別するためだけにありますよ。
ドル記号は端末のセッションで入力するコマンドの一部ではありません。）

```sh
$ idris2 --cg node --exec main1 --find-ipkg src/Tutorial/Folds.md
10000
```

見てとれるように今回は計算が呼び出しスタックが溢れることなしに終了しました。

末尾再帰関数を（入れ子になりうる）パターン照合で構成することも可能です。
パターン照合の複数の分岐それぞれで末尾位置での再帰呼び出しがあります。
以下は一例です。

```idris
countTR : (a -> Bool) -> List a -> Nat
countTR p = go 0
  where go : Nat -> List a -> Nat
        go k []        = k
        go k (x :: xs) = case p x of
          True  => go (S k) xs
          False => go k xs
```

それぞれの`go`の呼び出しがcase式の分岐の末尾位置にあることに着目してください。

### 相互再帰

複数の関連する、すなわちお互いに再帰的に呼び出す関数を実装すると便利なときがあります。
Idrisでは他の多くのプログラミング言語とは異なり、
関数は他の関数に呼び出されるより*前*にソースファイルで定義されなくてはいけません。
というのも一般的に関数の実装が型検査中に利用できなくてはいけないからです。
（Idrisが依存型であるためです。）
これには2つの方法があり、実際にはコンパイラ中で同じ内部表現に落ち着きます。
最初の選択肢は関数の宣言を最初に書き下し、そのあとに実装が続くようにすることです。
以下は他愛ない例です。

```idris
even : Nat -> Bool

odd : Nat -> Bool

even 0     = True
even (S k) = odd k

odd 0     = False
odd (S k) = even k
```

見ての通り、関数`even`は実装で関数`add`を呼ぶことができていますが、
これは`odd`が既に宣言されている（でも実装はまだ）からです。

宣言と実装がお互いに隣り合っている状態を維持したければ、
`mutual`ブロックを導入することができます。
このブロックには上と同じ効果があります。
他のコードブロックと同様に`mutual`ブロック中の関数は全て同量の空白で字下げされていなくてはなりません。

```idris
mutual
  even' : Nat -> Bool
  even' 0     = True
  even' (S k) = odd' k

  odd' : Nat -> Bool
  odd' 0     = False
  odd' (S k) = even' k
```

ちょうど単一再帰関数と同じように、
相互再帰関数は再帰呼び出しが末尾位置で起こっているときに命令的な繰返しに最適化することができます。
これは関数`even`や`odd`についても言え、
そのためここでも*Node.js*バックエンドで確かめることができます。

```idris
main2 : IO ()
main2 =  printLn (even 100000)
      >> printLn (odd 100000)
```

```sh
$ idris2 --cg node --exec main2 --find-ipkg src/Tutorial/Folds.md
True
False
```

### 総括

この節ではいくつかの重要な再帰と全域性検査の側面について学びました。
以下に要約します。

* 純粋関数型プログラミングでは再帰は繰返し手順を実装する手段である。

* 再帰関数が全域性検査器を通るのは、引数の1つが各再帰関数呼び出しで厳密に小さくなることが確かめられるときである

* 小さいスタックの大きさ上限を持つバックエンドでは、任意の再帰はスタックオーバーフロー例外に繋がりうる。

* IdrisのJavaScriptバックエンドは相互末尾呼び出し最適化を実施する。
  末尾再帰関数はスタック安全で命令的な繰返しに変換される。

なお、巷で遭遇する全てのIdrisバックエンドが末尾呼び出し最適化を施すとは限りません。
対応するドキュメントを確認してください。

これも注意ですが、中核ライブラリ（*prelude*と*base*）のほとんどの再帰関数はまだ末尾再帰を活用していません。
これには大切な理由があります。
多くの場合、非末尾再帰関数はコンパイル時証明で使いやすいのですが、
これは末尾再帰で対応するものより自然に統合が行えるからです。
コンパイル時証明は（後の章で見ていくように）Idrisでプログラミングする上での重要な側面であり、
実行時にいい感じに動くこととコンパイル時にいい感じに動くことの間には折り合いがあります。
ゆくゆく行き着くところは2つの実装を提供することでしょう。
ほとんどの再帰関数には*転轍規則*がついており、
コンパイラに実行時には最適化された版を使うように指示します。
これはプログラマがコードで最適化されていないバージョンを使うときは常に有効です。
そのような転轍規則は、例えば既に関数`pack`と`unpack`に書かれています。
（これらの関数では実行時に`fastPack`と`fastUnpack`を使います。
[リンク先のソースファイル](https://github.com/idris-lang/Idris2/blob/main/libs/prelude/Prelude/Types.idr)中の対応する規則をご参照ください。）

### 演習 その1

この演習ではいくつかの再帰関数を実装していきます。
できる限り末尾再帰を使うようにし、REPLで全ての関数について正しい振舞いをすることを簡単に確かめてください。

1. 関数`anyList`と`allList`を実装してください。
   この関数はリスト中のどれか1つの要素（`allList`の場合は全ての要素）が所与の条件を満足するとき`True`を返します。

   ```idris
   anyList : (a -> Bool) -> List a -> Bool

   allList : (a -> Bool) -> List a -> Bool
   ```

2. 関数`findList`を実装してください。
   この関数は（もしあれば）所与の条件を満足する最初の値を返します。

   ```idris
   findList : (a -> Bool) -> List a -> Maybe a
   ```

3. 関数`collectList`を実装してください。
   この関数は（もしあれば）所与の関数が`Just`を返すような最初の値を返します。

   ```idris
   collectList : (a -> Maybe b) -> List a -> Maybe b
   ```

   `collectList`を使って`lookupList`を実装してください。

   ```idris
   lookupList : Eq a => a -> List (a,b) -> Maybe b
   ```

4. `map`や`filter`のような関数は要素の順番に影響を与えることなくリストを巡回しますが、
   末尾再帰実装を書くことは難しいです。
   末尾再帰にする最も安全な方法は`SnocList`
   （リストの*逆*の類であり、尾鰭から先頭に向かって構築されるのではなく先頭から尾鰭に向かって構築されます。）
   を使うことで中間結果を累積することです。
   この型の2つの構築子は`Lin`と`(:<)`（*snoc*演算子と呼ばれます）です。
   モジュール`Data.SnocList`は*フィッシュ*と*チップス*（`(<><)`と`(<>>)`）
   と呼ばれる2つの末尾再帰演算子を輸出します。
   これは`SnocList`と`List`とを行き来するためのものです。
   演習を続ける前に、全ての新しいデータ構築子と演算子の型を眺めてください。

   `SnocList`を使って写されたリストを再編成することで、`List`に`map`の末尾再帰版を実装してください。
   それから最後に`Nil`引数つきの*チップス*演算子を使って`SnocList`を`List`に変換して戻してください。

   ```idris
   mapTR : (a -> b) -> List a -> List b
   ```

5. 末尾再帰版の`filter`を実装してください。
   この関数は、リスト中の所与の条件を満足する値だけを保持します。
   演習4で記載したのと同じ技法を使ってください。

   ```idris
   filterTR : (a -> Bool) -> List a -> List a
   ```

6. `mapMaybe`の末尾再帰版を実装してください。
   この関数はリスト中の、所与の関数引数が`Just`を返すような値のみを保持します。

   ```idris
   mapMaybeTR : (a -> Maybe b) -> List a -> List b
   ```

   `mapMaybeTR`を使って`catMaybesTR`を実装してください。

   ```idris
   catMaybesTR : List (Maybe a) -> List a
   ```

7. リスト連結の末尾再帰版を実装してください。

   ```idris
   concatTR : List a -> List a -> List a
   ```

8. リストの*束縛*と`join`の末尾再帰版を実装してください。

   ```idris
   bindTR : List a -> (a -> List b) -> List b

   joinTR : List (List a) -> List a
   ```

## 全域性検査について少々補足

Idrisの全域性検査器が確証しているのは、
再帰呼び出しでの少なくとも1つの引数（消去されうるものです！）が、基底の場合に向かって収束することです。
例えば自然数があったとき、基底の場合がゼロ（データ構築子`Z`に対応）であり、
`S k`でパターン照合したあとは`k`で続いているとします。
このときIdrisは`Nat`の構築子を以って、`k`が`S k`より厳密に小さいため、
再帰呼び出しは基底の場合に向かって収束するはずだと導出できるのです。
ちょうど同じ論拠が再帰呼び出しで尾鰭だけで続けるリストのパターン照合で用いられます。

これは多くの場合で機能しますが、常に期待通りにいくわけではありません。
以下では、*私達は*問題の関数が間違いなく全域だとわかるものの、
全域性検査が失敗する例をいくつかお見せします。

### 事例1：原始型での再帰

Idrisは原始的なデータ型の内部構造について何も知りません。
なので以下の関数は明らかに全域ですが、全域性検査が受けつけようとしません。

```idris
covering
replicatePrim : Bits32 -> a -> List a
replicatePrim 0 v = []
replicatePrim x v = v :: replicatePrim (x - 1) v
```

自然数 (`Nat`) は帰納的データ型として定義されコンパイル時にのみ整数の原始型に変換されます。
これとは違い、Idrisには`x - 1`が厳密に`x`よりも小さいかがわからず、
そのためこれが基底の場合に向かって収束するはずだと確証するのに失敗するのです。
（その理由は、`x - 1`が原始関数`prim__sub_Bits32`を使って実装されているからです。
この関数はコンパイラに備わっており、それぞれ個別のバックエンドで実装されていなくてはなりません。）
全域性検査器はIdrisで定義されたデータ型、構築子、関数について知っていますが、
バックエンドで実装された（原始）関数や異邦関数についてはその限りではありません。
理論的には原始型や異邦関数に法則を定義して使うこともできるのですが、
これはまだほとんどのものについて完了していません。

非全域性はかなり感染力が高いため（部分関数を呼び出す全ての関数は全域性検査器によって部分的だと見なされます）、
小間物関数`assert_smaller`があります。
この関数を使えば全域性検査器を説得し、さらに`total`キーワードを関数に註釈付けることができます。

```idris
replicatePrim' : Bits32 -> a -> List a
replicatePrim' 0 v = []
replicatePrim' x v = v :: replicatePrim' (assert_smaller x $ x - 1) v
```

ただし、全域性検査器を静かにさせるために`assert_smaller`を使うときは、
全域性を証明する責任が自分の肩にのしかかっていることに注意してください。
それをし損なうとありとあらゆる予期しないプログラムの振舞いに繋がる可能性があります。
（これはほとんどの他のプログラミング言語でも言えます。）

#### Ex Falso Quodlibet

以下はとある実演で、素朴な`Void`の証明です。
`Void`は*傍若無人型*、つまりは値のない型です。
*`Void`を証明する*ことが意味するのは、全域性検査器に受け入れられる関数を実装することであり、
そんな値はないので不可能でなくてはいけないにも関わらず、この関数は型`Void`の値を返します。
そうすることで型システムと提供されていた全ての保証諸共、完全に無効にすることができます。
以下はコードとその惨憺たる結果です。

```idris
-- `Void`を証明するためには、ただ無限ループさせればよいです。
-- `assert_smaller`を使って全域性検査器を大人しくさせます。
proofOfVoid : Bits8 -> Void
proofOfVoid n = proofOfVoid (assert_smaller n n)

-- 型`Void`の値からはどんなことも従います！
-- 型`Void`の値はないので、この関数は安全で全域なのです！
exFalsoQuodlibet : Void -> a
exFalsoQuodlibet _ impossible

-- voidの証明を`exFalsoQuodlibet`（`void`の名前で*Prelude*から輸出されています）に通すことで、
-- どんな値も別の型の値に押し込むことができます。
-- 異なる型の値に自由に変換できてしまっては、
-- 型検査が全くの役立たずになってしまいました。
coerce : a -> b
coerce _ = exFalsoQuodlibet (proofOfVoid 0)

-- 最後に文字列の代わりに数字で`putStrLn`を呼び出します。
-- `coerce`があればそれさえできてしまいます。
pain : IO ()
pain = putStrLn $ coerce 0
```

しばし証明的に全域な関数`coerce`に嘆じましょう。
この関数は*いかなる*値も*いかなる*他の型の値に変換することができると主張しているのです。
そしてそれは完全に安全で、なぜなら実装で全域関数のみを使っているからです。
問題があるとすれば……もちろん……`proofOfVoid`はどんなことがあろうと全域関数ではないことです。

`pain`で`coerce`を使って整数から文字列をでっち上げました。
最終的には自業自得となります。
要はプログラムがエラーでクラッシュするのです。
事態がこれよりさらに悪くなることもありえたでしょう。
実行にかなりの時間が費された挙句そのようなエラーの発生箇所を見つけ出すのが厄介になる可能性がありますから。

```sh
$ idris2 --cg node --exec pain --find-ipkg src/Tutorial/Folds.md
ERROR: No clauses
```

というわけで、たった1つでも無考えに`assert_smaller`を置くと、
全域性と型安全性が犠牲にされた純粋で全域なコードベースの裡で一挙に大惨事に見舞われるのです。
したがって、自己責任で使ってください！

補足：上のコード中で動いている全ての暗黒魔法を理解することは期待していません。
別の章でその時がきたら詳細をご説明しましょう。

2つめの補足：*Ex falso
quodlibet*、またの名を[爆発の原理](https://en.wikipedia.org/wiki/Principle_of_explosion)は古典論理の法則の1つです。
矛盾からはいかなる記述も証明されたものにできるというものです。
今回の場合、矛盾は`Void`の証明にありました。
`Void`は傍若無人型なのに、そのような値を生み出す全域関数を書いたと主張することがこれにあたるのです。
このことは`Void`をREPLで`:doc Void`で調べれば確かめることができます。
これにはデータ構築子がないのです。

### 事例2：関数呼び出しを介した再帰

以下は[*木薔薇*](https://en.wikipedia.org/wiki/Rose_tree)の実装です。
木薔薇はコンピュータアルゴリズムにおける探索経路を表現することができます。
グラフ理論がその一例です。

```idris
record Tree a where
  constructor Node
  value  : a
  forest : List (Tree a)

Forest : Type -> Type
Forest = List . Tree
```

以下のようにそのような木の大きさの計算を試みることができます。

```idris
covering
size : Tree a -> Nat
size (Node _ forest) = S . sum $ map size forest
```

上のコードでは再帰呼び出しは`map`の内側で起こっており、
*私達は*再帰呼び出しで副木しか使っていないことがわかります。
（どのように`map`が`List`に実装されているか知っているからです。）
でもIdrisはこのことを知らないのです。
（全域性検査器に自力でこれを調べさせることは研究の余地がある問題のようです。）
だから関数が全域であるとして認めることを拒みます。

上記の場合に対処するには2つの方法があります。
少々の余計な紋切り型のコードを書くのが気にならなければ、明示的な再帰を使うことができます。
実際*森*の探索に取り組むこともよくあるので、ここではより好ましい手段です。

```idris
mutual
  treeSize : Tree a -> Nat
  treeSize (Node _ forest) = S $ forestSize forest

  forestSize : Forest a -> Nat
  forestSize []        = 0
  forestSize (x :: xs) = treeSize x + forestSize xs
```

上の場合、それぞれの再帰の工程で何が起こるのか明示しているので、
Idrisは陰で木が膨れ上がらないことを確かめられます。
本事例に向き合う上ではこれが安全で、より好ましい方法です。
この言語や全域性検査を始めたばかりなら特にそうです。

しかし時には上で示した解法を書くのがあまりにも億劫すぎることがあります。
例えば以下は木薔薇への`Show`の実装です。

```idris
Show a => Show (Tree a) where
  showPrec p (Node v ts) =
    assert_total $ showCon p "Node" (showArg v ++ showArg ts)
```

この場合、木のリストに`Show`を手作業で再実装しなくてはなりません。
退屈な仕事であり……それ自体がエラーの温床になります。
代わりに全域性検査器を木っ端微塵にする手段を行使できます。
それが`assert_total`です。
言うまでもなくこれには`assert_smaller`と同じ危険性が付き纏うので、充分注意してください。

### 演習 その2

以下の関数を「ズル」せずに証明的に全域な風に実装してください。
補足：末尾再帰の方法で実装する必要はありません。

<!-- textlint-disable terminology -->
1. 木薔薇に関数`depth`を実装してください。
   これは現在のノードから最も遠くにある小ノードまでの`Node`構築子の最大数を返します。
   例えば現在のノードが深さ1のとき、全ての直接の小ノードは深さが2であり、
   それらの直接の子ノードは深さ3にある、などといった具合です。
<!-- textlint-enable -->

2. インスタンス`Eq`を木薔薇に実装してください。

3. インターフェース`Functor`を木薔薇に実装してください。

4. インターフェース`Show`を木薔薇に実装しましょう。お楽しみください。

5. 依存型でプログラムする方法を忘れないよう、
   木薔薇を正しい大きさのベクタに変換する関数`treeToVect`を実装してください。

   ヒント：`treeSize`の実装と同じ再帰構造に従うようにしてください。
   さもないと取り掛かるのがとても難しいでしょうから。

## インターフェースFoldable

再帰についての節で解いた全演習を振り返ると、リストにおけるほとんどの末尾再帰関数が次の様式になっています。
つまり、先頭から尾鰭までの全てのリストの要素を巡回しつつ、中間結果を累積する何らかの状態を渡すというものです。
リストの終端では最終的な状態を返すか追加の関数呼び出しにより変換するかします。

### 左畳み込み

ここでは関数型プログラミングをしており、そのような反復される様式は抽象化したいところです。
リストで末尾再帰的に巡回するためになくてはならないのは、
累積関数と何らかの初期状態だけです。
でも累積器の型はどうすべきなのでしょう？
そうですね、現在の状態とリストの次の要素をまとめて更新された状態を返すもの、つまり`state -> elem -> state`です。
もちろんこの振舞いを内蔵化する高階関数が頭に浮かびます。

```idris
leftFold : (acc : state -> el -> state) -> (st : state) -> List el -> state
leftFold _   st []        = st
leftFold acc st (x :: xs) = leftFold acc (acc st x) xs
```

この関数を*左畳み込み*と呼びますが、
それはリストを左から右（先頭から尾鰭へ）巡回し、
たった1つの値が残るまでリストを押し潰す（あるいは*畳み込む*）からです。
この新しい値はリストのままでも他の容器型でもよいのですが、
元のリストは徹頭徹尾消費されます。
`leftFold`が末尾再帰なことに注目してください。
したがって`leftFold`を利用して実装された全ての関数もまた末尾再帰（なのでスタック安全！）なのです。

以下はいくつかの例です。

```idris
sumLF : Num a => List a -> a
sumLF = leftFold (+) 0

reverseLF : List a -> List a
reverseLF = leftFold (flip (::)) Nil

-- this is more natural than `reverseLF`!
toSnocListLF : List a -> SnocList a
toSnocListLF = leftFold (:<) Lin
```

### 右畳み込み

`leftFold`を利用して実装した関数の例では常にリスト全体を完璧に巡回する必要がありましたが、
それは結果を計算するのに全ての要素1つ1つが必要だからです。
しかし私達にとっていつも必要とは限りません。
例えば演習の`findList`を見ると探索が成功するやいなやリストの巡回を中断できました。
`leftFold`を使っていてはより効率的な振舞いを実装することは*不*可能です。
というのも、結果が返されるおはパターン照合が`Nil`の場合に到達したときだけだからです。

興味深いことに別の非末尾再帰な再帰畳み込みがあります。
より自然にリストの構造を反映しており、
これを使えば巡回中に早い時点で中断することができます。
*右畳み込み*と呼ばれるもので、以下がその実装です。

```idris
rightFold : (acc : el -> state -> state) -> state -> List el -> state
rightFold acc st []        = st
rightFold acc st (x :: xs) = acc x (rightFold acc st xs)
```

さて、すぐにはこれが`leftFold`とどう違うのかはっきりしないでしょう。
それを知るにはまず、遅延評価についてお話ししなくてはなりません。

#### Idrisでの遅延評価

計算の中には、結果を返すために全ての関数の引数を評価する必要がないものもあります。
例えば真偽値演算子`(&&)`を考えましょう。
最初の引数が`False`に評価されたら、もう2つの引数を見向きもせず結果が`False`なのがわかります。
そのような場合、不要な2つ目の引数の評価はしたくありません。
長い計算が含まれているかもしれないからです。

以下のREPLセッションについて考えましょう。

```repl
Tutorial.Folds> False && (length [1..10000000000] > 100)
False
```

2つ目の引数が評価されるなら、この計算はきっとコンピュータのメモリを吹っ飛ばしてしまうか、
少なくとも計算を走らせるのにとても長い時間が掛かるでしょう。
しかしこの場合、結果の`False`が直ちに印字されます。
`(&&)`の方を見ると以下とあることがわかります。

```repl
Tutorial.Folds> :t (&&)
Prelude.&& : Bool -> Lazy Bool -> Bool
```

見てとれるように、2つ目の引数は`Lazy`型構築子に包まれています。
これは組み込み型で、ほとんどの場合はIdrisが自動的に細々としたことを制御します。
例えば引数を`(&&)`に渡したとき、値を何らかのデータ構築子に手作業で包む必要はありません。
遅延関数引数は関数の実装で*必要とされる*瞬間にのみ評価されます。
例えばパターン照合されたり他の関数の厳密な引数に渡されたりするときです。
`(&&)`の実装では最初の引数でパターン照合が起こっているので、
2つ目の引数が評価されるのは最初の引数が`True`のときだけで、
関数の（正格な）結果として返されます。

遅延評価に取り組む上で2つの小間物関数があります。
関数`delay`は値を`Lazy`データ型に包みます。
なお、`lazy`の引数は正格なので、以下は結果を印字するのに数秒掛かるかもしれません。

```repl
Tutorial.Folds> False && (delay $ length [1..10000] > 100)
False
```

加えて関数`force`があり、これは`Lazy`値の評価を強制します。

#### 遅延評価と右畳み込み

これで繰返しから早期に中断できる畳み込みを実装するための`rightFold`と遅延評価の使いかたがわかりました。
なお`rightFold`の実装では残りのリストを畳み込む結果が累積器に渡されています。
（再帰呼び出しで使われる累積器を呼び出した結果ではありません。）

```repl
rightFold acc st (x :: xs) = acc x (rightFold acc st xs)
```

`acc`の2つ目の引数が遅延評価されるなら、
リストの終端まで繰り返すことなく`acc`の結果の計算を中断することが可能です。

```idris
foldHead : List a -> Maybe a
foldHead = force . rightFold first Nothing
  where first : a -> Lazy (Maybe a) -> Lazy (Maybe a)
        first v _ = Just v
```

Idrisがほとんどの場合で遅延の予約を取り付けているところに注目してください。
（ただ`rightFold`のカリー化された呼び出しを正しく扱ってはいません。
なので`foldHead`のリスト引数に明示的に渡すか、
カリー化された関数に`force`をくっつけて型を正しくするかしないといけません。）

これが正しく動いていることを確かめるにはモジュール`Debug.trace`の`trace`と呼ばれるデバッグ用の小間物が必要です。
この「関数」があれば純粋なコード中のどこかの時点で端末にデバッグ文言を印字させられます。
ただしこれはデバッグ用途でのみのものであり、製品コードには決してあるべきではありません。
というのも、厳密に言えば端末に何か印字することは参照透過性を壊しているからです。

以下は`foldHead`を調整した版です。
これは小間物関数`first`が呼び出されたときに毎回 "folded" と標準出力に印字します。

```idris
foldHeadTraced : List a -> Maybe a
foldHeadTraced = force . rightFold first Nothing
  where first : a -> Lazy (Maybe a) -> Lazy (Maybe a)
        first v _ = trace "folded" (Just v)
```

これをREPLで試すには、`trace`が内部的に`unsafePerformIO`を使っており、
したがって評価の最中は簡約されることがないことを知っておかねばなりません。
この動作をREPLで見るには`:exec`コマンドを行使する必要があります。

```repl
Tutorial.Folds> :exec printLn $ foldHeadTraced [1..10]
folded
Just 1
```

見てわかるようにリストには10個の要素がありますが、`first`は1度しか呼ばれておらず、
結果としてかなりの効率性の向上となっています。

`first`の実装を正格評価を使うように変えると何が起こるのか見てみましょう。

```idris
foldHeadTracedStrict : List a -> Maybe a
foldHeadTracedStrict = rightFold first Nothing
  where first : a -> Maybe a -> Maybe a
        first v _ = trace "folded" (Just v)
```

2つ目の引数を`first`の実装で使っていませんが、
`frst`本体を評価する前にこの引数が評価されてしまっています。
これはIdrisが……Haskellとは違って！……既定で正格な意味論を使っているからです。
以下はこれのREPLでの振舞いです。

```repl
Tutorial.Folds> :exec printLn $ foldHeadTracedStrict [1..10]
folded
folded
folded
folded
folded
folded
folded
folded
folded
folded
Just 1
```

この技法はときに大変流麗なコードに導いてくれますが、
`rightFold`が一般的な場合ではスタック安全でないことをいつも頭の片隅に置いておいてください。
なので、累積器がそれほど多くない反復の末に結果を返す保証がない、といったことがない限りは、
関数を明示的なパターン照合で末尾再帰に実装するよう検討してください。
コードは僅かにより冗長になるでしょうが、スタック安全という保証された利点が付いてきます。

### 畳み込みとモノイド

左右の畳み込みはよくある様式を共有しています。
両方とも初期*状態*値から始まり累積器関数を使って現在の状態に現在の要素を組み合わせるのです。
この*初期値*から開始したあとに*値を組み合わせ*る*原理*は既に学んだインターフェースの核心をついています。
それは`Monoid`です。
したがってモノイド上でリストを畳み込むことは納得がいきます。

```idris
foldMapList : Monoid m => (a -> m) -> List a -> m
foldMapList f = leftFold (\vm,va => vm <+> f va) neutral
```

なお、`foldMapList`ではもはや累積器関数を渡す必要がないようになっています。
しなければいけないことは要素の型から`Monoid`の実装された型への変換だけです。
[インターフェース](Interfaces.md)の章で既に見たように、関数型プログラミングには*数多くの*モノイドがあります。
したがって`foldMapList`はもの凄く便利な関数です。

これをもっと短くできます。
もしリストの要素の型がモノイドの実装を持っていたら、リストを押し潰すのに変換関数さえも必要ではなくなります。

```idris
concatList : Monoid m => List m -> m
concatList = foldMapList id
```

### どこでも`List`を使うのは止めよう

ついにここまで来ました。
山程の小間物関数を見てきました。
これらには全て何らかの方法で値のリストを単一の結果に押し潰す（または折り畳む）着想がありました。
しかしこれら全ての折り畳み関数はリスト以外の型に取り組む際も同じように便利なのです。
ベクタ、非空のリスト、木薔薇、
果ては`Maybe`、`Either e`、`Identity`といった単一値の容器がそうです。
まあ完全を期すなら、
`Control.Applicative.Const e`のようなゼロ個の値の容器に取り組むときさえも便利なんですけどね！
そしてとても多くのこうした関数があるため、
それらの中から必要不可欠な集合を考えたほうがいいかもしれません。
それを使えば他の全てを実装でき、全体を1つのインターフェースに包むのに使えます。
このインターフェースは`Foldable`と呼ばれており、
`Prelude`で手に入ります。
REPLで定義を見ると (`:doc Foldable`) 6つの必須の関数が含まれていることがわかります。

* `foldr`: 右からの畳み込み用
* `foldl`: 左からの畳み込み用
* `null`: 容器が空かどうかの確認用
* `foldM`: モナドでの作用付き畳み込み用
* `toList`: 容器から値のリストへの変換用
* `foldMap`: モノイド上での畳み込み用

`Foldable`の最小の実装としては`foldr`を実装するだけで充分です。
しかし6つの関数を手作業で実装することを検討してください。
なぜなら容器型を折り畳むことはよく効率上致命的な操作となり、
それぞれ最適化されているべきだからです。
例えば`List`に`foldr`を使って`toList`を実装するのは単純に無意味です。
というのはこれが線形時間の複雑度で走る非末尾再帰関数だからです。
一方で手で書いた実装では引数を変更することなく返すだけでよいのです。

### 演習 その3

この演習では`Foldable`を様々のデータ型で実装してきます。
インターフェースの6つの関数全てを手作業で頑張って実装してください。

1. `Foldable`を`Crud i`に実装してください。

   ```idris
   data Crud : (i : Type) -> (a : Type) -> Type where
     Create : (value : a) -> Crud i a
     Update : (id : i) -> (value : a) -> Crud i a
     Read   : (id : i) -> Crud i a
     Delete : (id : i) -> Crud i a
   ```

2. `Foldable`を`Response e i`に実装してください。

   ```idris
   data Response : (e, i, a : Type) -> Type where
     Created : (id : i) -> (value : a) -> Response e i a
     Updated : (id : i) -> (value : a) -> Response e i a
     Found   : (values : List a) -> Response e i a
     Deleted : (id : i) -> Response e i a
     Error   : (err : e) -> Response e i a
   ```

3. `List01`に`Foldable`を実装してください。
   `toList`、`foldMap`、`foldl`の実装では末尾再帰を使ってください。

   ```idris
   data List01 : (nonEmpty : Bool) -> Type -> Type where
     Nil  : List01 False a
     (::) : a -> List01 False a -> List01 ne a
   ```

4. `Foldable`を`Tree`に実装してください。
   実装では末尾再帰を使う必要はありませんが、
   関数は全域性検査器が受け付けるものでなくてはいけません。
   また`assert_smaller`や`assert_total`を使ってズルすることも許しません。

   ヒント：実装が正しく振る舞うか試すには、
   同じ畳み込みを`treeToVect`の結果に走らせて出力が同じことを確かめればよいです。

5. `Functor`や`Applicative`と同様に、`Foldable`は組み合わさります。
   つまり、2つの折り畳みできる容器型の積や合成もまた折り畳みできる容器型なのです。
   これを、`Foldable`を`Comp`と`Product`に実装することで証明してください。

   ```idris
   record Comp (f,g : Type -> Type) (a : Type) where
     constructor MkComp
     unComp  : f (g a)

   record Product (f,g : Type -> Type) (a : Type) where
     constructor MkProduct
     fst : f a
     snd : g a
   ```

## まとめ

この章で再帰、全域性検査、そして畳み込みについて多くのことを学びました。
これら全ては一般に純粋関数型プログラミングで重要です。
再帰を会得するには時間と経験を要すものです。
したがって……いつも通り……できるだけ多くの演習を解いてみてください。

[次の章](./Traverse.md)では容器型を巡回する上での概念についてもう一歩踏み込み、作用つきデータの巡回についても見ていきます。

<!-- vi: filetype=idris2:syntax=markdown
-->
