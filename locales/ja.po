# 関数型プログラミングをIdris 2で
# Copyright (C) 2021 Stefan Höck (original).
# Copyright (C) 2022 gemmaro (translate).
# This file is distributed under the same license as the original document.
# gemmaro <gemmaro.dev@gmail.com>, 2022.
#
msgid ""
msgstr ""
"Project-Id-Version: idris 2-tutorial\n"
"POT-Creation-Date: 2022-08-15 20:56+0900\n"
"PO-Revision-Date: 2022-08-14 15:59+0900\n"
"Last-Translator: gemmaro <gemmaro.dev@gmail.com>\n"
"Language-Team: none\n"
"Language: ja\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"
"Plural-Forms: nplurals=1; plural=0;\n"

#. type: Title #
#: ../src/Appendices/Neovim.md:1
#, no-wrap
msgid "Interactive Editing in Neovim"
msgstr "対話的編集をNeovimで"

#. type: Plain text
#: ../src/Appendices/Neovim.md:10
msgid ""
"Idris provides extensive capabilities to interactively analyze the types of "
"values and expressions in our programs and fill out skeleton implementations "
"and sometimes even whole programs for us based on the types provided. These "
"interactive editing features are available via plugins in different "
"editors.  Since I am a Neovim user, I explain the Idris related parts of my "
"own setup in detail here."
msgstr ""
"Idrisには多岐にわたる機能があり、\n"
"プログラム中の値や式の型を対話的に分析したり、\n"
"実装の骨子、ときには与えられた型に基づいて全体のプログラムさえも、書き込んだ"
"りしてくれます。\n"
"これらの対話的な編集機能はそれぞれのエディタのプラグインを介して使うことがで"
"きます。\n"
"筆者はNeovim利用者なので自分の設定のうちIdrisに関係する部分をここで詳細に述べ"
"ます。"

#. type: Plain text
#: ../src/Appendices/Neovim.md:20
msgid ""
"The main component required to get all these features to run in Neovim is an "
"executable provided by the [idris2-lsp](https://github.com/idris-community/"
"idris2-lsp) project.  This executable makes use of the Idris compiler API "
"(application programming interface) internally and can check the syntax and "
"types of the source code we are working on. It communicates with Neovim via "
"the language server protocol (LSP). This communication is setup through the "
"[idris2-nvim](https://github.com/ShinKage/idris2-nvim)  plugin."
msgstr ""
"Neovimでこれら全ての機能を走らせるために必要な主要素は\n"
"[idris2-lsp](https://github.com/idris-community/idris2-lsp)\n"
"プロジェクトで提供されている実行プログラムです。\n"
"この実行プログラムは内部でIdrisのコンパイラAPI (application programming "
"interface) を活用して\n"
"編集中のソースコードの構文や型を検査することができます。\n"
"idris2-lspはlanguage server protocol (LSP) を介してNeovimと通信しています。\n"
"この通信は[idris2-nvim](https://github.com/ShinKage/idris2-nvim)プラグインを"
"通じて立ち上がります。"

#. type: Plain text
#: ../src/Appendices/Neovim.md:31
msgid ""
"As we will see in this tutorial, the `idris2-lsp` executable not only "
"supports syntax and type checking, but comes also with additional "
"interactive editing features. Finally, the Idris compiler API supports "
"semantic highlighting of Idris source code: Identifiers and keywords are "
"highlighted not only based on the language's syntax (that would be *syntax "
"highlighting*, a feature expected from all modern programming environments "
"and editors), but also based on their *semantics*. For instance, a local "
"variable in a function implementation gets highlighted differently than the "
"name of a top level function, although syntactically these are both just "
"identifiers."
msgstr ""
"このチュートリアルで見ていきますが、`idris2-lsp`実行プログラムは構文と型の検"
"査を行えるようにするだけではなく、\n"
"追加の対話的編集機能も備えています。\n"
"最後にIdrisコンパイラAPIはIdrisのソースコードの意味論的彩色をサポートしていま"
"す。\n"
"つまり、識別子やキーワードの彩色は、\n"
"言語の構文に基づくだけではなく（これは*構文彩色*であり、\n"
"あらゆる現代的なプログラミング環境やエディタにあるであろう機能です）、\n"
"その*意味論*にも基づいているのです。\n"
"例えば関数実装の局所変数と最上位関数の名前は、\n"
"どちらも構文的にはただの識別子ですが、それぞれ違うように彩色されます。"

#. type: Fenced code block (idris)
#: ../src/Appendices/Neovim.md:32
#, no-wrap
msgid ""
"module Appendices.Neovim\n"
"\n"
"import Data.Vect\n"
"\n"
"%default total\n"
msgstr ""
"module Appendices.Neovim\n"
"\n"
"import Data.Vect\n"
"\n"
"%default total\n"

#. type: Title ##
#: ../src/Appendices/Neovim.md:40
#, no-wrap
msgid "Setup"
msgstr "立ち上げ"

#. type: Plain text
#: ../src/Appendices/Neovim.md:44
msgid ""
"In order to make full use of interactive Idris editing in Neovim, at least "
"the following tools need to be installed:"
msgstr ""
"Neovimでの対話的なIdrisの編集方法を全部活用するには、\n"
"少なくとも以下のツールがインストールされている必要があります。"

#. type: Bullet: '* '
#: ../src/Appendices/Neovim.md:52
msgid "A recent version of Neovim (version 0.5 or later)."
msgstr "新しめのバージョンのNeovim（バージョン0.5以降）"

#. type: Bullet: '* '
#: ../src/Appendices/Neovim.md:52
msgid "A recent version of the Idris compiler (at least version 0.5.1)."
msgstr "新しめのバージョンのIdrisコンパイラ（最低でもバージョン0.5.1）"

#. type: Bullet: '* '
#: ../src/Appendices/Neovim.md:52
msgid "The Idris compiler API."
msgstr "IdrisコンパイラのAPI"

#. type: Bullet: '* '
#: ../src/Appendices/Neovim.md:52
msgid ""
"The [idris2-lsp](https://github.com/idris-community/idris2-lsp) package."
msgstr "[idris2-lsp](https://github.com/idris-community/idris2-lsp)パッケージ"

#. type: Bullet: '* '
#: ../src/Appendices/Neovim.md:52
msgid "The following Neovim plugins:"
msgstr "以下のNeovimプラグイン"

#. type: Bullet: '  * '
#: ../src/Appendices/Neovim.md:52
msgid "[idris2-nvim](https://github.com/ShinKage/idris2-nvim)"
msgstr "[idris2-nvim](https://github.com/ShinKage/idris2-nvim)"

#. type: Bullet: '  * '
#: ../src/Appendices/Neovim.md:52
msgid "[nvim-lspconfig](https://github.com/neovim/nvim-lspconfig)"
msgstr "[nvim-lspconfig](https://github.com/neovim/nvim-lspconfig)"

#. type: Plain text
#: ../src/Appendices/Neovim.md:57
msgid ""
"The `idris2-lsp` project gives detailed instructions about how to install "
"Idris 2 together with its standard libraries and compiler API. Make sure to "
"follow these instructions so that your compiler and `idris2-lsp` executable "
"are in sync."
msgstr ""
"`idris2-lsp`プロジェクトにはIdris 2や標準ライブラリ、コンパイラAPIのインス"
"トール方法の詳細な説明があります。\n"
"この説明に従い、コンパイラと`idris2-lsp`実行プログラムが協調するようにしてく"
"ださい。"

#. type: Plain text
#: ../src/Appendices/Neovim.md:67
msgid ""
"If you are new to Neovim, you might want to use the `init.vim` file provided "
"in the `resources` folder. In that case, the necessary Neovim plugins are "
"already included, but you need to install [vim-plug](https://github.com/"
"junegunn/vim-plug), a plugin manager.  Afterwards, copy all or parts of "
"`resources/init.vim` to your own `init.vim` file. (Use `:help init.vim` from "
"within Neovim in order to find out where to look for this file.). After "
"setting up your `init.vim` file, restart Neovim and run `:PlugUpdate` to "
"install the necessary plugins."
msgstr ""
"Neovimが初めてであれば、`resources`フォルダにある`init.vim`ファイルを使うとよ"
"いかもしれません。\n"
"その場合必要なNeovimプラグインは既に含まれていますが、\n"
"[vim-plug](https://github.com/junegunn/vim-plug)というプラグイン管理をインス"
"トールする必要があります。\n"
"そのあとで自分の`iniv.vim`ファイルに`resources/init.vim`の全部または一部をコ"
"ピーしてください。\n"
"（Neovim内で`:help init.vim`とするとどこでこのファイルを見つけられるのかがわ"
"かります。）\n"
"`init.vim`ファイルを設定したあとはNeovimを再起動し\n"
"`:PlugUpdate`を走らせて必要なプラグインをインストールしてください。"

#. type: Title ##
#: ../src/Appendices/Neovim.md:68
#, no-wrap
msgid "A Typical Workflow"
msgstr "よくある作業の流れ"

#. type: Plain text
#: ../src/Appendices/Neovim.md:77
msgid ""
"In order to checkout the interactive editing features available to us, we "
"will reimplement some small utilities from the *Prelude*. To follow along, "
"you should have already worked through the [Introduction](../Tutorial/Intro."
"md), [Functions Part 1](../Tutorial/Functions1.md), and at least parts of "
"[Algebraic Data Types](../Tutorial/DataTypes.md), otherwise it will be hard "
"to understand what's going on here."
msgstr ""
"使える対話的編集機能を試すために、*Prelude*からいくらかの小間物を再実装してい"
"きます。\n"
"進めるにあたって既に[導入](../Tutorial/Intro.md)、[関数 その1](../Tutorial/"
"Function1.md)、\n"
"そして少なくとも[代数的データ型](../Tutorial/DataTypes.md)の一部を進めている"
"とよいです。\n"
"さもないとここで起こっていることが理解しづらいでしょう。"

#. type: Plain text
#: ../src/Appendices/Neovim.md:83
#, fuzzy
#| msgid ""
#| "Before we begin, note that the commands and actions shown in this "
#| "tutorial might not work correctly after you edited a source file but did "
#| "not write your changes to disk. Therefore, the first thing you should try "
#| "if the things described here do not work, is to quickly safe the current "
#| "file (`:w`)."
msgid ""
"Before we begin, note that the commands and actions shown in this tutorial "
"might not work correctly after you edited a source file but did not write "
"your changes to disk. Therefore, the first thing you should try if the "
"things described here do not work, is to quickly save the current file (`:"
"w`)."
msgstr ""
"始める前に注意しておきますが、\n"
"ソースファイルを編集してディスクに変更を書き込んでいなかったら、\n"
"このチュートリアルでお見せするコマンドやアクションは正しく動かないかもしれま"
"せん。\n"
"したがって、ここに載っていることがうまくいかなかったら、\n"
"最初に試すことは現在のファイルをささっと保存する (`:w`) ことです。"

#. type: Plain text
#: ../src/Appendices/Neovim.md:85
msgid "Let's start with negation of a boolean value:"
msgstr "真偽値の否定から始めましょう。"

#. type: Fenced code block (idris)
#: ../src/Appendices/Neovim.md:86
#, no-wrap
msgid "negate1 : Bool -> Bool\n"
msgstr "negate1 : Bool -> Bool\n"

#. type: Plain text
#: ../src/Appendices/Neovim.md:102
msgid ""
"Typically, when writing Idris code we follow the mantra \"types first\". "
"Although you might already have an idea about how to implement a certain "
"piece of functionality, you still need to provide an accurate type before "
"you can start writing your implementation. This means, when programming in "
"Idris, we have to mentally keep track of the implementation of an algorithm "
"and the types involved at the same time, both of which can become "
"arbitrarily complex. Or do we? Remember that Idris knows at least as much "
"about the variables and their types available in the current context of a "
"function implementation as we do, so we probably should ask it for guidance "
"instead of trying to do everything on our own."
msgstr ""
"Idrisのコードを書くときにつきものなのは「型第一」という真言に従うことです。\n"
"何らかの機能の一部をどのように実装すればよいかのアイディアがもうあるかもしれ"
"ませんが、\n"
"それでも実装を書き始められる前に正確な型を提供する必要があります。\n"
"つまり、Idrisでプログラミングするときは\n"
"頭の中でアルゴリズムの実装と関連する型について同時に帳尻を合わせなくてはいけ"
"ず、\n"
"両方ともどこまでも複雑になりうるものなのです。\n"
"それでも実装からやります？\n"
"覚えておいてほしいのですが、\n"
"Idrisは私達と同じように少なくとも関数実装の現在の文脈で使える変数とその型の多"
"くを知っているので、\n"
"全部自分で試す代わりに道しるべを乞うとよいでしょう。"

#. type: Plain text
#: ../src/Appendices/Neovim.md:112
#, no-wrap
msgid ""
"So, in order to proceed, we ask Idris for a skeleton function\n"
"body: In normal editor mode, move your cursor on the line where\n"
"`negate1` is declared and enter `<LocalLeader>a` in quick\n"
"succession. `<LocalLeader>` is a special key that can be specified\n"
"in the `init.vim` file. If you\n"
"use the `init.vim` from the `resources` folder, it is set to\n"
"the comma character (`,`), in which case the above command\n"
"consists of a comma quickly followed by the lowercase letter \"a\".\n"
"See also `:help leader` and `:help localleader` in Neovim\n"
msgstr ""
"で、話を続けるために、Idrisに関数本体の骨子について尋ねます。\n"
"通常の編集モードで`negate`が宣言されている行にカーソルを持っていき、\n"
"`<LocalLeader>a`を素早く連続で入力してください。\n"
"`<LocalLeader>`は特別なキーで`init.vim`ファイル中で指定することができます。\n"
"`resources`フォルダの`init.vim`を使っていたら、\n"
"コンマ文字 (`,`) に設定されています。\n"
"その場合上のコマンドは、コンマとそのすぐあとに小文字の \"a\" が続きます。\n"
"Neovimで`:help leader`と`:help localleader`もご参照ください。\n"

#. type: Plain text
#: ../src/Appendices/Neovim.md:115
msgid "Idris will generate a skeleton implementation similar to the following:"
msgstr "Idrisは以下のような実装の骨子を生成するでしょう。"

#. type: Fenced code block (idris)
#: ../src/Appendices/Neovim.md:116
#, no-wrap
msgid ""
"negate2 : Bool -> Bool\n"
"negate2 x = ?negate2_rhs\n"
msgstr ""
"negate2 : Bool -> Bool\n"
"negate2 x = ?negate2_rhs\n"

#. type: Plain text
#: ../src/Appendices/Neovim.md:139
#, no-wrap
msgid ""
"Note, that on the left hand side a new variable with name\n"
"`x` was introduced, while on the right hand side Idris\n"
"added a *metavariable* (also called a *hole*). This is an\n"
"identifier prefixed with a question mark. It signals to Idris,\n"
"that we will implement this part of the function at a later time.\n"
"The great thing about holes is, that we can *hover* over them\n"
"and inspect their types and the types of values in the\n"
"surrounding context. You can do so by placing the cursor\n"
"on the identifier of a hole and entering `K` (the uppercase letter) in\n"
"normal mode. This will open a popup displaying the type of\n"
"the variable under the cursor plus the types and quantities of the variables\n"
"in the surrounding context. You can also have this information\n"
"displayed in a separate window: Enter `<LocalLeader>so` to\n"
"open this window and repeat the hovering. The information will\n"
"appear in the new window and as an additional benefit, it will\n"
"be semantically highlighted. Enter `<LocalLeader>sc` to close\n"
"this window again. Go ahead and checkout the type and\n"
"context of `?negate2_rhs`.\n"
msgstr ""
"左側に`x`という名前の新しい変数が導入され、\n"
"右側にはIdrisが*メタ変数*（*穴開き*とも呼ばれます）を加えましたね。\n"
"後者は疑問符が前置された識別子です。\n"
"関数のこの部分をあとで実装するつもりがあることを、Idrisに合図しているのです。\n"
"穴開きの素晴しいところは、その上に*かざして*型や周囲の文脈の値の型を調べられることです。\n"
"そうするにはカーソルを穴開きの識別子の上に置いて通常モードで`K`（大文字）を入力します。\n"
"これでポップアップが開いてカーソルの下の変数の型に加えて周囲の文脈の変数の型と数量子が表示されます。\n"
"この表示された情報を分離した窓に移すこともできます。\n"
"`<LocalLeader>so`と入力するとこの窓を開きつつカーソルをかざしたままになります。\n"
"情報が新しい窓に現れますが、これには意味論的彩色される利点もあります。\n"
"`<LocalLeader>sc`と入力するとこの窓を閉じて元に戻ります。\n"
"さあ、`?negate2_rhs`の型と文脈を見てみましょう。\n"

#. type: Plain text
#: ../src/Appendices/Neovim.md:148
#, no-wrap
msgid ""
"Most functions in Idris are implemented by pattern matching\n"
"on one or more of the arguments. Idris,\n"
"knowing the data constructors of all non-primitive data types,\n"
"can write such pattern matches for us (a process also called\n"
"*case splitting*). To give this a try, move the cursor onto the `x`\n"
"in the skeleton implementation of `negate2`, and enter\n"
"`<LocalLeader>c` in normal mode. The result will look as\n"
"follows:\n"
msgstr ""
"Idrisのほとんどの関数は1つ以上の引数についてのパターン照合によって実装されています。\n"
"Idrisは全ての原始的でないデータ型のデータ構築子を知っており、\n"
"その通りにパターン照合を書いてくれます。\n"
"（この工程は*場合分割*とも呼ばれます。）\n"
"カーソルを`negate2`の実装の骨子中にある`x`の上に移動させて、\n"
"通常モードで`<LocalLeader>c`を入力してください。\n"
"結果は以下のようになるでしょう。\n"

#. type: Fenced code block (idris)
#: ../src/Appendices/Neovim.md:149
#, no-wrap
msgid ""
"negate3 : Bool -> Bool\n"
"negate3 False = ?negate3_rhs_0\n"
"negate3 True = ?negate3_rhs_1\n"
msgstr ""
"negate3 : Bool -> Bool\n"
"negate3 False = ?negate3_rhs_0\n"
"negate3 True = ?negate3_rhs_1\n"

#. type: Plain text
#: ../src/Appendices/Neovim.md:158
msgid ""
"As you can see, Idris inserted a hole for each of the cases on the right "
"hand side. We can again inspect their types or replace them with a proper "
"implementation directly."
msgstr ""
"見てとれるようにIdrisは右側のそれぞれの場合に穴開きを挿入しました。\n"
"再度それぞれの型を調べることもできますし、\n"
"直接適切な実装で置き換えることもできます。"

#. type: Plain text
#: ../src/Appendices/Neovim.md:164
msgid ""
"This concludes the introduction of the (in my opinion) core features of "
"interactive editing: Hovering on metavariables, adding skeleton function "
"implementations, and case splitting (which also works in case blocks and for "
"nested pattern matches). You should start using these all the time *now*!"
msgstr ""
"これが対話的編集の（筆者にとっての）中核の機能への入口だという結論になりま"
"す。\n"
"メタ変数にかざし、関数の実装の骨子を加え、場合分割する（これはcaseブロックと"
"入れ子のパターン照合でも動きます）。\n"
"これらを*今*この瞬間から使い始めるべきです！"

#. type: Title ##
#: ../src/Appendices/Neovim.md:165
#, no-wrap
msgid "Expression Search"
msgstr "式検索"

#. type: Plain text
#: ../src/Appendices/Neovim.md:173
msgid ""
"Sometimes, Idris knows enough about the types involved to come up with a "
"function implementation on its own. For instance, let us implement function "
"`either` from the *Prelude*.  After giving its type, creating a skeleton "
"implementation, and case splitting on the `Either` argument, we arrive at "
"something similar to the following:"
msgstr ""
"時々Idrisが充分関係する型について知っていて、自力で関数の実装を思い付けること"
"があります。\n"
"例えば*Prelude*の関数`either`を実装してみましょう。\n"
"型を与えたあと、実装の骨子をつくり、`Either`引数で場合分割すると、\n"
"以下のようなものに行き着きます。"

#. type: Fenced code block (idris)
#: ../src/Appendices/Neovim.md:174
#, no-wrap
msgid ""
"either2 : (a -> c) -> (b -> c) -> Either a b -> c\n"
"either2 f g (Left x) = ?either2_rhs_0\n"
"either2 f g (Right x) = ?either2_rhs_1\n"
msgstr ""
"either2 : (a -> c) -> (b -> c) -> Either a b -> c\n"
"either2 f g (Left x) = ?either2_rhs_0\n"
"either2 f g (Right x) = ?either2_rhs_1\n"

#. type: Plain text
#: ../src/Appendices/Neovim.md:186
#, no-wrap
msgid ""
"Idris can come up with expressions for the two metavariables\n"
"on its own, because the types are specific enough. Move\n"
"the cursor onto one of the metavariables and enter\n"
"`<LocalLeader>o` in normal mode. You will be given\n"
"a selection of possible expressions (only one in this case),\n"
"of which you can choose a fitting one (or abort with `q`).\n"
msgstr ""
"Idrisは自力で2つのメタ変数の式を思い付くことができますが、\n"
"これは型が充分に限定されているからです。\n"
"カーソルをメタ変数の1つの上に移動させ、\n"
"通常モードで`<LocalLeader>o`を入力してください。\n"
"すると可能な式の骨子（今回の場合は1つのみ）が得られ、\n"
"この中から合うものを選べます（もしくは`q`で中断）。\n"

#. type: Plain text
#: ../src/Appendices/Neovim.md:190
msgid ""
"Here is another example: A reimplementation of function `maybe`.  If you run "
"an expression search on `?maybe2_rhs1`, you will get a larger list of "
"choices."
msgstr ""
"以下は別の例で、関数`maybe`の再実装です。\n"
"`?maybe2_rhs1`で式検索を走らせるともっと選択肢が多くなります。"

#. type: Fenced code block (idris)
#: ../src/Appendices/Neovim.md:191
#, no-wrap
msgid ""
"maybe2 : b -> (a -> b) -> Maybe a -> b\n"
"maybe2 x f Nothing = x\n"
"maybe2 x f (Just y) = ?maybe2_rhs_1\n"
msgstr ""
"maybe2 : b -> (a -> b) -> Maybe a -> b\n"
"maybe2 x f Nothing = x\n"
"maybe2 x f (Just y) = ?maybe2_rhs_1\n"

#. type: Plain text
#: ../src/Appendices/Neovim.md:208
#, no-wrap
msgid ""
"Idris is also sometimes capable of coming up with complete function\n"
"implementations based on a function's type. For this to work well\n"
"in practice, the number of possible implementations satisfying\n"
"the type checker must be pretty small. As an example, here is\n"
"function `zipWith` for vectors. You might not have heard\n"
"about vectors yet: They will be introduced in the chapter about\n"
"[dependent types](../Tutorial/Dependent.md). You can still give\n"
"this a go to check out its effect. Just move the cursor on the\n"
"line declaring `zipWithV`, enter `<LocalLeader>gd` and select the first option.\n"
"This will automatically generate the whole function body including\n"
"case splits and implementations.\n"
msgstr ""
"Idrisは時々関数の型に基づいて完全な関数の実装を思い付けることもあります。\n"
"これが実際にうまくいくのは型検査を満足する可能な実装が充分に少なくなければいけません。\n"
"例として以下は関数`zipWith`のベクタ用のものです。\n"
"ベクタについてまだ聞いたことがないかもしれませんが、\n"
"これは[依存型](../Tutorial/Dependent.md)についての章で紹介されます。\n"
"それでも式検索の効果を確認するために試してみることはできます。\n"
"`zipWithV`を宣言している行にカーソルを移動させ、\n"
"`<LocalLeader>gd`を入力して最初の選択肢を選ぶ、それだけです。\n"
"こうすると自動的に場合分割と実装を含む関数全体が生成されます。\n"

#. type: Fenced code block (idris)
#: ../src/Appendices/Neovim.md:209
#, no-wrap
msgid "zipWithV : (a -> b -> c) -> Vect n a -> Vect n b -> Vect n c\n"
msgstr "zipWithV : (a -> b -> c) -> Vect n a -> Vect n b -> Vect n c\n"

#. type: Plain text
#: ../src/Appendices/Neovim.md:218
#, no-wrap
msgid ""
"Expression search only works well if the types are specific\n"
"enough. If you feel like that might be the case, go ahead\n"
"and give it a go, either by running `<LocalLeader>o` on\n"
"a metavariable, or by trying `<LocalLeader>gd` on a\n"
"function declaration.\n"
msgstr ""
"式検索は充分に特化された型のときにのみうまくいきます。\n"
"今がそのときだと思ったら、\n"
"`<LocalLeader>o`をメタ変数の上で走らせるか、\n"
"`<LocalLeader>gd`を関数制限の上で試してみるか、\n"
"どちらかをぜひやってみてください。\n"

#. type: Title ##
#: ../src/Appendices/Neovim.md:219
#, no-wrap
msgid "More Code Actions"
msgstr "もっとコードアクション"

#. type: Plain text
#: ../src/Appendices/Neovim.md:223
msgid ""
"There are other shortcuts available for generating part of your code, two of "
"which I'll explain here."
msgstr ""
"他にもコードの一部を生成することができるショートカットがあり、\n"
"そのうち2つをここで述べます。"

#. type: Plain text
#: ../src/Appendices/Neovim.md:231
#, no-wrap
msgid ""
"First, it is possible to add a new case block by entering\n"
"`<LocalLeader>mc` in normal mode when on a metavariable.\n"
"For instance, here is part of an implementation of `filterList`,\n"
"which appears in an exercise in the chapter about\n"
"algebraic data types. I arrived at this by letting Idris\n"
"generate a skeleton implementation followed by a case split\n"
"and an expression search on the first metavariable:\n"
msgstr ""
"1つ目として、通常モードのときにメタ変数上で`<LocalLeader>mc`を入力することで新しいcaseブロックを加えられます。\n"
"例えば以下は代数的データ型についての章の中の演習で登場する`filterList`の実装の一部です。\n"
"ここまで辿り着くのに、Idrisに実装の骨子の生成、\n"
"場合分割、最初のメタ変数での式検索をしてもらったところです。\n"

#. type: Fenced code block (idris)
#: ../src/Appendices/Neovim.md:232
#, no-wrap
msgid ""
"filterList : (a -> Bool) -> List a -> List a\n"
"filterList f [] = []\n"
"filterList f (x :: xs) = ?filterList_rhs_1\n"
msgstr ""
"filterList : (a -> Bool) -> List a -> List a\n"
"filterList f [] = []\n"
"filterList f (x :: xs) = ?filterList_rhs_1\n"

#. type: Plain text
#: ../src/Appendices/Neovim.md:247
#, no-wrap
msgid ""
"We will next have to pattern match on the result of applying\n"
"`x` to `f`. Idris can introduce a new case block for us,\n"
"if we move the cursor onto metavariable `?filterList_rhs_1`\n"
"and enter `<LocalLeader>mc` in normal mode. We can then\n"
"continue with our implementation by first giving the\n"
"expression to use in the case block (`f x`) followed by a\n"
"case split on the new variable in the case block.\n"
"This will lead us to an implementation similar to the following\n"
"(I had to fix the indentation, though):\n"
msgstr ""
"次に`x`を`f`に適用した結果をパターン照合しなければいけません。\n"
"カーソルをメタ変数`?filterList_rhs_1`の上に持っていき、\n"
"通常モードで`<LocalLeader>mc`と入力すれば、\n"
"Idrisは新しいcaseブロックを導入してくれます。\n"
"それから、まず式 (`f x`) をcaseブロックで使えるように与えて、\n"
"次にcaseブロック中の新しい変数上で場合分割して実装を続けられます。\n"
"これにより以下のような実装になります。\n"
"（ただし字下げは修正せねばなりませんでしたが。）\n"

#. type: Fenced code block (idris)
#: ../src/Appendices/Neovim.md:248
#, no-wrap
msgid ""
"filterList2 : (a -> Bool) -> List a -> List a\n"
"filterList2 f [] = []\n"
"filterList2 f (x :: xs) = case f x of\n"
"  False => ?filterList2_rhs_2\n"
"  True => ?filterList2_rhs_3\n"
msgstr ""
"filterList2 : (a -> Bool) -> List a -> List a\n"
"filterList2 f [] = []\n"
"filterList2 f (x :: xs) = case f x of\n"
"  False => ?filterList2_rhs_2\n"
"  True => ?filterList2_rhs_3\n"

#. type: Plain text
#: ../src/Appendices/Neovim.md:266
#, no-wrap
msgid ""
"Sometimes, we want to extract a utility function from\n"
"an implementation we are working on. For instance, this is often\n"
"useful or even necessary when we write proofs about our code\n"
"(see chapters [Propositional Equality](../Tutorial/Eq.md)\n"
"and [Predicates](../Tutorial/Predicates.md), for instance).\n"
"In order to do so, we can move the cursor on a metavariable,\n"
"and enter `<LocalLeader>ml`. Give this a try with\n"
"`?whatNow` in the following example (this will work better\n"
"in a regular Idris source file instead of the literate\n"
"file I use for this tutorial):\n"
msgstr ""
"時々、作業中の実装から小間物関数を取り出したいことがあります。\n"
"例えばこれは、コードについての証明を書くときに、よく便利だったり果ては必要だったりします。\n"
"（[命題の等価性](../Tutorial/Eq.md)や[前提条件](../Tutorial/Predicates.md)などの章を見てください。）\n"
"そうするためにはカーソルをメタ変数の上に移動させて`<LocalLeader>ml`と入力すればできます。\n"
"以下の例の`?whatNow`で試してみてください。\n"
"（これは通常のIdrisのソースファイルのほうが、\n"
"私がこのチュートリアルで使用している文芸的ファイルよりもうまくいくでしょう。）\n"

#. type: Fenced code block (idris)
#: ../src/Appendices/Neovim.md:267
#, no-wrap
msgid ""
"traverseEither : (a -> Either e b) -> List a -> Either e (List b)\n"
"traverseEither f [] = Right []\n"
"traverseEither f (x :: xs) = ?whatNow x xs f (f x) (traverseEither f xs)\n"
msgstr ""
"traverseEither : (a -> Either e b) -> List a -> Either e (List b)\n"
"traverseEither f [] = Right []\n"
"traverseEither f (x :: xs) = ?whatNow x xs f (f x) (traverseEither f xs)\n"

#. type: Plain text
#: ../src/Appendices/Neovim.md:279
msgid ""
"Idris will create a new function declaration with the type and name of `?"
"whatNow`, which takes as arguments all variables currently in scope. It also "
"replaces the hole in `traverseEither` with a call to this new function. "
"Typically, you will have to manually remove unneeded arguments afterwards. "
"This led me to the following version:"
msgstr ""
"Idrisは`?whatNow`の型と名前を持つ新しい関数宣言を作ります。\n"
"作られた関数は現在範疇にある全ての変数を引数として取ります。\n"
"また、`traverseEither`中の穴開きをこの新しい関数の呼び出しで置き換えます。\n"
"大抵はその後に手ずから不要な引数を削除しなければいけないでしょう。\n"
"こうすると以下の版に行き着きます。"

#. type: Fenced code block (idris)
#: ../src/Appendices/Neovim.md:280
#, no-wrap
msgid ""
"whatNow2 : Either e b -> Either e (List b) -> Either e (List b)\n"
"\n"
"traverseEither2 : (a -> Either e b) -> List a -> Either e (List b)\n"
"traverseEither2 f [] = Right []\n"
"traverseEither2 f (x :: xs) = whatNow2 (f x) (traverseEither f xs)\n"
msgstr ""
"whatNow2 : Either e b -> Either e (List b) -> Either e (List b)\n"
"\n"
"traverseEither2 : (a -> Either e b) -> List a -> Either e (List b)\n"
"traverseEither2 f [] = Right []\n"
"traverseEither2 f (x :: xs) = whatNow2 (f x) (traverseEither f xs)\n"

#. type: Title ##
#: ../src/Appendices/Neovim.md:288
#, no-wrap
msgid "Getting Information"
msgstr "情報を得る"

#. type: Plain text
#: ../src/Appendices/Neovim.md:294
msgid ""
"The `idris2-lsp` executable and through it, the `idris2-nvim` plugin, not "
"only supports the code actions described above. Here is a non-comprehensive "
"list of other capabilities. I suggest you try out each of them from within "
"this source file."
msgstr ""
"`idris2-lsp`実行プログラムと介在する`idris2-nvim`プラグインがサポートしている"
"のは、\n"
"上で述べたコードアクションだけではありません。\n"
"以下は他の機能の非網羅的な一覧です。\n"
"それぞれをこのソースファイルの中で試してみてください。"

#. type: Bullet: '* '
#: ../src/Appendices/Neovim.md:329
msgid ""
"Typing `K` when on an identifier or operator in normal mode shows its type "
"and namespace (if any). In case of a metavariable, variables in the current "
"context are displayed as well together with their types and quantities "
"(quantities will be explained in [Functions Part 2](../Tutorial/Functions2."
"md)).  If you don't like popups, enter `<LocalLeader>so` to open a new "
"window where this information is displayed and semantically highlighted "
"instead."
msgstr ""
"識別子や演算子の上にいるとき通常モードで`K`と打つと（もしあれば）型と名前空間"
"が出ます。\n"
"メタ変数の場合は現在の文脈も型と数量子とともに表示されます。\n"
"（数量子は[関数 その2](../Tutorial/Functions2.md)で説明されます。）\n"
"ポップアップが好きでなければ、`<LocalLeader>so`とすると代わりに新しい窓が開"
"き、\n"
"この情報が意味論的彩色されて表示されます。"

#. type: Bullet: '* '
#: ../src/Appendices/Neovim.md:329
msgid ""
"Typing `gd` on a function, operator, data constructor or type constructor in "
"normal mode jumps to the item's definition.  For external modules, this "
"works only if the module in question has been installed together with its "
"source code (by using the `idris2 --install-with-src` command)."
msgstr ""
"通常モードで、関数、演算子、データ構築子、型構築子の上にいるとき`gd`と打つ"
"と、その定義に飛びます。\n"
"外部モジュールの場合、これは対象のモジュールがソースコードと一緒にインストー"
"ルされているときにのみ機能します。\n"
"（ソースコードのインストールには`idris2 --install-with-src`コマンドを使いま"
"す。）"

#. type: Bullet: '* '
#: ../src/Appendices/Neovim.md:329
msgid ""
"Typing `<LocalLeader>mm` opens a popup window listing all metavariables in "
"the current module. You can place the cursor on an entry and jump to its "
"location by pressing `<Enter>`."
msgstr ""
"`<LocalLeader>mm`と打つと、ポップアップ窓を開いて現在のモジュール中の全てのメ"
"タ変数を一覧にします。\n"
"カーソルを項目の上に置いて`<Enter>`を押せばその場所に飛ぶことができます。"

#. type: Bullet: '* '
#: ../src/Appendices/Neovim.md:329
msgid ""
"Typing `<LocalLeader>mn` (or `<LocalLeader>mp`) jumps to the next (or "
"previous) metavariable in the current module."
msgstr ""
"`<LocalLeader>mn` (`<LocalLeader>mp`) と打つと現在のモジュール中の次（前）の"
"メタ変数に飛びます。"

#. type: Bullet: '* '
#: ../src/Appendices/Neovim.md:329
msgid ""
"Typing `<LocalLeader>br` opens a popup where you can enter a namespace. "
"Idris will then show all functions (plus their types)  exported from that "
"namespace in a popup window, and you can jump to a function's definition by "
"pressing enter on one of the entries. Note: The module in question must be "
"imported in the current source file."
msgstr ""
"`<LocalLeader>br`と打つとポップアップが開き、そこに名前空間を入力できます。\n"
"そうするとIdrisはポップアップ窓の中にその名前空間から輸出されている全ての関数"
"（とその型）を出し、\n"
"項目のうち1つの上でエンターを押すと関数の定義に飛ぶことができます。\n"
"なお、モジュールは現在のソースファイルでインポートされていなくてはいけませ"
"ん。"

#. type: Bullet: '* '
#: ../src/Appendices/Neovim.md:329
msgid ""
"Typing `<LocalLeader>x` opens a popup where you can enter a REPL command or "
"Idris expression, and the plugin will reply with a response from the REPL. "
"Whenever REPL examples are shown in the main part of this guide, you can try "
"them from within Neovim with this shortcut if you like."
msgstr ""
"`<LocalLeader>x`と打つと、ポップアップが開いてREPLコマンドやIdrisの式を入力で"
"き、\n"
"プラグインはREPLからの応答で返信します。\n"
"この導入書の主部にあるREPLの例については、いつでもNeovimからこのショートカッ"
"トをで試すことができますよ。"

#. type: Bullet: '* '
#: ../src/Appendices/Neovim.md:329
#, fuzzy
#| msgid ""
#| "Typing `<LocalLeader><LocalLeader>e` will display the error message from "
#| "the current line in a popup window. This can be highly useful, if error "
#| "messages are too long to fit on a single line. Likewise, "
#| "`<LocalLeader>el` will list all error messages from the current buffer in "
#| "a new window. You can then select an error message and jump to its origin "
#| "by pressing `<Enter>`."
msgid ""
"Typing `<LocalLeader><LocalLeader>e` will display the error message from the "
"current line in a popup window. This can be highly useful, if error messages "
"are too long to fit on a single line. Likewise, "
"`<LocalLeader><LocalLeader>el` will list all error messages from the current "
"buffer in a new window. You can then select an error message and jump to its "
"origin by pressing `<Enter>`."
msgstr ""
"`<LocalLeader><LocalLeader>e`と打つと現在の行からのエラー文言をポップアップ窓"
"に表示します。\n"
"これはエラー文言が1行に収まらないほどに長すぎるときに大変便利です。\n"
"同様に`<LocalLeader><LocalLeader>el`は新しい窓で現在のバッファからの全てのエ"
"ラー文言を一覧にします。\n"
"エラー文言を選択して`<Enter>`を押すとその出自に飛ぶことができます。"

#. type: Plain text
#: ../src/Appendices/Neovim.md:332
msgid ""
"Other use cases and examples are described on the GitHub page of the `idris2-"
"nvim` plugin and can be included as described there."
msgstr ""
"他のユースケースや例は`idris2-nvim`プラグインのGitHubのページで記述されてお"
"り、\n"
"そちらで記述されているように設定に含められます。"

#. type: Title ##
#: ../src/Appendices/Neovim.md:333
#, no-wrap
msgid "The `%name` Pragma"
msgstr "`%name`プラグマ"

#. type: Plain text
#: ../src/Appendices/Neovim.md:345
#, no-wrap
msgid ""
"When you ask Idris for a skeleton implementation with `<LocalLeader>a`\n"
"or a case split with `<LocalLeader>c`,\n"
"it has to decide on what names to use for the new variables it introduces.\n"
"If these variables already have predefined names (from the function's\n"
"signature, record fields, or named data constructor arguments),\n"
"those names will be used, but\n"
"otherwise Idris will as a default use names `x`, `y`, and `z`, followed\n"
"by other letters. You can change this default behavior by\n"
"specifying a list of names to use for such occasions for any\n"
"data type.\n"
msgstr ""
"Idrisに`<LocalLeader>a`で実装の骨子を尋ねたり`<LocalLeader>c`で場合分割したりしたとき、\n"
"Idrisは導入する新しい変数にどの名前を使うべきかを決めなくてはなりません。\n"
"もしこの変数が既に事前に定義された名前（関数の処方、レコードフィールド、名前付きのデータ構築子の引数）だったら、\n"
"その名前が使われるでしょうが、そうでないときは既定で`x`、`y`、`z`や他の文字を使います。\n"
"この既定の振舞いは変えることができ、\n"
"どんなデータ型についてもそのような状況で使うべき名前の一覧を指定することができます。\n"

#. type: Plain text
#: ../src/Appendices/Neovim.md:347
msgid "For instance:"
msgstr "例えば以下です。"

#. type: Fenced code block (idris)
#: ../src/Appendices/Neovim.md:348
#, no-wrap
msgid ""
"data Element = H | He | C | N | O | F | Ne\n"
"\n"
"%name Element e,f\n"
msgstr ""
"data Element = H | He | C | N | O | F | Ne\n"
"\n"
"%name Element e,f\n"

#. type: Plain text
#: ../src/Appendices/Neovim.md:358
msgid ""
"Idris will then use these names (followed by these names postfixed with "
"increasing integers), when it has to come up with variable names of this "
"type on its own. For instance, here is a test function and the result of "
"adding a skeleton definition to it:"
msgstr ""
"そしてIdrisはこの型の変数名を自分で思い付かなければいけないときに、\n"
"この名前（この名前に続いて適宜増加させた整数を後置します）を使います。\n"
"例えば以下はお試しの関数で、定義の骨子を加えたものです。"

#. type: Fenced code block (idris)
#: ../src/Appendices/Neovim.md:359
#, no-wrap
msgid ""
"test : Element -> Element -> Element -> Element -> Element -> Element\n"
"test e f e1 f1 e2 = ?test_rhs\n"
msgstr ""
"test : Element -> Element -> Element -> Element -> Element -> Element\n"
"test e f e1 f1 e2 = ?test_rhs\n"

#. type: Title ##
#: ../src/Appendices/Neovim.md:364 ../src/Tutorial/DPair.md:1191
#: ../src/Tutorial/DataTypes.md:1319 ../src/Tutorial/Dependent.md:872
#: ../src/Tutorial/Eq.md:1085 ../src/Tutorial/Folds.md:1051
#: ../src/Tutorial/Functions1.md:524 ../src/Tutorial/Functions2.md:924
#: ../src/Tutorial/Functor.md:1395 ../src/Tutorial/IO.md:1095
#: ../src/Tutorial/Interfaces.md:792 ../src/Tutorial/Predicates.md:1358
#: ../src/Tutorial/Traverse.md:1109
#, no-wrap
msgid "Conclusion"
msgstr "まとめ"

#. type: Plain text
#: ../src/Appendices/Neovim.md:372
msgid ""
"Neovim, together with the `idris2-lsp` executable and the `idris2-nvim` "
"editor plugin, provides extensive utilities for interactive editing when "
"programming in Idris. Similar functionality is available for some other "
"editors, so feel free to ask what's available for your editor of choice, for "
"instance on the [Idris 2 Discord channel](https://discord.gg/UX68fDs2jc)."
msgstr ""
"`idris2-lsp`実行プログラムと`idris2-nvim`エディタプラグインを備えたNeovim"
"は、\n"
"Idrisでのプログラミングをする際に対話的編集のための豊富な小間物を提供しま"
"す。\n"
"似た機能は別のエディタで利用できるので、\n"
"読者の選んだエディタでどんなことができるのか\n"
"[Idris 2 Discordチャンネル](https://discord.gg/UX68fDs2jc)で気軽に尋ねてくだ"
"さい。"

#. type: Plain text
#: ../src/Appendices/Neovim.md:374 ../src/Tutorial/DPair.md:1206
#: ../src/Tutorial/DataTypes.md:1368 ../src/Tutorial/Dependent.md:910
#: ../src/Tutorial/Eq.md:1098 ../src/Tutorial/Folds.md:1064
#: ../src/Tutorial/Functions1.md:583 ../src/Tutorial/Functions2.md:964
#: ../src/Tutorial/Functor.md:1427 ../src/Tutorial/IO.md:1125
#: ../src/Tutorial/Interfaces.md:821 ../src/Tutorial/Predicates.md:1369
#: ../src/Tutorial/Prim.md:1411 ../src/Tutorial/Traverse.md:1148
#, no-wrap
msgid ""
"<!-- vi: filetype=idris2\n"
"-->\n"
msgstr ""
"<!-- vi: filetype=idris2\n"
"-->\n"

#. type: Title #
#: ../src/Tutorial/DPair.md:1
#, no-wrap
msgid "Sigma Types"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:18
msgid ""
"So far in our examples of dependently typed programming, type indices such "
"as the length of vectors were known at compile time or could be calculated "
"from values known at compile time. In real applications, however, such "
"information is often not available until runtime, where values depend on the "
"decisions made by users or the state of the surrounding world.  For "
"instance, if we store a file's content as a vector of lines of text, the "
"length of this vector is in general unknown until the file has been loaded "
"into memory.  As a consequence, the types of values we work with depend on "
"other values only known at runtime, and we can often only figure out these "
"types by pattern matching on the values they depend on.  To express these "
"dependencies, we need so called [*sigma types*](https://en.wikipedia.org/"
"wiki/Dependent_type#%CE%A3_type): Dependent pairs and their generalization, "
"dependent records."
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:19
#, no-wrap
msgid ""
"module Tutorial.DPair\n"
"\n"
"import Control.Monad.State\n"
"\n"
"import Data.DPair\n"
"import Data.Either\n"
"import Data.HList\n"
"import Data.List\n"
"import Data.List1\n"
"import Data.Singleton\n"
"import Data.String\n"
"import Data.Vect\n"
"\n"
"import Text.CSV\n"
"\n"
"%default total\n"
msgstr ""

#. type: Title ##
#: ../src/Tutorial/DPair.md:38
#, no-wrap
msgid "Dependent Pairs"
msgstr "依存対"

#. type: Plain text
#: ../src/Tutorial/DPair.md:46
msgid ""
"We've already seen several examples of how useful the length index of a "
"vector is to describe more precisely in the types what a function can and "
"can't do. For instance, `map` or `traverse` operating on a vector will "
"return a vector of exactly the same length. The types guarantee that this is "
"true, therefore the following function is perfectly safe and provably total:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:47
#, no-wrap
msgid ""
"parseAndDrop : Vect (3 + n) String -> Maybe (Vect n Nat)\n"
"parseAndDrop = map (drop 3) . traverse parsePositive\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:60
msgid ""
"Since the argument of `traverse parsePositive` is of type `Vect (3 + n) "
"String`, its result will be of type `Maybe (Vect (3 + n) Nat)`. It is "
"therefore safe to use this in a call to `drop 3`. Note, how all of this is "
"known at compile time: We encoded the prerequisite that the first argument "
"is a vector of at least three elements in the length index and could derive "
"the length of the result from this."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/DPair.md:61
#, no-wrap
msgid "Vectors of Unknown Length"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:65
msgid ""
"However, this is not always possible. Consider the following function, "
"defined on `List` and exported by `Data.List`:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/DPair.md:66
#, no-wrap
msgid ""
"Tutorial.Relations> :t takeWhile\n"
"Data.List.takeWhile : (a -> Bool) -> List a -> List a\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:75
msgid ""
"This will take the longest prefix of the list argument, for which the given "
"predicate returns `True`. In this case, it depends on the list elements and "
"the predicate, how long this prefix will be.  Can we write such a function "
"for vectors? Let's give it a try:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:76
#, no-wrap
msgid "takeWhile' : (a -> Bool) -> Vect n a -> Vect m a\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:92
msgid ""
"Go ahead, and try to implement this. Don't try too long, as you will not be "
"able to do so in a provably total way. The question is: What is the problem "
"here? In order to understand this, we have to realize what the type of "
"`takeWhile'` promises: \"For all predicates operating on values on type `a`, "
"and for all vectors holding values of this type, and for all lengths `m`, I "
"give you a vector of length `m` holding values of type `a`\".  All three "
"arguments are said to be [*universally quantified*](https://en.wikipedia.org/"
"wiki/Universal_quantification): The caller of our function is free to choose "
"the predicate, the input vector, the type of values the vector holds, and "
"*the length of the output vector*. Don't believe me? See here:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:93
#, no-wrap
msgid ""
"-- This looks like trouble: We got a non-empty vector of `Void`...\n"
"voids : Vect 7 Void\n"
"voids = takeWhile' (const True) []\n"
"\n"
"-- ...from which immediately follows a proof of `Void`\n"
"proofOfVoid : Void\n"
"proofOfVoid = head voids\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:108
msgid ""
"See how I could freely decide on the value of `m` when invoking "
"`takeWhile'`? Although I passed `takeWhile'` an empty vector (the only "
"existing vector holding values of type `Void`), the function's type promises "
"me to return a possibly non-empty vector holding values of the same type, "
"from which I freely extracted the first one."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:115
msgid ""
"Luckily, Idris doesn't allow this: We won't be able to implement "
"`takeWhile'` without cheating (for instance, by turning totality checking "
"off and looping forever).  So, the question remains, how to express the "
"result of `takeWhile'` in a type. The answer to this is: \"Use a *dependent "
"pair*\", a vector paired with a value corresponding to its length."
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:116
#, no-wrap
msgid ""
"record AnyVect a where\n"
"  constructor MkAnyVect\n"
"  length : Nat\n"
"  vect   : Vect length a\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:131
msgid ""
"This corresponds to [*existential quantification*](https://en.wikipedia.org/"
"wiki/Existential_quantification)  in predicate logic: There is a natural "
"number, which corresponds to the length of the vector I have here. Note, how "
"from the outside of `AnyVect a`, the length of the wrapped vector is no "
"longer visible at the type level but we can still inspect it and learn "
"something about it at runtime, since it is wrapped up together with the "
"actual vector. We can implement `takeWhile` in such a way that it returns a "
"value of type `AnyVect a`:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:132
#, no-wrap
msgid ""
"takeWhile : (a -> Bool) -> Vect n a -> AnyVect a\n"
"takeWhile f []        = MkAnyVect 0 []\n"
"takeWhile f (x :: xs) = case f x of\n"
"  False => MkAnyVect 0 []\n"
"  True  => let MkAnyVect n ys = takeWhile f xs in MkAnyVect (S n) (x :: ys)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:147
msgid ""
"This works in a provably total way, because callers of this function can no "
"longer choose the length of the resulting vector themselves. Our function, "
"`takeWhile`, decides on this length and returns it together with the vector, "
"and the type checker verifies that we make no mistakes when pairing the two "
"values. In fact, the length can be inferred automatically by Idris, so we "
"can replace it with underscores, if we so desire:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:148
#, no-wrap
msgid ""
"takeWhile2 : (a -> Bool) -> Vect n a -> AnyVect a\n"
"takeWhile2 f []        = MkAnyVect _ []\n"
"takeWhile2 f (x :: xs) = case f x of\n"
"  False => MkAnyVect 0 []\n"
"  True  => let MkAnyVect _ ys = takeWhile2 f xs in MkAnyVect _ (x :: ys)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:161
msgid ""
"To summarize: Parameters in generic function types are universally "
"quantified, and their values can be decided on at the call site of such "
"functions. Dependent record types allow us to describe existentially "
"quantified values. Callers cannot choose such values freely: They are "
"returned as part of a function's result."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:164
msgid ""
"Note, that Idris allows us to be explicit about universal quantification.  "
"The type of `takeWhile'` can also be written like so:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:165
#, no-wrap
msgid "takeWhile'' : forall a, n, m . (a -> Bool) -> Vect n a -> Vect m a\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:173
msgid ""
"Universally quantified arguments are desugared to implicit erased arguments "
"by Idris. The above is a less verbose version of the following function "
"type, the likes of which we have seen before:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:174
#, no-wrap
msgid ""
"takeWhile''' :  {0 a : _}\n"
"             -> {0 n : _}\n"
"             -> {0 m : _}\n"
"             -> (a -> Bool)\n"
"             -> Vect n a\n"
"             -> Vect m a\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:189
msgid ""
"In Idris, we are free to choose whether we want to be explicit about "
"universal quantification. Sometimes it can help understanding what's going "
"on at the type level. Other languages - for instance [PureScript](https://"
"www.purescript.org/) - are more strict about this: There, explicit "
"annotations on universally quantified parameters are [mandatory](https://"
"github.com/purescript/documentation/blob/master/language/Differences-from-"
"Haskell.md#explicit-forall)."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/DPair.md:190
#, no-wrap
msgid "The Essence of Dependent Pairs"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:202
msgid ""
"It can take some time and experience to understand what's going on here. At "
"least in my case, it took many sessions programming in Idris, before I "
"figured out what dependent pairs are about: They pair a *value* of some type "
"with a second value of a type calculated from the first value.  For "
"instance, a natural number `n` (the value)  paired with a vector of length "
"`n` (the second value, the type of which *depends* on the first value).  "
"This is such a fundamental concept of programming with dependent types, that "
"a general dependent pair type is provided by the *Prelude*. Here is its "
"implementation (primed for disambiguation):"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:203
#, no-wrap
msgid ""
"record DPair' (a : Type) (p : a -> Type) where\n"
"  constructor MkDPair'\n"
"  fst : a\n"
"  snd : p fst\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:215
msgid ""
"It is essential to understand what's going on here. There are two "
"parameters: A type `a`, and a function `p`, calculating a *type* from a "
"*value* of type `a`. Such a value (`fst`) is then used to calculate the "
"*type* of the second value (`snd`).  For instance, here is `AnyVect a` "
"represented as a `DPair`:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:216
#, no-wrap
msgid ""
"AnyVect' : (a : Type) -> Type\n"
"AnyVect' a = DPair Nat (\\n => Vect n a)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:225
#, no-wrap
msgid ""
"Note, how `\\n => Vect n a` is a function from `Nat` to `Type`.\n"
"Idris provides special syntax for describing dependent pairs, as\n"
"they are important building blocks for programming in languages\n"
"with first class types:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:226
#, no-wrap
msgid ""
"AnyVect'' : (a : Type) -> Type\n"
"AnyVect'' a = (n : Nat ** Vect n a)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:233
msgid ""
"We can inspect at the REPL, that the right hand side of `AnyVect''` get's "
"desugared to the right hand side of `AnyVect'`:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/DPair.md:234
#, no-wrap
msgid ""
"Tutorial.Relations> (n : Nat ** Vect n Int)\n"
"DPair Nat (\\n => Vect n Int)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:242
msgid ""
"Idris can infer, that `n` must be of type `Nat`, so we can drop this "
"information. (We still need to put the whole expression in parentheses.)"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:243
#, no-wrap
msgid ""
"AnyVect3 : (a : Type) -> Type\n"
"AnyVect3 a = (n ** Vect n a)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:254
msgid ""
"This allows us to pair a natural number `n` with a vector of length `n`, "
"which is exactly what we did with `AnyVect`. We can therefore rewrite "
"`takeWhile` to return a `DPair` instead of our custom type `AnyVect`. Note, "
"that like with regular pairs, we can use the same syntax `(x ** y)` for "
"creating and pattern matching on dependent pairs:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:255
#, no-wrap
msgid ""
"takeWhile3 : (a -> Bool) -> Vect m a -> (n ** Vect n a)\n"
"takeWhile3 f []        = (_ ** [])\n"
"takeWhile3 f (x :: xs) = case f x of\n"
"  False => (_ ** [])\n"
"  True  => let (_  ** ys) = takeWhile3 f xs in (_ ** x :: ys)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:265
msgid ""
"Just like with regular pairs, we can use the dependent pair syntax to define "
"dependent triples and larger tuples:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:266
#, no-wrap
msgid ""
"AnyMatrix : (a : Type) -> Type\n"
"AnyMatrix a = (m ** n ** Vect m (Vect n a))\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/DPair.md:271
#, no-wrap
msgid "Erased Existentials"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:281
msgid ""
"Sometimes, it is possible to determine the value of an index by pattern "
"matching on a value of the indexed type.  For instance, by pattern matching "
"on a vector, we can learn about its length index. In these cases, it is not "
"strictly necessary to carry around the index at runtime, and we can write a "
"special version of a dependent pair where the first argument has quantity "
"zero. Module `Data.DPair` from *base* exports data type `Exists` for this "
"use case."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:284
msgid ""
"As an example, here is a version of `takeWhile` returning a value of type "
"`Exists`:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:285
#, no-wrap
msgid ""
"takeWhileExists : (a -> Bool) -> Vect m a -> Exists (\\n => Vect n a)\n"
"takeWhileExists f []        = Evidence _ []\n"
"takeWhileExists f (x :: xs) = case f x of\n"
"  True  => let Evidence _ ys = takeWhileExists f xs\n"
"            in Evidence _ (x :: ys)\n"
"  False => takeWhileExists f xs\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:297
msgid ""
"In order to restore an erased value, data type `Singleton` from *base* "
"module `Data.Singleton` can be useful: It is parameterized by the *value* it "
"stores:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:298
#, no-wrap
msgid ""
"true : Singleton True\n"
"true = Val True\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:306
msgid ""
"This is called a *singleton* type: A type corresponding to exactly one "
"value. It is a type error to return any other value for constant `true`, and "
"Idris knows this:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:307
#, no-wrap
msgid ""
"true' : Singleton True\n"
"true' = Val _\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:314
msgid ""
"We can use this to conjure the (erased!) length of a vector out of thin air:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:315
#, no-wrap
msgid ""
"vectLength : Vect n a -> Singleton n\n"
"vectLength []        = Val 0\n"
"vectLength (x :: xs) = let Val k = vectLength xs in Val (S k)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:326
msgid ""
"This function comes with much stronger guarantees than `Data.Vect.length`: "
"The latter claims to just return *any* natural number, while `vectLength` "
"*must* return exactly `n` in order to type check. As a demonstration, here "
"is a well-typed bogus implementation of `length`:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:327
#, no-wrap
msgid ""
"bogusLength : Vect n a -> Nat\n"
"bogusLength = const 0\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:334
msgid ""
"This would not be accepted as a valid implementation of `vectLength`, as you "
"may quickly verify yourself."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:338
msgid ""
"With the help of `vectLength` (but not with `Data.Vect.length`)  we can "
"convert an erased existential to a proper dependent pair:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:339
#, no-wrap
msgid ""
"toDPair : Exists (\\n => Vect n a) -> (m ** Vect m a)\n"
"toDPair (Evidence _ as) = let Val m = vectLength as in (m ** as)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:347
msgid ""
"Again, as a quick exercise, try implementing `toDPair` in terms of `length`, "
"and note how Idris will fail to unify the result of `length` with the actual "
"length of the vector."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/DPair.md:348 ../src/Tutorial/DataTypes.md:261
#: ../src/Tutorial/Dependent.md:444 ../src/Tutorial/Eq.md:279
#: ../src/Tutorial/Folds.md:373 ../src/Tutorial/Functor.md:381
#: ../src/Tutorial/IO.md:317 ../src/Tutorial/Interfaces.md:189
#: ../src/Tutorial/Predicates.md:305 ../src/Tutorial/Prim.md:448
#: ../src/Tutorial/Traverse.md:247
#, no-wrap
msgid "Exercises part 1"
msgstr "演習 その1"

#. type: Bullet: '1. '
#: ../src/Tutorial/DPair.md:352
msgid ""
"Declare and implement a function for filtering a vector similar to `Data."
"List.filter`."
msgstr ""

#. type: Bullet: '2. '
#: ../src/Tutorial/DPair.md:356
msgid ""
"Declare and implement a function for mapping a partial function over the "
"values of a vector similar to `Data.List.mapMaybe`."
msgstr ""

#. type: Bullet: '3. '
#: ../src/Tutorial/DPair.md:360
msgid ""
"Declare and implement a function similar to `Data.List.dropWhile` for "
"vectors. Use `Data.DPair.Exists` as your return type."
msgstr ""

#. type: Bullet: '4. '
#: ../src/Tutorial/DPair.md:363
msgid ""
"Repeat exercise 3 but return a proper dependent pair. Use the function from "
"exercise 3 in your implementation."
msgstr ""

#. type: Title ##
#: ../src/Tutorial/DPair.md:364
#, no-wrap
msgid "Use Case: Nucleic Acids"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:372
msgid ""
"We'd like to come up with a small, simplified library for running "
"computations on nucleic acids: RNA and DNA. These are built from five types "
"of nucleobases, three of which are used in both types of nucleic acids and "
"two bases specific for each type of acid. We'd like to make sure that only "
"valid bases are in strands of nucleic acids.  Here's a possible encoding:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:373
#, no-wrap
msgid ""
"data BaseType = DNABase | RNABase\n"
"\n"
"data Nucleobase : BaseType -> Type where\n"
"  Adenine  : Nucleobase b\n"
"  Cytosine : Nucleobase b\n"
"  Guanine  : Nucleobase b\n"
"  Thymine  : Nucleobase DNABase\n"
"  Uracile  : Nucleobase RNABase\n"
"\n"
"NucleicAcid : BaseType -> Type\n"
"NucleicAcid = List . Nucleobase\n"
"\n"
"RNA : Type\n"
"RNA = NucleicAcid RNABase\n"
"\n"
"DNA : Type\n"
"DNA = NucleicAcid DNABase\n"
"\n"
"encodeBase : Nucleobase b -> Char\n"
"encodeBase Adenine  = 'A'\n"
"encodeBase Cytosine = 'C'\n"
"encodeBase Guanine  = 'G'\n"
"encodeBase Thymine  = 'T'\n"
"encodeBase Uracile  = 'U'\n"
"\n"
"encode : NucleicAcid b -> String\n"
"encode = pack . map encodeBase\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:404
msgid "It is a type error to use `Uracile` in a strand of DNA:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:405
#, no-wrap
msgid ""
"failing \"Mismatch between: RNABase and DNABase.\"\n"
"  errDNA : DNA\n"
"  errDNA = [Uracile, Adenine]\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:415
msgid ""
"Note, how we used a variable for nucleobases `Adenine`, `Cytosine`, and "
"`Guanine`: These are again universally quantified, and client code is free "
"to choose a value here. This allows us to use these bases in strands of DNA "
"*and* RNA:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:416
#, no-wrap
msgid ""
"dna1 : DNA\n"
"dna1 = [Adenine, Cytosine, Guanine]\n"
"\n"
"rna1 : RNA\n"
"rna1 = [Adenine, Cytosine, Guanine]\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:427
msgid ""
"With `Thymine` and `Uracile`, we are more restrictive: `Thymine` is only "
"allowed in DNA, while `Uracile` is restricted to be used in RNA strands.  "
"Let's write parsers for strands of DNA and RNA:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:428
#, no-wrap
msgid ""
"readAnyBase : Char -> Maybe (Nucleobase b)\n"
"readAnyBase 'A' = Just Adenine\n"
"readAnyBase 'C' = Just Cytosine\n"
"readAnyBase 'G' = Just Guanine\n"
"readAnyBase _   = Nothing\n"
"\n"
"readRNABase : Char -> Maybe (Nucleobase RNABase)\n"
"readRNABase 'U' = Just Uracile\n"
"readRNABase c   = readAnyBase c\n"
"\n"
"readDNABase : Char -> Maybe (Nucleobase DNABase)\n"
"readDNABase 'T' = Just Thymine\n"
"readDNABase c   = readAnyBase c\n"
"\n"
"readRNA : String -> Maybe RNA\n"
"readRNA = traverse readRNABase . unpack\n"
"\n"
"readDNA : String -> Maybe DNA\n"
"readDNA = traverse readDNABase . unpack\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:454
msgid ""
"Again, in case of the bases appearing in both kinds of strands, users of the "
"universally quantified `readAnyBase` are free to choose what base type they "
"want, but they will never get a `Thymine` or `Uracile` value."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:458
msgid ""
"We can now implement some simple calculations on sequences of nucleobases. "
"For instance, we can come up with the complementary strand:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:459
#, no-wrap
msgid ""
"complementRNA' : RNA -> RNA\n"
"complementRNA' = map calc\n"
"  where calc : Nucleobase RNABase -> Nucleobase RNABase\n"
"        calc Guanine  = Cytosine\n"
"        calc Cytosine = Guanine\n"
"        calc Adenine  = Uracile\n"
"        calc Uracile  = Adenine\n"
"\n"
"complementDNA' : DNA -> DNA\n"
"complementDNA' = map calc\n"
"  where calc : Nucleobase DNABase -> Nucleobase DNABase\n"
"        calc Guanine  = Cytosine\n"
"        calc Cytosine = Guanine\n"
"        calc Adenine  = Thymine\n"
"        calc Thymine  = Adenine\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:480
msgid ""
"Ugh, code repetition! Not too bad here, but imagine there were dozens of "
"bases with only few specialized ones. Surely, we can do better? "
"Unfortunately, the following won't work:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:481
#, no-wrap
msgid ""
"complementBase' : Nucleobase b -> Nucleobase b\n"
"complementBase' Adenine  = ?what_now\n"
"complementBase' Cytosine = Guanine\n"
"complementBase' Guanine  = Cytosine\n"
"complementBase' Thymine  = Adenine\n"
"complementBase' Uracile  = Adenine\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:497
msgid ""
"All goes well with the exception of the `Adenine` case. Remember: Parameter "
"`b` is universally quantified, and the *callers* of our function can decide "
"what `b` is supposed to be. We therefore can't just return `Thymine`: Idris "
"will respond with a type error since callers might want a `Nucleobase "
"RNABase` instead.  One way to go about this is to take an additional "
"unerased argument (explicit or implicit) representing the base type:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:498
#, no-wrap
msgid ""
"complementBase : (b : BaseType) -> Nucleobase b -> Nucleobase b\n"
"complementBase DNABase Adenine  = Thymine\n"
"complementBase RNABase Adenine  = Uracile\n"
"complementBase _       Cytosine = Guanine\n"
"complementBase _       Guanine  = Cytosine\n"
"complementBase _       Thymine  = Adenine\n"
"complementBase _       Uracile  = Adenine\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:512
msgid ""
"This is again an example of a dependent *function* type (also called a [*pi "
"type*](https://en.wikipedia.org/wiki/Dependent_type#%CE%A0_type)): The input "
"and output types both *depend* on the *value* of the first argument.  We can "
"now use this to calculate the complement of any nucleic acid:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:513
#, no-wrap
msgid ""
"complement : (b : BaseType) -> NucleicAcid b -> NucleicAcid b\n"
"complement b = map (complementBase b)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:528
msgid ""
"Now, here is an interesting use case: We'd like to read a sequence of "
"nucleobases from user input, accepting two strings: The first telling us, "
"whether the user plans to enter a DNA or RNA sequence, the second being the "
"sequence itself. What should be the type of such a function? Well, we're "
"describing computations with side effects, so something involving `IO` seems "
"about right. User input almost always needs to be validated or translated, "
"so something might go wrong and we need an error type for this case. "
"Finally, our users can decide whether they want to enter a strand of RNA or "
"DNA, so this distinction should be encoded as well."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:531
msgid ""
"Of course, it is always possible to write a custom sum type for such a use "
"case:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:532
#, no-wrap
msgid ""
"data Result : Type where\n"
"  UnknownBaseType : String -> Result\n"
"  InvalidSequence : String -> Result\n"
"  GotDNA          : DNA -> Result\n"
"  GotRNA          : RNA -> Result\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:544
msgid ""
"This has all possible outcomes encoded in a single data type.  However, it "
"is lacking in terms of flexibility. If we want to handle errors early on and "
"just extract a strand of RNA or DNA, we need yet another data type:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:545
#, no-wrap
msgid "data RNAOrDNA = ItsRNA RNA | ItsDNA DNA\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:552
msgid ""
"This might be the way to go, but for results with many options, this can get "
"cumbersome quickly. Also: Why come up with a custom data type when we "
"already have the tools to deal with this at our hands?"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:554
msgid "Here is how we can encode this with a dependent pair:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:555
#, no-wrap
msgid ""
"namespace InputError\n"
"  public export\n"
"  data InputError : Type where\n"
"    UnknownBaseType : String -> InputError\n"
"    InvalidSequence : String -> InputError\n"
"\n"
"readAcid : (b : BaseType) -> String -> Either InputError (NucleicAcid b)\n"
"readAcid b str =\n"
"  let err = InvalidSequence str\n"
"   in case b of\n"
"        DNABase => maybeToEither err $ readDNA str\n"
"        RNABase => maybeToEither err $ readRNA str\n"
"\n"
"getNucleicAcid : IO (Either InputError (b ** NucleicAcid b))\n"
"getNucleicAcid = do\n"
"  baseString <- getLine\n"
"  case baseString of\n"
"    \"DNA\" => map (MkDPair _) . readAcid DNABase <$> getLine\n"
"    \"RNA\" => map (MkDPair _) . readAcid RNABase <$> getLine\n"
"    _     => pure $ Left (UnknownBaseType baseString)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:583
msgid ""
"Note, how we paired the type of nucleobases with the nucleic acid sequence. "
"Assume now we implement a function for transcribing a strand of DNA to RNA, "
"and we'd like to convert a sequence of nucleobases from user input to the "
"corresponding RNA sequence.  Here's how to do this:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:584
#, no-wrap
msgid ""
"transcribeBase : Nucleobase DNABase -> Nucleobase RNABase\n"
"transcribeBase Adenine  = Uracile\n"
"transcribeBase Cytosine = Guanine\n"
"transcribeBase Guanine  = Cytosine\n"
"transcribeBase Thymine  = Adenine\n"
"\n"
"transcribe : DNA -> RNA\n"
"transcribe = map transcribeBase\n"
"\n"
"printRNA : RNA -> IO ()\n"
"printRNA = putStrLn . encode\n"
"\n"
"transcribeProg : IO ()\n"
"transcribeProg = do\n"
"  Right (b ** seq) <- getNucleicAcid\n"
"    | Left (InvalidSequence str) => putStrLn $ \"Invalid sequence: \" ++ str\n"
"    | Left (UnknownBaseType str) => putStrLn $ \"Unknown base type: \" ++ str\n"
"  case b of\n"
"    DNABase => printRNA $ transcribe seq\n"
"    RNABase => printRNA seq\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:611
msgid ""
"By pattern matching on the first value of the dependent pair we could "
"determine, whether the second value is an RNA or DNA sequence.  In the first "
"case, we had to transcribe the sequence first, in the second case, we could "
"invoke `printRNA` directly."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:620
msgid ""
"In a more interesting scenario, we would *translate* the RNA sequence to the "
"corresponding protein sequence. Still, this example shows how to deal with a "
"simplified real world scenario: Data may be encoded differently and coming "
"from different sources. By using precise types, we are forced to first "
"convert values to the correct format. Failing to do so leads to a compile "
"time exception instead of an error at runtime or - even worse - the program "
"silently running a bogus computation."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/DPair.md:621
#, no-wrap
msgid "Dependent Records vs Sum Types"
msgstr "依存型対直和型"

#. type: Plain text
#: ../src/Tutorial/DPair.md:630
msgid ""
"Dependent records as shown for `AnyVect a` are a generalization of dependent "
"pairs: We can have an arbitrary number of fields and use the values stored "
"therein to calculate the types of other values. For very simple cases like "
"the example with nucleobases, it doesn't matter too much, whether we use a "
"`DPair`, a custom dependent record, or even a sum type. In fact, the three "
"encodings are equally expressive:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:631
#, no-wrap
msgid ""
"Acid1 : Type\n"
"Acid1 = (b ** NucleicAcid b)\n"
"\n"
"record Acid2 where\n"
"  constructor MkAcid2\n"
"  baseType : BaseType\n"
"  sequence : NucleicAcid baseType\n"
"\n"
"data Acid3 : Type where\n"
"  SomeRNA : RNA -> Acid3\n"
"  SomeDNA : DNA -> Acid3\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:652
msgid ""
"It is trivial to write lossless conversions between these encodings, and "
"with each encoding we can decide with a simple pattern match, whether we "
"currently have a sequence of RNA or DNA. However, dependent types can depend "
"on more than one value, as we will see in the exercises. In such cases, sum "
"types and dependent pairs quickly become unwieldy, and you should go for an "
"encoding as a dependent record."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/DPair.md:653 ../src/Tutorial/DataTypes.md:436
#: ../src/Tutorial/Dependent.md:623 ../src/Tutorial/Eq.md:555
#: ../src/Tutorial/Folds.md:668 ../src/Tutorial/Functor.md:962
#: ../src/Tutorial/IO.md:728 ../src/Tutorial/Interfaces.md:352
#: ../src/Tutorial/Predicates.md:672 ../src/Tutorial/Prim.md:712
#: ../src/Tutorial/Traverse.md:574
#, no-wrap
msgid "Exercises part 2"
msgstr "演習 その2"

#. type: Plain text
#: ../src/Tutorial/DPair.md:661
msgid ""
"Sharpen your skills in using dependent pairs and dependent records! In "
"exercises 2 to 7 you have to decide yourself, when a function should return "
"a dependent pair or record, when a function requires additional arguments, "
"on which you can pattern match, and what other utility functions might be "
"necessary."
msgstr ""

#. type: Bullet: '1. '
#: ../src/Tutorial/DPair.md:666
msgid ""
"Proof that the three encodings for nucleobases are *isomorphic* (meaning: of "
"the same structure) by writing lossless conversion functions from `Acid1` to "
"`Acid2` and back. Likewise for `Acid1` and `Acid3`."
msgstr ""

#. type: Bullet: '2. '
#: ../src/Tutorial/DPair.md:673
msgid ""
"Sequences of nucleobases can be encoded in one of two directions: [*Sense* "
"and *antisense*](https://en.wikipedia.org/wiki/Sense_(molecular_biology)).  "
"Declare a new data type to describe the sense of a sequence of nucleobases, "
"and add this as an additional parameter to type `Nucleobase` and types `DNA` "
"and `RNA`."
msgstr ""

#. type: Bullet: '3. '
#: ../src/Tutorial/DPair.md:677
msgid ""
"Refine the types of `complement` and `transcribe`, so that they reflect the "
"changing of *sense*. In case of `transcribe`, a strand of antisense DNA is "
"converted to a strand of sense RNA."
msgstr ""

#. type: Bullet: '4. '
#: ../src/Tutorial/DPair.md:680
msgid ""
"Define a dependent record storing the base type and sense together with a "
"sequence of nucleobases."
msgstr ""

#. type: Bullet: '5. '
#: ../src/Tutorial/DPair.md:685
msgid ""
"Adjust `readRNA` and `readDNA` in such a way that the *sense* of a sequence "
"is read from the input string.  Sense strands are encoded like so: \"5´-"
"CGGTAG-3´\". Antisense strands are encoded like so: \"3´-CGGTAG-5´\"."
msgstr ""

#. type: Bullet: '6. '
#: ../src/Tutorial/DPair.md:688
msgid "Adjust `encode` in such a way that it includes the sense in its output."
msgstr ""

#. type: Bullet: '7. '
#: ../src/Tutorial/DPair.md:693
msgid ""
"Enhance `getNucleicAcid` and `transcribeProg` in such a way that the sense "
"and base type are stored together with the sequence, and that "
"`transcribeProg` always prints the *sense* RNA strand (after transcription, "
"if necessary)."
msgstr ""

#. type: Bullet: '8. '
#: ../src/Tutorial/DPair.md:695
msgid "Enjoy the fruits of your labour and test your program at the REPL."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:703
msgid ""
"Note: Instead of using a dependent record, we could again have used a sum "
"type of four constructors to encode the different types of sequences. "
"However, the number of constructors required corresponds to the *product* of "
"the number of values of each type level index. Therefore, this number can "
"grow quickly and sum type encodings can lead to lengthy blocks of pattern "
"matches in these cases."
msgstr ""

#. type: Title ##
#: ../src/Tutorial/DPair.md:704
#, no-wrap
msgid "Use Case: CSV Files with a Schema"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:712
msgid ""
"In this section, we are going to look at an extended example based on our "
"previous work on CSV parsers. We'd like to write a small command-line "
"program, where users can specify a schema for the CSV tables they'd like to "
"parse and load into memory. Before we begin, here is a REPL session running "
"the final program, which you will complete in the exercises:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/DPair.md:713
#, no-wrap
msgid ""
"Solutions.DPair> :exec main\n"
"Enter a command: load resources/example\n"
"Table loaded. Schema: str,str,fin2023,str?,boolean?\n"
"Enter a command: get 3\n"
"Row 3:\n"
"\n"
"str   | str    | fin2023 | str? | boolean?\n"
"------------------------------------------\n"
"Floor | Jansen | 1981    |      | t\n"
"\n"
"Enter a command: add Mikael,Stanne,1974,,\n"
"Row prepended:\n"
"\n"
"str    | str    | fin2023 | str? | boolean?\n"
"-------------------------------------------\n"
"Mikael | Stanne | 1974    |      |\n"
"\n"
"Enter a command: get 1\n"
"Row 1:\n"
"\n"
"str    | str    | fin2023 | str? | boolean?\n"
"-------------------------------------------\n"
"Mikael | Stanne | 1974    |      |\n"
"\n"
"Enter a command: delete 1\n"
"Deleted row: 1.\n"
"Enter a command: get 1\n"
"Row 1:\n"
"\n"
"str | str     | fin2023 | str? | boolean?\n"
"-----------------------------------------\n"
"Rob | Halford | 1951    |      |\n"
"\n"
"Enter a command: quit\n"
"Goodbye.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:754
msgid ""
"This example was inspired by a similar program used as an example in the "
"[Type-Driven Development with Idris](https://www.manning.com/books/type-"
"driven-development-with-idris)  book."
msgstr ""
"この例は書籍[Type-Driven Development with Idris](https://www.manning.com/"
"books/type-driven-development-with-idris)にある例で\n"
"使われたプログラムに着想を得ました。"

#. type: Plain text
#: ../src/Tutorial/DPair.md:756
msgid "We'd like to focus on several things here:"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/DPair.md:763
msgid ""
"Purity: With the exception of the main program loop, all functions used in "
"the implementation should be pure, which in this context means \"not running "
"in any monad with side effects such as `IO`\"."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/DPair.md:763
msgid ""
"Fail early: With the exception of the command parser, all functions updating "
"the table and handling queries should be typed and implemented in such a way "
"that they cannot fail."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:766
msgid ""
"We are often well advised to adhere to these two guidelines, as they can "
"make the majority of our functions easier to implement and test."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:772
msgid ""
"Since we allow users of our library to specify a schema (order and types of "
"columns) for the table they work with, this information is not known until "
"runtime. The same goes for the current size of the table. We will therefore "
"store both values as fields in a dependent record."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/DPair.md:773
#, no-wrap
msgid "Encoding the Schema"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:780
msgid ""
"We need to inspect the table schema at runtime. Although theoretically "
"possible, it is not advisable to operate on Idris types directly here.  We'd "
"rather use a closed custom data type describing the types of columns we "
"understand. In a first try, we only support some Idris primitives:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:781
#, no-wrap
msgid ""
"data ColType = I64 | Str | Boolean | Float\n"
"\n"
"Schema : Type\n"
"Schema = List ColType\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:791
msgid ""
"Next, we need a way to convert a `Schema` to a list of Idris types, which we "
"will then use as the index of a heterogeneous list representing the rows in "
"our table:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:792
#, no-wrap
msgid ""
"IdrisType : ColType -> Type\n"
"IdrisType I64     = Int64\n"
"IdrisType Str     = String\n"
"IdrisType Boolean = Bool\n"
"IdrisType Float   = Double\n"
"\n"
"Row : Schema -> Type\n"
"Row = HList . map IdrisType\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:807
msgid ""
"We can now describe a table as a dependent record storing the table's "
"content as a vector of rows. In order to safely index rows of the table and "
"parse new rows to be added, the current schema and size of the table must be "
"known at runtime:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:808
#, no-wrap
msgid ""
"record Table where\n"
"  constructor MkTable\n"
"  schema : Schema\n"
"  size   : Nat\n"
"  rows   : Vect size (Row schema)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:823
msgid ""
"Finally, we define an indexed data type describing commands operating on the "
"current table. Using the current table as the command's index allows us to "
"make sure that indices for accessing and deleting rows are within bounds and "
"that new rows agree with the current schema. This is necessary to uphold our "
"second design principle: All functions operating on tables must do so "
"without the possibility of failure."
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:824
#, no-wrap
msgid ""
"data Command : (t : Table) -> Type where\n"
"  PrintSchema : Command t\n"
"  PrintSize   : Command t\n"
"  New         : (newSchema : Schema) -> Command t\n"
"  Prepend     : Row (schema t) -> Command t\n"
"  Get         : Fin (size t) -> Command t\n"
"  Delete      : Fin (size t) -> Command t\n"
"  Quit        : Command t\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:839
msgid ""
"We can now implement the main application logic: How user entered commands "
"affect the application's current state. As promised, this comes without the "
"risk of failure, so we don't have to wrap the return type in an `Either`:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:840
#, no-wrap
msgid ""
"applyCommand : (t : Table) -> Command t -> Table\n"
"applyCommand t                 PrintSchema = t\n"
"applyCommand t                 PrintSize   = t\n"
"applyCommand _                 (New ts)    = MkTable ts _ []\n"
"applyCommand (MkTable ts n rs) (Prepend r) = MkTable ts _ $ r :: rs\n"
"applyCommand t                 (Get x)     = t\n"
"applyCommand t                 Quit        = t\n"
"applyCommand (MkTable ts n rs) (Delete x)  = case n of\n"
"  S k => MkTable ts k (deleteAt x rs)\n"
"  Z   => absurd x\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:857
msgid ""
"Please understand, that the constructors of `Command t` are typed in such a "
"way that indices are always within bounds (constructors `Get` and `Delete`), "
"and new rows adhere to the table's current schema (constructor `Prepend`)."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:866
msgid ""
"One thing you might not have seen so far is the call to `absurd` on the last "
"line. This is a derived function of the `Uninhabited` interface, which is "
"used to describe types such as `Void` or - in the case above - `Fin 0`, of "
"which there can be no value. Function `absurd` is then just another "
"manifestation of the principle of explosion. If this doesn't make too much "
"sense yet, don't worry. We will look at `Void` and its uses in the next "
"chapter."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/DPair.md:867
#, no-wrap
msgid "Parsing Commands"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:879
msgid ""
"User input validation is an important topic when writing applications. If it "
"happens early, you can keep larger parts of your application pure (which - "
"in this context - means: \"without the possibility of failure\") and "
"provably total.  If done properly, this step encodes and handles most if not "
"all ways in which things can go wrong in your program, allowing you to come "
"up with clear error messages telling users exactly what caused an issue. As "
"you surely have experienced yourself, there are few things more frustrating "
"than a non-trivial computer program terminating with an unhelpful \"There "
"was an error\" message."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:892
msgid ""
"So, in order to treat this important topic with all due respect, we are "
"first going to implement a custom error type. This is not *strictly* "
"necessary for small programs, but once your software gets more complex, it "
"can be tremendously helpful for keeping track of what can go wrong where. In "
"order to figure out what can possibly go wrong, we first need to decide on "
"how the commands should be entered.  Here, we use a single keyword for each "
"command, together with an optional number of arguments separated from the "
"keyword by a single space character. For instance: `\"new i64,boolean,str,str"
"\"`, for initializing an empty table with a new schema. With this settled, "
"here is a list of things that can go wrong, and the messages we'd like to "
"print:"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/DPair.md:907
msgid ""
"A bogus command is entered. We repeat the input with a message that we don't "
"know the command plus a list of commands we know about."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/DPair.md:907
msgid ""
"An invalid schema was entered. In this case, we list the position of the "
"first unknown type, the string we found there, and a list of types we know "
"about."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/DPair.md:907
msgid ""
"An invalid CSV encoding of a row was entered. We list the erroneous "
"position, the string encountered there, plus the expected type. In case of a "
"too small or too large number of fields, we also print a corresponding error "
"message."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/DPair.md:907
msgid ""
"An index was out of bounds. This can happen, when users try to access or "
"delete specific rows. We print the current number of rows plus the value "
"entered."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/DPair.md:907
msgid ""
"A value not representing a natural number was entered as an index.  We print "
"an according error message."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:910
msgid ""
"That's a lot of stuff to keep track off, so let's encode this in a sum type:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:911
#, no-wrap
msgid ""
"data Error : Type where\n"
"  UnknownCommand : String -> Error\n"
"  UnknownType    : (pos : Nat) -> String -> Error\n"
"  InvalidField   : (pos : Nat) -> ColType -> String -> Error\n"
"  ExpectedEOI    : (pos : Nat) -> String -> Error\n"
"  UnexpectedEOI  : (pos : Nat) -> String -> Error\n"
"  OutOfBounds    : (size : Nat) -> (index : Nat) -> Error\n"
"  NoNat          : String -> Error\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:929
msgid ""
"In order to conveniently construct our error messages, it is best to use "
"Idris' string interpolation facilities: We can enclose arbitrary string "
"expressions in a string literal by enclosing them in curly braces, the first "
"of which must be escaped with a backslash. Like so: `\"foo \\{myExpr a b "
"c}\"`.  We can pair this with multiline string literals to get nicely "
"formatted error messages."
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:930
#, no-wrap
msgid ""
"showColType : ColType -> String\n"
"showColType I64      = \"i64\"\n"
"showColType Str      = \"str\"\n"
"showColType Boolean  = \"boolean\"\n"
"showColType Float    = \"float\"\n"
"\n"
"showSchema : Schema -> String\n"
"showSchema = concat . intersperse \",\" . map showColType\n"
"\n"
"allTypes : String\n"
"allTypes = concat\n"
"         . List.intersperse \", \"\n"
"         . map showColType\n"
"         $ [I64,Str,Boolean,Float]\n"
"\n"
"showError : Error -> String\n"
"showError (UnknownCommand x) = \"\"\"\n"
"  Unknown command: \\{x}.\n"
"  Known commands are: clear, schema, size, new, add, get, delete, quit.\n"
"  \"\"\"\n"
"\n"
"showError (UnknownType pos x) = \"\"\"\n"
"  Unknown type at position \\{show pos}: \\{x}.\n"
"  Known types are: \\{allTypes}.\n"
"  \"\"\"\n"
"\n"
"showError (InvalidField pos tpe x) = \"\"\"\n"
"  Invalid value at position \\{show pos}.\n"
"  Expected type: \\{showColType tpe}.\n"
"  Value found: \\{x}.\n"
"  \"\"\"\n"
"\n"
"showError (ExpectedEOI k x) = \"\"\"\n"
"  Expected end of input.\n"
"  Position: \\{show k}\n"
"  Input: \\{x}\n"
"  \"\"\"\n"
"\n"
"showError (UnexpectedEOI k x) = \"\"\"\n"
"  Unxpected end of input.\n"
"  Position: \\{show k}\n"
"  Input: \\{x}\n"
"  \"\"\"\n"
"\n"
"showError (OutOfBounds size index) = \"\"\"\n"
"  Index out of bounds.\n"
"  Size of table: \\{show size}\n"
"  Index: \\{show index}\n"
"  Note: Indices start at 1.\n"
"  \"\"\"\n"
"\n"
"showError (NoNat x) = \"Not a natural number: \\{x}\"\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:990
msgid ""
"We can now write parsers for the different commands. We need facilities to "
"parse vector indices, schemata, and CSV rows.  Since we are using a CSV "
"format for encoding and decoding rows, it makes sense to also encode the "
"schema as a comma-separated list of values:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:991
#, no-wrap
msgid ""
"zipWithIndex : Traversable t => t a -> t (Nat, a)\n"
"zipWithIndex = evalState 1 . traverse pairWithIndex\n"
"  where pairWithIndex : a -> State Nat (Nat,a)\n"
"        pairWithIndex v = (,v) <$> get <* modify S\n"
"\n"
"fromCSV : String -> List String\n"
"fromCSV = forget . split (',' ==)\n"
"\n"
"readColType : Nat -> String -> Either Error ColType\n"
"readColType _ \"i64\"      = Right I64\n"
"readColType _ \"str\"      = Right Str\n"
"readColType _ \"boolean\"  = Right Boolean\n"
"readColType _ \"float\"    = Right Float\n"
"readColType n s          = Left $ UnknownType n s\n"
"\n"
"readSchema : String -> Either Error Schema\n"
"readSchema = traverse (uncurry readColType) . zipWithIndex . fromCSV\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:1018
msgid ""
"We also need to decode CSV content based on the current schema.  Note, how "
"we can do so in a type safe manner by pattern matching on the schema, which "
"will not be known until runtime. Unfortunately, we need to reimplement CSV-"
"parsing, because we want to add the expected type to the error messages (a "
"thing that would be much harder to do with interface `CSVLine` and error "
"type `CSVError`)."
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:1019
#, no-wrap
msgid ""
"decodeField : Nat -> (c : ColType) -> String -> Either Error (IdrisType c)\n"
"decodeField k c s =\n"
"  let err = InvalidField k c s\n"
"   in case c of\n"
"        I64     => maybeToEither err $ read s\n"
"        Str     => maybeToEither err $ read s\n"
"        Boolean => maybeToEither err $ read s\n"
"        Float   => maybeToEither err $ read s\n"
"\n"
"decodeRow : {ts : _} -> String -> Either Error (Row ts)\n"
"decodeRow s = go 1 ts $ fromCSV s\n"
"  where go : Nat -> (cs : Schema) -> List String -> Either Error (Row cs)\n"
"        go k []       []         = Right []\n"
"        go k []       (_ :: _)   = Left $ ExpectedEOI k s\n"
"        go k (_ :: _) []         = Left $ UnexpectedEOI k s\n"
"        go k (c :: cs) (s :: ss) = [| decodeField k c s :: go (S k) cs ss |]\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:1040
msgid ""
"There is no hard and fast rule about whether to pass an index as an implicit "
"argument or not. Some considerations:"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/DPair.md:1047
msgid ""
"Pattern matching on explicit arguments comes with less syntactic overhead."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/DPair.md:1047
msgid ""
"If an argument can be inferred from the context most of the time, consider "
"passing it as an implicit to make your function nicer to use in client code."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/DPair.md:1047
msgid ""
"Use explicit (possibly erased) arguments for values that can't be inferred "
"by Idris most of the time."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:1052
msgid ""
"All that is missing now is a way to parse indices for accessing the current "
"table's rows. We use the conversion for indices to start at one instead of "
"zero, which feels more natural for most non-programmers."
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:1053
#, no-wrap
msgid ""
"readFin : {n : _} -> String -> Either Error (Fin n)\n"
"readFin s = do\n"
"  S k <- maybeToEither (NoNat s) $ parsePositive {a = Nat} s\n"
"    | Z => Left $ OutOfBounds n Z\n"
"  maybeToEither (OutOfBounds n $ S k) $ natToFin k n\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:1067
msgid ""
"We are finally able to implement a parser for user commands.  Function `Data."
"String.words` is used for splitting a string at space characters. In most "
"cases, we expect the name of the command plus a single argument without "
"additional spaces.  CSV rows can have additional space characters, however, "
"so we use `Data.String.unwords` on the split string."
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:1068
#, no-wrap
msgid ""
"readCommand :  (t : Table) -> String -> Either Error (Command t)\n"
"readCommand _                \"schema\"  = Right PrintSchema\n"
"readCommand _                \"size\"    = Right PrintSize\n"
"readCommand _                \"quit\"    = Right Quit\n"
"readCommand (MkTable ts n _) s         = case words s of\n"
"  [\"new\",    str] => New     <$> readSchema str\n"
"  \"add\" ::   ss   => Prepend <$> decodeRow (unwords ss)\n"
"  [\"get\",    str] => Get     <$> readFin str\n"
"  [\"delete\", str] => Delete  <$> readFin str\n"
"  _               => Left $ UnknownCommand s\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/DPair.md:1081
#, no-wrap
msgid "Running the Application"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:1087
msgid ""
"All that's left to do is to write functions for printing the results of "
"commands to users and run the application in a loop until command `\"quit\"` "
"is entered."
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:1088
#, no-wrap
msgid ""
"encodeField : (t : ColType) -> IdrisType t -> String\n"
"encodeField I64     x     = show x\n"
"encodeField Str     x     = show x\n"
"encodeField Boolean True  = \"t\"\n"
"encodeField Boolean False = \"f\"\n"
"encodeField Float   x     = show x\n"
"\n"
"encodeRow : (ts : List ColType) -> Row ts -> String\n"
"encodeRow ts = concat . intersperse \",\" . go ts\n"
"  where go : (cs : List ColType) -> Row cs -> Vect (length cs) String\n"
"        go []        []        = []\n"
"        go (c :: cs) (v :: vs) = encodeField c v :: go cs vs\n"
"\n"
"result :  (t : Table) -> Command t -> String\n"
"result t PrintSchema = \"Current schema: \\{showSchema t.schema}\"\n"
"result t PrintSize   = \"Current size: \\{show t.size}\"\n"
"result _ (New ts)    = \"Created table. Schema: \\{showSchema ts}\"\n"
"result t (Prepend r) = \"Row prepended: \\{encodeRow t.schema r}\"\n"
"result _ (Delete x)  = \"Deleted row: \\{show $ FS x}.\"\n"
"result _ Quit        = \"Goodbye.\"\n"
"result t (Get x)     =\n"
"  \"Row \\{show $ FS x}: \\{encodeRow t.schema (index x t.rows)}\"\n"
"\n"
"covering\n"
"runProg : Table -> IO ()\n"
"runProg t = do\n"
"  putStr \"Enter a command: \"\n"
"  str <- getLine\n"
"  case readCommand t str of\n"
"    Left err   => putStrLn (showError err) >> runProg t\n"
"    Right Quit => putStrLn (result t Quit)\n"
"    Right cmd  => putStrLn (result t cmd) >>\n"
"                  runProg (applyCommand t cmd)\n"
"\n"
"covering\n"
"main : IO ()\n"
"main = runProg $ MkTable [] _ []\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/DPair.md:1128 ../src/Tutorial/DataTypes.md:742
#: ../src/Tutorial/Dependent.md:843 ../src/Tutorial/Eq.md:826
#: ../src/Tutorial/Folds.md:988 ../src/Tutorial/Functor.md:1232
#: ../src/Tutorial/IO.md:949 ../src/Tutorial/Interfaces.md:624
#: ../src/Tutorial/Predicates.md:1020 ../src/Tutorial/Prim.md:936
#: ../src/Tutorial/Traverse.md:1016
#, no-wrap
msgid "Exercises part 3"
msgstr "演習 その3"

#. type: Plain text
#: ../src/Tutorial/DPair.md:1136
msgid ""
"The challenges presented here all deal with enhancing our table editor in "
"several interesting ways. Some of them are more a matter of style and less a "
"matter of learning to write dependently typed programs, so feel free to "
"solve these as you please. Exercises 1 to 3 should be considered to be "
"mandatory."
msgstr ""

#. type: Bullet: '1. '
#: ../src/Tutorial/DPair.md:1139
msgid "Add support for storing Idris types `Integer` and `Nat` in CSV columns"
msgstr ""

#. type: Bullet: '2. '
#: ../src/Tutorial/DPair.md:1142
msgid ""
"Add support for `Fin n` to CSV columns. Note: We need runtime access to `n` "
"in order for this to work."
msgstr ""

#. type: Bullet: '3. '
#: ../src/Tutorial/DPair.md:1148
msgid ""
"Add support for optional types to CSV columns. Since missing values should "
"be encoded by empty strings, it makes no sense to allow for nested optional "
"types, meaning that types like `Maybe Nat` should be allowed while `Maybe "
"(Maybe Nat)` should not."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:1151
#, no-wrap
msgid ""
"   Hint: There are several ways to encode these, one being\n"
"   to add a boolean index to `ColType`.\n"
msgstr ""

#. type: Bullet: '4. '
#: ../src/Tutorial/DPair.md:1154
msgid ""
"Add a command for printing the whole table. Bonus points if all columns are "
"properly aligned."
msgstr ""

#. type: Bullet: '5. '
#: ../src/Tutorial/DPair.md:1158
msgid ""
"Add support for simple queries: Given a column number and a value, list all "
"rows where entries match the given value."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:1160
#, no-wrap
msgid "   This might be a challenge, as the types get pretty interesting.\n"
msgstr ""

#. type: Bullet: '6. '
#: ../src/Tutorial/DPair.md:1164
msgid ""
"Add support for loading and saving tables from and to disk.  A table should "
"be stored in two files: One for the schema and one for the CSV content."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:1179
#, no-wrap
msgid ""
"   Note: Reading files in a provably total way can be pretty\n"
"   hard and will be a topic for another day. For now,\n"
"   just use function `readFile` exported from\n"
"   `System.File` in base for reading a file as a whole.\n"
"   This function is partial, because\n"
"   it will not terminate when used with an infinite input\n"
"   stream such as `/dev/urandom` or `/dev/zero`.\n"
"   It is important to *not* use `assert_total` here.\n"
"   Using partial functions like `readFile` might well impose\n"
"   a security risk in a real world application, so eventually,\n"
"   we'd have to deal with this and allow for some way to\n"
"   limit the size of accepted input. It is therefore best\n"
"   to make this partiality visible and annotate all downstream\n"
"   functions accordingly.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:1183
msgid ""
"You can find an implementation of these additions in the solutions. A small "
"example table can be found in folder `resources`."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:1190
msgid ""
"Note: There are of course tons of projects to pursue from here, such as "
"writing a proper query language, calculating new rows from existing ones, "
"accumulating values in a column, concatenating and zipping tables, and so "
"on.  We will stop for now, probably coming back to this in later examples."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:1198
msgid ""
"Dependent pairs and records are necessary to at runtime inspect the values "
"defining the types we work with. By pattern matching on these values, we "
"learn about the types and possible shapes of other values, allowing us to "
"reduce the number of potential bugs in our programs."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:1204
msgid ""
"In the [next chapter](Eq.md) we start learning about how to write data "
"types, which we use as proofs that certain contracts between values hold. "
"These will eventually allow us to define pre- and post conditions for our "
"function arguments and output types."
msgstr ""

#. type: Title #
#: ../src/Tutorial/DataTypes.md:1
#, no-wrap
msgid "Algebraic Data Types"
msgstr "代数的データ型"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:8
msgid ""
"In the [previous chapter](Functions1.md), we learned how to write our own "
"functions and combine them to create more complex functionality. Of equal "
"importance is the ability to define our own data types and use them as "
"arguments and results in functions."
msgstr ""
"[前の節](Functions1.md)では自前の関数を書いたり、関数同士を組み合わせてより複"
"雑な機能をつくったりしました。\n"
"関数と同じくらい大事なのは、自前のデータ型を定義できたり、関数の引数や返り値"
"に使えたりすることです。"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:15
msgid ""
"This is a lengthy chapter, densely packed with information.  If you are new "
"to Idris and functional programming, make sure to follow along slowly, "
"experimenting with the examples, and possibly coming up with your own. Make "
"sure to try and solve *all* exercises. The solutions to the exercises can be "
"found [here](../Solutions/DataTypes.idr)."
msgstr ""
"この章は分量が多く、情報が密に詰まっています。\n"
"Idrisや関数型プログラミングが初見でしたら、\n"
"ゆっくりと読み進めたり、\n"
"例で実験したり、\n"
"できれば自分で色々試してみてくださいね。\n"
"是非 *全ての* 演習を解いてみてください。\n"
"演習の解答は[ここ](../Solutions/DataTypes.idr)にあります。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:16
#, no-wrap
msgid "module Tutorial.DataTypes\n"
msgstr "module Tutorial.DataTypes\n"

#. type: Title ##
#: ../src/Tutorial/DataTypes.md:20
#, no-wrap
msgid "Enumerations"
msgstr "列挙型"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:24
msgid "Let's start with a data type for the days of the week as an example."
msgstr "例として曜日のデータ型から始めましょう。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:25
#, no-wrap
msgid ""
"data Weekday = Monday\n"
"             | Tuesday\n"
"             | Wednesday\n"
"             | Thursday\n"
"             | Friday\n"
"             | Saturday\n"
"             | Sunday\n"
msgstr ""
"data Weekday = Monday\n"
"             | Tuesday\n"
"             | Wednesday\n"
"             | Thursday\n"
"             | Friday\n"
"             | Saturday\n"
"             | Sunday\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:38
msgid ""
"The declaration above defines a new *type* (`Weekday`) and several new "
"*values* (`Monday` to `Sunday`) of the given type. Go ahead, and verify this "
"at the REPL:"
msgstr ""
"上記の宣言は新しい *型* （`Weekday`）と、\n"
"この型のいくつかの新しい *値* （`Monday`から`Sunday`まで）を定義していま"
"す。\n"
"さあ、REPLで確かめてみてください。"

#. type: Fenced code block (repl)
#: ../src/Tutorial/DataTypes.md:39
#, no-wrap
msgid ""
"Tutorial.DataTypes> :t Monday\n"
"Tutorial.DataTypes.Monday : Weekday\n"
"Tutorial.DataTypes> :t Weekday\n"
"Tutorial.DataTypes.Weekday : Type\n"
msgstr ""
"Tutorial.DataTypes> :t Monday\n"
"Tutorial.DataTypes.Monday : Weekday\n"
"Tutorial.DataTypes> :t Weekday\n"
"Tutorial.DataTypes.Weekday : Type\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:48
msgid ""
"So, `Monday` is of type `Weekday`, while `Weekday` itself is of type `Type`."
msgstr ""
"つまり、`Monday`は`Weekday`の型で、\n"
"`Weekday`自体の型は`Type`です。"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:52
msgid ""
"It is important to note, that a value of type `Weekday` can only ever be one "
"of the values listed above. It is a *type error* to use anything else where "
"a `Weekday` is expected."
msgstr ""
"これは大事なことなのですが、\n"
"型`Weekday`の値は必ず上に挙げた値のうち、どれか1つでなければいけません。\n"
"`Weekday`とされているのに他の値を使うと *型エラー* になります。"

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:53
#, no-wrap
msgid "Pattern Matching"
msgstr "パターン照合"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:59
msgid ""
"In order to use our new data type as a function argument, we need to learn "
"about an important concept in functional programming languages: Pattern "
"matching. Let's implement a function, which calculates the successor of a "
"weekday:"
msgstr ""
"新しいデータ型を関数の引数で使うためには、\n"
"関数型プログラミング言語の重要な概念、パターン照合について学ばねばなりませ"
"ん。\n"
"次の曜日を計算する関数を実装してみましょう。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:60
#, no-wrap
msgid ""
"total\n"
"next : Weekday -> Weekday\n"
"next Monday    = Tuesday\n"
"next Tuesday   = Wednesday\n"
"next Wednesday = Thursday\n"
"next Thursday  = Friday\n"
"next Friday    = Saturday\n"
"next Saturday  = Sunday\n"
"next Sunday    = Monday\n"
msgstr ""
"total\n"
"next : Weekday -> Weekday\n"
"next Monday    = Tuesday\n"
"next Tuesday   = Wednesday\n"
"next Wednesday = Thursday\n"
"next Thursday  = Friday\n"
"next Friday    = Saturday\n"
"next Saturday  = Sunday\n"
"next Sunday    = Monday\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:81
msgid ""
"In order to inspect a `Weekday` argument, we match on the different possible "
"values and return a result for each of them.  This is a very powerful "
"concept, as it allows us to match on and extract values from deeply nested "
"data structures.  The different cases in a pattern match are inspected from "
"top to bottom, each being compared against the current function argument. "
"Once a matching pattern is found, the computation on the right hand side of "
"this pattern is evaluated. Later patterns are then ignored."
msgstr ""
"`Weekday`な引数の正体を調べるために、\n"
"ありうる値を照合して対応する結果を返しています。\n"
"この照合という概念はとても強力で、\n"
"深く入れ子になった構造体のデータから値を抜き出すことができるのです。\n"
"パターン照合のそれぞれの場合は上から下に順番に調べられ、\n"
"関数の引数に対して比較されます。\n"
"最初に照合するパターンが見つかったら、\n"
"そのパターンの右側にある計算が実行されます。\n"
"それ以降のパターンは無視されます。"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:89
msgid ""
"For instance, if we invoke `next` with argument `Thursday`, the first three "
"patterns (`Monaday`, `Tuesday`, and `Wednesday`)  will be checked against "
"the argument, but they do not match.  The fourth pattern is a match, and "
"result `Friday` is being returned. Later patterns are then ignored, even if "
"they would also match the input (this becomes relevant with catch-all "
"patterns, which we will talk about in a moment)."
msgstr ""
"例えば、`next`を引数`Thursday`で呼び出したら、\n"
"最初の3つの引数（`Monday`, `Tuesday`, `Wednesday`）は引数と比較されるもの"
"の、\n"
"照合に失敗します。\n"
"4つ目のパターンには合致し、結果である`Friday`が返されます。\n"
"それ以降のパターンは無視されます。\n"
"たとえ引数と照合したとしてもダメです。\n"
"（これは全部受け止めるパターンと関係してきますが、\n"
"これについては少しあとで話します。）"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:98
msgid ""
"The function above is provably total. Idris knows about the possible values "
"of type `Weekday`, and can therefore figure out that our pattern match "
"covers all possible cases. We can therefore annotate the function with the "
"`total` keyword, and Idris will answer with a type error, if it can't verify "
"the function's totality. (Go ahead, and try removing one of the clauses in "
"`next` to get an idea about how an error message from the coverage checker "
"looks like.)"
msgstr ""
"上記の関数は全域であることが証明されています。\n"
"Idrisは`Weekday`のとりうる値を知っており、\n"
"したがってパターン照合が全ての可能性を網羅していることを突き止めます。\n"
"この場合さらに関数を`total`キーワードで註釈することができます。\n"
"こうするとIdrisはその関数の全域性を検証できなかったときに型エラーを出すように"
"なります。\n"
"（さあさあ、`next`から節を1つ消してみてください。\n"
"網羅性検査器はどんなエラー文言を出しましたか。）"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:105
msgid ""
"Please remember, that these are very strong guarantees from the type "
"checker: Given enough resources, a provably total function will *always* "
"return a result of the given type in a finite amount of time (*resources* "
"here meaning computational resources like memory or, in case of recursive "
"functions, stack space)."
msgstr ""
"覚えておいてほしいのですが、\n"
"全域であるということは型検査器による大変強力な保証がなされているということで"
"す。\n"
"充分なリソースがあれば、\n"
"全域であると証明された関数は *常に* 有限時間内で正しい型の結果を返します。\n"
"（ここでの*リソース*とは、計算機の資源を指します。\n"
"例えばメモリや、再帰的な関数でのスタック空間のことです。）"

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:106
#, no-wrap
msgid "Catch-all Patterns"
msgstr "全部受け止めるパターン"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:111
msgid ""
"Sometimes, it is convenient to only match on a subset of the possible values "
"and collect the remaining possibilities in a catch-all clause:"
msgstr ""
"ときどき、ありうる値のうち一部のみを照合し、\n"
"残りの可能性を全部受け止める節で回収すると便利なときもあります。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:112
#, no-wrap
msgid ""
"total\n"
"isWeekend : Weekday -> Bool\n"
"isWeekend Saturday = True\n"
"isWeekend Sunday   = True\n"
"isWeekend _        = False\n"
msgstr ""
"total\n"
"isWeekend : Weekday -> Bool\n"
"isWeekend Saturday = True\n"
"isWeekend Sunday   = True\n"
"isWeekend _        = False\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:125
msgid ""
"The final line with the catch-all pattern is only invoked, if the argument "
"is not equal to `Saturday` or `Sunday`.  Remember: Patterns in a pattern "
"match are matched against the input from top to bottom and the first match "
"decides, which path on the right hand side will be taken."
msgstr ""
"全部受けとめるパターンである最後の行が呼び出されるのは、\n"
"引数が`Saturday`でも`Sunday`でもないときだけです。\n"
"ただし、パターン照合中のパターンは入力に対して上から下に照合が試みられ、\n"
"最初に合致したものによって右側のどれが使われるのかが決められます。"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:129
msgid ""
"We can use catch-all patterns to implement an equality test for `Weekday` "
"(we will not yet use the `==` operator for this; this will have to wait "
"until we learn about *interfaces*):"
msgstr ""
"全部受け止めるパターンがあれば、\n"
"`Weekday`の等価性検査を実装できます。\n"
"（これにはまだ`==`は使えません。\n"
"*インターフェース*を学んでからにしましょう。）"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:130
#, no-wrap
msgid ""
"total\n"
"eqWeekday : Weekday -> Weekday -> Bool\n"
"eqWeekday Monday Monday        = True\n"
"eqWeekday Tuesday Tuesday      = True\n"
"eqWeekday Wednesday Wednesday  = True\n"
"eqWeekday Thursday Thursday    = True\n"
"eqWeekday Friday Friday        = True\n"
"eqWeekday Saturday Saturday    = True\n"
"eqWeekday Sunday Sunday        = True\n"
"eqWeekday _ _                  = False\n"
msgstr ""
"total\n"
"eqWeekday : Weekday -> Weekday -> Bool\n"
"eqWeekday Monday Monday        = True\n"
"eqWeekday Tuesday Tuesday      = True\n"
"eqWeekday Wednesday Wednesday  = True\n"
"eqWeekday Thursday Thursday    = True\n"
"eqWeekday Friday Friday        = True\n"
"eqWeekday Saturday Saturday    = True\n"
"eqWeekday Sunday Sunday        = True\n"
"eqWeekday _ _                  = False\n"

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:143
#, no-wrap
msgid "Enumeration Types in the Prelude"
msgstr "Preludeにある列挙型"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:151
msgid ""
"Data types like `Weekday` consisting of a finite set of values are sometimes "
"called *enumerations*. The Idris *Prelude* defines some common enumerations "
"for us, for instance `Bool` and `Ordering`. As with `Weekday`, we can use "
"pattern matching when implementing functions on these types:"
msgstr ""
"`Weekday`のようなデータ型は限られた数の値からなっており、\n"
"しばしば*列挙*と呼ばれます。\n"
"Idrisの*Prelude*では一般によくある列挙型が定義されています。\n"
"例えば`Bool`や`Ordering`です。\n"
"`Weekday`と同様に、\n"
"これらの型を扱う関数を実装するときにはパターン照合が使えます。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:152
#, no-wrap
msgid ""
"-- this is how `not` is implemented in the *Prelude*\n"
"total\n"
"negate : Bool -> Bool\n"
"negate False = True\n"
"negate True  = False\n"
msgstr ""
"-- `not`の*Prelude*での実装\n"
"total\n"
"negate : Bool -> Bool\n"
"negate False = True\n"
"negate True  = False\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:162
msgid ""
"The `Ordering` data type describes an ordering relation between two values. "
"For instance:"
msgstr ""
"`Ordering`データ型は2つの値の序列を表現します。\n"
"例えば次のように。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:163
#, no-wrap
msgid ""
"total\n"
"compareBool : Bool -> Bool -> Ordering\n"
"compareBool False False = EQ\n"
"compareBool False True  = LT\n"
"compareBool True True   = EQ\n"
"compareBool True False  = GT\n"
msgstr ""
"total\n"
"compareBool : Bool -> Bool -> Ordering\n"
"compareBool False False = EQ\n"
"compareBool False True  = LT\n"
"compareBool True True   = EQ\n"
"compareBool True False  = GT\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:176
msgid ""
"Here, `LT` means that the first argument is *less than* the second, `EQ` "
"means that the two arguments are *equal* and `GT` means, that the first "
"argument is *greater than* the second."
msgstr ""
"ここで、`LT`は最初の引数が2つ目*よりも小さい*ということを、\n"
"`EQ`は2つの引数が互いに*等しい*ことを、\n"
"そして`GT`は最初の引数が2つ目*よりも大きい*ということを、\n"
"それぞれ意味しています。"

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:177
#, no-wrap
msgid "Case Expressions"
msgstr "case式"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:183
msgid ""
"Sometimes we need to perform a computation with one of the arguments and "
"want to pattern match on the result of this computation. We can use *case "
"expressions* in this situation:"
msgstr ""
"ときどき、引数を使った計算を行って、\n"
"その結果をパターン照合したいときがあります。\n"
"こんなときは*case式*が使えます。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:184
#, no-wrap
msgid ""
"-- returns the larger of the two arguments\n"
"total\n"
"maxBits8 : Bits8 -> Bits8 -> Bits8\n"
"maxBits8 x y =\n"
"  case compare x y of\n"
"    LT => y\n"
"    _  => x\n"
msgstr ""
"-- 2つの引数のうち、より大きい方を返す\n"
"total\n"
"maxBits8 : Bits8 -> Bits8 -> Bits8\n"
"maxBits8 x y =\n"
"  case compare x y of\n"
"    LT => y\n"
"    _  => x\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:202
msgid ""
"The first line of the case expression (`case compare x y of`)  will invoke "
"function `compare` with arguments `x` and `y`. On the following (indented) "
"lines, we pattern match on the result of this computation. This is of type "
"`Ordering`, so we expect one of the three constructors `LT`, `EQ`, or `GT` "
"as the result.  On the first line, we handle the `LT` case explicitly, while "
"the other two cases are handled with an underscore as a catch-all pattern."
msgstr ""
"case式の最初の行（`case compare x y of`）では、\n"
"関数`compare`を引数`x`と`y`に対して呼び出しています。\n"
"次の（字下げされた）行ではこの計算結果に対してパターン照合しています。\n"
"この計算結果の型は`Ordering`なので、\n"
"3つの構築子`LT`, `EQ`, `GT`のうちのいずれかです。\n"
"最初の行で明示的に`LT`の場合を扱っており、\n"
"他の2つの行は全部を受け止めるパターンである下線文字で扱っています。"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:206
msgid ""
"Note, that indentation matters here: The case block as a whole must be "
"indented (if it starts on a new line), and the different cases must also be "
"indented by the same amount of whitespace."
msgstr ""
"ここでの字下げは大事ですよ。\n"
"caseブロック全体は（新しい行から始まる場合）字下げされていなければいけませ"
"ん。\n"
"そして、それぞれの場合は空白文字で同じ字下げが必要です。"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:209
msgid ""
"Function `compare` is overloaded for many data types. We will learn how this "
"works when we talk about interfaces."
msgstr ""
"関数`compare`は多くのデータ型でオーバーロードされています。\n"
"この仕組みについてはインターフェースのところでお話しします。"

#. type: Title ####
#: ../src/Tutorial/DataTypes.md:210
#, no-wrap
msgid "If Then Else"
msgstr "もし、そうなら、でないなら"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:214
msgid ""
"When working with `Bool`, there is an alternative to pattern matching common "
"to most programming languages:"
msgstr ""
"`Bool`で何かするときは、パターン照合の代わりにほとんどのプログラミング言語で"
"もよくあるアレがあります。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:215
#, no-wrap
msgid ""
"total\n"
"maxBits8' : Bits8 -> Bits8 -> Bits8\n"
"maxBits8' x y = if compare x y == LT then y else x\n"
msgstr ""
"total\n"
"maxBits8' : Bits8 -> Bits8 -> Bits8\n"
"maxBits8' x y = if compare x y == LT then y else x\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:225
msgid ""
"Note, that the `if then else` expression always returns a value and "
"therefore, the `else` branch cannot be dropped. This is different from the "
"behavior in typical imperative languages, where `if` is a statement with "
"possible side effects."
msgstr ""
"ただし、`if then else`式は常に値を返します。\n"
"したがって、`else`の分枝は省けません。\n"
"これは典型的な命令型言語の振舞いとは違います。\n"
"命令型言語では`if`は文で副作用がありうるためです。"

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:226
#, no-wrap
msgid "Naming Conventions: Identifiers"
msgstr "命名慣習：識別子"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:233
msgid ""
"While we are free to use lower-case and upper-case identifiers for function "
"names, type- and data constructors must be given upper-case identifiers in "
"order not to confuse Idris (operators are also fine).  For instance, the "
"following data definition is not valid, and Idris will complain that it "
"expected upper-case identifiers:"
msgstr ""
"関数名には小文字始まりの識別子も大文字始まりの識別子も両方使えますが、\n"
"型構築子とデータ構築子は大文字始まりの識別子でなければいけません。\n"
"でなければIdrisが困惑します。\n"
"（ちなみに演算子は大文字でもOKです。）\n"
"たとえば以下のデータ定義は妥当ではなく、Idrisは大文字の識別子ではないことに小"
"言を言います。"

#. type: Fenced code block (repl)
#: ../src/Tutorial/DataTypes.md:234
#, no-wrap
msgid "data foo = bar | baz\n"
msgstr "data foo = bar | baz\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:240
msgid ""
"The same goes for similar data definitions like records and sum types (both "
"will be explained below):"
msgstr ""
"同じことはレコードや直和型のデータ定義についても言えます。\n"
"（これらについては後述します。）"

#. type: Fenced code block (repl)
#: ../src/Tutorial/DataTypes.md:241
#, no-wrap
msgid ""
"-- not valid Idris\n"
"record Foo where\n"
"  constructor mkfoo\n"
msgstr ""
"-- not valid Idris\n"
"record Foo where\n"
"  constructor mkfoo\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:252
msgid ""
"On the other hand, we typically use lower-case identifiers for function "
"names, unless we plan to use them mostly during type checking (more on this "
"later). This is not enforced by Idris, however, so if you are working in a "
"domain where upper-case identifiers are preferable, feel free to use those:"
msgstr ""
"他方で、ほぼ型検査で使うつもりでない限り（詳細はのちほど）、関数名には大抵小"
"文字始まりの識別子を使います。\n"
"とはいえこれはIdrisが何か後押しするわけではないので、\n"
"大文字始まりの識別子が好ましいような状況では自由に使ってください。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:253
#, no-wrap
msgid ""
"foo : Bits32 -> Bits32\n"
"foo = (* 2)\n"
"\n"
"Bar : Bits32 -> Bits32\n"
"Bar = foo\n"
msgstr ""
"foo : Bits32 -> Bits32\n"
"foo = (* 2)\n"
"\n"
"Bar : Bits32 -> Bits32\n"
"Bar = foo\n"

#. type: Bullet: '1. '
#: ../src/Tutorial/DataTypes.md:267
msgid ""
"Use pattern matching to implement your own versions of boolean operators "
"`(&&)` and `(||)` calling them `and` and `or` respectively."
msgstr ""
"パターン照合を使って自前の真偽値演算子`(&&)`と`(||)`を実装してください。\n"
"それぞれの関数名は`and`と`or`にしてください。"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:274
#, no-wrap
msgid ""
"   Note: One way to go about this is to enumerate\n"
"   all four possible combinations of two boolean\n"
"   values and give the result for each. However, there\n"
"   is a shorter, more clever way,\n"
"   requiring only two pattern matches for each of the\n"
"   two functions.\n"
msgstr ""
"   附記：1つの解決策としては、\n"
"   2つの真偽値のありうるあらゆる組み合わせを列挙して、\n"
"   それぞれの結果を与える、というのがあります。\n"
"   しかし、もっと短かくてもっと賢いやりかたがあります。\n"
"   その方法だとそれぞれの関数の実装に、\n"
"   パターン照合の分岐の数が2つだけで済みます。\n"

#. type: Bullet: '2. '
#: ../src/Tutorial/DataTypes.md:282
msgid ""
"Define your own data type representing different units of time (seconds, "
"minutes, hours, days, weeks), and implement the following functions for "
"converting between time spans using different units. Hint: Use integer "
"division (`div`)  when going from seconds to some larger unit like hours)."
msgstr ""
"異なる時間の単位（秒 (second)、分 (minute)、時 (hour)、日 (day)、週 (week)）"
"を表す自前のデータ型を定義してください。\n"
"そして、単位間で期間を変換する以下の関数を実装してください。\n"
"解決の糸口：秒から時のようなより大きい単位に変換するには、\n"
"整数の除算(`div`)を使ってください。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:283
#, no-wrap
msgid ""
"   data UnitOfTime = Second -- add additional values\n"
"\n"
"   -- calculate the number of seconds from a\n"
"   -- number of steps in the given unit of time\n"
"   total\n"
"   toSeconds : UnitOfTime -> Integer -> Integer\n"
"\n"
"   -- Given a number of seconds, calculate the\n"
"   -- number of steps in the given unit of time\n"
"   total\n"
"   fromSeconds : UnitOfTime -> Integer -> Integer\n"
"\n"
"   -- convert the number of steps in a given unit of time\n"
"   -- to the number of steps in another unit of time.\n"
"   -- use `fromSeconds` and `toSeconds` in your implementation\n"
"   total\n"
"   convert : UnitOfTime -> Integer -> UnitOfTime -> Integer\n"
msgstr ""
"   data UnitOfTime = Second -- 残りの値を追加してください\n"
"\n"
"   -- 与えられた時間の単位での長さから、\n"
"   -- その秒数を計算してください\n"
"   total\n"
"   toSeconds : UnitOfTime -> Integer -> Integer\n"
"\n"
"   -- 秒数がわかっているとき、\n"
"   -- 与えられた時間の単位での長さを計算してください\n"
"   total\n"
"   fromSeconds : UnitOfTime -> Integer -> Integer\n"
"\n"
"   -- 与えられた時間の単位とその長さを、\n"
"   -- 他の時間の単位での長さに変換してください。\n"
"   -- 実装では`fromSeconds`と`toSeconds`を使ってください\n"
"   total\n"
"   convert : UnitOfTime -> Integer -> UnitOfTime -> Integer\n"

#. type: Bullet: '3. '
#: ../src/Tutorial/DataTypes.md:306
msgid ""
"Define a data type for representing a subset of the chemical elements: "
"Hydrogen (H), Carbon (C), Nitrogen (N), Oxygen (O), and Fluorine (F)."
msgstr ""
"化学の原子の一部を表すデータ型を定義してください。\n"
"水素 (H)、炭素 (C)、窒素 (N)、酸素 (O)、そしてフッ素 (F) だけでよいです。"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:309
#, no-wrap
msgid ""
"   Declare and implement function `atomicMass`, which for each element\n"
"   returns its atomic mass in dalton:\n"
msgstr ""
"   `atomicMass`を宣言して実装してください。\n"
"   この関数は、それぞれの原子に対して、\n"
"   dalton単位（統一原子質量単位）での粒子の質量を返します。\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/DataTypes.md:310
#, no-wrap
msgid ""
"   Hydrogen : 1.008\n"
"   Carbon : 12.011\n"
"   Nitrogen : 14.007\n"
"   Oxygen : 15.999\n"
"   Fluorine : 18.9984\n"
msgstr ""
"   Hydrogen : 1.008\n"
"   Carbon : 12.011\n"
"   Nitrogen : 14.007\n"
"   Oxygen : 15.999\n"
"   Fluorine : 18.9984\n"

#. type: Title ##
#: ../src/Tutorial/DataTypes.md:318
#, no-wrap
msgid "Sum Types"
msgstr "直和型"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:326
msgid ""
"Assume we'd like to write some web form, where users of our web application "
"can decide how they like to be addressed.  We give them a choice between two "
"common predefined forms of address (Mr and Mrs), but also allow them to "
"decide on a customized form. The possible choices can be encapsulated in an "
"Idris data type:"
msgstr ""
"なんらかのWebフォームを書くとします。\n"
"このフォームでは、Webアプリケーションのユーザーがどう呼ばれてほしいかを決めら"
"れます。\n"
"2つのよくある事前に定義された呼び方（MrとMrs）だけではなく、\n"
"自前で決められる形式にもできるとします。\n"
"取れる選択肢は、Idrisのデータ型で次のようにカプセル化できます。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:327
#, no-wrap
msgid "data Title = Mr | Mrs | Other String\n"
msgstr "data Title = Mr | Mrs | Other String\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:336
msgid ""
"This looks almost like an enumeration type, with the exception that there is "
"a new thing, called a *data constructor*, which accepts a `String` argument "
"(actually, the values in an enumeration are also called (nullary) data "
"constructors).  If we inspect the types at the REPL, we learn the following:"
msgstr ""
"これは列挙型とそっくりですが、\n"
"1つ新しい要素があります。\n"
"これは*データ構築子*と呼ばれるもので、\n"
"`String`な引数を受け付けます。\n"
"（実は、列挙型での値は（引数のない）データ構築子とも呼ばれます。）\n"
"REPLで型を調べると、以下がわかります。"

#. type: Fenced code block (repl)
#: ../src/Tutorial/DataTypes.md:337
#, no-wrap
msgid ""
"Tutorial.DataTypes> :t Mr\n"
"Tutorial.DataTypes.Mr : Title\n"
"Tutorial.DataTypes> :t Other\n"
"Tutorial.DataTypes.Other : String -> Title\n"
msgstr ""
"Tutorial.DataTypes> :t Mr\n"
"Tutorial.DataTypes.Mr : Title\n"
"Tutorial.DataTypes> :t Other\n"
"Tutorial.DataTypes.Other : String -> Title\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:347
msgid ""
"So, `Other` is a *function* from `String` to `Title`. This means, that we "
"can pass `Other` a `String` argument and get a `Title` as the result:"
msgstr ""
"つまり、`Other`は`String`から`Type`への*関数*です。\n"
"言い換えると、`Other`に`String`な引数を渡すと、結果として`Title`な値が得られ"
"ます。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:348
#, no-wrap
msgid ""
"total\n"
"dr : Title\n"
"dr = Other \"Dr.\"\n"
msgstr ""
"total\n"
"dr : Title\n"
"dr = Other \"Dr.\"\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:358
msgid ""
"Again, a value of type `Title` can only consist of one of the three choices "
"listed above, and again, we can use pattern matching to implement functions "
"on the `Title` data type in a provably total way:"
msgstr ""
"繰り返しになりますが、\n"
"型`Title`の値は前述した3つの選択肢のうちのいずれかです。\n"
"さらに、パターン照合を使って`Title`データ型に関する関数を実装できるのも同じで"
"す。\n"
"この実装は全域であることが証明されています。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:359
#, no-wrap
msgid ""
"total\n"
"showTitle : Title -> String\n"
"showTitle Mr        = \"Mr.\"\n"
"showTitle Mrs       = \"Mrs.\"\n"
"showTitle (Other x) = x\n"
msgstr ""
"total\n"
"showTitle : Title -> String\n"
"showTitle Mr        = \"Mr.\"\n"
"showTitle Mrs       = \"Mrs.\"\n"
"showTitle (Other x) = x\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:372
msgid ""
"Note, how in the last pattern match, the string value stored in the `Other` "
"data constructor is *bound* to local variable `x`.  Also, the `Other x` "
"pattern has to be wrapped in parentheses, as otherwise Idris would think "
"`Other` and `x` were to distinct function arguments."
msgstr ""
"パターン照合の最後の場合にご注目。\n"
"`Other`データ構築子に格納された文字列の値がローカル変数`x`に*束縛*されていま"
"す。\n"
"また、`Other x`パターンは括弧でくるまれていなければいけません。\n"
"そうしないとIdrisは`Other`と`x`が別個な関数の引数だと考えます。"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:377
msgid ""
"This is a very common way to extract the values from data constructors.  We "
"can use `showTitle` to implement a function for creating a courteous "
"greeting:"
msgstr ""
"これはデータ構築子から値を抽出する大変よくあるやりかたです。\n"
"`showTitle`を使えば慇懃な挨拶をする関数を実装できます。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:378
#, no-wrap
msgid ""
"total\n"
"greet : Title -> String -> String\n"
"greet t name = \"Hello, \" ++ showTitle t ++ \" \" ++ name ++ \"!\"\n"
msgstr ""
"total\n"
"greet : Title -> String -> String\n"
"greet t name = \"Hello, \" ++ showTitle t ++ \" \" ++ name ++ \"!\"\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:387
msgid ""
"In the implementation of `greet`, we use string literals and the string "
"concatenation operator `(++)` to assemble the greeting from its parts."
msgstr ""
"`greet`の実装では文字列リテラルと文字列結合演算子`(++)`を使っています。\n"
"これにより部品から挨拶を組み立てられます。"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:389
msgid "At the REPL:"
msgstr "REPLで次のようにしてみましょう。"

#. type: Fenced code block (repl)
#: ../src/Tutorial/DataTypes.md:390
#, no-wrap
msgid ""
"Tutorial.DataTypes> greet dr \"Höck\"\n"
"\"Hello, Dr. Höck!\"\n"
"Tutorial.DataTypes> greet Mrs \"Smith\"\n"
"\"Hello, Mrs. Smith!\"\n"
msgstr ""
"Tutorial.DataTypes> greet dr \"Höck\"\n"
"\"Hello, Dr. Höck!\"\n"
"Tutorial.DataTypes> greet Mrs \"Smith\"\n"
"\"Hello, Mrs. Smith!\"\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:400
msgid ""
"Data types like `Title` are called *sum types* as they consist of the sum of "
"their different parts: A value of type `Title` is either a `Mr`, a `Mrs`, or "
"a `String` wrapped up in `Other`."
msgstr ""
"`Title`のようなデータ型は*直和型*と呼ばれます。\n"
"なぜならこの型はそれぞれの場合の和からなっているためです。\n"
"型`Title`の値は`Mr`か`Mrs`かそれとも`Other`にくるまれた`String`かのいずれかで"
"す。"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:407
msgid ""
"Here's another (drastically simplified) example of a sum type.  Assume we "
"allow two forms of authentication in our web application: Either by entering "
"a username plus a password (for which we'll use an unsigned 64 bit integer "
"here), or by providing user name plus a (very complex) secret key.  Here's a "
"data type to encapsulate this use case:"
msgstr ""
"また、以下は他の（劇的に簡素な）直和型の例です。\n"
"Webアプリケーションで2つの形式の認証ができるとしましょう。\n"
"利用者名とパスワード（ここでは符号なし64ビット整数）を入力するか、\n"
"利用者名と（とても複雑な）秘密鍵を使うかのいずれかです。\n"
"こちらがこの用例をカプセル化したデータ型です。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:408
#, no-wrap
msgid "data Credentials = Password String Bits64 | Key String String\n"
msgstr "data Credentials = Password String Bits64 | Key String String\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:414
msgid ""
"As an example of a very primitive login function, we can hard-code some "
"known credentials:"
msgstr ""
"とても原始的なログイン関数の例として、\n"
"既知の認証情報を埋め込むことにします。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:415
#, no-wrap
msgid ""
"total\n"
"login : Credentials -> String\n"
"login (Password \"Anderson\" 6665443) = greet Mr \"Anderson\"\n"
"login (Key \"Y\" \"xyz\")               = greet (Other \"Agent\") \"Y\"\n"
"login _                             = \"Access denied!\"\n"
msgstr ""
"total\n"
"login : Credentials -> String\n"
"login (Password \"Anderson\" 6665443) = greet Mr \"Anderson\"\n"
"login (Key \"Y\" \"xyz\")               = greet (Other \"Agent\") \"Y\"\n"
"login _                             = \"Access denied!\"\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:426
msgid ""
"As can be seen in the example above, we can also pattern match against "
"primitive values by using integer and string literals. Give `login` a go at "
"the REPL:"
msgstr ""
"上の例からわかるように、\n"
"整数と文字列のリテラルで原始的な値に対してパターン照合することもできます。\n"
"REPLで`login`を試してみましょう。"

#. type: Fenced code block (repl)
#: ../src/Tutorial/DataTypes.md:427
#, no-wrap
msgid ""
"Tutorial.DataTypes> login (Password \"Anderson\" 6665443)\n"
"\"Hello, Mr. Anderson!\"\n"
"Tutorial.DataTypes> login (Key \"Y\" \"xyz\")\n"
"\"Hello, Agent Y!\"\n"
"Tutorial.DataTypes> login (Key \"Y\" \"foo\")\n"
"\"Access denied!\"\n"
msgstr ""
"Tutorial.DataTypes> login (Password \"Anderson\" 6665443)\n"
"\"Hello, Mr. Anderson!\"\n"
"Tutorial.DataTypes> login (Key \"Y\" \"xyz\")\n"
"\"Hello, Agent Y!\"\n"
"Tutorial.DataTypes> login (Key \"Y\" \"foo\")\n"
"\"Access denied!\"\n"

#. type: Bullet: '1. '
#: ../src/Tutorial/DataTypes.md:440
msgid ""
"Implement an equality test for `Title` (you can use the equality operator "
"`(==)` for comparing two `String`s):"
msgstr ""
"`Title`の等価性検査を実装してください。\n"
"（2つの`String`を比較するのに等価性演算子`(==)`が使えます。）"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:441
#, no-wrap
msgid ""
"   total\n"
"   eqTitle : Title -> Title -> Bool\n"
msgstr ""
"   total\n"
"   eqTitle : Title -> Title -> Bool\n"

#. type: Bullet: '2. '
#: ../src/Tutorial/DataTypes.md:448
msgid ""
"For `Title`, implement a simple test to check, whether a custom title is "
"being used:"
msgstr ""
"`Title`について、\n"
"自前の敬称が使われているかを確認する簡単な検査を実装してください。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:449
#, no-wrap
msgid ""
"   total\n"
"   isOther : Title -> Bool\n"
msgstr ""
"   total\n"
"   isOther : Title -> Bool\n"

#. type: Bullet: '3. '
#: ../src/Tutorial/DataTypes.md:456
msgid ""
"Given our simple `Credentials` type, there are three ways for authentication "
"to fail:"
msgstr ""
"前述した簡素な`Credential`型についてだけでも、\n"
"3つの認証失敗の場合があります。"

#. type: Bullet: '   * '
#: ../src/Tutorial/DataTypes.md:461
msgid "An unknown username was used."
msgstr "不明な利用者名が使われた。"

#. type: Bullet: '   * '
#: ../src/Tutorial/DataTypes.md:461
msgid "The password given does not match the one associated with the username."
msgstr "与えられたパスワードが利用者名に紐付くパスワードと一致しない。"

#. type: Bullet: '   * '
#: ../src/Tutorial/DataTypes.md:461
msgid "An invalid key was used."
msgstr "不正な鍵が使用された。"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:467
#, no-wrap
msgid ""
"   Encapsulate these three possibilities in a sum type\n"
"   called `LoginError`,\n"
"   but make sure not to disclose any confidential information:\n"
"   An invalid username should be stored in the corresponding\n"
"   error value, but an invalid password or key should not.\n"
msgstr ""
"   これら3つの可能性を`LoginError`という名前の直和型でカプセル化してください。\n"
"   ただし、あらゆる機密情報を漏洩しないようにしてくださいね。\n"
"   不正な利用者名は対応するエラー型に格納されますが、\n"
"   不正なパスワードや鍵は格納されません。\n"

#. type: Bullet: '4. '
#: ../src/Tutorial/DataTypes.md:471
msgid ""
"Implement function `showError : LoginError -> String`, which can be used to "
"display an error message to the user who unsuccessfully tried to login into "
"our web application."
msgstr ""
"関数`showError : LoginError -> String`を実装してください。\n"
"この関数はWebアプリケーションにログインしようとして失敗した利用者にエラー文言"
"を表示するのに使えます。"

#. type: Title ##
#: ../src/Tutorial/DataTypes.md:472
#, no-wrap
msgid "Records"
msgstr "レコード"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:481
msgid ""
"It is often useful to group together several values as a logical unit. For "
"instance, in our web application we might want to group information about a "
"user in a single data type. Such data types are often called *product types* "
"(see below for an explanation).  The most common and convenient way to "
"define them is the `record` construct:"
msgstr ""
"いくつかの値を論理的な単位として集めておくと便利なことがよくあります。\n"
"たとえば、Webアプリケーションで利用者の情報を単一のデータ型に集めておきたいこ"
"とがあるでしょう。\n"
"そのようなデータ型はしばしば*直積型*と呼ばれます。\n"
"（後述の説明を参照してください。）\n"
"これを定義するもっとも一般的で便利な方法は*record*構築子を使うというもので"
"す。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:482
#, no-wrap
msgid ""
"record User where\n"
"  constructor MkUser\n"
"  name  : String\n"
"  title : Title\n"
"  age   : Bits8\n"
msgstr ""
"record User where\n"
"  constructor MkUser\n"
"  name  : String\n"
"  title : Title\n"
"  age   : Bits8\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:493
msgid ""
"The declaration above creates a new *type* called `User`, and a new *data "
"constructor* called `MkUser`. As usual, have a look at their types in the "
"REPL:"
msgstr ""
"上記の宣言は`User`という名前の新しい*型*と`MkUser`という名前の新しい*データ構"
"築子*を作ります。\n"
"いつものように、型をREPLでのぞいてみましょう。"

#. type: Fenced code block (repl)
#: ../src/Tutorial/DataTypes.md:494
#, no-wrap
msgid ""
"Tutorial.DataTypes> :t User\n"
"Tutorial.DataTypes.User : Type\n"
"Tutorial.DataTypes> :t MkUser\n"
"Tutorial.DataTypes.MkUser : String -> Title -> Bits8 -> User\n"
msgstr ""
"Tutorial.DataTypes> :t User\n"
"Tutorial.DataTypes.User : Type\n"
"Tutorial.DataTypes> :t MkUser\n"
"Tutorial.DataTypes.MkUser : String -> Title -> Bits8 -> User\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:504
msgid ""
"We can use `MkUser` (which is a function from `String` to `Title` to `Bits8` "
"to `User`)  to create values of type `User`:"
msgstr ""
"`MkUser`（`String`と`Title`と`Bits8`から`User`を返す関数）は型`User`の値を作"
"るのに使えます。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:505
#, no-wrap
msgid ""
"total\n"
"agentY : User\n"
"agentY = MkUser \"Y\" (Other \"Agent\") 51\n"
"\n"
"total\n"
"drNo : User\n"
"drNo = MkUser \"No\" dr 73\n"
msgstr ""
"total\n"
"agentY : User\n"
"agentY = MkUser \"Y\" (Other \"Agent\") 51\n"
"\n"
"total\n"
"drNo : User\n"
"drNo = MkUser \"No\" dr 73\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:517
msgid ""
"We can also use pattern matching to extract the fields from a `User` value "
"(they can again be bound to local variables):"
msgstr ""
"パターン照合で`User`の値からフィールドを抽出することもできます。\n"
"（ここでもパターン照合でローカル変数に束縛できます。）"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:518
#, no-wrap
msgid ""
"total\n"
"greetUser : User -> String\n"
"greetUser (MkUser n t _) = greet t n\n"
msgstr ""
"total\n"
"greetUser : User -> String\n"
"greetUser (MkUser n t _) = greet t n\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:530
msgid ""
"In the example above, the `name` and `title` field are bound to two new "
"local variables (`n` and `t` respectively), which can then be used on the "
"right hand side of `greetUser`'s implementation. For the `age` field, which "
"is not used on the right hand side, we can use an underscore as a catch-all "
"pattern."
msgstr ""
"上の例では、`name`, `title`フィールドが\n"
"2つの新しいローカル変数（それぞれ`n`と`t`）に束縛されています。\n"
"これらのローカル変数は右側にある`greetUser`の実装で使うことができます。\n"
"`age`フィールドについては右側で使われないので、\n"
"その部分には全てを受け止めるパターンとしての下線文字を使うことができます。"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:545
msgid ""
"Note, how Idris will prevent us from making a common mistake: If we confuse "
"the order of arguments, the implementation will no longer type check. We can "
"verify this by putting the erroneous code in a `failing` block: This is an "
"indented code block, which will lead to an error during elaboration (type "
"checking). We can give part of the expected error message as an optional "
"string argument to a failing block. If this does not match part of the error "
"message (or the whole code block does not fail to type check) the `failing` "
"block itself fails to type check. This is a useful tool to demonstrate that "
"type safety works in two directions: We can show that valid code type checks "
"but also that invalid code is rejected by the Idris elaborator:"
msgstr ""
"ここでIdrisがよくある間違いを防いでいることにご注目。\n"
"引数の順序を混同したら実装は型検査を通りません。\n"
"エラーを含むコードを`failing`ブロック内に置くことで、このことを確かめられま"
"す。\n"
"これは字下げされたブロックで、このブロックの中のコードは細密化（型検査）の段"
"階でエラーになります。\n"
"期待されるエラーメッセージの一部を失敗ブロックの引数に加えても構いません。\n"
"これがエラーメッセージの一部と一致しないとき（もしくはコードブロック全体が型"
"検査に失敗しなかったとき）は、\n"
"`failing`ブロック自体が型検査に失敗します。\n"
"これは型安全性が2つの方面で便利な道具であることを示しています。\n"
"Idrisの細密化器によって、妥当なコードが型検査に通ることだけではなく、不当な"
"コードが弾かれることがわかるのです。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:546
#, no-wrap
msgid ""
"failing \"Mismatch between: String and Title\"\n"
"  greetUser' : User -> String\n"
"  greetUser' (MkUser n t _) = greet n t\n"
msgstr ""
"failing \"Mismatch between: String and Title\"\n"
"  greetUser' : User -> String\n"
"  greetUser' (MkUser n t _) = greet n t\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:558
msgid ""
"In addition, for every record field, Idris creates an extractor function of "
"the same name. This can either be used as a regular function, or it can be "
"used in postfix notation by appending it to a variable of the record type "
"separated by a dot. Here are two examples for extracting the age from a user:"
msgstr ""
"加えて、全てのレコードのフィールドについて、\n"
"Idrisはそれらと同名の抽出関数を作ります。\n"
"この関数は通常の関数として使うこともできますし、\n"
"レコード型の変数にドット区切りでフィールド名を後置する使い方もできます。\n"
"こちらが利用者から年齢を抽出する2つの例です。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:559
#, no-wrap
msgid ""
"getAgeFunction : User -> Bits8\n"
"getAgeFunction u = age u\n"
"\n"
"getAgePostfix : User -> Bits8\n"
"getAgePostfix u = u.age\n"
msgstr ""
"getAgeFunction : User -> Bits8\n"
"getAgeFunction u = age u\n"
"\n"
"getAgePostfix : User -> Bits8\n"
"getAgePostfix u = u.age\n"

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:567
#, no-wrap
msgid "Syntactic Sugar for Records"
msgstr "レコードの糖衣構文"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:581
msgid ""
"As was already mentioned in the [intro](Intro.md), Idris is a *pure* "
"functional programming language. In pure functions, we are not allowed to "
"modify global mutable state. As such, if we want to modify a record value, "
"we will always create a *new* value with the original value remaining "
"unchanged: Records and other Idris values are *immutable*.  While this *can* "
"have a slight impact on performance, it has the benefit that we can freely "
"pass a record value to different functions, without fear of the functions "
"modifying the value by in-place mutation. These are, again, very strong "
"guarantees, which makes it drastically easier to reason about our code."
msgstr ""
"既に[導入](Intro.md)で言及したように、\n"
"Idrisは*純粋*関数型プログラミング言語です。\n"
"純粋な関数では、大域的な可変の状態に変更を加えることができません。\n"
"そういうわけで、\n"
"レコードの値を変更したければ、\n"
"変更する部分以外の値は元のままに常に*新しい*値を作る必要があります。\n"
"レコードやその他のIdrisでの値は*不変*なのです。\n"
"このことはパフォーマンスに若干の影響が*ありうる*ものの、\n"
"レコードの値を別々の関数に気ままに渡すことができるという利点があります。\n"
"関数がその場で値に変更を加えるかもしれないと恐れる必要がありません。\n"
"再三ですが、これはとても強力な保証です。\n"
"これによりコードの検証が劇的に容易になるのです。"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:586
msgid ""
"There are several ways to modify a record, the most general being to pattern "
"match on the record and adjust each field as desired. If, for instance, we'd "
"like to increase the age of a `User` by one, we could do the following:"
msgstr ""
"レコードを変更するにはいくつかの方法があります。\n"
"もっとも一般的なものとしては、\n"
"レコードに対してパターン照合し、\n"
"好きなようにそれぞれのフィールドを調整するというものです。\n"
"たとえばもし`User`の年齢を1歳上げたかったら、以下のようにすればできます。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:587
#, no-wrap
msgid ""
"total\n"
"incAge : User -> User\n"
"incAge (MkUser name title age) = MkUser name title (age + 1)\n"
msgstr ""
"total\n"
"incAge : User -> User\n"
"incAge (MkUser name title age) = MkUser name title (age + 1)\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:597
msgid ""
"That's a lot of code for such a simple thing, so Idris offers several "
"syntactic conveniences for this. For instance, using *record* syntax, we can "
"just access and update the `age` field of a value:"
msgstr ""
"こんな簡単なことなのに、コードを沢山書いています。\n"
"なのでIdrisではこうした操作について、いくつかの文法的な便宜が図られていま"
"す。\n"
"たとえば、*record*文法を使えば、\n"
"値の`age`フィールドにアクセスして更新することができます。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:598
#, no-wrap
msgid ""
"total\n"
"incAge2 : User -> User\n"
"incAge2 u = { age := u.age + 1 } u\n"
msgstr ""
"total\n"
"incAge2 : User -> User\n"
"incAge2 u = { age := u.age + 1 } u\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:607
msgid ""
"Assignment operator `:=` assigns a new value to the `age` field in `u`. "
"Remember, that this will create a new `User` value. The original value `u` "
"remains unaffected by this."
msgstr ""
"代入演算子`:=`は`u`の`age`フィールドに新しい値を代入します。\n"
"ただし、これは新しい`Usre`の値を作ります。\n"
"`u`の値はこの影響を受けず元のままです。"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:613
msgid ""
"We can access a record field, either by using the field name as a projection "
"function (`age u`; also have a look at `:t age` in the REPL), or by using "
"dot syntax: `u.age`. This is special syntax and *not* related to the dot "
"operator for function composition (`(.)`)."
msgstr ""
"レコードのフィールドは2つの方法で読み取れます。\n"
"1つはフィールド名の射影関数（`age u`のように。REPLで`:t age`としてみてくださ"
"い。）を使うことで、\n"
"もう1つは`u.age`のようなドット文法を使うものです。\n"
"ドット文法は特殊な文法であり、関数合成のためのドット演算子（`(.)`）とは関係*"
"ありません*。"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:616
msgid ""
"The use case of modifying a record field is so common that Idris provides "
"special syntax for this as well:"
msgstr ""
"レコードのフィールドを変更する使用例はとてもよくあるので、\n"
"Idrisはさらにこのための特別な文法を提供しています。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:617
#, no-wrap
msgid ""
"total\n"
"incAge3 : User -> User\n"
"incAge3 u = { age $= (+ 1) } u\n"
msgstr ""
"total\n"
"incAge3 : User -> User\n"
"incAge3 u = { age $= (+ 1) } u\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:627
msgid ""
"Here, I used an *operator section* (`(+ 1)`) to make the code more concise.  "
"As an alternative to an operator section, we could have used an anonymous "
"function like so:"
msgstr ""
"ここではコードをもっと簡潔にするために*演算子節* (`(+ 1)`) を使いました。\n"
"演算子節の代わりに匿名関数を使うこともできます。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:628
#, no-wrap
msgid ""
"total\n"
"incAge4 : User -> User\n"
"incAge4 u = { age $= \\x => x + 1 } u\n"
msgstr ""
"total\n"
"incAge4 : User -> User\n"
"incAge4 u = { age $= \\x => x + 1 } u\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:637
msgid ""
"Finally, since our function's argument `u` is only used once at the very "
"end, we can drop it altogether, to get the following, highly concise version:"
msgstr ""
"最後に、上記の関数の引数`u`は末尾に1度だけしか使われていないので、\n"
"引数と実装の両方から省略して以下の定義が得られます。\n"
"とても簡潔になりました。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:638
#, no-wrap
msgid ""
"total\n"
"incAge5 : User -> User\n"
"incAge5 = { age $= (+ 1) }\n"
msgstr ""
"total\n"
"incAge5 : User -> User\n"
"incAge5 = { age $= (+ 1) }\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:645
msgid "As usual, we should have a look at the result at the REPL:"
msgstr "いつも通りREPLで結果を確認してみましょう。"

#. type: Fenced code block (repl)
#: ../src/Tutorial/DataTypes.md:646
#, no-wrap
msgid ""
"Tutorial.DataTypes> incAge5 drNo\n"
"MkUser \"No\" (Other \"Dr.\") 74\n"
msgstr ""
"Tutorial.DataTypes> incAge5 drNo\n"
"MkUser \"No\" (Other \"Dr.\") 74\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:653
msgid ""
"It is possible to use this syntax to set and/or update several record fields "
"at once:"
msgstr ""
"この文法では複数のレコードフィールドを一度に設定・更新することができます。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:654
#, no-wrap
msgid ""
"total\n"
"drNoJunior : User\n"
"drNoJunior = { name $= (++ \" Jr.\"), title := Mr, age := 17 } drNo\n"
msgstr ""
"total\n"
"drNoJunior : User\n"
"drNoJunior = { name $= (++ \" Jr.\"), title := Mr, age := 17 } drNo\n"

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:660
#, no-wrap
msgid "Tuples"
msgstr "タプル"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:666
msgid ""
"I wrote above that a record is also called a *product type*.  This is quite "
"obvious when we consider the number of possible values inhabiting a given "
"type. For instance, consider the following custom record:"
msgstr ""
"レコードは*直積型*とも呼ばれていると書きました。\n"
"これは与えられた型のありえる値の数を考えればかなり明らかです。\n"
"たとえば、以下の自前のレコードについて考えてみてください。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:667
#, no-wrap
msgid ""
"record Foo where\n"
"  constructor MkFoo\n"
"  wd   : Weekday\n"
"  bool : Bool\n"
msgstr ""
"record Foo where\n"
"  constructor MkFoo\n"
"  wd   : Weekday\n"
"  bool : Bool\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:678
msgid ""
"How many possible values of type `Foo` are there? The answer is `7 * 2 = "
"14`, as we can pair every possible `Weekday` (seven in total) with every "
"possible `Bool` (two in total). So, the number of possible values of a "
"record type is the *product* of the number of possible values for each field."
msgstr ""
"このとき、型`Foo`の取り得る値はいくつあるでしょうか。\n"
"答えは`7 * 2 = 14`です。\n"
"なぜなら`Monday`の全ての取り得るもの（計7つ）と\n"
"`Bool`の全ての取り得るもの（計2つ）の組であると見なせるためです。\n"
"ですから、レコード型で有り得る値の数はそれぞれのフィールドの有り得る値の数の*"
"積*なのです。"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:680
msgid ""
"The canonical product type is the `Pair`, which is available from the "
"*Prelude*:"
msgstr ""
"基本的な直積型は`Pair`です。\n"
"これは*Prelude*から使うことができます。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:681
#, no-wrap
msgid ""
"total\n"
"weekdayAndBool : Weekday -> Bool -> Pair Weekday Bool\n"
"weekdayAndBool wd b = MkPair wd b\n"
msgstr ""
"total\n"
"weekdayAndBool : Weekday -> Bool -> Pair Weekday Bool\n"
"weekdayAndBool wd b = MkPair wd b\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:692
msgid ""
"Since it is quite common to return several values from a function wrapped in "
"a `Pair` or larger tuple, Idris provides some syntactic sugar for working "
"with these. Instead of `Pair Weekday Bool`, we can just write `(Weekday, "
"Bool)`. Likewise, instead of `MkPair wd b`, we can just write `(wd, b)` (the "
"space is optional):"
msgstr ""
"いくつかの値を関数から`Pair`やより大きなタプルにくるんで返すことはかなりよく"
"あるので、\n"
"Idrisはいくつかの糖衣構文を提供しています。\n"
"`Pair Weekday Bool`とする代わりに、\n"
"ただ`(Weekday, Bool)`と書けばよいです。\n"
"そんな感じで`MkPair wd b`とする代わりに単に`(wd, b)`と書けばよいのです。\n"
"（空白は任意です。）"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:693
#, no-wrap
msgid ""
"total\n"
"weekdayAndBool2 : Weekday -> Bool -> (Weekday, Bool)\n"
"weekdayAndBool2 wd b = (wd, b)\n"
msgstr ""
"total\n"
"weekdayAndBool2 : Weekday -> Bool -> (Weekday, Bool)\n"
"weekdayAndBool2 wd b = (wd, b)\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:700
msgid "This works also for nested tuples:"
msgstr "この糖衣構文は入れ子のタプルでも大丈夫。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:701
#, no-wrap
msgid ""
"total\n"
"triple : Pair Bool (Pair Weekday String)\n"
"triple = MkPair False (Friday, \"foo\")\n"
"\n"
"total\n"
"triple2 : (Bool, Weekday, String)\n"
"triple2 = (False, Friday, \"foo\")\n"
msgstr ""
"total\n"
"triple : Pair Bool (Pair Weekday String)\n"
"triple = MkPair False (Friday, \"foo\")\n"
"\n"
"total\n"
"triple2 : (Bool, Weekday, String)\n"
"triple2 = (False, Friday, \"foo\")\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:713
msgid ""
"In the example above, `triple2` is converted to the form used in `triple` by "
"the Idris compiler."
msgstr ""
"上の例での`triple2`はIdrisのコンパイラによって`triple`での形式に変換されま"
"す。"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:715
msgid "We can even use tuple syntax in pattern matches:"
msgstr "タプルの構文をパターン照合で使うことさえできます。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:716
#, no-wrap
msgid ""
"total\n"
"bar : Bool\n"
"bar = case triple of\n"
"  (b,wd,_) => b && isWeekend wd\n"
msgstr ""
"total\n"
"bar : Bool\n"
"bar = case triple of\n"
"  (b,wd,_) => b && isWeekend wd\n"

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:723
#, no-wrap
msgid "As Patterns"
msgstr "asパターン"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:728
msgid ""
"Sometimes, we'd like to take apart a value by pattern matching on it but "
"still retain the value as a whole for using it in further computations:"
msgstr ""
"ときどき、値をパターン照合でばらしつつ、\n"
"あとあとの計算で使うために元の全体の値をそのまま取っておきたいときがありま"
"す。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:729
#, no-wrap
msgid ""
"total\n"
"baz : (Bool,Weekday,String) -> (Nat,Bool,Weekday,String)\n"
"baz t@(_,_,s) = (length s, t)\n"
msgstr ""
"total\n"
"baz : (Bool,Weekday,String) -> (Nat,Bool,Weekday,String)\n"
"baz t@(_,_,s) = (length s, t)\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:741
msgid ""
"In `baz`, variable `t` is *bound* to the triple as a whole, which is then "
"reused to construct the resulting quadruple. Remember, that `(Nat,Bool,"
"Weekday,String)` is just sugar for `Pair Nat (Bool,Weekday,String)`, and "
"`(length s, t)` is just sugar for `MkPair (length s) t`. Hence, the "
"implementation above is correct as is confirmed by the type checker."
msgstr ""
"`baz`では変数`t`はタプル全体に*束縛*されています。\n"
"この変数は結果の3要素のタプルを構築するときに再利用されます。\n"
"ここで、`(Nat,Bool,Weekday,String)`はただの糖衣で、\n"
"`Pair Nat (Bool,Weekday,String)`と同じです。\n"
"また、`(length s, t)`も糖衣で`MkPair (length s) t`と同じです。\n"
"だから、上の実装は型検査器で確証される正しいものなのです。"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:748
#, no-wrap
msgid ""
"1. Define a record type for time spans by pairing a `UnitOfTime`\n"
"with an integer representing the duration of the time span in\n"
"the given unit of time. Define also a function for converting\n"
"a time span to an `Integer` representing the duration in seconds.\n"
msgstr ""
"1. 期間を表すレコード型を定義してください。\n"
"このレコード型は`UnitOfTime`とその時間の単位での期間の幅を表す整数の対です。\n"
"期間を秒数で表したときの`Integer`に変換する関数も定義してください。\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:752
#, no-wrap
msgid ""
"2. Implement an equality check for time spans: Two time spans\n"
"should be considered equal, if and only if they correspond to\n"
"the same number of seconds.\n"
msgstr ""
"2. 期間の等価性検査を実装してください。\n"
"2つの期間が等しいのは、\n"
"秒数に直したときに一致するときに限ります。\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:757
#, no-wrap
msgid ""
"3. Implement a function for pretty printing time spans:\n"
"The resulting string should display the time span in its\n"
"given unit, plus show the number of seconds in parentheses,\n"
"if the unit is not already seconds.\n"
msgstr ""
"3. 期間を綺麗に表示する関数を実装してください。\n"
"結果の文字列は与えられた単位での期間を表示し、\n"
"なおかつ単位が秒でないときは括弧内に秒数を表示するようにしてください。\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:761
#, no-wrap
msgid ""
"4. Implement a function for adding two time spans. If the\n"
"two time spans use different units of time, use the smaller\n"
"unit of time to ensure a lossless conversion.\n"
msgstr ""
"4. 2つの期間を加算する関数を実装してください。\n"
"もし2つの期間が異なる時間の単位を使っていたら、\n"
"小さいほうの時間の単位を使うようにしてください。\n"
"これは損失のない変換を実現するためです。\n"

#. type: Title ##
#: ../src/Tutorial/DataTypes.md:762
#, no-wrap
msgid "Generic Data Types"
msgstr "汎化データ型"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:772
msgid ""
"Sometimes, a concept is general enough that we'd like to apply it not only "
"to a single type, but to all kinds of types. For instance, we might not want "
"to define data types for lists of integers, lists of strings, and lists of "
"booleans, as this would lead to a lot of code duplication.  Instead, we'd "
"like to have a single generic list type *parameterized* by the type of "
"values it stores. This section explains how to define and use generic types."
msgstr ""
"ときどき、概念が充分に汎用的であるために、\n"
"1つの型だけに適用するのではなく、\n"
"ある種類の型全てに適用したいときがあります。\n"
"たとえば、整数型のリストと文字列型のリストと真偽値型のリストを定義したくはあ"
"りません。\n"
"どうしてかっていうと、これをやると沢山コードに重複が生まれるためです。\n"
"その代わりに、1つの汎化されたリスト型でもって、\n"
"そのリストが持つ値の型を*変数に取る*ようにしたいのです。\n"
"この節では汎化型をどう定義しどう使うかを説明します。"

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:773
#, no-wrap
msgid "Maybe"
msgstr "Maybe"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:786
msgid ""
"Consider the case of parsing a `Weekday` from user input. Surely, such a "
"function should return `Saturday`, if the string input was `\"Saturday\"`, "
"but what if the input was `\"sdfkl332\"`? We have several options here.  For "
"instance, we could just return a default result (`Sunday` perhaps?). But is "
"this the behavior programmers expect when using our library? Maybe not. To "
"silently continue with a default value in the face of invalid user input is "
"hardly ever the best choice and may lead to a lot of confusion."
msgstr ""
"`Weekday`をユーザーの入力からパースする場合を考えましょう。\n"
"当然、文字列の入力が`\"Saturday\"`なら、関数が返すのは`Saturday`です。\n"
"でも入力が`\"sdfkl332\"`だったらどうなるでしょうか。\n"
"ここでいくつか選択肢があります。\n"
"たとえば、デフォルト値を返すというもの。\n"
"（`Sunday`とか？）\n"
"でもこれはライブラリを使うプログラマが期待する振舞いなのでしょうか。\n"
"そうではないでしょう。\n"
"不正な利用者の入力を目の前にして、\n"
"何事もなかったかのようにデフォルト値で続行するのはめったに最善の選択ではない"
"ですし、\n"
"多大な混乱のもとになるでしょう。"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:792
msgid ""
"In an imperative language, our function would probably throw an exception. "
"We could do this in Idris as well (there is function `idris_crash` in the "
"*Prelude* for this), but doing so, we would abandon totality! A high price "
"to pay for such a common thing as a parsing error."
msgstr ""
"命令型言語では関数は例外を投げるのかもしれません。\n"
"Idrisでもそれはできます\n"
"（このために*Prelude*に`idris_crash`という関数があります）、\n"
"がしかし、そうすると全域性を放棄することになります！\n"
"パースエラーのようなよくあることのために、全域性を捨てるのはコスパが悪いで"
"す。"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:803
msgid ""
"In languages like Java, our function might also return some kind of `null` "
"value (leading to the dreaded `NullPointerException`s if not handled "
"properly in client code). Our solution will be similar, but instead of "
"silently returning `null`, we will make the possibility of failure visible "
"in the types! We define a custom data type, which encapsulates the "
"possibility of failure. Defining new data types in Idris is very cheap (in "
"terms of the amount of code needed), therefore this is often the way to go "
"in order to increase type safety.  Here's an example how to do this:"
msgstr ""
"Javaのような言語では関数は`null`値の類を返すこともあります。\n"
"（各々のコードで適切に対処されていないと、恐るべき`NullPointererException`"
"に。）\n"
"Idrisの解決策もこれに似ていますが、しれっと`null`を返すのではなく、\n"
"型で失敗する可能性があることを目に見えるようにします！\n"
"このために自前のデータ型を定義し、\n"
"その型が失敗する可能性をカプセル化するようにします。\n"
"Idrisで新しいデータ型を定義することは（必要なコードの量の意味で）とても安く済"
"みます。\n"
"なのでこれは型安全性を増すためにはよくあるやりかたです。\n"
"例はこちら。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:804
#, no-wrap
msgid ""
"data MaybeWeekday = WD Weekday | NoWeekday\n"
"\n"
"total\n"
"readWeekday : String -> MaybeWeekday\n"
"readWeekday \"Monday\"    = WD Monday\n"
"readWeekday \"Tuesday\"   = WD Tuesday\n"
"readWeekday \"Wednesday\" = WD Wednesday\n"
"readWeekday \"Thursday\"  = WD Thursday\n"
"readWeekday \"Friday\"    = WD Friday\n"
"readWeekday \"Saturday\"  = WD Saturday\n"
"readWeekday \"Sunday\"    = WD Sunday\n"
"readWeekday _           = NoWeekday\n"
msgstr ""
"data MaybeWeekday = WD Weekday | NoWeekday\n"
"\n"
"total\n"
"readWeekday : String -> MaybeWeekday\n"
"readWeekday \"Monday\"    = WD Monday\n"
"readWeekday \"Tuesday\"   = WD Tuesday\n"
"readWeekday \"Wednesday\" = WD Wednesday\n"
"readWeekday \"Thursday\"  = WD Thursday\n"
"readWeekday \"Friday\"    = WD Friday\n"
"readWeekday \"Saturday\"  = WD Saturday\n"
"readWeekday \"Sunday\"    = WD Sunday\n"
"readWeekday _           = NoWeekday\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:823
msgid ""
"But assume now, we'd also like to read `Bool` values from user input. We'd "
"now have to write a custom data type `MaybeBool` and so on for all types "
"we'd like to read from `String`, and the conversion of which might fail."
msgstr ""
"でもここで、`Bool`も利用者の入力から読めるようにしたいのだとします。\n"
"そうしたら自前のデータ型`MaybeBool`を書くはめになり、\n"
"`String`から読み取りたい全ての型と失敗するかもしれない変換に対して同じような"
"ことをすることになります。"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:827
msgid ""
"Idris, like many other programming languages, allows us to generalize this "
"behavior by using *generic data types*. Here's an example:"
msgstr ""
"Idrisは他のプログラミング言語のようにこの振舞いを*汎化データ型*で汎化できま"
"す。\n"
"例はこんな感じ。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:828
#, no-wrap
msgid ""
"data Option a = Some a | None\n"
"\n"
"total\n"
"readBool : String -> Option Bool\n"
"readBool \"True\"    = Some True\n"
"readBool \"False\"   = Some False\n"
"readBool _         = None\n"
msgstr ""
"data Option a = Some a | None\n"
"\n"
"total\n"
"readBool : String -> Option Bool\n"
"readBool \"True\"    = Some True\n"
"readBool \"False\"   = Some False\n"
"readBool _         = None\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:839
msgid "It is important to go to the REPL and look at the types:"
msgstr "REPLで型を見るのは大事です。"

#. type: Fenced code block (repl)
#: ../src/Tutorial/DataTypes.md:840
#, no-wrap
msgid ""
"Tutorial.DataTypes> :t Some\n"
"Tutorial.DataTypes.Some : a -> Option a\n"
"Tutorial.DataTypes> :t None\n"
"Tutorial.DataTypes.None : Optin a\n"
"Tutorial.DataTypes> :t Option\n"
"Tutorial.DataTypes.Option : Type -> Type\n"
msgstr ""
"Tutorial.DataTypes> :t Some\n"
"Tutorial.DataTypes.Some : a -> Option a\n"
"Tutorial.DataTypes> :t None\n"
"Tutorial.DataTypes.None : Optin a\n"
"Tutorial.DataTypes> :t Option\n"
"Tutorial.DataTypes.Option : Type -> Type\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:857
msgid ""
"We need to introduce some jargon here. `Option` is what we call a *type "
"constructor*. It is not yet a saturated type: It is a function from `Type` "
"to `Type`.  However, `Option Bool` is a type, as is `Option Weekday`.  Even "
"`Option (Option Bool)` is a valid type. `Option` is a type constructor "
"*parameterized* over a *parameter* of type `Type`.  `Some` and `None` are "
"`Option`s *data constructors*: The functions used to create values of type "
"`Option a` for a type `a`."
msgstr ""
"ここでいくつかの専門用語を紹介しなければいけません。\n"
"`Option`は*型構築子*と呼ぶものです。\n"
"これは完全な型ではなく、`Type`から`Type`への関数です。\n"
"一方で`Option Bool`は型です。\n"
"`Option Weekday`なんかがそうです。\n"
"`Option (Option Bool)`さえ妥当な型です。\n"
"`Option`は型構築子で、型が`Type`の*変数*を*引数に取る*ものなのです。\n"
"`Some`と`None`は`Option`の*データ構築子*です。\n"
"これは関数で、型`a`があったとして、型`Option a`の値をつくるのに使われます。"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:860
msgid ""
"Let's see some other use cases for `Option`. Below is a safe division "
"operation:"
msgstr ""
"`Option`の他の使用例を見てみましょう。\n"
"以下は安全な除算の操作です。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:861
#, no-wrap
msgid ""
"total\n"
"safeDiv : Integer -> Integer -> Option Integer\n"
"safeDiv n 0 = None\n"
"safeDiv n k = Some (n `div` k)\n"
msgstr ""
"total\n"
"safeDiv : Integer -> Integer -> Option Integer\n"
"safeDiv n 0 = None\n"
"safeDiv n k = Some (n `div` k)\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:872
msgid ""
"The possibility of returning some kind of *null* value in the face of "
"invalid input is so common, that there is a data type like `Option` already "
"in the *Prelude*: `Maybe`, with data constructors `Just` and `Nothing`."
msgstr ""
"不正な入力に直面したときに*null*のような類の値を返しうるというのはよくあるの"
"で、\n"
"*Prelude*には既に`Option`のようなデータ型があります。\n"
"その名は`Maybe`。\n"
"データ構築子は`Just`と`Nothing`です。"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:884
msgid ""
"It is important to understand the difference between returning `Maybe "
"Integer` in a function, which might fail, and returning `null` in languages "
"like Java: In the former case, the possibility of failure is visible in the "
"types. The type checker will force us to treat `Maybe Integer` differently "
"than `Integer`: Idris will *not* allow us to forget to eventually handle the "
"failure case.  Not so, if `null` is silently returned without adjusting the "
"types. Programmers may (and often *will*) forget to handle the `null` case, "
"leading to unexpected and sometimes hard to debug runtime exceptions."
msgstr ""
"失敗しうる関数で`Maybe Integer`を返すのと、\n"
"Javaのような言語で`null`を返すのには違いがある、ということを理解するのは大事"
"です。\n"
"前者では失敗する可能性があることは型で見てとれます。\n"
"型検査器によって`Maybe Integer`を`Integer`とは違う風に取り扱うようにしなくて"
"はいけません。\n"
"Idrisは決して失敗する場合の対処をするのを忘れさせ*ません*。\n"
"`null`が何食わぬ顔で返されて、型に合わし損ねるのとは違います。\n"
"プログラマはもしかすると（というかまあ*きっと*）\n"
"`null`の場合の対処をするのを忘れるかもしれないので、\n"
"予想していないような、ときに修復しにくい実行時例外に繋がるのです。"

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:885
#, no-wrap
msgid "Either"
msgstr "Either"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:896
msgid ""
"While `Maybe` is very useful to quickly provide a default value to signal "
"some kind of failure, this value (`Nothing`) is not very informative. It "
"will not tell us *what exactly* went wrong. For instance, in case of our "
"`Weekday` reading function, it might be interesting later on to know the "
"value of the invalid input string. And just like with `Maybe` and `Option` "
"above, this concept is general enough that we might encounter other types of "
"invalid values.  Here's a data type to encapsulate this:"
msgstr ""
"`Maybe`がとても便利で、手っ取り早くなんらかの失敗を知らせるために既定値を返し"
"てくれるとはいえ、\n"
"この値 (`Nothing`) はそれほど有意味ではありません。\n"
"*実際に何が*まずかったのかがわからないのです。\n"
"たとえば、`Weekday`を読み取る関数の例でいうと、\n"
"あとあとで不正な入力文字列の値を知りたくなることがあるかもしれません。\n"
"そしてちょうど上記の`Maybe`と`Option`のように、\n"
"この概念は充分に汎用的なので、\n"
"不正な値のための型を文字列型以外に変えたいことがあるかもしれません。\n"
"これをカプセル化するデータ型はこうなります。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:897
#, no-wrap
msgid "data Validated e a = Invalid e | Valid a\n"
msgstr "data Validated e a = Invalid e | Valid a\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:907
msgid ""
"`Validated` is a type constructor parameterized over two type parameters `e` "
"and `a`. It's data constructors are `Invalid` and `Valid`, the former "
"holding a value describing some error condition, the latter the result in "
"case of a successful computation.  Let's see this in action:"
msgstr ""
"`Validated`は2つの型変数`e`と`a`を引数に取る型構築子です。\n"
"データ構築子は`Invalid`と`Valid`で、\n"
"前者は何らかのエラーの状態を、\n"
"後者は成功した場合の計算の結果を表現します。\n"
"実際に見てみましょう。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:908
#, no-wrap
msgid ""
"total\n"
"readWeekdayV : String -> Validated String Weekday\n"
"readWeekdayV \"Monday\"    = Valid Monday\n"
"readWeekdayV \"Tuesday\"   = Valid Tuesday\n"
"readWeekdayV \"Wednesday\" = Valid Wednesday\n"
"readWeekdayV \"Thursday\"  = Valid Thursday\n"
"readWeekdayV \"Friday\"    = Valid Friday\n"
"readWeekdayV \"Saturday\"  = Valid Saturday\n"
"readWeekdayV \"Sunday\"    = Valid Sunday\n"
"readWeekdayV s           = Invalid (\"Not a weekday: \" ++ s)\n"
msgstr ""
"total\n"
"readWeekdayV : String -> Validated String Weekday\n"
"readWeekdayV \"Monday\"    = Valid Monday\n"
"readWeekdayV \"Tuesday\"   = Valid Tuesday\n"
"readWeekdayV \"Wednesday\" = Valid Wednesday\n"
"readWeekdayV \"Thursday\"  = Valid Thursday\n"
"readWeekdayV \"Friday\"    = Valid Friday\n"
"readWeekdayV \"Saturday\"  = Valid Saturday\n"
"readWeekdayV \"Sunday\"    = Valid Sunday\n"
"readWeekdayV s           = Invalid (\"Not a weekday: \" ++ s)\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:929
msgid ""
"Again, this is such a general concept that a data type similar to "
"`Validated` is already available from the *Prelude*: `Either` with data "
"constructors `Left` and `Right`.  It is very common for functions to "
"encapsulate the possibility of failure by returning an `Either err val`, "
"where `err` is the error type and `val` is the desired return type. This is "
"the type safe (and total!) alternative to throwing a catchable exception in "
"an imperative language."
msgstr ""
"繰り返しますが、これは汎用的な概念なので`Validated`に似たデータ型が既に"
"*Prelude*にあります。\n"
"それは`Either`で、データ構築子は`Left`と`Right`です。\n"
"関数が失敗する可能性をカプセル化して`Either err val`として返すことはとてもよ"
"くあります。\n"
"ここで`err`はエラーの型で`val`は求める結果の型です。\n"
"これは型安全であり（加えて全域です！）、\n"
"命令型言語で例外を投げたり捕えたりするものに代わるものです。"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:934
msgid ""
"Note, however, that the semantics of `Either` are not always \"`Left` is an "
"error and `Right` a success\". A function returning an `Either` just means "
"that it can have to different types of results, each of which are *tagged* "
"with the corresponding data constructor."
msgstr ""
"ただしかし、`Either`の意味論は必ずしも「`Left`が失敗で`Right`が成功を表す」も"
"のとは限りません。\n"
"関数が`Either`を返すということは、単に異なる型の結果を返すという意味であ"
"り、\n"
"それぞれが対応するデータ構築子に*タグ付けされている*だけなのです。"

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:935
#, no-wrap
msgid "List"
msgstr "List"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:941
msgid ""
"One of the most important data structures in pure functional programming is "
"the singly linked list. Here is its definition (called `Seq` in order for it "
"not to collide with `List`, which is of course already available from the "
"Prelude):"
msgstr ""
"純粋関数型プログラミングで最も重要なデータ構造の1つは単方向連結リストです。\n"
"以下がその定義です。\n"
"（`Seq`と呼び、`List`と衝突しないようにしています。\n"
"`List`はもちろんPreludeで既にあります。）"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:942
#, no-wrap
msgid "data Seq a = Nil | (::) a (Seq a)\n"
msgstr "data Seq a = Nil | (::) a (Seq a)\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:953
msgid ""
"This calls for some explanations. `Seq` consists of two *data constructors*: "
"`Nil` (representing an empty sequence of values) and `(::)` (also called the "
"*cons operator*), which prepends a new value of type `a` to an already "
"existing list of values of the same type. As you can see, we can also use "
"operators as data constructors, but please do not overuse this. Use clear "
"names for your functions and data constructors and only introduce new "
"operators when it truly helps readability!"
msgstr ""
"これには少々説明が必要です。\n"
"`Seq`は2つの*データ構築子*からなります。\n"
"`Nil`（値の連なりが空であることを表す）と`(::)`（またの名を*cons演算子*）で"
"す。\n"
"`(::)`は型`a`の新しい値を既存の同じ型の値からなるリストに後付けします。\n"
"見てみると、演算子をデータ構築子としても使えることがわかります。\n"
"しかし、乱用しないでください。\n"
"関数とデータ構築子には明白な名前を使い、\n"
"本当に可読性を向上させるときにだけ新しい演算子を導入すること！"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:956
msgid ""
"Here is an example of how to use the `List` constructors (I use `List` here, "
"as this is what you should use in your own code):"
msgstr ""
"`List`の構築子を使う方法の例はこちらです。\n"
"（ここでは`List`を使っています。\n"
"今後、実際には`Seq`ではなく`List`を使うことになるからです。）"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:957
#, no-wrap
msgid ""
"total\n"
"ints : List Int64\n"
"ints = 1 :: 2 :: -3 :: Nil\n"
msgstr ""
"total\n"
"ints : List Int64\n"
"ints = 1 :: 2 :: -3 :: Nil\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:966
msgid ""
"However, there is a more concise way of writing the above. Idris accepts "
"special syntax for constructing data types consisting exactly of the two "
"constructors `Nil` and `(::)`:"
msgstr ""
"しかし、上の書き方はもっと簡潔にできます。\n"
"Idrisには特殊な文法があり、\n"
"2つの構築子`Nil`と`(::)`からなるデータ型であれば、値の構築に使えます。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:967
#, no-wrap
msgid ""
"total\n"
"ints2 : List Int64\n"
"ints2 = [1, 2, -3]\n"
"\n"
"total\n"
"ints3 : List Int64\n"
"ints3 = []\n"
msgstr ""
"total\n"
"ints2 : List Int64\n"
"ints2 = [1, 2, -3]\n"
"\n"
"total\n"
"ints3 : List Int64\n"
"ints3 = []\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:980
msgid ""
"The two definitions `ints` and `ints2` are treated identically by the "
"compiler.  Note, that list syntax can also be used in pattern matches."
msgstr ""
"2つの定義`ints`と`ints2`はコンパイラによって同一のものとして扱われます。\n"
"なお、リストの文法はパターン照合でも使えます。"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:991
msgid ""
"There is another thing that's special about `Seq` and `List`: Each of them "
"is defined in terms of itself (the cons operator accepts a value and another "
"`Seq` as arguments). We call such data types *recursive* data types, and "
"their recursive nature means, that in order to decompose or consume them, we "
"typically require recursive functions. In an imperative language, we might "
"use a for loop or similar construct to iterate over the values of a `List` "
"or a `Seq`, but these things do not exist in a language without in-place "
"mutation. Here's how to sum a list of integers:"
msgstr ""
"前述の`Seq`と`List`には他にも特別なことがあります。\n"
"どちらも自分自身を使って定義されていることです。\n"
"（cons演算子は値と別の`Seq`を引数に取ります。）\n"
"このようなデータ型を*再帰的な*データ型と呼び、\n"
"この再帰的な性質のために、\n"
"この型の値を分解したり消費したりするためには再帰的な関数が必要になるのがお約"
"束です。\n"
"命令型言語ではforの繰返しのようなもので`List`や`Seq`の値を巡っていきます"
"が、\n"
"そのようなものはその場で値を変更することがない言語には存在しません。\n"
"こちらが整数のリストの合計を求めるやりかたです。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:992
#, no-wrap
msgid ""
"total\n"
"intSum : List Integer -> Integer\n"
"intSum Nil       = 0\n"
"intSum (n :: ns) = n + intSum ns\n"
msgstr ""
"total\n"
"intSum : List Integer -> Integer\n"
"intSum Nil       = 0\n"
"intSum (n :: ns) = n + intSum ns\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1004
msgid ""
"Recursive functions can be hard to grasp at first, so I'll break this down a "
"bit. If we invoke `intSum` with the empty list, the first pattern matches "
"and the function returns zero immediately.  If, however, we invoke `intSum` "
"with a non-empty list - `[7,5,9]` for instance - the following happens:"
msgstr ""
"再帰的な関数は最初は取っ付きにくいかもしれませんから、\n"
"少し分解してみましょう。\n"
"空のリストに対して`intSum`を呼び出すと、\n"
"最初のパターンが照合して関数は直ちにゼロを返します。\n"
"一方で空ではないリスト、例えば`[7,5,9]`、に対して`intSum`を呼び出すと、\n"
"以下のようなことが起こります。"

#. type: Bullet: '1. '
#: ../src/Tutorial/DataTypes.md:1008
msgid ""
"The second pattern matches and splits the list into two parts: Its head "
"(`7`) is bound to variable `n` and its tail (`[5,9]`) is bound to `ns`:"
msgstr ""
"2つ目のパターンが照合し、リスト2つに分割します。\n"
"頭部(`7`)は変数`n`に束縛し、\n"
"尾部(`[5,9]`)は`ns`に束縛します。"

#. type: Fenced code block (repl)
#: ../src/Tutorial/DataTypes.md:1009
#, no-wrap
msgid "   7 + intSum [5,9]\n"
msgstr "   7 + intSum [5,9]\n"

#. type: Bullet: '2. '
#: ../src/Tutorial/DataTypes.md:1015
msgid ""
"In a second invocation, `intSum` is called with a new list: `[5,9]`.  The "
"second pattern matches and `n` is bound to `5` and `ns` is bound to `[9]`:"
msgstr ""
"2回目の呼び出しでは、`intSum`は新しいリスト`[5,9]`とともに呼ばれます。\n"
"2つ目のパターンが照合し、`n`は`5`に束縛し、\n"
"`ns`は`[9]`に束縛します。"

#. type: Fenced code block (repl)
#: ../src/Tutorial/DataTypes.md:1016
#, no-wrap
msgid "   7 + (5 + intSum [9])\n"
msgstr "   7 + (5 + intSum [9])\n"

#. type: Bullet: '3. '
#: ../src/Tutorial/DataTypes.md:1023
msgid ""
"In a third invocation `intSum` is called with list `[9]`.  The second "
"pattern matches and `n` is bound to `9` and `ns` is bound to `[]`:"
msgstr ""
"3回目の`intSum`の呼び出しではリスト`[9]`とともに呼ばれます。\n"
"2つ目のパターンが照合し、`n`は`9`に束縛し、`ns`は`[]`に束縛します。"

#. type: Fenced code block (repl)
#: ../src/Tutorial/DataTypes.md:1024
#, no-wrap
msgid "   7 + (5 + (9 + intSum [])\n"
msgstr "   7 + (5 + (9 + intSum [])\n"

#. type: Bullet: '4. '
#: ../src/Tutorial/DataTypes.md:1030
msgid ""
"In a fourth invocation, `intSum` is called with list `[]` and returns `0` "
"immediately:"
msgstr ""
"4回目の呼び出しでは`intSum`はリスト`[]`とともに呼ばれ、直ちに`0`を返します。"

#. type: Fenced code block (repl)
#: ../src/Tutorial/DataTypes.md:1031
#, no-wrap
msgid "   7 + (5 + (9 + 0)\n"
msgstr "   7 + (5 + (9 + 0)\n"

#. type: Bullet: '5. '
#: ../src/Tutorial/DataTypes.md:1037
msgid "In the third invocation, `9` and `0` are added and `9` is returned:"
msgstr "3回目の呼び出しの部分で、`9`と`0`は加算され、`9`が返ります。"

#. type: Fenced code block (repl)
#: ../src/Tutorial/DataTypes.md:1038
#, no-wrap
msgid "   7 + (5 + 9)\n"
msgstr "   7 + (5 + 9)\n"

#. type: Bullet: '6. '
#: ../src/Tutorial/DataTypes.md:1044
msgid "In the second invocation, `5` and `9` are added and `14` is returned:"
msgstr "2回目の呼び出しの部分で、`5`と`9`が加算され`14`が返ります。"

#. type: Fenced code block (repl)
#: ../src/Tutorial/DataTypes.md:1045
#, no-wrap
msgid "   7 + 14\n"
msgstr "   7 + 14\n"

#. type: Bullet: '7. '
#: ../src/Tutorial/DataTypes.md:1051
msgid ""
"Finally, our initial invocation of `intSum` adds `7` and `14` and returns "
"`21`."
msgstr ""
"最後に`intSum`の最初の呼び出しの部分で、`7`と`14`が加算されて`21`が返ります。"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1055
msgid ""
"Thus, the recursive implementation of `intSum` leads to a sequence of nested "
"calls to `intSum`, which terminates once the argument is the empty list."
msgstr ""
"なので、`intSum`の再帰的な実装によって、`intSum`の入れ子の呼び出しの連なりに"
"なり、\n"
"その連なりは引数が空リストになったときに終わります。"

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:1056
#, no-wrap
msgid "Generic Functions"
msgstr "汎化関数"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1062
msgid ""
"In order to fully appreciate the versatility that comes with generic data "
"types, we also need to talk about generic functions.  Like generic types, "
"these are parameterized over one or more type parameters."
msgstr ""
"汎化データ型によりもたらされる多様性を十全に享受するためには、\n"
"汎化関数についても語らねばなりません。\n"
"汎化型のように汎化関数は1つ以上の型変数を変数に取ります。"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1068
msgid ""
"Consider for instance the case of breaking out of the `Option` data type. In "
"case of a `Some`, we'd like to return the stored value, while for the `None` "
"case we provide a default value. Here's how to do this, specialized to "
"`Integer`s:"
msgstr ""
"たとえば`Option`データ型の殻を破ることを考えてみましょう。\n"
"`Some`の場合は保持している値を返し、\n"
"`None`の場合はデフォルト値を提供します。\n"
"これをする方法は以下で、ここでは`Integer`に特殊化しています。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:1069
#, no-wrap
msgid ""
"total\n"
"integerFromOption : Integer -> Option Integer -> Integer\n"
"integerFromOption _ (Some y) = y\n"
"integerFromOption x None     = x\n"
msgstr ""
"total\n"
"integerFromOption : Integer -> Option Integer -> Integer\n"
"integerFromOption _ (Some y) = y\n"
"integerFromOption x None     = x\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1080
msgid ""
"It's pretty obvious that this, again, is not general enough.  Surely, we'd "
"also like to break out of `Option Bool` or `Option String` in a similar "
"fashion. That's exactly what the generic function `fromOption` does:"
msgstr ""
"これもまたかなり明らかなことですが、充分に汎用的ではありません。\n"
"当然`Option Bool`や`Option String`を似たような様式で解体したくなるでしょ"
"う。\n"
"そしてこれを実現するのがまさに汎化関数`fromOption`なのです。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:1081
#, no-wrap
msgid ""
"total\n"
"fromOption : a -> Option a -> a\n"
"fromOption _ (Some y) = y\n"
"fromOption x None     = x\n"
msgstr ""
"total\n"
"fromOption : a -> Option a -> a\n"
"fromOption _ (Some y) = y\n"
"fromOption x None     = x\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1095
msgid ""
"The lower-case `a` is again a *type parameter*. You can read the type "
"signature as follows: \"For any type `a`, given a *value* of type `a`, and "
"an `Option a`, we can return a value of type `a`.\" Note, that `fromOption` "
"knows nothing else about `a`, other than it being a type. It is therefore "
"not possible, to conjure a value of type `a` out of thin air. We *must* have "
"a value available to deal with the `None` case."
msgstr ""
"小文字`a`もまた*型変数*です。\n"
"型シグネチャを以下のように読むことができます。\n"
"「あらゆる型`a`について、型`a`と`Option a`の*値*があったら、\n"
"型`a`の値を返すことができる。」\n"
"ここで、`fromOption`は`a`について何も知りません。\n"
"知っているのは`a`が型であることぐらいです。\n"
"したがって、型`a`の値の中身を掻き回すことは不可能です。\n"
"`None`の場合に対処できる値が*なくてはいけません*。"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1098
msgid ""
"The pendant to `fromOption` for `Maybe` is called `fromMaybe` and is "
"available from module `Data.Maybe` from the *base* library."
msgstr ""
"`Maybe`用の`fromOption`は`fromMaybe`と呼ばれ、\n"
"モジュール`Data.Maybe`にあり、そのモジュールは*base*ライブラリにあります。"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1104
msgid ""
"Sometimes, `fromOption` is not general enough. Assume we'd like to print the "
"value of a freshly parsed `Bool`, giving some generic error message in case "
"of a `None`. We can't use `fromOption` for this, as we have an `Option Bool` "
"and we'd like to return a `String`. Here's how to do this:"
msgstr ""
"ときどき、`fromOption`では充分に汎用的でないときがあります。\n"
"`Bool`をパースして文字で表示したいのだとしましょう。\n"
"`None`の場合は何かの汎用的なエラーメッセージを出します。\n"
"これには`fromOption`は使えません。\n"
"`Option Bool`があって`String`を返したいからです。\n"
"次のようにすればできます。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:1105
#, no-wrap
msgid ""
"total\n"
"option : b -> (a -> b) -> Option a -> b\n"
"option _ f (Some y) = f y\n"
"option x _ None     = x\n"
"\n"
"total\n"
"handleBool : Option Bool -> String\n"
"handleBool = option \"Not a boolean value.\" show\n"
msgstr ""
"total\n"
"option : b -> (a -> b) -> Option a -> b\n"
"option _ f (Some y) = f y\n"
"option x _ None     = x\n"
"\n"
"total\n"
"handleBool : Option Bool -> String\n"
"handleBool = option \"Not a boolean value.\" show\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1121
#, no-wrap
msgid ""
"Function `option` is parameterized over *two* type parameters:\n"
"`a` represents the type of values stored in the `Option`,\n"
"while `b` is the return type. In case of a `Just`, we need\n"
"a way to convert the stored `a` to a `b`, an that's done\n"
"using the function argument of type `a -> b`.\n"
msgstr ""
"関数`option`は*2つの*型変数を引数に取ります。\n"
"`a`は`Option`に保管されている値の型を表現しており、\n"
"`b`は返り値の型です。\n"
"`Just`の場合は保管されている`a`を`b`に変換する方法が必要であり、\n"
"それには関数の引数`a -> b`を使えばよいです。\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1126
msgid ""
"In Idris, lower-case identifiers in function types are treated as *type "
"parameters*, while upper-case identifiers are treated as types or type "
"constructors that must be in scope."
msgstr ""
"Idrisでは関数の型での小文字の識別子は*型変数*として扱われます。\n"
"一方で大文字の識別子は型か型構築子でスコープにある必要があります。"

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:1127 ../src/Tutorial/Eq.md:1056
#, no-wrap
msgid "Exercises part 4"
msgstr "演習パート4"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1137
msgid ""
"If this is your first time programming in a purely functional language, the "
"exercises below are *very* important. Do not skip any of them! Take your "
"time and work through them all. In most cases, the types should be enough to "
"explain what's going on, even though they might appear cryptic in the "
"beginning. Otherwise, have a look at the comments (if any)  of each exercise."
msgstr ""
"もしこれが初めての関数型言語でのプログラミングであれば、\n"
"以下の演習は*とても*大事です。\n"
"1つも飛ばしてはいけません！\n"
"時間を取って全てに取り組んでください。\n"
"ほとんどの場合、型から何が起こるのかを充分に読み取れます。\n"
"最初は取っ付きにくいかもしれませんが。\n"
"もし読み取れない場合は（もしあれば）それぞれの演習のコメントを見てください。"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1140
msgid ""
"Remember, that lower-case identifiers in a function signature are treated as "
"type parameters."
msgstr ""
"いいですか、関数のシグネチャにある小文字の識別子は型変数と見なされますよ。"

#. type: Bullet: '1. '
#: ../src/Tutorial/DataTypes.md:1142
msgid "Implement the following generic functions for `Maybe`:"
msgstr "以下の`Maybe`に関する汎化関数を実装してください。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:1143
#, no-wrap
msgid ""
"   -- make sure to map a `Just` to a `Just`.\n"
"   total\n"
"   mapMaybe : (a -> b) -> Maybe a -> Maybe b\n"
"\n"
"   -- Example: `appMaybe (Just (+2)) (Just 20) = Just 22`\n"
"   total\n"
"   appMaybe : Maybe (a -> b) -> Maybe a -> Maybe b\n"
"\n"
"   -- Example: `bindMaybe (Just 12) Just = Just 12`\n"
"   total\n"
"   bindMaybe : Maybe a -> (a -> Maybe b) -> Maybe b\n"
"\n"
"   -- keep the value in a `Just` only if the given predicate holds\n"
"   total\n"
"   filterMaybe : (a -> Bool) -> Maybe a -> Maybe a\n"
"\n"
"   -- keep the first value that is not a `Nothing` (if any)\n"
"   total\n"
"   first : Maybe a -> Maybe a -> Maybe a\n"
"\n"
"   -- keep the last value that is not a `Nothing` (if any)\n"
"   total\n"
"   last : Maybe a -> Maybe a -> Maybe a\n"
"\n"
"   -- this is another general way to extract a value from a `Maybe`.\n"
"   -- Make sure the following holds:\n"
"   -- `foldMaybe (+) 5 Nothing = 5`\n"
"   -- `foldMaybe (+) 5 (Just 12) = 17`\n"
"   total\n"
"   foldMaybe : (acc -> el -> acc) -> acc -> Maybe el -> acc\n"
msgstr ""
"   -- `Just`は`Just`に写してください。\n"
"   total\n"
"   mapMaybe : (a -> b) -> Maybe a -> Maybe b\n"
"\n"
"   -- 例：`appMaybe (Just (+2)) (Just 20) = Just 22`\n"
"   total\n"
"   appMaybe : Maybe (a -> b) -> Maybe a -> Maybe b\n"
"\n"
"   -- 例：`bindMaybe (Just 12) Just = Just 12`\n"
"   total\n"
"   bindMaybe : Maybe a -> (a -> Maybe b) -> Maybe b\n"
"\n"
"   -- 与えられた命題が満たされているときにのみ、`Just`の値を保持してください。\n"
"   total\n"
"   filterMaybe : (a -> Bool) -> Maybe a -> Maybe a\n"
"\n"
"   -- 最初の`Nothing`でない値を保持してください。（もし1つでもあるなら）\n"
"   total\n"
"   first : Maybe a -> Maybe a -> Maybe a\n"
"\n"
"   -- 最後の`Nothing`でない値を保持してください。（もし1つでもあるなら）\n"
"   total\n"
"   last : Maybe a -> Maybe a -> Maybe a\n"
"\n"
"   -- `Maybe`から値を抽出する別の一般的なやりかたです。\n"
"   -- ただし、以下を満たします。\n"
"   -- `foldMaybe (+) 5 Nothing = 5`\n"
"   -- `foldMaybe (+) 5 (Just 12) = 17`\n"
"   total\n"
"   foldMaybe : (acc -> el -> acc) -> acc -> Maybe el -> acc\n"

#. type: Bullet: '2. '
#: ../src/Tutorial/DataTypes.md:1177
msgid "Implement the following generic functions for `Either`:"
msgstr "以下の`Either`についての汎化関数を実装してください。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:1178
#, no-wrap
msgid ""
"   total\n"
"   mapEither : (a -> b) -> Either e a -> Either e b\n"
"\n"
"   -- In case of both `Either`s being `Left`s, keep the\n"
"   -- value stored in the first `Left`.\n"
"   total\n"
"   appEither : Either e (a -> b) -> Either e a -> Either e b\n"
"\n"
"   total\n"
"   bindEither : Either e a -> (a -> Either e b) -> Either e b\n"
"\n"
"   -- Keep the first value that is not a `Left`\n"
"   -- If both `Either`s are `Left`s, use the given accumulator\n"
"   -- for the error values\n"
"   total\n"
"   firstEither : (e -> e -> e) -> Either e a -> Either e a -> Either e a\n"
"\n"
"   -- Keep the last value that is not a `Left`\n"
"   -- If both `Either`s are `Left`s, use the given accumulator\n"
"   -- for the error values\n"
"   total\n"
"   lastEither : (e -> e -> e) -> Either e a -> Either e a -> Either e a\n"
"\n"
"   total\n"
"   fromEither : (e -> c) -> (a -> c) -> Either e a -> c\n"
msgstr ""
"   total\n"
"   mapEither : (a -> b) -> Either e a -> Either e b\n"
"\n"
"   -- 両方の`Either`が`Left`なら、\n"
"   -- 最初の`Left`に格納された値を保持してください。\n"
"   total\n"
"   appEither : Either e (a -> b) -> Either e a -> Either e b\n"
"\n"
"   total\n"
"   bindEither : Either e a -> (a -> Either e b) -> Either e b\n"
"\n"
"   -- 最初の`Left`ではない値を保持してください。\n"
"   -- もし両方の`Either`が`Left`であれば、与えられた積載子を使ってエラーの値を出してください。\n"
"   total\n"
"   firstEither : (e -> e -> e) -> Either e a -> Either e a -> Either e a\n"
"\n"
"   -- 最後の`Left`ではない値を保持してください。\n"
"   -- 両方の`Either`が`Left`なら、与えられた積載子を使ってエラーの値を出してください。\n"
"   total\n"
"   lastEither : (e -> e -> e) -> Either e a -> Either e a -> Either e a\n"
"\n"
"   total\n"
"   fromEither : (e -> c) -> (a -> c) -> Either e a -> c\n"

#. type: Bullet: '3. '
#: ../src/Tutorial/DataTypes.md:1207
msgid "Implement the following generic functions for `List`:"
msgstr "`List`についての以下の汎化関数を実装してください。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:1208
#, no-wrap
msgid ""
"   total\n"
"   mapList : (a -> b) -> List a -> List b\n"
"\n"
"   total\n"
"   filterList : (a -> Bool) -> List a -> List a\n"
"\n"
"   -- return the first value of a list, if it is non-empty\n"
"   total\n"
"   headMaybe : List a -> Maybe a\n"
"\n"
"   -- return everything but the first value of a list, if it is non-empty\n"
"   total\n"
"   tailMaybe : List a -> Maybe (List a)\n"
"\n"
"   -- return the last value of a list, if it is non-empty\n"
"   total\n"
"   lastMaybe : List a -> Maybe a\n"
"\n"
"   -- return everything but the last value of a list,\n"
"   -- if it is non-empty\n"
"   total\n"
"   initMaybe : List a -> Maybe (List a)\n"
"\n"
"   -- accumulate the values in a list using the given\n"
"   -- accumulator function and initial value\n"
"   --\n"
"   -- Examples:\n"
"   -- `foldList (+) 10 [1,2,7] = 20`\n"
"   -- `foldList String.(++) \"\" [\"Hello\",\"World\"] = \"HelloWorld\"`\n"
"   -- `foldList last Nothing (mapList Just [1,2,3]) = Just 3`\n"
"   total\n"
"   foldList : (acc -> el -> acc) -> acc -> List el -> acc\n"
msgstr ""
"   total\n"
"   mapList : (a -> b) -> List a -> List b\n"
"\n"
"   total\n"
"   filterList : (a -> Bool) -> List a -> List a\n"
"\n"
"   -- リストの最初の値を返してください。もし空でなければですが。\n"
"   total\n"
"   headMaybe : List a -> Maybe a\n"
"\n"
"   -- リストの最初の値以外全部を返してください。もし空でなければですが。\n"
"   total\n"
"   tailMaybe : List a -> Maybe (List a)\n"
"\n"
"   -- リストの最後の値を返してください。もし空でなければですが。\n"
"   total\n"
"   lastMaybe : List a -> Maybe a\n"
"\n"
"   -- リストの最後の値以外全部を返してください。もし空でなければですが。\n"
"   total\n"
"   initMaybe : List a -> Maybe (List a)\n"
"\n"
"   -- リストの値を積み上げてください。\n"
"   -- 与えられた積載関数と初期値を使います。\n"
"   --\n"
"   -- 例：\n"
"   -- `foldList (+) 10 [1,2,7] = 20`\n"
"   -- `foldList String.(++) \"\" [\"Hello\",\"World\"] = \"HelloWorld\"`\n"
"   -- `foldList last Nothing (mapList Just [1,2,3]) = Just 3`\n"
"   total\n"
"   foldList : (acc -> el -> acc) -> acc -> List el -> acc\n"

#. type: Bullet: '4. '
#: ../src/Tutorial/DataTypes.md:1245
msgid ""
"Assume we store user data for our web application in the following record:"
msgstr ""
"Webアプリケーションで、以下のレコードで利用者のデータを保存するのだとしましょ"
"う。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:1246
#, no-wrap
msgid ""
"   record Client where\n"
"     constructor MkClient\n"
"     name          : String\n"
"     title         : Title\n"
"     age           : Bits8\n"
"     passwordOrKey : Either Bits64 String\n"
msgstr ""
"   record Client where\n"
"     constructor MkClient\n"
"     name          : String\n"
"     title         : Title\n"
"     age           : Bits8\n"
"     passwordOrKey : Either Bits64 String\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1260
#, no-wrap
msgid ""
"   Using `LoginError` from an earlier exercise,\n"
"   implement function `login`, which, given a list of `Client`s\n"
"   plus a value of type `Credentials` will return either a `LoginError`\n"
"   in case no valid credentials where provided, or the first `Client`\n"
"   for whom the credentials match.\n"
msgstr ""
"前の演習での`LoginError`を使って、関数`login`を実装してください。\n"
"この関数は`Client`のリストと`Credentials`な値を受け取って、\n"
"もし1つも妥当な認証情報がなかったときは`LoginError`を、\n"
"そうでないときは最初に認証情報が合致した`Client`を、それぞれ返します。\n"

#. type: Bullet: '5. '
#: ../src/Tutorial/DataTypes.md:1264
msgid ""
"Using your data type for chemical elements from an earlier exercise, "
"implement a function for calculating the molar mass of a molecular formula."
msgstr ""
"前の演習での化学原子のデータ型を使って、\n"
"分子式からモル質量を計算する関数を実装してください。"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1268
#, no-wrap
msgid ""
"   Use a list of elements each paired with its count\n"
"   (a natural number) for representing formulae. For\n"
"   instance:\n"
msgstr ""
"   原子とその個数（自然数）が対になったリストを使って式を表現してください。\n"
"   例えばこんな感じです。\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:1269
#, no-wrap
msgid ""
"   ethanol : List (Element,Nat)\n"
"   ethanol = [(C,2),(H,6),(O,1)]\n"
msgstr ""
"   ethanol : List (Element,Nat)\n"
"   ethanol = [(C,2),(H,6),(O,1)]\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1276
#, no-wrap
msgid ""
"   Hint: You can use function `cast` to convert a natural\n"
"   number to a `Double`.\n"
msgstr "   解決の糸口：関数`cast`を使えば自然数を`Double`に変換できます。\n"

#. type: Title ##
#: ../src/Tutorial/DataTypes.md:1277
#, no-wrap
msgid "Alternative Syntax for Data Definitions"
msgstr "データ定義の別の文法"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1285
msgid ""
"While the examples in the section about parameterized data types are short "
"and concise, there is a slightly more verbose but much more general form for "
"writing such definitions, which makes it much clearer what's going on.  In "
"my opinion, this more general form should be preferred in all but the most "
"simple data definitions."
msgstr ""
"引数を取るデータ型の節での例は短く簡潔でしたが、\n"
"それより僅かに冗長でもはるかに汎用的な形式があります。\n"
"そのような定義の書き方をすると、何が起こっているのかもっと明白になります。\n"
"持論ですが、\n"
"最も簡素なデータ定義を除く全ての場合で、\n"
"このより汎用的な形式は優れているだろうと考えます。"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1290
msgid ""
"Here are the definitions of `Option`, `Validated`, and `Seq` again, using "
"this more general form (I put them in their own *namespace*, so Idris will "
"not complain about identical names in the same source file):"
msgstr ""
"`Option`, `Validated`, `Seq`の定義を改めて出します。\n"
"ただしこの汎用的な形式で。\n"
"（定義を*namespace*の中に置きましたが、\n"
"これでIdrisは1つのソースファイル中に同じ名前があることについて文句を言わなく"
"なります。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:1291
#, no-wrap
msgid ""
"-- GADT is an acronym for \"generalized algebraic data type\"\n"
"namespace GADT\n"
"  data Option : Type -> Type where\n"
"    Some : a -> Option a\n"
"    None : Option a\n"
"\n"
"  data Validated : Type -> Type -> Type where\n"
"    Invalid : e -> Validated e a\n"
"    Valid   : a -> Validated e a\n"
"\n"
"  data Seq : Type -> Type where\n"
"    Nil  : Seq a\n"
"    (::) : a -> GADT.Seq a -> Seq a\n"
msgstr ""
"-- GADTは\"generalized algebraic data type\"の頭字語です\n"
"namespace GADT\n"
"  data Option : Type -> Type where\n"
"    Some : a -> Option a\n"
"    None : Option a\n"
"\n"
"  data Validated : Type -> Type -> Type where\n"
"    Invalid : e -> Validated e a\n"
"    Valid   : a -> Validated e a\n"
"\n"
"  data Seq : Type -> Type where\n"
"    Nil  : Seq a\n"
"    (::) : a -> GADT.Seq a -> Seq a\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1318
#, no-wrap
msgid ""
"Here, `Option` is clearly declared as a type constructor\n"
"(a function of type `Type -> Type`), while `Some`\n"
"is a generic function of type `a -> Option a` (where `a` is\n"
"a *type parameter*)\n"
"and `None` is a nullary generic function of type `Option a`\n"
"(`a` again being a type parameter).\n"
"Likewise for `Validated` and `Seq`. Note, that in case\n"
"of `Seq` we had to disambiguate between the different\n"
"`Seq` definitions in the recursive case. Since we will\n"
"usually not define several data types with the same name in\n"
"a source file, this is not necessary most of the time.\n"
msgstr ""
"ここで`Option`ははっきりと型構築子として宣言されています。\n"
"（型の関数`Type -> Type`です。）\n"
"また、`Some`は汎化関数で型`a -> Option a`であり（ここで`a`は*型変数*です）、\n"
"`None`は引数を持たない汎化関数で型`Option a`です（ここでも`a`は型変数です）。\n"
"`Validated`と`Seq`についても似たようなものです。\n"
"ただ、`Seq`の場合、再帰する部分での異なる`Seq`の定義の曖昧さ回避をせねばなりません。\n"
"たいていは同じ名前のデータ型を1つのファイルで複数回定義することはないので、\n"
"ほとんどの場合は必要ではありません。\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1323
msgid ""
"We covered a lot of ground in this chapter, so I'll summarize the most "
"important points below:"
msgstr ""
"この章では多くの領域の内容を押さえました。\n"
"以下に最も大事な点を要約します。"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1326
#, no-wrap
msgid ""
"* Enumerations are data types consisting of a finite\n"
"number of possible *values*.\n"
msgstr "* 列挙型はデータ型で有限の数の取り得る*値*からなります。\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1330
#, no-wrap
msgid ""
"* Sum types are data types with more than one data\n"
"constructor, where each constructor describes a\n"
"*choice* that can be made.\n"
msgstr ""
"* 直和型もデータ型で1つ以上のデータ構築子からなります。\n"
"それぞれの構築子は可能な*選択*を表現するのでした。\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1333
#, no-wrap
msgid ""
"* Product types are data types with a single constructor\n"
"used to group several values of possibly different types.\n"
msgstr ""
"* 直積型もデータ型で1つの構築子を持ち、\n"
"複数の互いに異なってもよい型の値を取り纏めるのに使います。\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1337
#, no-wrap
msgid ""
"* We use pattern matching to deconstruct immutable\n"
"values in Idris. The possible patterns correspond to\n"
"a data type's data constructors.\n"
msgstr ""
"* パターン照合を使ってIdrisの不変な値を分解します。\n"
"使えるパターンはデータ型のデータ構築子に対応します。\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1341
#, no-wrap
msgid ""
"* We can *bind* variables to values in a pattern or\n"
"use an underscore as a placeholder for a value that's\n"
"not needed on the right hand side of an implementation.\n"
msgstr "* パターンでは値に変数を*束縛*したり下線文字で右側にある実装では不要な値の場所取りをしたりできます。\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1344
#, no-wrap
msgid ""
"* We can pattern match on an intermediary result by introducing\n"
"a *case block*.\n"
msgstr "* *caseブロック*を導入することで、一時的な結果にパターン照合できます。\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1349
#, no-wrap
msgid ""
"* The preferred way to define new product types is\n"
"to define them as *records*, since these come with\n"
"additional syntactic conveniences for setting and\n"
"modifying individual *record fields*.\n"
msgstr ""
"* 新しい直積型を定義する好ましい方法は*レコード*として定義することです。\n"
"なぜなら型に加えて、\n"
"それぞれの*レコードのフィールド*を設定したり変更したりするための文法的な便宜があるためです。\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1354
#, no-wrap
msgid ""
"* Generic types and functions allow us generalize\n"
"certain concepts and make them available for many\n"
"types by using *type parameters* instead of\n"
"concrete types in function and type signatures.\n"
msgstr ""
"* 汎化型と汎化関数で概念を汎化したり関数の型シグネチャで決まった型を使う代わりに*型変数*を使うことで\n"
"多くの型で使えるようにしました。\n"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1361
#, no-wrap
msgid ""
"* Common concepts like *nullary values* (`Maybe`),\n"
"computations that might fail with some error\n"
"condition (`Either`), and handling collections\n"
"of values of the same type at once (`List`) are\n"
"example use cases of generic types and functions\n"
"already provided by the *Prelude*.\n"
msgstr ""
"* *nullになりかねない値* (`Maybe`) のようなよくある概念や、\n"
"何らかのエラー状態でもって失敗するかもしれない計算 (`Either`)、\n"
"そして同じ型の値の集まりを一度に扱うこと (`List`) は汎化型と汎化関数の使用例で、\n"
"既に*Prelude*から提供されています。\n"

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:1362 ../src/Tutorial/Dependent.md:904
#: ../src/Tutorial/Functions1.md:575 ../src/Tutorial/Functions2.md:954
#: ../src/Tutorial/IO.md:1118 ../src/Tutorial/Interfaces.md:813
#, no-wrap
msgid "What's next"
msgstr "お次は？"

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1366
msgid ""
"In the [next section](Interfaces.md), we will introduce *interfaces*, "
"another approach to *function overloading*."
msgstr ""
"[次の節](Interfaces.md)では*インターフェース*を導入します。\n"
"インターフェースは*関数のオーバーロード*の他の手法です。"

#. type: Title ###
#: ../src/Tutorial/Dependent.md:1 ../src/Tutorial/Intro.md:76
#, no-wrap
msgid "Dependent Types"
msgstr "依存型"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:9
msgid ""
"The ability to calculate types from values, pass them as arguments to "
"functions, and return them as results from functions - in short, being a "
"dependently typed language - is one of the most distinguishing features of "
"Idris. Many of the more advanced type level extensions of languages like "
"Haskell (and quite a bit more) can be treated in one fell swoop with "
"dependent types."
msgstr ""
"値から型を計算したり、型を引数として関数に渡したり、型を関数からの結果として"
"返したりできるということ、\n"
"これを端的に依存型言語であると言いますが、\n"
"そのことはIdrisの最も際立った特徴の1つです。\n"
"Haskellのような多くの（というかちょっと多すぎる）より発展的な型段階拡張を行う"
"言語も、依存型を一息に処理できます。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:10
#, no-wrap
msgid ""
"module Tutorial.Dependent\n"
"\n"
"%default total\n"
msgstr ""
"module Tutorial.Dependent\n"
"\n"
"%default total\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:17
msgid "Consider the following functions:"
msgstr "以下の関数を考えます。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:18
#, no-wrap
msgid ""
"bogusMapList : (a -> b) -> List a -> List b\n"
"bogusMapList _ _ = []\n"
"\n"
"bogusZipList : (a -> b -> c) -> List a -> List b -> List c\n"
"bogusZipList _ _ _ = []\n"
msgstr ""
"bogusMapList : (a -> b) -> List a -> List b\n"
"bogusMapList _ _ = []\n"
"\n"
"bogusZipList : (a -> b -> c) -> List a -> List b -> List c\n"
"bogusZipList _ _ _ = []\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:35
msgid ""
"The implementations type check, and still, they are obviously not what users "
"of our library would expect. In the first example, we'd expect the "
"implementation to apply the function argument to all values stored in the "
"list, without dropping any of them or changing their order.  The second is "
"trickier: The two list arguments might be of different length.  What are we "
"supposed to do when that's the case? Return a list of the same length as the "
"smaller of the two? Return an empty list? Or shouldn't we in most use cases "
"expect the two lists to be of the same length? How could we even describe "
"such a precondition?"
msgstr ""
"実装は型検査を通りますがしかし、その実装は明らかにライブラリ利用者が期待する"
"ものではありません。\n"
"最初の例では実装で関数引数をリスト中に格納された全ての値に適用されることが期"
"待されています。\n"
"1つとして欠落していてはいけませんし、順番が変わってもなりません。\n"
"2つ目はもう少し注意が必要です。\n"
"というのは、2つのリストの引数が異なる長さかもしれないからです。\n"
"その場合どうしたらいいのでしょうか。\n"
"2つのうち小さいほうのと同じ長さのリストを返すのでしょうか。\n"
"空リストを返すのでしょうか。\n"
"それともほとんどの使用例で2つのリストが同じ長さであることを期待すべきではない"
"のでしょうか。\n"
"どうすればそのような前提条件を表現できるのでしょうか。"

#. type: Title ##
#: ../src/Tutorial/Dependent.md:36
#, no-wrap
msgid "Length-Indexed Lists"
msgstr "長さ指標付きリスト"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:41
msgid ""
"The answer to the issues described above is of course: Dependent types.  And "
"the most common introductory example is the *vector*: A list indexed by its "
"length:"
msgstr ""
"上述した問題への答えはもちろん、依存型です。\n"
"そして最もよく知られた導入例は*ベクタ*、長さ指標付きリストです。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:42
#, no-wrap
msgid ""
"data Vect : (len : Nat) -> (a : Type) -> Type where\n"
"  Nil  : Vect 0 a\n"
"  (::) : (x : a) -> (xs : Vect n a) -> Vect (S n) a\n"
msgstr ""
"data Vect : (len : Nat) -> (a : Type) -> Type where\n"
"  Nil  : Vect 0 a\n"
"  (::) : (x : a) -> (xs : Vect n a) -> Vect (S n) a\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:58
#, no-wrap
msgid ""
"Before we move on, please compare this with the implementation of `Seq` in\n"
"the [section about algebraic data types](DataTypes.md). The constructors\n"
"are exactly the same: `Nil` and `(::)`. But there is an important difference:\n"
"`Vect`, unlike `Seq` or `List`, is not a function from `Type` to `Type`, it is\n"
"a function from `Nat` to `Type` to `Type`. Go ahead! Open the REPL and\n"
"verify this! The `Nat` argument (also called an *index*) represents\n"
"the *length* of the vector here.\n"
"`Nil` has type `Vect 0 a`: A vector of length\n"
"zero. *Cons* has type `a -> Vect n a -> Vect (S n) a`: It is exactly one\n"
"element longer (`S n`) than its second argument, which is of length `n`.\n"
msgstr ""
"進める前に、これと[代数的データ型の節](DataTypes.md)の`Seq`の実装を比較してください。\n"
"構築子はまったく同じで、`Nil`と`(::)`です。\n"
"それでも重大な違いがあります。\n"
"`Vect`は、`Seq`や`List`とは違い、`Type`から`Type`への関数ではなく、`Nat`から`Type`そして`Type`への関数なのです。\n"
"さあ、REPLを開いてこれを確かめましょう！\n"
"`Nat`引数（*指標*とも呼ばれます）はここではベクタの*長さ*を表しています。\n"
"`Nil`は型`Vect 0 a`で長さゼロのベクタです。\n"
"*Cons*は型`a -> Vect n a -> Vect (S n) a`です。\n"
"これは`n`2つ目の引数よりちょうど要素1つ分長い (`S n`) です。\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:61
msgid ""
"Let's experiment with this idea to gain a better understanding.  There is "
"only one way to come up with a vector of length zero:"
msgstr ""
"この考え方を手を動かしてより深く理解しましょう。\n"
"長さがゼロのベクタを作る方法は1つだけです。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:62
#, no-wrap
msgid ""
"ex1 : Vect 0 Integer\n"
"ex1 = Nil\n"
msgstr ""
"ex1 : Vect 0 Integer\n"
"ex1 = Nil\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:69
msgid ""
"The following, on the other hand, leads to a type error (a pretty "
"complicated one, actually):"
msgstr ""
"他方で以下は型エラーです。\n"
"（実際はかなり複雑なエラーです。）"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:70
#, no-wrap
msgid ""
"failing \"Mismatch between: S ?n and 0.\"\n"
"  ex2 : Vect 0 Integer\n"
"  ex2 = [12]\n"
msgstr ""
"failing \"Mismatch between: S ?n and 0.\"\n"
"  ex2 : Vect 0 Integer\n"
"  ex2 = [12]\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:80
msgid ""
"The problem: `[12]` gets desugared to `12 :: Nil`, but this has the wrong "
"type! Since `Nil` has type `Vect 0 Integer` here, `12 :: Nil` has type `Vect "
"(S 0) Integer`, which is identical to `Vect 1 Integer`. Idris verifies, at "
"compile time, that our vector is of the correct length!"
msgstr ""
"問題点は以下です。\n"
"`[12]`は`12 :: Nil`に脱糖されますが、\n"
"これは誤った型です！\n"
"`Nil`はここでは型`Vect 0 Integer`なので、`12 :: Nil`は型`Vect (S 0) "
"Integer`、つまり`Vect 1 Integer`となります。\n"
"Idrisはベクタが正しい長さになっていることを、コンパイル時に検証するのです。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:81
#, no-wrap
msgid ""
"ex3 : Vect 1 Integer\n"
"ex3 = [12]\n"
msgstr ""
"ex3 : Vect 1 Integer\n"
"ex3 = [12]\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:93
msgid ""
"So, we found a way to encode the *length* of a list-like data structure in "
"its *type*, and it is a *type error* if the number of elements in a vector "
"does not agree with then length given in its type. We will shortly see "
"several use cases, where this additional piece of information allows us to "
"be more precise in the types and rule out additional programming mistakes. "
"But first, we need to quickly clarify some terminology."
msgstr ""
"というわけでリストのようなデータ構造の*長さ*を*型*に書き換える方法がわかりま"
"した。\n"
"ベクタの要素数が型にある長さと合致しなければ*型エラー*になるのです。\n"
"すぐあとでいくつかの使用例を見ていきますが、\n"
"この追加情報により型をより精密なものにしてこれ以上のプログラミングの誤りを排"
"除できます。\n"
"でもまずはさくっといくつかの用語を明らかにしておかねばなりません。"

#. type: Title ###
#: ../src/Tutorial/Dependent.md:94
#, no-wrap
msgid "Type Indices versus Type Parameters"
msgstr "型指標対型変数"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:101
msgid ""
"`Vect` is not only a generic type, parameterized over the type of elements "
"it holds, it is actually a *family of types*, each of them associated with a "
"natural number representing it's length. We also say, the type family `Vect` "
"is *indexed* by its length."
msgstr ""
"`Vect`は汎化型、つまり保管している要素の型を変数として取るもの、というだけで"
"はなくて、\n"
"実のところは*型族*で、それぞれがその長さを表す自然数と関連付けられていま"
"す。\n"
"もっと言うと型族`Vect`は長さが*指標付けられている*のです。"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:108
msgid ""
"The difference between a type parameter and an index is, that the latter can "
"and does change across data constructors, while the former is the same for "
"all data constructors. Or, put differently, we can learn about the *value* "
"of an index by pattern matching on a *value* of the type family, while this "
"is not possible with a type parameter."
msgstr ""
"型変数と指標の違いは、後者がデータ構築子によって異なるようにすることができる"
"ということです。\n"
"対して前者は全てのデータ構築子について同じです。\n"
"あるいは視点を変えると、型族の*値*にパターン照合することで指標の*値*を知るこ"
"とができますが、\n"
"これは型変数では不可能なことです。"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:110
msgid "Let's demonstrate this with a contrived example:"
msgstr "以下のわざとらしい例について考えましょう。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:111
#, no-wrap
msgid ""
"data Indexed : Nat -> Type where\n"
"  I0 : Indexed 0\n"
"  I3 : Indexed 3\n"
"  I4 : String -> Indexed 4\n"
msgstr ""
"data Indexed : Nat -> Type where\n"
"  I0 : Indexed 0\n"
"  I3 : Indexed 3\n"
"  I4 : String -> Indexed 4\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:124
msgid ""
"Here, `Indexed` is indexed over its `Nat` argument, as values of the index "
"changes across constructors (I chose some arbitrary value for each "
"constructor), and we can learn about these values by pattern matching on "
"`Indexed` values.  We can use this, for instance, to create a `Vect` of the "
"same length as the index of `Indexed`:"
msgstr ""
"ここで`Index`は`Nat`引数が指標付けられていますが、\n"
"それは指標値が構築子によって変わっているからです。\n"
"（それぞれの構築子には好きに値をを選びました。）\n"
"こうすると`Indexed`の値にパターン照合することでこれらの値がわかります。\n"
"例えばこれを`Indexed`の指標と同じ長さの`Vect`を作るのに使えます。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:125
#, no-wrap
msgid "fromIndexed : Indexed n -> a -> Vect n a\n"
msgstr "fromIndexed : Indexed n -> a -> Vect n a\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:133
msgid ""
"Go ahead, and try implementing this yourself! Work with holes, pattern match "
"on the `Indexed` argument, and learn about the expected output type in each "
"case by inspecting the holes and their context."
msgstr ""
"さあ、自分でこれを実装してみましょう！\n"
"穴あきを使い、\n"
"`Indexed`引数でパターン照合し、\n"
"そして穴あきとその文脈を調べることによって、\n"
"それぞれの場合の期待される出力型を調べてください。"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:135
msgid "Here is my implementation:"
msgstr "私の実装はこうです。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:136
#, no-wrap
msgid ""
"fromIndexed I0     va = []\n"
"fromIndexed I3     va = [va, va, va]\n"
"fromIndexed (I4 _) va = [va, va, va, va]\n"
msgstr ""
"fromIndexed I0     va = []\n"
"fromIndexed I3     va = [va, va, va]\n"
"fromIndexed (I4 _) va = [va, va, va, va]\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:146
msgid ""
"As you can see, by pattern matching on the value of the `Indexed n` "
"argument, we learned about the value of the `n` index itself, which was "
"necessary to return a `Vect` of the correct length."
msgstr ""
"見てわかるように、`Indexed n`の引数の値にパターン照合することで`n`指標自体の"
"値がわかり、\n"
"それを使って正しい長さの`Vect`を返す必要があるのです。"

#. type: Title ###
#: ../src/Tutorial/Dependent.md:147
#, no-wrap
msgid "Length-Preserving `map`"
msgstr "長さが保存された`map`"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:154
msgid ""
"Function `bogusMapList` behaved unexpectedly, because it always returned the "
"empty list. With `Vect`, we need to be true to the types here. If we map "
"over a `Vect`, the argument *and* output type contain a length index, and "
"these length indices will tell us *exactly*, if and how the lengths of our "
"vectors are modified:"
msgstr ""
"関数`bogusMapList`は期待した通りには振舞いませんでしたが、\n"
"これはいつも空リストを返却していたからです。\n"
"これが`Vect`だったら型に正直でなければなりません。\n"
"`Vect`をmapする場合、引数*および*出力型は長さ指標を含んでおり、\n"
"この長さ指標は*厳密に*ベクタの長さがどれほど変わったのかがわかります。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:155
#, no-wrap
msgid ""
"map3_1 : (a -> b) -> Vect 3 a -> Vect 1 b\n"
"map3_1 f [_,y,_] = [f y]\n"
"\n"
"map5_0 : (a -> b) -> Vect 5 a -> Vect 0 b\n"
"map5_0 f _ = []\n"
"\n"
"map5_10 : (a -> b) -> Vect 5 a -> Vect 10 b\n"
"map5_10 f [u,v,w,x,y] = [f u, f u, f v, f v, f w, f w, f x, f x, f y, f y]\n"
msgstr ""
"map3_1 : (a -> b) -> Vect 3 a -> Vect 1 b\n"
"map3_1 f [_,y,_] = [f y]\n"
"\n"
"map5_0 : (a -> b) -> Vect 5 a -> Vect 0 b\n"
"map5_0 f _ = []\n"
"\n"
"map5_10 : (a -> b) -> Vect 5 a -> Vect 10 b\n"
"map5_10 f [u,v,w,x,y] = [f u, f u, f v, f v, f w, f w, f x, f x, f y, f y]\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:173
msgid ""
"While these examples are quite interesting, they are not really useful, are "
"they? That's because they are too specialized. We'd like to have a *general* "
"function for mapping vectors of any length.  Instead of using concrete "
"lengths in type signatures, we can also use *variables* as already seen in "
"the definition of `Vect`.  This allows us to declare the general case:"
msgstr ""
"こうした例はかなり面白いとはいえ、あまり便利ではありませんよね。\n"
"どうしてかというと、あまりにも局所的だからです。\n"
"どんな長さのベクタにもmapできる*汎化*関数がほしいものです。\n"
"型処方に固定長を使う代わりに、既に`Vect`の定義で見たように*変数*を使うことも"
"できます。\n"
"これがあれば汎用的な場合を宣言できます。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:174
#, no-wrap
msgid "mapVect' : (a -> b) -> Vect n a -> Vect n b\n"
msgstr "mapVect' : (a -> b) -> Vect n a -> Vect n b\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:181
msgid ""
"This type describes a length-preserving map. It is actually more instructive "
"(but not necessary) to include the implicit arguments as well:"
msgstr ""
"この型は長さが保存されたmapを表します。\n"
"暗黙引数も含めるようにすれば実際どうなっているのかがよりわかりやすくなりま"
"す。\n"
"（必要ではありませんが。）"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:182
#, no-wrap
msgid "mapVect : {0 a,b : _} -> {0 n : Nat} -> (a -> b) -> Vect n a -> Vect n b\n"
msgstr "mapVect : {0 a,b : _} -> {0 n : Nat} -> (a -> b) -> Vect n a -> Vect n b\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:196
msgid ""
"We ignore the two type parameters `a`, and `b`, as these just describe a "
"generic function (note, however, that we can group arguments of the same "
"type and quantity in a single pair of curly braces; this is optional, but it "
"sometimes helps making type signatures a bit shorter). The implicit argument "
"of type `Nat`, however, tells us that the input and output `Vect` are of the "
"same length. It is a type error to not uphold to this contract. When "
"implementing `mapVect`, it is very instructive to follow along and use some "
"holes. In order to get *any* information about the length of the `Vect` "
"argument, we need to pattern match on it:"
msgstr ""
"2つの型変数`a`と`b`は無視できます。\n"
"ただの汎化関数なので。\n"
"（ただ、同じ型と数量子の引数を単一対の波括弧内にまとめられることは覚えておい"
"てください。\n"
"これはやってもやらなくてもいいですが、型処方を少しだけ短くできることもありま"
"す。）\n"
"型`Nat`の暗黙引数はしかし、入出力の`Vect`が同じ長さであることを示していま"
"す。\n"
"この契約を履行しないと型エラーです。\n"
"`mapVect`を実装しているときなどでこの契約は大変説明的なもので、\n"
"これに沿って実装したり穴あきを使ったりできます。\n"
"`Vect`の長さについての*どんな*情報を得るのにも、\n"
"パターン照合が要ります。"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Dependent.md:197
#, no-wrap
msgid ""
"mapVect _ Nil       = ?impl_0\n"
"mapVect f (x :: xs) = ?impl_1\n"
msgstr ""
"mapVect _ Nil       = ?impl_0\n"
"mapVect f (x :: xs) = ?impl_1\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:203
msgid "At the REPL, we learn the following:"
msgstr "このファイルをREPLセッションに読み込んで以下を試してみましょう。"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Dependent.md:204
#, no-wrap
msgid ""
"Tutorial.Dependent> :t impl_0\n"
" 0 a : Type\n"
" 0 b : Type\n"
" 0 n : Nat\n"
"------------------------------\n"
"impl_0 : Vect 0 b\n"
"\n"
"\n"
"Tutorial.Dependent> :t impl_1\n"
" 0 a : Type\n"
" 0 b : Type\n"
"   x : a\n"
"   xs : Vect n a\n"
"   f : a -> b\n"
" 0 n : Nat\n"
"------------------------------\n"
"impl_1 : Vect (S n) b\n"
msgstr ""
"Tutorial.Dependent> :t impl_0\n"
" 0 a : Type\n"
" 0 b : Type\n"
" 0 n : Nat\n"
"------------------------------\n"
"impl_0 : Vect 0 b\n"
"\n"
"\n"
"Tutorial.Dependent> :t impl_1\n"
" 0 a : Type\n"
" 0 b : Type\n"
"   x : a\n"
"   xs : Vect n a\n"
"   f : a -> b\n"
" 0 n : Nat\n"
"------------------------------\n"
"impl_1 : Vect (S n) b\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:226
msgid ""
"The first hole, `impl_0` is of type `Vect 0 b`. There is only one such "
"value, as discussed above:"
msgstr ""
"最初の穴あき`impl_0`は型`Vect 0 b`です。\n"
"前述したようにそのような値は1つしかありません。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:227
#, no-wrap
msgid "mapVect _ Nil       = Nil\n"
msgstr "mapVect _ Nil       = Nil\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:238
msgid ""
"The second case is again more interesting. We note, that `xs` is of type "
"`Vect n a`, for an arbitrary length `n` (given as an erased argument), while "
"the result is of type `Vect (S n) b`. So, the result has to be one element "
"longer than `xs`. Luckily, we already have a value of type `a` (bound to "
"variable `x`) and a function from `a` to `b` (bound to variable `f`), so we "
"can apply `f` to `x` and prepend the result to a yet unknown remainder:"
msgstr ""
"2つ目の場合はこれまたもっと面白いものです。\n"
"`xs`は任意長の`n`（消去引数として与えられます）について型`Vect n a`であると書"
"きました。\n"
"そうして結果は型`Vect (S n) b`なのです。\n"
"ということは、結果は`xs`よりも1要素分長くなければいけません。\n"
"運よく既に型`a`の値（変数`x`に束縛されています）があり、\n"
"`a`から`b`への関数（変数`f`に束縛されています）があるので、\n"
"`f`を`x`に適用して結果を未知の残りの部分の先頭にくっつけられます。"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Dependent.md:239
#, no-wrap
msgid "mapVect f (x :: xs) = f x :: ?rest\n"
msgstr "mapVect f (x :: xs) = f x :: ?rest\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:244
msgid "Let's inspect the new hole at the REPL:"
msgstr "REPLで新しい穴あきを調べてみましょう。"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Dependent.md:245
#, no-wrap
msgid ""
"Tutorial.Dependent> :t rest\n"
" 0 a : Type\n"
" 0 b : Type\n"
"   x : a\n"
"   xs : Vect n a\n"
"   f : a -> b\n"
" 0 n : Nat\n"
"------------------------------\n"
"rest : Vect n b\n"
msgstr ""
"Tutorial.Dependent> :t rest\n"
" 0 a : Type\n"
" 0 b : Type\n"
"   x : a\n"
"   xs : Vect n a\n"
"   f : a -> b\n"
" 0 n : Nat\n"
"------------------------------\n"
"rest : Vect n b\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:265
msgid ""
"Now, we have a `Vect n a` and need a `Vect n b`, without knowing anything "
"else about `n`. We *could* learn more about `n` by pattern matching further "
"on `xs`, but this would quickly lead us down a rabbit hole, since after such "
"a pattern match, we'd end up with another `Nil` case and another *cons* "
"case, with a new tail of unknown length. Instead, we can invoke `mapVect` "
"recursively to convert the remainder (`xs`) to a `Vect n b`.  The type "
"checker guarantees, that the lengths of `xs` and `mapVect f xs` are the "
"same, so the whole expression type checks and we are done:"
msgstr ""
"さて、`Vect n a`があり、`Vect n b`がほしいところです。\n"
"ただし`n`についてはなんにもわかりません。\n"
"さらに`xs`をパターン照合することで`n`をより知ることは*できはします*が、\n"
"すぐさまいたちごっこになってしまうでしょう。\n"
"というのはそのようなパターン照合をしたら、新しく未知の長さの尾鰭が生えるから"
"です。\n"
"その代わり、`mapVect`を再帰的に呼び出して残り (`xs`) を`Vect n b`に変換できま"
"す。\n"
"`xs`と`mapVect f xs`の長さが等しいことは型検査器が保証してくれます。\n"
"式全体が型検査を通ったので、これにて完了です。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:266
#, no-wrap
msgid "mapVect f (x :: xs) = f x :: mapVect f xs\n"
msgstr "mapVect f (x :: xs) = f x :: mapVect f xs\n"

#. type: Title ###
#: ../src/Tutorial/Dependent.md:270
#, no-wrap
msgid "Zipping Vectors"
msgstr "ベクタを縫い合わす"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:277
msgid ""
"Let us now have a look at `bogusZipList`: We'd like to pairwise merge two "
"lists holding elements of (possibly) distinct types through a given binary "
"function. As discussed above, the most reasonable thing to do is to expect "
"the two lists as well as the result to be of equal length.  With `Vect`, "
"this can be expressed and implemented as follows:"
msgstr ""
"さて、`bogusZipList`を見てみましょう。\n"
"異な（りう）る型の要素を持つ2つのリストについて、所与の2引数関数を通して向か"
"い合うものを1つに閉じるというものです。\n"
"前述したように、2つのリストと結果はいずれも同じ長さになるのが一番理に適ってい"
"ます。\n"
"`Vect`があればこれは以下のように表現でき、実装されます。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:278
#, no-wrap
msgid ""
"zipWith : (a -> b -> c) -> Vect n a -> Vect n b -> Vect n c\n"
"zipWith f []        []         = Nil\n"
"zipWith f (x :: xs) (y :: ys)  = f x y :: zipWith f xs ys\n"
msgstr ""
"zipWith : (a -> b -> c) -> Vect n a -> Vect n b -> Vect n c\n"
"zipWith f []        []         = Nil\n"
"zipWith f (x :: xs) (y :: ys)  = f x y :: zipWith f xs ys\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:295
msgid ""
"Now, here is an interesting thing: The totality checker (activated "
"throughout this source file due to the initial `%default total` pragma)  "
"accepts the above implementation as being total, although it is missing two "
"more cases. This works, because Idris can figure out on its own, that the "
"other two cases are *impossible*.  From the pattern match on the first "
"`Vect` argument, Idris learns whether `n` is zero or the successor of "
"another natural number. But from this it can derive, whether the second "
"vector, being also of length `n`, is a `Nil` or a *cons*. Still, it can be "
"informative to add the impossible cases explicitly. We can use keyword "
"`impossible` to do so:"
msgstr ""
"さてさて、ここが面白いところです。\n"
"全域性検査器（最初の`%default total`プラグマがあるのでこのソースファイルを通"
"じて有効）は、\n"
"あと2つ場合分けが足りないのですが、\n"
"上の実装を全域であるとして受理します。\n"
"これが動くのは、他の2つの場合が*不可能*であることを、\n"
"Idrisが自分で調べてくれるからです。\n"
"最初の`Vect`引数にパターン照合したことから、\n"
"Idrisは`n`がゼロかゼロよりあとに続く他の自然数だと読み取ります。\n"
"しかしここから、2つ目のベクタもまた長さが`n`であり、`Nil`ないし*cons*であるこ"
"とを導出できるのです。\n"
"それでも明示的に不可能な場合を加えたほうが親切なこともあります。\n"
"これには`impossible`キーワードが使えます。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:296
#, no-wrap
msgid ""
"zipWith _ [] (_ :: _) impossible\n"
"zipWith _ (_ :: _) [] impossible\n"
msgstr ""
"zipWith _ [] (_ :: _) impossible\n"
"zipWith _ (_ :: _) [] impossible\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:306
msgid ""
"It is - of course - a type error to annotate a case in a pattern match with "
"`impossible`, if Idris cannot verify that this case is indeed impossible. We "
"will learn in a later section what to do, when we think we are right about "
"an impossible case and Idris is not."
msgstr ""
"もちろん、パターン照合中の場合に`impossible`を付けるのは、\n"
"Idrisがたしかに不可能だと確証できない限り、型エラーです。\n"
"後の節で、自分は不可能だとわかっているのにIdrisがわかってくれないときに、\n"
"どうすればよいのかを学びます。"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:308
msgid "Let's give `zipWith` a spin at the REPL:"
msgstr "ちょっとREPLで`zipWith`を動かしてみましょう。"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Dependent.md:309
#, no-wrap
msgid ""
"Tutorial.Dependent> zipWith (*) [1,2,3] [10,20,30]\n"
"[10, 40, 90]\n"
"Tutorial.Dependent> zipWith (\\x,y => x ++ \": \" ++ show y) [\"The answer\"] [42]\n"
"[\"The answer: 42\"]\n"
"Tutorial.Dependent> zipWith (*) [1,2,3] [10,20]\n"
"... Nasty type error ...\n"
msgstr ""
"Tutorial.Dependent> zipWith (*) [1,2,3] [10,20,30]\n"
"[10, 40, 90]\n"
"Tutorial.Dependent> zipWith (\\x,y => x ++ \": \" ++ show y) [\"The answer\"] [42]\n"
"[\"The answer: 42\"]\n"
"Tutorial.Dependent> zipWith (*) [1,2,3] [10,20]\n"
"... ひどい型エラー ...\n"

#. type: Title ####
#: ../src/Tutorial/Dependent.md:318
#, no-wrap
msgid "Simplifying Type Errors"
msgstr "型エラーを簡潔にする"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:329
msgid ""
"It is amazing to experience the amount of work Idris can do for us and the "
"amount of things it can infer on its own when things go well. When things "
"don't go well, however, the error messages we get from Idris can be quite "
"long and hard to understand, especially for programmers new to the language. "
"For instance, the error message in the last REPL example above was pretty "
"long, listing different things Idris tried to do together with the reason "
"why each of them failed."
msgstr ""
"Idrisがやってくれることの多さと、物事がうまく運んでいるときに自分で推論できる"
"ことの多さには、目を瞠るものがあります。\n"
"しかし物事がうまく運んでいない場合は、Idrisが出力するエラー文言はかなり長く、"
"理解しづらいものです。\n"
"とりわけ言語に入門したてのプログラマはそうでしょう。\n"
"例えば前述した最後のREPLでの例でのエラー文言はかなり長く、\n"
"Idrisが試みたことそれぞれを、なぜ失敗したのかについての理由を混じえて一覧にし"
"ています。"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:341
msgid ""
"If this happens, it often means that a combination of a type error and an "
"ambiguity resulting from overloaded function names is at work. In the "
"example above, the two vectors are of distinct length, which leads to a type "
"error if we interpret the list literals as vectors. However, list literals "
"are overloaded to work with all data types with constructors `Nil` and "
"`(::)`, so Idris will now try other data constructors than those of `Vect` "
"(the ones of `List` and `Stream` from the *Prelude* in this case), each of "
"which will again fail with a type error since `zipWith` expects arguments of "
"type `Vect`, and neither `List` nor `Stream` will work."
msgstr ""
"こうなってしまうと、型エラーとオーバーロード関数由来の曖昧さのごった煮に手を"
"付けることになります。\n"
"上の例では2つのベクタは異なる長さであり、\n"
"そのためリスト表記をベクタとして見做すなら型エラーとなります。\n"
"しかしリスト表記はオーバーロードされており構築子`Nil`と`(::)`を持つ全てのデー"
"タ型に対して使えるため、\n"
"Idrisは`Vect`以外の他のデータ構築子を試し始めてしまうのです。\n"
"（今回の場合は*Prelude*にある`List`と`Stream`の構築子があたります。）\n"
"`zipWith`は型`Vect`の引数を期待しており、\n"
"`List`も`Stream`も当てはまらないため、\n"
"これらの構築子それぞれについても型エラーにより失敗します。"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:345
msgid ""
"If this happens, prefixing overloaded function names with their namespaces "
"can often simplify things, as Idris no longer needs to disambiguate these "
"functions:"
msgstr ""
"そんなときは名前空間をオーバーロードされた関数名に前置することで事態が簡単に"
"なることがよくあります。\n"
"Idrisがもはやこれらの関数の曖昧さを解消する必要がないからです。"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Dependent.md:346
#, no-wrap
msgid ""
"Tutorial.Dependent> zipWith (*) (Dependent.(::) 1 Dependent.Nil) Dependent.Nil\n"
"Error: When unifying:\n"
"    Vect 0 ?c\n"
"and:\n"
"    Vect 1 ?c\n"
"Mismatch between: 0 and 1.\n"
msgstr ""
"Tutorial.Dependent> zipWith (*) (Dependent.(::) 1 Dependent.Nil) Dependent.Nil\n"
"Error: When unifying:\n"
"    Vect 0 ?c\n"
"and:\n"
"    Vect 1 ?c\n"
"Mismatch between: 0 and 1.\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:360
msgid ""
"Here, the message is much clearer: Idris can't *unify* the lengths of the "
"two vectors. *Unification* means: Idris tries to at compile time convert two "
"expressions to the same normal form. If this succeeds, the two expressions "
"are considered to be equivalent, if it doesn't, Idris fails with a "
"unification error."
msgstr ""
"ほら、文言がぐっと明らかになりました。\n"
"Idrisは2つのベクタの長さを*統合*できていません。\n"
"*統合*とは、Idrisがコンパイル時に2つの式を同じ普遍的な形式に変換しようとする"
"ことです。\n"
"これが成功すれば2式は等価であると考えられ、\n"
"そうでない場合はIdrisは統合エラーにより失敗します。"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:363
msgid ""
"As an alternative to prefixing overloaded functions with their namespace, we "
"can use `the` to help with type inference:"
msgstr ""
"名前空間でオーバーロードされた関数を前置する代替として、\n"
"`the`を使って型推論の手助けができます。"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Dependent.md:364
#, no-wrap
msgid ""
"Tutorial.Dependent> zipWith (*) (the (Vect 3 _) [1,2,3]) (the (Vect 2 _) [10,20])\n"
"Error: When unifying:\n"
"    Vect 2 ?c\n"
"and:\n"
"    Vect 3 ?c\n"
"Mismatch between: 0 and 1.\n"
msgstr ""
"Tutorial.Dependent> zipWith (*) (the (Vect 3 _) [1,2,3]) (the (Vect 2 _) [10,20])\n"
"Error: When unifying:\n"
"    Vect 2 ?c\n"
"and:\n"
"    Vect 3 ?c\n"
"Mismatch between: 0 and 1.\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:379
msgid ""
"It is interesting to note, that the error above is not \"Mismatch between: 2 "
"and 3\" but \"Mismatch between: 0 and 1\" instead. Here's what's going on: "
"Idris tries to unify integer literals `2` and `3`, which are first converted "
"to the corresponding `Nat` values `S (S Z)` and `S (S (S Z))`, "
"respectively.  The two patterns match until we arrive at `Z` vs `S Z`, "
"corresponding to values `0` and `1`, which is the discrepancy reported in "
"the error message."
msgstr ""
"興味深いことに上のエラーは \"Mismatch between: 2 and 3\" ではなく、\n"
"\"Mismatch between: 0 and 1\" になっています。\n"
"その理由はこうです。\n"
"Idrisは整数表記`2`と`3`を統合しようとします。\n"
"これらの整数は最初に対応する`Nat`値`S (S Z)`と`S (S (S Z))`にそれぞれ変換され"
"ます。\n"
"2式は`Z`と`S Z`に行き着くまでパターン照合され、\n"
"これは値`0`と`1`に対応します。\n"
"これがエラー文言で不一致として報告されます。"

#. type: Title ###
#: ../src/Tutorial/Dependent.md:380
#, no-wrap
msgid "Creating Vectors"
msgstr "ベクタを作る"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:387
msgid ""
"So far, we were able to learn something about the lengths of vectors by "
"pattern matching on them. In the `Nil` case, it was clear that the length is "
"0, while in the *cons* case the length was the successor of another natural "
"number.  This is not possible when we want to create a new vector:"
msgstr ""
"これまでパターン照合することでベクタの長さについてのことを知ることができまし"
"た。\n"
"`Nil`の場合は長さがゼロであることが明らかで、\n"
"*cons*の場合は長さが後続する他の自然数の長さなのでした。\n"
"新しいベクタを作りたいときはそう簡単にはいきません。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:388
#, no-wrap
msgid ""
"failing \"Mismatch between: S ?n and n.\"\n"
"  fill : a -> Vect n a\n"
msgstr ""
"failing \"Mismatch between: S ?n and n.\"\n"
"  fill : a -> Vect n a\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:395
msgid ""
"You will have a hard time implementing `fill`. The following, for instance, "
"leads to a type error:"
msgstr ""
"`fill`を実装すると手詰まりになるでしょう。\n"
"例えば以下は型エラーになります。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:396
#, no-wrap
msgid "  fill va = [va,va]\n"
msgstr "  fill va = [va,va]\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:403
msgid ""
"The problem is, that *the callers of our function decide about the length of "
"the resulting vector*. The full type of `fill` is actually the following:"
msgstr ""
"問題は*関数の呼び出し手が結果のベクタの長さを決める*というところにありま"
"す。\n"
"`fill`の型全体は実は以下のようです。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:404
#, no-wrap
msgid "fill' : {0 a : Type} -> {0 n : Nat} -> a -> Vect n a\n"
msgstr "fill' : {0 a : Type} -> {0 n : Nat} -> a -> Vect n a\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:415
msgid ""
"You can read this type as follows: For every type `a` and for every natural "
"number `n` (about which I know *nothing* at runtime, since it has quantity "
"zero), given a value of type `a`, I'll give you a vector holding exactly `n` "
"elements of type `a`. This is like saying: \"Think about a natural number "
"`n`, and I'll give you `n` apples without you telling me the value of `n`"
"\".  Idris is powerful, but it is not a clairvoyant."
msgstr ""
"この型は以下のように読めます。\n"
"あらゆる型`a`とあらゆる自然数`n`（数量子ゼロなので実行時には*何にも*わかりま"
"せん）について、\n"
"型`a`の値が与えられたとき、ちょうど`n`個の型`a`の要素を保管するベクタを渡して"
"くれる、と。\n"
"これは次のように言うような感じです。\n"
"「自然数`n`について考えてください。\n"
"そしたら`n`の値を教えてくれなくても、`n`個のりんごをあげます。」\n"
"Idrisは強力ですが、透視能力者ではありません。"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:420
msgid ""
"In order to implement `fill`, we need to know what `n` actually is: We need "
"to pass `n` as an explicit, unerased argument, which will allow us to "
"pattern match on it and decide - based on this pattern match - which "
"constructors of `Vect` to use:"
msgstr ""
"`fill`を実装するには`n`が実際なんであるかを知る必要があります。\n"
"`n`を明示的で消去されない引数として渡さねばなりません。\n"
"そうすることでそれをパターン照合でき、\n"
"その結果に基づいてどちらの`Vect`の構築子を使うのかを決定するのです。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:421
#, no-wrap
msgid "replicate : (n : Nat) -> a -> Vect n a\n"
msgstr "replicate : (n : Nat) -> a -> Vect n a\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:428
#, fuzzy
#| msgid ""
#| "Now, `replicate` is a *dependent function type*: The output type "
#| "*depends* on the value of one the arguments. It is straight forward to "
#| "implement `replicate` by pattern matching on `n`:"
msgid ""
"Now, `replicate` is a *dependent function type*: The output type *depends* "
"on the value of one of the arguments. It is straight forward to implement "
"`replicate` by pattern matching on `n`:"
msgstr ""
"ここで`replicate`は*依存関数型*です。\n"
"出力型は引数中の1つの値に*依存*しています。\n"
"`replicate`を`n`についてのパターン照合により実装するのは直感的です。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:429
#, no-wrap
msgid ""
"replicate 0     _  = []\n"
"replicate (S k) va = va :: replicate k va\n"
msgstr ""
"replicate 0     _  = []\n"
"replicate (S k) va = va :: replicate k va\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:443
msgid ""
"This is a pattern that comes up often when working with indexed types: We "
"can learn about the values of the indices by pattern matching on the values "
"of the type family. However, in order to return a value of the type family "
"from a function, we need to either know the values of the indices at compile "
"time (see constants `ex1` or `ex3`, for instance), or we need to have access "
"to the values of the indices at runtime, in which case we can pattern match "
"on them and learn from this, which constructor(s) of the type family to use."
msgstr ""
"こうしたことは指標付き型に取り組む際によく思い浮かぶパターンです。\n"
"型族の値にパターン照合によって指標の値について知ることができます。\n"
"しかし関数から型族の値を返すためには、\n"
"コンパイル時に指標の値を知っているか（例えば定数`ex1`や`ex3`を見てくださ"
"い）、\n"
"または実行時に指標値にアクセスする必要があります。\n"
"後者の場合、指標値に対してパターン照合でき、型族のどの構築子を使うべきかがわ"
"かります。"

#. type: Bullet: '1. '
#: ../src/Tutorial/Dependent.md:447
msgid "Implement function `head` for non-empty vectors:"
msgstr "関数`head`を非空のベクタに実装してください。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:448
#, no-wrap
msgid "   head : Vect (S n) a -> a\n"
msgstr "   head : Vect (S n) a -> a\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:457
#, no-wrap
msgid ""
"   Note, how we can describe non-emptiness by using a *pattern*\n"
"   in the length of `Vect`. This rules out the `Nil` case, and we can\n"
"   return a value of type `a`, without having to wrap it in\n"
"   a `Maybe`! Make sure to add an `impossible` clause for the `Nil`\n"
"   case (although this is not strictly necessary here).\n"
msgstr ""
"   `Vect`の長さに*パターン*を使うことで非空性を表現できているところに注目してください。\n"
"   ここでは`Nil`の場合は排除されており、`Maybe`にくるむことなく型`a`の値を返せます！\n"
"   `Nil`の場合に`impossible`節を加えて確かめてみてください。\n"
"   （ただ、ここでは厳密には必要ありません。）\n"

#. type: Bullet: '2. '
#: ../src/Tutorial/Dependent.md:461
msgid ""
"Using `head` as a reference, declare and implement function `tail` for non-"
"empty vectors. The types should reflect that the output is exactly one "
"element shorter than the input."
msgstr ""
"`head`を参照しつつ、非空のベクタに対して関数`tail`を宣言し実装してくださ"
"い。\n"
"型では出力が入力よりちょうど1要素分短かくなることを反映してください。"

#. type: Bullet: '3. '
#: ../src/Tutorial/Dependent.md:464
msgid ""
"Implement `zipWith3`. If possible, try to doing so without looking at the "
"implementation of `zipWith`:"
msgstr ""
"`zipWith3`を実装してください。\n"
"もし可能であれば`zipWith`の実装を見ずにやってみてください。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:465
#, fuzzy, no-wrap
#| msgid "zipWithV : (a -> b -> c) -> Vect n a -> Vect n b -> Vect n c\n"
msgid "   zipWith3 : (a -> b -> c -> d) -> Vect n a -> Vect n b -> Vect n c -> Vect n d\n"
msgstr "zipWithV : (a -> b -> c) -> Vect n a -> Vect n b -> Vect n c\n"

#. type: Bullet: '4. '
#: ../src/Tutorial/Dependent.md:474
msgid ""
"Declare and implement a function `foldSemi` for accumulating the values "
"stored in a `List` through `Semigroup`s append operator (`(<+>)`).  (Make "
"sure to only use a `Semigroup` constraint, as opposed to a `Monoid` "
"constraint.)"
msgstr ""

#. type: Bullet: '5. '
#: ../src/Tutorial/Dependent.md:477
msgid ""
"Do the same as in Exercise 4, but for non-empty vectors. How does a vector's "
"non-emptiness affect the output type?"
msgstr ""

#. type: Bullet: '6. '
#: ../src/Tutorial/Dependent.md:482
msgid ""
"Given an initial value of type `a` and a function `a -> a`, we'd like to "
"generate `Vect`s of `a`s, the first value of which is `a`, the second value "
"being `f a`, the third being `f (f a)` and so on."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:485
#, no-wrap
msgid ""
"   For instance, if `a` is 1 and `f` is `(* 2)`, we'd like\n"
"   to get results similar to the following: `[1,2,4,8,16,...]`.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:489
#, no-wrap
msgid ""
"   Declare and implement function `iterate`, which should\n"
"   encapsulate this behavior. Get some inspiration from `replicate`\n"
"   if you don't know where to start.\n"
msgstr ""

#. type: Bullet: '7. '
#: ../src/Tutorial/Dependent.md:495
msgid ""
"Given an initial value of a state type `s` and a function `fun : s -> (s,"
"a)`, we'd like to generate `Vect`s of `a`s. Declare and implement function "
"`generate`, which should encapsulate this behavior. Make sure to use the "
"updated state in every new invocation of `fun`."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:498
#, fuzzy, no-wrap
#| msgid "   Here is an example how this should work in action:\n"
msgid ""
"   Here's an example how this can be used to generate the first\n"
"   `n` Fibonacci numbers:\n"
msgstr "   以下は実際に動かす例です。\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Dependent.md:499
#, no-wrap
msgid ""
"   generate 10 (\\(x,y) => let z = x + y in ((y,z),z)) (0,1)\n"
"   [1, 2, 3, 5, 8, 13, 21, 34, 55, 89]\n"
msgstr ""

#. type: Bullet: '8. '
#: ../src/Tutorial/Dependent.md:507
msgid ""
"Implement function `fromList`, which converts a list of values to a `Vect` "
"of the same length. Use holes if you get stuck:"
msgstr ""
"関数`fromList`を実装してください。\n"
"この関数は値のリストを同じ長さのベクタに変換します。\n"
"詰まったら穴開きを使ってください。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:508
#, no-wrap
msgid "   fromList : (as : List a) -> Vect (length as) a\n"
msgstr "   fromList : (as : List a) -> Vect (length as) a\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:515
#, no-wrap
msgid ""
"   Note how, in the type of `fromList`, we can *calculate* the\n"
"   length of the resulting vector by passing the list argument\n"
"   to function *length*.\n"
msgstr "   `fromList`の型で、リスト引数を関数*length*に渡すことで、結果のベクタの長さを*計算*できていることにご注目。\n"

#. type: Bullet: '9. '
#: ../src/Tutorial/Dependent.md:517
msgid "Consider the following declarations:"
msgstr "以下の宣言について考えてください。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:518
#, no-wrap
msgid ""
"   maybeSize : Maybe a -> Nat\n"
"\n"
"   fromMaybe : (m : Maybe a) -> Vect (maybeSize m) a\n"
msgstr ""
"   maybeSize : Maybe a -> Nat\n"
"\n"
"   fromMaybe : (m : Maybe a) -> Vect (maybeSize m) a\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:526
#, no-wrap
msgid ""
"   Choose a reasonable implementation for `maybeSize` and\n"
"   implement `fromMaybe` afterwards.\n"
msgstr ""
"   `maybeSize`の理に適った実装を選び、\n"
"   その後で`fromMaybe`を実装してください。\n"

#. type: Title ##
#: ../src/Tutorial/Dependent.md:527
#, no-wrap
msgid "`Fin`: Safe Indexing into Vectors"
msgstr "`Fin`: ベクタから安全に指標で引く"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:531
msgid ""
"Consider function `index`, which tries to extract a value from a `List` at "
"the given position:"
msgstr ""
"関数`index`を考えましょう。\n"
"この関数は`List`から所与の位置で値を抽出しようとします。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:532
#, no-wrap
msgid ""
"indexList : (pos : Nat) -> List a -> Maybe a\n"
"indexList _     []        = Nothing\n"
"indexList 0     (x :: _)  = Just x\n"
"indexList (S k) (_ :: xs) = indexList k xs\n"
msgstr ""
"indexList : (pos : Nat) -> List a -> Maybe a\n"
"indexList _     []        = Nothing\n"
"indexList 0     (x :: _)  = Just x\n"
"indexList (S k) (_ :: xs) = indexList k xs\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:553
msgid ""
"Now, here is a thing to consider when writing functions like `indexList`: Do "
"we want to express the possibility of failure in the output type, or do we "
"want to restrict the accepted arguments, so the function can no longer fail? "
"These are important design decisions, especially in larger applications.  "
"Returning a `Maybe` or `Either` from a function forces client code to "
"eventually deal with the `Nothing` or `Left` case, and until this happens, "
"all intermediary results will carry the `Maybe` or `Either` stain, which "
"will make it more cumbersome to run calculations with these intermediary "
"results.  On the other hand, restricting the values accepted as input will "
"complicate the argument types and will put the burden of input validation on "
"our functions' callers, (although, at compile time we can get help from "
"Idris, as we will see when we talk about auto implicits) while keeping the "
"output pure and clean."
msgstr ""
"さて、ここで`indexList`のような関数を書くときに考慮すべき点があります。\n"
"出力型で失敗する可能性を表現したものか、\n"
"もしくは関数が決して失敗しないように受け付ける引数を制限したものか、というこ"
"とです。\n"
"これは大切な設計時の決断であり、特に大きめのアプリケーションではそうです。\n"
"`Maybe`や`Either`を関数から返すと、\n"
"その関数を使う側のコードで結局`Nothing`や`Left`の場合に対処することになりま"
"す。\n"
"そして対処するまでは中間結果は`Maybe`や`Either`の手荷物を持ち回ることにな"
"り、\n"
"これらの中間結果を計算するのが億劫になっていきます。\n"
"他方で入力として受け付ける値を制限するのは、\n"
"引数の型を複雑にすることになり、\n"
"関数の呼び出し手に入力の検証という重荷を強いることになります。\n"
"（とはいえ、auto暗示子でお話しすることになりますが、コンパイル時にIdrisから助"
"けが得られます。）\n"
"出力は純粋で明快になるのですが。"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:558
msgid ""
"Languages without dependent types (like Haskell), can often only take the "
"route described above: To wrap the result in a `Maybe` or `Either`.  "
"However, in Idris we can often *refine* the input types to restrict the set "
"of accepted values, thus ruling out the possibility of failure."
msgstr ""
"依存型のない言語（例えばHaskell）は上の道筋のみをよく取ります。\n"
"つまり結果を`Maybe`や`Either`でくるむのです。\n"
"しかし、Idrisでは入力型を*洗練する*ことで受け付ける値の集合を制限でき、\n"
"したがって失敗の可能性を排除できるのです。"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:564
msgid ""
"Assume, as an example, we'd like to extract a value from a `Vect n a` at "
"(zero-based) index `k`. Surely, this can succeed if and only if `k` is a "
"natural number strictly smaller than the length `n` of the vector. Luckily, "
"we can express this precondition in an indexed type:"
msgstr ""
"例として、（ゼロ始まりの）索引`k`で`Vect n a`から値を抽出したいときを考えま"
"しょう。\n"
"当然これが成功するのは、`k`がベクタの長さ`n`より厳密に小さい自然数であるとき"
"に限ります。\n"
"幸運にもこの前提条件を指標付き型で表現できます。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:565
#, no-wrap
msgid ""
"data Fin : (n : Nat) -> Type where\n"
"  FZ : {0 n : Nat} -> Fin (S n)\n"
"  FS : (k : Fin n) -> Fin (S n)\n"
msgstr ""
"data Fin : (n : Nat) -> Type where\n"
"  FZ : {0 n : Nat} -> Fin (S n)\n"
"  FS : (k : Fin n) -> Fin (S n)\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:577
msgid ""
"`Fin n` is the type of natural numbers strictly smaller than `n`.  It is "
"defined inductively: `FZ` corresponds to natural number *zero*, which, as "
"can be seen in its type, is strictly smaller than `S n` for any natural "
"number `n`. `FS` is the inductive case: If `k` is strictly smaller than `n` "
"(`k` being of type `Fin n`), then `FS k` is strictly smaller than `S n`."
msgstr ""
"`Fin n`は`n`より厳密に小さい自然数の型で、\n"
"帰納的に定義されています。\n"
"`FZ`は自然数*ゼロ*に対応し、\n"
"型で見てとれるようにあらゆる自然数`n`に対して`S n`より厳密に小さいです。\n"
"`FS`は帰納的な場合です。\n"
"もし`k`が`n`より厳密に小さいなら（`k`は型が`Fin n`です）、\n"
"`FS k`は`S n`より厳密に小さいです。"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:579
msgid "Let's come up with some values of type `Fin`:"
msgstr "型`Fin`の値をいくつか挙げてみましょう。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:580
#, no-wrap
msgid ""
"fin0_5 : Fin 5\n"
"fin0_5 = FZ\n"
"\n"
"fin0_7 : Fin 7\n"
"fin0_7 = FZ\n"
"\n"
"fin1_3 : Fin 3\n"
"fin1_3 = FS FZ\n"
"\n"
"fin4_5 : Fin 5\n"
"fin4_5 = FS (FS (FS (FS FZ)))\n"
msgstr ""
"fin0_5 : Fin 5\n"
"fin0_5 = FZ\n"
"\n"
"fin0_7 : Fin 7\n"
"fin0_7 = FZ\n"
"\n"
"fin1_3 : Fin 3\n"
"fin1_3 = FS FZ\n"
"\n"
"fin4_5 : Fin 5\n"
"fin4_5 = FS (FS (FS (FS FZ)))\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:597
msgid ""
"Note, that there is no value of type `Fin 0`. We will learn in a later "
"session, how to express \"there is no value of type `x`\" in a type."
msgstr ""
"型`Fin 0`の値がないことにご注意を。\n"
"のちの節で、「型`x`に値が1つもない」ことを型中で表現する方法を学びます。"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:600
msgid ""
"Let us now check, whether we can use `Fin` to safely index into a `Vect`:"
msgstr ""
"`Fin`を使って`Vect`から安全に指標で引けるかどうかを確認してみましょう。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:601
#, no-wrap
msgid "index : Fin n -> Vect n a -> a\n"
msgstr "index : Fin n -> Vect n a -> a\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:607
msgid ""
"Before you continue, try to implement `index` yourself, making use of holes "
"if you get stuck."
msgstr ""
"読み進める前に自分で`index`を実装してみてください。\n"
"詰まったら穴開きを利用しましょう。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:608
#, no-wrap
msgid ""
"index FZ     (x :: _) = x\n"
"index (FS k) (_ :: xs) = index k xs\n"
msgstr ""
"index FZ     (x :: _) = x\n"
"index (FS k) (_ :: xs) = index k xs\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:617
msgid ""
"Note, how there is no `Nil` case and the totality checker is still happy. "
"That's because `Nil` is of type `Vect 0 a`, but there is no value of type "
"`Fin 0`! We can verify this by adding the missing impossible clauses:"
msgstr ""
"`Nil`の場合がなくても全域性検査器は満足していますね。\n"
"なぜかというと`Nil`は型が`Vect 0 a`ですが、型`Fin 0`が存在しないからです！\n"
"このことは欠けている不可能節を加えることで確かめられます。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:618
#, no-wrap
msgid ""
"index FZ     Nil impossible\n"
"index (FS _) Nil impossible\n"
msgstr ""
"index FZ     Nil impossible\n"
"index (FS _) Nil impossible\n"

#. type: Bullet: '1. '
#: ../src/Tutorial/Dependent.md:627
msgid ""
"Implement function `update`, which, given a function of type `a -> a`, "
"updates the value in a`Vect n a` at position `k < n`."
msgstr ""
"関数`update`を実装してください。\n"
"この関数は型`a -> a`の関数を受け取って`Vect n a`の位置`k < n`での値を更新しま"
"す。"

#. type: Bullet: '2. '
#: ../src/Tutorial/Dependent.md:631
msgid ""
"Implement function `insert`, which inserts a value of type `a` at position "
"`k <= n` in a `Vect n a`. Note, that `k` is the index of the freshly "
"inserted value, so that the following holds:"
msgstr ""
"関数`insert`を実装してください。\n"
"この関数は`Vect n a`の位置`k <= n`に型`a`の値を挿入します。\n"
"ここで`k`は新しく挿入された値の索引であり、なので以下が満たされます。"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Dependent.md:632
#, no-wrap
msgid "   index k (insert k v vs) = v\n"
msgstr "   index k (insert k v vs) = v\n"

#. type: Bullet: '3. '
#: ../src/Tutorial/Dependent.md:638
msgid ""
"Implement function `delete`, which deletes a value from a vector at the "
"given index."
msgstr ""
"関数`delete`を実装してください。\n"
"この関数はベクタから所与の索引のところで値を削除します。"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:641
#, no-wrap
msgid ""
"   This is trickier than Exercises 1 and 2, as we have to properly\n"
"   encode in the types that the vector is getting one element shorter.\n"
msgstr ""
"   これは演習1, 2よりも取っ付きにくいです。\n"
"   というのは、ベクタが1要素分短いことを適切に型に落とし込む必要があるからです。\n"

#. type: Bullet: '4. '
#: ../src/Tutorial/Dependent.md:644
msgid ""
"We can use `Fin` to implement safe indexing into `List`s as well. Try to "
"come up with a type and implementation for `safeIndexList`."
msgstr ""
"`Fin`があれば`List`も同様に安全に索引で引くように実装できます。\n"
"`safeIndexList`の型を思い浮かべて実装してください。"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:648
#, no-wrap
msgid ""
"   Note: If you don't know how to start, look at the type of `fromList`\n"
"   for some inspiration. You might also need give the arguments in\n"
"   a different order than for `index`.\n"
msgstr ""
"   注意：どこから手を付けたらよいかわからなかったら、\n"
"   `fromList`の型を見ると着想が得られるでしょう。\n"
"   また、`index`とは異なる順番で引数を与えなくてはならないでしょう。\n"

#. type: Bullet: '5. '
#: ../src/Tutorial/Dependent.md:653
msgid ""
"Implement function `finToNat`, which converts a `Fin n` to the corresponding "
"natural number, and use this to declare and implement function `take` for "
"splitting of the first `k` elements of a `Vect n a` with `k <= n`."
msgstr ""
"関数`finToNat`を実装してください。\n"
"この関数は`Fin n`を対応する自然数に変換します。\n"
"そして、これを使って関数`take`を宣言し実装してください。\n"
"`take`は`Vect n a`から最初の`k`個分の要素を切り出します。\n"
"なお`k <= n`です。"

#. type: Bullet: '6. '
#: ../src/Tutorial/Dependent.md:656
msgid ""
"Implement function `minus` for subtracting a value `k` from a natural number "
"`n` with `k <= n`."
msgstr ""
"自然数`n`から値`k`を差し引く関数`minus`を実装してください。\n"
"なお`k <= n`です。"

#. type: Bullet: '7. '
#: ../src/Tutorial/Dependent.md:660
msgid ""
"Use `minus` from Exercise 6 to declare and implement function `drop`, for "
"dropping the first `k` values from a `Vect n a`, with `k <= n`."
msgstr ""
"演習6の`minus`を使って、`Vect n a`から最初の`k`個分の値を切り落とす関数`drop`"
"を宣言し実装してください。\n"
"なお`k <= n`です。"

#. type: Bullet: '8. '
#: ../src/Tutorial/Dependent.md:664
msgid ""
"Implement function `splitAt` for splitting a `Vect n a` at position `k <= "
"n`, returning the prefix and suffix of the vector wrapped in a pair."
msgstr ""
"位置`k <= n`で`Vect n a`を切り分ける関数`splitAt`を実装してください。\n"
"この関数はベクタの前半部分と後半部分を対に包んで返します。"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:666
#, no-wrap
msgid "   Hint: Use `take` and `drop` in your implementation.\n"
msgstr "   解決の糸口：実装で`take`と`drop`を使ってください。\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:670
msgid ""
"Hint: Since `Fin n` consists of the values strictly smaller than `n`, `Fin "
"(S n)` consists of the values smaller than or equal to `n`."
msgstr ""
"解決の糸口：`Fin n`は`n`より厳密に小さい値からなります。\n"
"`Fin (S n)`は`n`以下の値からなります。"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:675
msgid ""
"Note: Functions `take`, `drop`, and `splitAt`, while correct and provably "
"total, are rather cumbersome to type.  There is an alternative way to "
"declare their types, as we will see in the next section."
msgstr ""
"附記：関数`take`, `drop`, `splitAt`は正確で全域性が証明されていますが、\n"
"それ以上に型付けるのが億劫です。\n"
"型を宣言する代わりの方法があるので、それを次の節で見ていきます。"

#. type: Title ##
#: ../src/Tutorial/Dependent.md:676
#, no-wrap
msgid "Compile-Time Computations"
msgstr "コンパイル時計算"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:683
msgid ""
"In the last section - especially in some of the exercises - we started more "
"and more to use compile time computations to describe the types of our "
"functions and values.  This is a very powerful concept, as it allows us to "
"compute output types from input types. Here's an example:"
msgstr ""
"先程の節、特にいくつかの演習では、関数や値の型を表現するために、ますますコン"
"パイル時計算を使い始めました。\n"
"これは大変強力な概念で、というのも入力型から出力型を計算できるからです。\n"
"以下は例です。"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:690
msgid ""
"It is possible to concatenate two `List`s with the `(++)` operator. Surely, "
"this should also be possible for `Vect`. But `Vect` is indexed by its "
"length, so we have to reflect in the types exactly how the lengths of the "
"inputs affect the lengths of the output. Here's how to do this:"
msgstr ""
"`(++)`演算子で2つの`List`を結合することができます。\n"
"もちろんこれは`Vect`についても可能です。\n"
"しかし`Vect`は長さで指標付けられているので、入力の長さがどのように出力の長さ"
"に影響しているのかを厳密に型に反映させなくてはなりません。\n"
"こちらがその方法です。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:691
#, no-wrap
msgid ""
"(++) : Vect m a -> Vect n a -> Vect (m + n) a\n"
"(++) []        ys = ys\n"
"(++) (x :: xs) ys = x :: (xs ++ ys)\n"
msgstr ""
"(++) : Vect m a -> Vect n a -> Vect (m + n) a\n"
"(++) []        ys = ys\n"
"(++) (x :: xs) ys = x :: (xs ++ ys)\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:700
msgid ""
"Note, how we keep track of the lengths at the type-level, again ruling out "
"certain common programming errors like inadvertently dropping some values."
msgstr ""
"型段階で長さを監視していますね。\n"
"ここでも手違いで値が欠落するようなよくあるプログラミングの誤りの類を排除しま"
"す。"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:705
msgid ""
"We can also use type-level computations as patterns on the input types. Here "
"is an alternative type and implementation for `drop`, which you implemented "
"in the exercises by using a `Fin n` argument:"
msgstr ""
"型段階計算を入力型でのパターンとして使うこともできます。\n"
"こちらは`drop`の別の型と実装です。\n"
"この関数は演習で`Fin n`引数を使って実装したのでした。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:706
#, no-wrap
msgid ""
"drop' : (m : Nat) -> Vect (m + n) a -> Vect n a\n"
"drop' 0     xs        = xs\n"
"drop' (S k) (_ :: xs) = drop' k xs\n"
msgstr ""
"drop' : (m : Nat) -> Vect (m + n) a -> Vect n a\n"
"drop' 0     xs        = xs\n"
"drop' (S k) (_ :: xs) = drop' k xs\n"

#. type: Title ###
#: ../src/Tutorial/Dependent.md:712
#, no-wrap
msgid "Limitations"
msgstr "制約"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:718
msgid ""
"After all the examples and exercises in this section you might have come to "
"the conclusion that we can use arbitrary expressions in the types and Idris "
"will happily evaluate and unify all of them for us."
msgstr ""
"本節の全ての例と演習を終えたあとでは、型で任意の式が使えて、Idrisが喜んですべ"
"て評価・一体化してくれるのだ、という結論に至るかもしれません。"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:724
msgid ""
"I'm afraid that's not even close to the truth. The examples in this section "
"were hand-picked because they are known to *just work*. The reason being, "
"that there was always a direct link between our own pattern matches and the "
"implementations of functions we used at compile time."
msgstr ""
"残念ですがそれは真実からはほど遠いものです。\n"
"本節の例は*ひとまず動く*ことが知られているような、選別されたものなのです。\n"
"その理由というのは、パターン照合とコンパイル時に使う関数の実装との間に常に直"
"接の繋がりがあるためです。"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:727
msgid ""
"For instance, here is the implementation of addition of natural numbers:"
msgstr "例えば、以下は自然数の加算の実装です。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:728
#, no-wrap
msgid ""
"add : Nat -> Nat -> Nat\n"
"add Z     n = n\n"
"add (S k) n = S $ add k n\n"
msgstr ""
"add : Nat -> Nat -> Nat\n"
"add Z     n = n\n"
"add (S k) n = S $ add k n\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:745
msgid ""
"As you can see, `add` is implemented via a pattern match on its *first* "
"argument, while the second argument is never inspected. Note, how this is "
"exactly how `(++)` for `Vect` is implemented: There, we also pattern match "
"on the first argument, returning the second unmodified in the `Nil` case, "
"and prepending the head to the result of appending the tail in the *cons* "
"case. Since there is a direct correspondence between the two pattern "
"matches, it is possible for Idris to unify `0 + n` with `n` in the `Nil` "
"case, and `(S k) + n` with `S (k + n)` in the *cons* case."
msgstr ""
"見てみると`add`は*最初の*引数でパターン照合して実装されており、\n"
"2つ目の引数は調べられていません。\n"
"これは`(++)`が`Vect`に実装されているのとちょうど同じですね。\n"
"最初の引数でパターン照合して、`Nil`の場合あ2つ目を変更せずに返し、\n"
"*cons*の場合は尾っぽをくっつけた結果に先頭を前置したものを返しているのでし"
"た。\n"
"ここで2つのパターン照合には直接合致するところがあるので、\n"
"Idrisは`Nil`の場合に`0 + n`と`n`を、*cons*の場合に`(S k) + n`と`S (k + n)`"
"を、それぞれ一体化できます。"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:748
msgid ""
"Here is a simple example, where Idris will not longer be convinced without "
"some help from us:"
msgstr "以下の素朴な例では、手助けなしには、Idrisはもはや納得してくれません。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:749
#, no-wrap
msgid ""
"failing \"Can't solve constraint\"\n"
"  reverse : Vect n a -> Vect n a\n"
"  reverse []        = []\n"
"  reverse (x :: xs) = reverse xs ++ [x]\n"
msgstr ""
"failing \"Can't solve constraint\"\n"
"  reverse : Vect n a -> Vect n a\n"
"  reverse []        = []\n"
"  reverse (x :: xs) = reverse xs ++ [x]\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:768
msgid ""
"When we type-check the above, Idris will fail with the following error "
"message: \"Can't solve constraint between: plus n 1 and S n.\" Here's what's "
"going on: From the pattern match on the left hand side, Idris knows that the "
"length of the vector is `S n`, for some natural number `n` corresponding to "
"the length of `xs`. The length of the vector on the right hand side is `n + "
"1`, according to the type of `(++)` and the lengths of `xs` and `[x]`. "
"Overloaded operator `(+)` is implemented via function `Prelude.plus`, that's "
"why Idris replaces `(+)` with `plus` in the error message."
msgstr ""
"上記を型検査すると、\n"
"Idrisは以下のエラー文言とともに失敗します。\n"
"\"Can't solve constraint between: plus n 1 and S n.\"\n"
"（訳註：制約を解決できません：plus n 1とS nとで差があります。）\n"
"何が起こっているのかというと、こうです。\n"
"左側のパターン照合から、Idrisはベクタの長さが`S n`であること、自然数`n`は`xs`"
"の長さに対応することがわかります。\n"
"`(++)`の型と`xs`の長さおよび`[x]`によると、右側のベクタの長さは`n + 1`で"
"す。\n"
"オーバーロードされた演算子`(+)`は関数`Prelude.plus`を介して実装されており、\n"
"そのためIdrisはエラー文言で`(+)`を`plus`に置き換えています。"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:780
msgid ""
"As you can see from the above, Idris can't verify on its own that `1 + n` is "
"the same thing as `n + 1`.  It can accept some help from us, though. If we "
"come up with a *proof* that the above equality holds (or - more generally - "
"that our implementation of addition for natural numbers is *commutative*), "
"we can use this proof to *rewrite* the types on the right hand side of "
"`reverse`. Writing proofs and using `rewrite` will require some in-depth "
"explanations and examples. Therefore, these things will have to wait until "
"another chapter."
msgstr ""
"上からわかるように、Idrisは自分では`1 + n`が`n + 1`と同じことを確かめられませ"
"ん。\n"
"手助けを受けることはできるんですけどね。\n"
"上の等式が満たされるという*証明*を思い付いたら（あるいはもっと一般化して、自"
"然数の加算の実装が*可換的*であれば）、\n"
"証明を`reverse`の右側の型を*書き換える*のに使うことができます。\n"
"証明を書いたり`rewrite`を使ったりするには詳細な説明と例が必要でしょう。\n"
"したがってこれらの話題は別の章まで待つことにします。"

#. type: Title ###
#: ../src/Tutorial/Dependent.md:781
#, no-wrap
msgid "Unrestricted Implicits"
msgstr "制約なし暗黙子"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:789
msgid ""
"In functions like `replicate`, we pass a natural number `n` as an explicit, "
"unrestricted argument from which we infer the length of the vector to "
"return.  In some circumstances, `n` can be inferred from the context.  For "
"instance, in the following example it is tedious to pass `n` explicitly:"
msgstr ""
"`replicate`のような関数では、自然数`n`を明示的で制約のない引数として渡しまし"
"たが、\n"
"これは返すベクタの長さから推論したものでした。\n"
"状況次第で`n`は文脈から推論できます。\n"
"例えば以下の例では`n`を明示的に渡すのは億劫です。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:790
#, no-wrap
msgid ""
"ex4 : Vect 3 Integer\n"
"ex4 = zipWith (*) (replicate 3 10) (replicate 3 11)\n"
msgstr ""
"ex4 : Vect 3 Integer\n"
"ex4 = zipWith (*) (replicate 3 10) (replicate 3 11)\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:797
msgid ""
"The value `n` is clearly derivable from the context, which can be confirmed "
"by replacing it with underscores:"
msgstr ""
"値`n`が文脈から導出できることは明らかで、下線文字で置き換えることでも確かめら"
"れます。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:798
#, no-wrap
msgid ""
"ex5 : Vect 3 Integer\n"
"ex5 = zipWith (*) (replicate _ 10) (replicate _ 11)\n"
msgstr ""
"ex5 : Vect 3 Integer\n"
"ex5 = zipWith (*) (replicate _ 10) (replicate _ 11)\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:806
msgid ""
"We therefore can implement an alternative version of `replicate`, where we "
"pass `n` as an implicit argument of *unrestricted* quantity:"
msgstr ""
"したがって`replicate`の代わりの版を実装でき、\n"
"*制約なし*数量子の暗黙引数として`n`を渡すようにできます。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:807
#, no-wrap
msgid ""
"replicate' : {n : _} -> a -> Vect n a\n"
"replicate' = replicate n\n"
msgstr ""
"replicate' : {n : _} -> a -> Vect n a\n"
"replicate' = replicate n\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:814
msgid ""
"Note how, in the implementation of `replicate'`, we can refer to `n` and "
"pass it as an explicit argument to `replicate`."
msgstr ""
"`replicate`の実装中で`n`を推論し、`replicate`の明示的な引数として渡せています"
"ね。"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:820
msgid ""
"Deciding whether to pass potentially inferable arguments to a function "
"implicitly or explicitly is a question of how often the arguments actually "
"*are* inferable by Idris. Sometimes it might even be useful to have both "
"verions of a function. Remember, however, that even in case of an implicit "
"argument we can still pass the value explicitly:"
msgstr ""
"関数へ潜在的に推論可能な引数を渡しているとき、それを暗黙的にすべきか明示的に"
"すべきか決定することとは、\n"
"その引数が実際どれほどIdrisによって推論されて*いる*のかということです。\n"
"その関数の両方の版があると便利なことさえあるでしょう。\n"
"ただし覚えておいてほしいのですが、暗黙引数の場合でも明示的に値を渡せることに"
"は変わりないのです。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:821
#, no-wrap
msgid ""
"ex6 : Vect ? Bool\n"
"ex6 = replicate' {n = 2} True\n"
msgstr ""
"ex6 : Vect ? Bool\n"
"ex6 = replicate' {n = 2} True\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:829
msgid ""
"In the type signature above, the question mark (`?`) means, that Idris "
"should try and figure out the value on its own by unification. This forces "
"us to specify `n` explicitly on the right hand side of `ex6`."
msgstr ""
"上の型処方中の疑問符 (`?`) は、\n"
"Idrisがどうにかして自分で一体化により値を見付けだせるだろうという意味です。\n"
"こうなると`ex6`の右側で明示的に`n`を指定することになります。"

#. type: Title ####
#: ../src/Tutorial/Dependent.md:830
#, no-wrap
msgid "Pattern Matching on Implicits"
msgstr "暗黙子に対するパターン照合"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:836
msgid ""
"The implementation of `replicate'` makes use of function `replicate`, where "
"we could pattern match on the explicit argument `n`. However, it is also "
"possible to pattern match on implicit, named arguments of non-zero quantity:"
msgstr ""
"`replicate'`の実装は関数`replicate`を使い、そこで明示引数`n`でのパターン照合"
"をしているのでした。\n"
"しかし、暗黙子、つまり非ゼロの数量子の名前付き引数でパターン照合することもで"
"きます。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:837
#, no-wrap
msgid ""
"replicate'' : {n : _} -> a -> Vect n a\n"
"replicate'' {n = Z}   _ = Nil\n"
"replicate'' {n = S _} v = v :: replicate'' v\n"
msgstr ""
"replicate'' : {n : _} -> a -> Vect n a\n"
"replicate'' {n = Z}   _ = Nil\n"
"replicate'' {n = S _} v = v :: replicate'' v\n"

#. type: Bullet: '1. '
#: ../src/Tutorial/Dependent.md:846
msgid "Here is a function declaration for flattening a `List` of `List`s:"
msgstr "以下は`List`の`List`を平坦にする関数の宣言です。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:847
#, no-wrap
msgid "   flattenList : List (List a) -> List a\n"
msgstr "   flattenList : List (List a) -> List a\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:853
#, no-wrap
msgid ""
"   Implement `flattenList` and declare and implement a similar\n"
"   function `flattenVect` for flattening vectors of vectors.\n"
msgstr "   `flattenList`を実装し、これと似たベクタのベクタを平坦にする関数`flattenVect`を宣言し実装してください。\n"

#. type: Bullet: '2. '
#: ../src/Tutorial/Dependent.md:857
msgid ""
"Implement functions `take'` and `splitAt'` like in the exercises of the "
"previous section but using the technique shown for `drop'`."
msgstr ""
"前の節の演習のように関数`take'`と`splitAt'`を実装してください。\n"
"ただし`drop'`で見た技法を使ってください。"

#. type: Bullet: '3. '
#: ../src/Tutorial/Dependent.md:861
msgid ""
"Implement function `transpose` for converting an `m x n`-matrix (represented "
"as a `Vect m (Vect n a)`)  to an `n x m`-matrix."
msgstr ""
"`m x n`行列（`Vect m (Vect n a)`として表されます）を`n x m`行列に変換する関数"
"`transpose`を実装してください。"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:864
#, no-wrap
msgid ""
"   Note: This might be a challenging exercise, but make sure\n"
"   to give it a try. As usual, make use of holes if you get stuck!\n"
msgstr ""
"   附記：これは発展的な演習かもしれませんが、\n"
"   ぜひ挑戦してみてください。\n"
"   いつも通り手詰まりになったら穴開きを活用しましょう！\n"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:866
#, no-wrap
msgid "   Here is an example how this should work in action:\n"
msgstr "   以下は実際に動かす例です。\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Dependent.md:867
#, no-wrap
msgid ""
"   Solutions.Dependent> transpose [[1,2,3],[4,5,6]]\n"
"   [[1, 4], [2, 5], [3, 6]]\n"
msgstr ""
"   Solutions.Dependent> transpose [[1,2,3],[4,5,6]]\n"
"   [[1, 4], [2, 5], [3, 6]]\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Dependent.md:878
msgid ""
"Dependent types allow us to calculate types from values.  This makes it "
"possible to encode properties of values at the type-level and verify these "
"properties at compile time."
msgstr ""
"依存型があれば型を値から計算できます。\n"
"この性質により値の性質を型段階に落とし込み、その性質をコンパイル時に検証でき"
"ます。"

#. type: Bullet: '* '
#: ../src/Tutorial/Dependent.md:882
msgid ""
"Length-indexed lists (vectors) let us rule out certain implementation "
"errors, by forcing us to be precise about the lengths of input and output "
"vectors."
msgstr ""
"長さで指標付けられたリスト（ベクタ）は、\n"
"入出力ベクタの長さを強制的に正確にすることにより、\n"
"特定の実装誤りを排除してくれます。"

#. type: Bullet: '* '
#: ../src/Tutorial/Dependent.md:886
msgid ""
"We can use patterns in type signatures, for instance to express that the "
"length of a vector is non-zero and therefore, the vector is non-empty."
msgstr ""
"型処方でパターンを使用でき、例えばベクタの長さが非ゼロなのでベクタが非空だと"
"いうことを表現できます。"

#. type: Bullet: '* '
#: ../src/Tutorial/Dependent.md:891
msgid ""
"When creating values of a type family, the values of the indices need to be "
"known at compile time, or they need to be passed as arguments to the "
"function creating the values, where we can pattern match on them to figure "
"out, which constructors to use."
msgstr ""
"型族の値をつくる場合、指標値はコンパイル時に既知であるか、値を作る関数に引数"
"として渡されていなくてはいけません。\n"
"関数は指標値でパターン照合してどの構築子を使うべきか調べられます。"

#. type: Bullet: '* '
#: ../src/Tutorial/Dependent.md:894
msgid ""
"We can use `Fin n`, the type of natural numbers strictly smaller than `n`, "
"to safely index into a vector of length `n`."
msgstr ""
"`n`より厳密に小さい自然数の型である`Fin n`を使って、安全に長さ`n`のベクタから"
"索引で引くことができます。"

#. type: Bullet: '* '
#: ../src/Tutorial/Dependent.md:899
msgid ""
"Sometimes, it is convenient to pass inferable arguments as non-erased "
"implicits, in which case we can still inspect them by pattern matching or "
"pass them to other functions, while Idris will try and fill in the values "
"for us."
msgstr ""
"時々推論できる引数を消去されない暗黙子として渡すと便利なことがあります。\n"
"このとき、Idrisはできる限り値を埋めてくれますが、\n"
"パターン照合したり他の関数に渡すこともできることには変わりありません。"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:903
msgid ""
"Note, that data type `Vect` together with many of the functions we "
"implemented here is available from module `Data.Vect` from the *base* "
"library. Likewise, `Fin` is available from `Data.Fin` from *base*."
msgstr ""
"データ型`Vect`とここで実装した大くの関数は*base*ライブラリのモジュール`Data."
"Vect`で使えます。\n"
"同様に`Fin`は*base*の`Data.Fin`で使えます。"

#. type: Plain text
#: ../src/Tutorial/Dependent.md:908
msgid ""
"In the [next section](IO.md), it is time to learn how to write effectful "
"programs and how to do this while still staying *pure*."
msgstr ""
"[次節](IO.md)では、そろそろ副作用のあるプログラムを*純粋*なまま書く方法につい"
"て学びましょう。"

#. type: Title #
#: ../src/Tutorial/Eq.md:1
#, no-wrap
msgid "Propositional Equality"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:9
msgid ""
"In the [last chapter](DPair.md) we learned, how dependent pairs and records "
"can be used to calculate *types* from values only known at runtime by "
"pattern matching on these values. We will now look at how we can describe "
"relations - or *contracts* - between values as types, and how we can use "
"values of these types as proofs that the contracts hold."
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:10
#, no-wrap
msgid ""
"module Tutorial.Eq\n"
"\n"
"import Data.Either\n"
"import Data.HList\n"
"import Data.Vect\n"
"import Data.String\n"
"\n"
"%default total\n"
msgstr ""

#. type: Title ##
#: ../src/Tutorial/Eq.md:21
#, no-wrap
msgid "Equality as a Type"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:26
msgid ""
"Imagine, we'd like to concatenate the contents of two CSV files, both of "
"which we stored on disk as tables together with their schemata as shown in "
"our discussion about dependent pairs:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:27
#, no-wrap
msgid ""
"data ColType = I64 | Str | Boolean | Float\n"
"\n"
"Schema : Type\n"
"Schema = List ColType\n"
"\n"
"IdrisType : ColType -> Type\n"
"IdrisType I64     = Int64\n"
"IdrisType Str     = String\n"
"IdrisType Boolean = Bool\n"
"IdrisType Float   = Double\n"
"\n"
"Row : Schema -> Type\n"
"Row = HList . map IdrisType\n"
"\n"
"record Table where\n"
"  constructor MkTable\n"
"  schema : Schema\n"
"  size   : Nat\n"
"  rows   : Vect size (Row schema)\n"
"\n"
"concatTables1 : Table -> Table -> Maybe Table\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:55
msgid ""
"We will not be able to implement `concatTables` by appending the two row "
"vectors, unless we can somehow verify that the two schemata are identical. "
"\"Well,\" I hear you say, \"that shouldn't be a big issue! Just implement "
"`Eq` for `ColType`\". Let's give this a try:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:56
#, no-wrap
msgid ""
"Eq ColType where\n"
"  I64     == I64     = True\n"
"  Str     == Str     = True\n"
"  Boolean == Boolean = True\n"
"  Float   == Float   = True\n"
"  _       == _       = False\n"
"\n"
"concatTables1 (MkTable s1 m rs1) (MkTable s2 n rs2) = case s1 == s2 of\n"
"  True  => ?what_now\n"
"  False => Nothing\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:73
msgid ""
"Somehow, this doesn't seem to work. If we inspect the context of hole "
"`what_now`, Idris still thinks that `s1` and `s2` are different, and if we "
"go ahead and invoke `Vect.(++)` anyway in the `True` case, Idris will "
"respond with a type error."
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Eq.md:74
#, no-wrap
msgid ""
"Tutorial.Relations> :t what_now\n"
"   m : Nat\n"
"   s1 : List ColType\n"
"   rs1 : Vect m (HList (map IdrisType s1))\n"
"   n : Nat\n"
"   s2 : List ColType\n"
"   rs2 : Vect n (HList (map IdrisType s2))\n"
"------------------------------\n"
"what_now : Maybe Table\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:92
msgid ""
"The problem is, that there is no reason for Idris to unify the two values, "
"even though `(==)` returned `True` because the result of `(==)` holds no "
"other information than the type being a `Bool`. *We* think, if this is "
"`True` the two values should be identical, but Idris is not convinced. In "
"fact, the following implementation of `Eq ColType` would be perfectly fine "
"as far as the type checker is concerned:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Eq.md:93
#, no-wrap
msgid ""
"Eq ColType where\n"
"  _       == _       = True\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:106
msgid ""
"So Idris is right in not trusting us. You might expect it to inspect the "
"implementation of `(==)` and figure out on its own, what the `True` result "
"means, but this is not how these things work in general, because most of the "
"time the number of computational paths to check would be far too large.  As "
"a consequence, Idris is able to evaluate functions during unification, but "
"it will not trace back information about function arguments from a "
"function's result for us. We can do so manually, however, as we will see "
"later."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Eq.md:107
#, no-wrap
msgid "A Type for equal Schemata"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:114
msgid ""
"The problem described above is similar to what we saw when we talked about "
"the benefit of [singleton types](DPair.md#erased-existentials): The types "
"are not precise enough. What we are going to do now, is something we'll "
"repeat time again for different use cases: We encode a contract between "
"values in an indexed data type:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:115
#, no-wrap
msgid ""
"data SameSchema : (s1 : Schema) -> (s2 : Schema) -> Type where\n"
"  Same : SameSchema s s\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:124
msgid ""
"First, note how `SameSchema` is a family of types indexed over two values of "
"type `Schema`. But note also that the sole constructor restricts the values "
"we allow for `s1` and `s2`: The two indices *must* be identical."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:128
msgid ""
"Why is this useful? Well, imagine we had a function for checking the "
"equality of two schemata, which would try and return a value of type "
"`SameSchema s1 s2`:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:129
#, no-wrap
msgid "sameSchema : (s1, s2 : Schema) -> Maybe (SameSchema s1 s2)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:134
msgid "We could then use this function to implement `concatTables`:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:135
#, no-wrap
msgid ""
"concatTables : Table -> Table -> Maybe Table\n"
"concatTables (MkTable s1 m rs1) (MkTable s2 n rs2) = case sameSchema s1 s2 of\n"
"  Just Same => Just $ MkTable s1 _ (rs1 ++ rs2)\n"
"  Nothing   => Nothing\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:143
msgid ""
"It worked! What's going on here? Well, let's inspect the types involved:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:144
#, no-wrap
msgid ""
"concatTables2 : Table -> Table -> Maybe Table\n"
"concatTables2 (MkTable s1 m rs1) (MkTable s2 n rs2) = case sameSchema s1 s2 of\n"
"  Just Same => ?almost_there\n"
"  Nothing   => Nothing\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:152
msgid "At the REPL, we get the following context for `almost_there`:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Eq.md:153
#, no-wrap
msgid ""
"Tutorial.Relations> :t almost_there\n"
"   m : Nat\n"
"   s2 : List ColType\n"
"   rs1 : Vect m (HList (map IdrisType s2))\n"
"   n : Nat\n"
"   rs2 : Vect n (HList (map IdrisType s2))\n"
"   s1 : List ColType\n"
"------------------------------\n"
"almost_there : Maybe Table\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:168
msgid ""
"See, how the types of `rs1` and `rs2` unify? Value `Same`, coming as the "
"result of `sameSchema s1 s2`, is a *witness* that `s1` and `s2` are actually "
"identical, because this is what we specified in the definition of `Same`."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:172
msgid ""
"All that remains to do is to implement `sameSchema`. For this, we will write "
"another data type for specifying when two values of type `ColType` are "
"identical:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:173
#, no-wrap
msgid ""
"data SameColType : (c1, c2 : ColType) -> Type where\n"
"  SameCT : SameColType c1 c1\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:180
msgid ""
"We can now define several utility functions. First, one for figuring out if "
"two column types are identical:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:181
#, no-wrap
msgid ""
"sameColType : (c1, c2 : ColType) -> Maybe (SameColType c1 c2)\n"
"sameColType I64     I64     = Just SameCT\n"
"sameColType Str     Str     = Just SameCT\n"
"sameColType Boolean Boolean = Just SameCT\n"
"sameColType Float   Float   = Just SameCT\n"
"sameColType _ _             = Nothing\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:195
msgid ""
"This will convince Idris, because in each pattern match, the return type "
"will be adjusted according to the values we matched on. For instance, on the "
"first line, the output type is `Maybe (SameColType I64 I64)` as you can "
"easily verify yourself by inserting a hole and checking its type at the REPL."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:203
msgid ""
"We will need two additional utilities: Functions for creating values of type "
"`SameSchema` for the nil and cons cases. Please note, how the "
"implementations are trivial. Still, we often have to quickly write such "
"small proofs (I'll explain in the next section, why I call them *proofs*), "
"which will then be used to convince the type checker about some fact we "
"already take for granted but Idris does not."
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:204
#, no-wrap
msgid ""
"sameNil : SameSchema [] []\n"
"sameNil = Same\n"
"\n"
"sameCons :  SameColType c1 c2\n"
"         -> SameSchema s1 s2\n"
"         -> SameSchema (c1 :: s1) (c2 :: s2)\n"
"sameCons SameCT Same = Same\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:221
msgid ""
"As usual, it can help understanding what's going on by replacing the right "
"hand side of `sameCons` with a hole an check out its type and context at the "
"REPL. The presence of values `SameCT` and `Same` on the left hand side "
"forces Idris to unify `c1` and `c2` as well as `s1` and `s2`, from which the "
"unification of `c1 :: s1` and `c2 :: s2` immediately follows.  With these, "
"we can finally implement `sameSchema`:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:222
#, no-wrap
msgid ""
"sameSchema []        []        = Just sameNil\n"
"sameSchema (x :: xs) (y :: ys) =\n"
"  [| sameCons (sameColType x y) (sameSchema xs ys) |]\n"
"sameSchema (x :: xs) []        = Nothing\n"
"sameSchema []        (x :: xs) = Nothing\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:238
msgid ""
"What we described here is a far stronger form of equality than what is "
"provided by interface `Eq` and the `(==)` operator: Equality of values that "
"is accepted by the type checker when trying to unify type level indices.  "
"This is also called *propositional equality*: We will see below, that we can "
"view types as mathematical *propositions*, and values of these types a "
"*proofs* that these propositions hold."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Eq.md:239
#, no-wrap
msgid "Type `Equal`"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:251
msgid ""
"Propositional equality is such a fundamental concept, that the *Prelude* "
"exports a general data type for this already: `Equal`, with its only data "
"constructor `Refl`. In addition, there is a built-in operator for expressing "
"propositional equality, which gets desugared to `Equal`: `(=)`. This can "
"sometimes lead to some confusion, because the equals symbol is also used for "
"*definitional equality*: Describing in function implementations that the "
"left-hand side and right-hand side are defined to be equal. If you want to "
"disambiguate propositional from definitional equality, you can also use "
"operator `(===)` for the former."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:253
msgid "Here is another implementation of `concatTables`:"
msgstr "考えられる実装はこちらです。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:254
#, no-wrap
msgid ""
"eqColType : (c1,c2 : ColType) -> Maybe (c1 = c2)\n"
"eqColType I64     I64     = Just Refl\n"
"eqColType Str     Str     = Just Refl\n"
"eqColType Boolean Boolean = Just Refl\n"
"eqColType Float   Float   = Just Refl\n"
"eqColType _ _             = Nothing\n"
"\n"
"eqCons :  {0 c1,c2 : a}\n"
"       -> {0 s1,s2 : List a}\n"
"       -> c1 = c2 -> s1 = s2 ->  c1 :: s1 = c2 :: s2\n"
"eqCons Refl Refl = Refl\n"
"\n"
"eqSchema : (s1,s2 : Schema) -> Maybe (s1 = s2)\n"
"eqSchema []        []        = Just Refl\n"
"eqSchema (x :: xs) (y :: ys) = [| eqCons (eqColType x y) (eqSchema xs ys) |]\n"
"eqSchema (x :: xs) []        = Nothing\n"
"eqSchema []        (x :: xs) = Nothing\n"
"\n"
"concatTables3 : Table -> Table -> Maybe Table\n"
"concatTables3 (MkTable s1 m rs1) (MkTable s2 n rs2) = case eqSchema s1 s2 of\n"
"  Just Refl => Just $ MkTable _ _ (rs1 ++ rs2)\n"
"  Nothing   => Nothing\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:285
msgid ""
"In the following exercises, you are going to implement some very basic "
"properties of equality proofs. You'll have to come up with the types of the "
"functions yourself, as the implementations will be incredibly simple."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:289
msgid ""
"Note: If you can't remember what the terms \"reflexive\", \"symmetric\", and "
"\"transitive\" mean, quickly read about equivalence relations [here](https://"
"en.wikipedia.org/wiki/Equivalence_relation)."
msgstr ""

#. type: Bullet: '1. '
#: ../src/Tutorial/Eq.md:291
msgid "Show that `SameColType` is a reflexive relation."
msgstr ""

#. type: Bullet: '2. '
#: ../src/Tutorial/Eq.md:293
msgid "Show that `SameColType` is a symmetric relation."
msgstr ""

#. type: Bullet: '3. '
#: ../src/Tutorial/Eq.md:295
msgid "Show that `SameColType` is a transitive relation."
msgstr ""

#. type: Bullet: '4. '
#: ../src/Tutorial/Eq.md:299
msgid ""
"Let `f` be a function of type `ColType -> a` for an arbitrary type `a`. Show "
"that from a value of type `SameColType c1 c2` follows that `f c1` and `f c2` "
"are equal."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:303
msgid ""
"For `(=)` the above properties are available from the *Prelude* as functions "
"`sym`, `trans`, and `cong`. Reflexivity comes from the data constructor "
"`Refl` itself."
msgstr ""

#. type: Bullet: '5. '
#: ../src/Tutorial/Eq.md:307
msgid ""
"Implement a function for verifying that two natural numbers are identical. "
"Try using `cong` in your implementation."
msgstr ""

#. type: Bullet: '6. '
#: ../src/Tutorial/Eq.md:310
msgid ""
"Use the function from exercise 5 for zipping two `Table`s if they have the "
"same number of rows."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:315
#, no-wrap
msgid ""
"   Hint: Use `Vect.zipWith`. You will need to implement\n"
"   custom function `appRows` for this, since Idris will\n"
"   not automatically figure out that the types unify when\n"
"   using `HList.(++)`:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:316
#, no-wrap
msgid "   appRows : {ts1 : _} -> Row ts1 -> Row ts2 -> Row (ts1 ++ ts2)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:323
msgid ""
"We will later learn how to use *rewrite rules* to circumvent the need of "
"writing custom functions like `appRows` and use `(++)` in `zipWith` directly."
msgstr ""

#. type: Title ##
#: ../src/Tutorial/Eq.md:324
#, no-wrap
msgid "Programs as Proofs"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:333
msgid ""
"A famous observation by mathematician *Haskell Curry* and logician *William "
"Alvin Howard* leads to the conclusion, that we can view a *type* in a "
"programming language with a sufficiently rich type system as a mathematical "
"proposition and a total program calculating a *value* of this type as a "
"proof that the proposition holds. This is also known as the [Curry-Howard "
"isomorphism](https://en.wikipedia.org/wiki/Curry"
"%E2%80%93Howard_correspondence)."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:336
msgid "For instance, here is a simple proof that one plus one equals two:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:337
#, no-wrap
msgid ""
"onePlusOne : the Nat 1 + 1 = 2\n"
"onePlusOne = Refl\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:346
msgid ""
"The above proof is trivial, as Idris solves this by unification.  But we "
"already stated some more interesting things in the exercises. For instance, "
"the symmetry and transitivity of `SameColType`:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:347
#, no-wrap
msgid ""
"sctSymmetric : SameColType c1 c2 -> SameColType c2 c1\n"
"sctSymmetric SameCT = SameCT\n"
"\n"
"sctTransitive : SameColType c1 c2 -> SameColType c2 c3 -> SameColType c1 c3\n"
"sctTransitive SameCT SameCT = SameCT\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:357
msgid ""
"Note, that a type alone is not a proof. For instance, we are free to state "
"that one plus one equals three:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:358
#, no-wrap
msgid "onePlusOneWrong : the Nat 1 + 1 = 3\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:365
msgid ""
"We will, however, have a hard time implementing this in a provably total "
"way. We say: \"The type `the Nat 1 + 1 = 3` is *uninhabited*\", meaning, "
"that there is no value of this type."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Eq.md:366
#, no-wrap
msgid "When Proofs replace Tests"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:373
msgid ""
"We will see several different use cases for compile time proofs, a very "
"straight forward one being to show that our functions behave as they should "
"by proofing some properties about them. For instance, here is a proposition "
"that `map` on list does not change the number of elements in the list:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:374
#, no-wrap
msgid "mapListLength : (f : a -> b) -> (as : List a) -> length as = length (map f as)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:381
msgid ""
"Read this as a universally quantified statement: For all functions `f` from "
"`a` to `b` and for all lists `as` holding values of type `a`, the length of "
"`map f as` is the same the as the length of the original list."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:387
msgid ""
"We can implement `mapListLength` by pattern matching on `as`. The `Nil` case "
"will be trivial: Idris solves this by unification. It knows the value of the "
"input list (`Nil`), and since `map` is implemented by pattern matching on "
"the input as well, it follows immediately that the result will be `Nil` as "
"well:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:388
#, no-wrap
msgid "mapListLength f []        = Refl\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:395
msgid ""
"The `cons` case is more involved, and we will do this stepwise.  First, note "
"that we can proof that the length of a map over the tail will stay the same "
"by means of recursion:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Eq.md:397
#, no-wrap
msgid ""
"mapListLength f (x :: xs) = case mapListLength f xs of\n"
"  prf => ?mll1\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:403
msgid "Let's inspect the types and context we have here:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Eq.md:404
#, no-wrap
msgid ""
" 0 b : Type\n"
" 0 a : Type\n"
"   xs : List a\n"
"   f : a -> b\n"
"   x : a\n"
"   prf : length xs = length (map f xs)\n"
"------------------------------\n"
"mll1 : S (length xs) = S (length (map f xs))\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:422
msgid ""
"So, we have a proof of type `length xs = length (map f xs)`, and from the "
"implementation of `map` Idris concludes that what we are actually looking "
"for is a result of type `S (length xs) = S (length (map f xs))`. This is "
"exactly what function `cong` from the *Prelude* is for (\"cong\" is an "
"abbreviation for *congruence*). We can thus implement the *cons* case "
"concisely like so:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:423
#, no-wrap
msgid "mapListLength f (x :: xs) = cong S $ mapListLength f xs\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:431
msgid ""
"Please take a moment to appreciate what we achieved here: A *proof* in the "
"mathematical sense that our function will not affect the length of our list. "
"We no longer need a unit test or similar program to verify this."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:435
msgid ""
"Before we continue, please note an important thing: In our case expression, "
"we used a *variable* for the result from the recursive call:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Eq.md:436
#, no-wrap
msgid ""
"mapListLength f (x :: xs) = case mapListLength f xs of\n"
"  prf => cong S prf\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:448
msgid ""
"Here, we did not want the two lengths to unify, because we needed the "
"distinction in our call to `cong`. Therefore: If you need a proof of type `x "
"= y` in order for two variables to unify, use the `Refl` data constructor in "
"the pattern match.  If, on the other hand, you need to run further "
"computations on such a proof, use a variable and the left and right-hand "
"sides will remain distinct."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:453
msgid ""
"Here is another example from the last chapter: We want to show that parsing "
"and printing column types behaves correctly.  Writing proofs about parsers "
"can be very hard in general, but here it can be done with a mere pattern "
"match:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:454
#, no-wrap
msgid ""
"showColType : ColType -> String\n"
"showColType I64      = \"i64\"\n"
"showColType Str      = \"str\"\n"
"showColType Boolean  = \"boolean\"\n"
"showColType Float    = \"float\"\n"
"\n"
"readColType : String -> Maybe ColType\n"
"readColType \"i64\"      = Just I64\n"
"readColType \"str\"      = Just Str\n"
"readColType \"boolean\"  = Just Boolean\n"
"readColType \"float\"    = Just Float\n"
"readColType s          = Nothing\n"
"\n"
"showReadColType : (c : ColType) -> readColType (showColType c) = Just c\n"
"showReadColType I64     = Refl\n"
"showReadColType Str     = Refl\n"
"showReadColType Boolean = Refl\n"
"showReadColType Float   = Refl\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:477
msgid ""
"Such simple proofs give us quick but strong guarantees that we did not make "
"any stupid mistakes."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:485
msgid ""
"The examples we saw so far were very easy to implement. In general, this is "
"not the case, and we will have to learn about several additional techniques "
"in order to proof interesting things about our programs. However, when we "
"use Idris as a general purpose programming language and not as a proof "
"assistant, we are free to choose whether some aspect of our code needs such "
"strong guarantees or not."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Eq.md:486
#, no-wrap
msgid "A Note of Caution: Lowercase Identifiers in Function Types"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:494
msgid ""
"When writing down the types of proofs as we did above, one has to be very "
"careful not to fall into the following trap: In general, Idris will treat "
"lowercase identifiers in function types as type parameters (erased implicit "
"arguments).  For instance, here is a try at proofing the identity functor "
"law for `Maybe`:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:495
#, no-wrap
msgid ""
"mapMaybeId1 : (ma : Maybe a) -> map id ma = ma\n"
"mapMaybeId1 Nothing  = Refl\n"
"mapMaybeId1 (Just x) = ?mapMaybeId1_rhs\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:504
msgid ""
"You will not be able to implement the `Just` case, because Idris treats `id` "
"as an implicit argument as can easily be seen when inspecting the context of "
"`mapMaybeId1_rhs`:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Eq.md:505
#, no-wrap
msgid ""
"Tutorial.Relations> :t mapMaybeId1_rhs\n"
" 0 a : Type\n"
" 0 id : a -> a\n"
"   x : a\n"
"------------------------------\n"
"mapMaybeId1_rhs : Just (id x) = Just x\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:517
#, no-wrap
msgid ""
"As you can see, `id` is an erased argument of type `a -> a`. And in\n"
"fact, when type-checking this module, Idris will issue a warning that\n"
"parameter `id` is shadowing an existing function:\n"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Eq.md:518
#, no-wrap
msgid ""
"Warning: We are about to implicitly bind the following lowercase names.\n"
"You may be unintentionally shadowing the associated global definitions:\n"
"  id is shadowing Prelude.Basics.id\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:527
msgid ""
"The same is not true for `map`: Since we explicitly pass arguments to `map`, "
"Idris treats this as a function name and not as an implicit argument."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:530
msgid ""
"You have several options here. For instance, you could use an uppercase "
"identifier, as these will never be treated as implicit arguments:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:531
#, no-wrap
msgid ""
"Id : a -> a\n"
"Id = id\n"
"\n"
"mapMaybeId2 : (ma : Maybe a) -> map Id ma = ma\n"
"mapMaybeId2 Nothing  = Refl\n"
"mapMaybeId2 (Just x) = Refl\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:543
msgid ""
"As an alternative - and this is the preferred way to handle this case - you "
"can prefix `id` with part of its namespace, which will immediately resolve "
"the issue:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:544
#, no-wrap
msgid ""
"mapMaybeId : (ma : Maybe a) -> map Prelude.id ma = ma\n"
"mapMaybeId Nothing  = Refl\n"
"mapMaybeId (Just x) = Refl\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:554
msgid ""
"Note: If you have semantic highlighting turned on in your editor (for "
"instance, by using the [idris2-lsp plugin](https://github.com/idris-"
"community/idris2-lsp)), you will note that `map` and `id` in `mapMaybeId1` "
"get highlighted differently: `map` as a function name, `id` as a bound "
"variable."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:562
msgid ""
"In these exercises, you are going to proof several simple properties of "
"small functions. When writing proofs, it is even more important to use holes "
"to figure out what Idris expects from you next. Use the tools given to you, "
"instead of trying to find your way in the dark!"
msgstr ""

#. type: Bullet: '1. '
#: ../src/Tutorial/Eq.md:564
msgid "Proof that `map id` on an `Either e` returns the value unmodified."
msgstr ""

#. type: Bullet: '2. '
#: ../src/Tutorial/Eq.md:566
msgid "Proof that `map id` on a list returns the list unmodified."
msgstr ""

#. type: Bullet: '3. '
#: ../src/Tutorial/Eq.md:570
msgid ""
"Proof that complementing a strand of a nucleobase (see the [previous chapter]"
"(DPair.md#use-case-nucleic-acids))  twice leads to the original strand."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:574
#, no-wrap
msgid ""
"   Hint: Proof this for single bases first, and use `cong2`\n"
"   from the *Prelude* in your implementation for sequences\n"
"   of nucleic acids.\n"
msgstr ""

#. type: Bullet: '4. '
#: ../src/Tutorial/Eq.md:576
msgid "Implement function `replaceVect`:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:577
#, no-wrap
msgid "   replaceVect : (ix : Fin n) -> a -> Vect n a -> Vect n a\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:584
#, no-wrap
msgid ""
"   Now proof, that after replacing an element in a vector\n"
"   using `replaceAt` accessing the same element using\n"
"   `index` will return the value we just added.\n"
msgstr ""

#. type: Bullet: '5. '
#: ../src/Tutorial/Eq.md:586
msgid "Implement function `insertVect`:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:587
#, no-wrap
msgid "   insertVect : (ix : Fin (S n)) -> a -> Vect n a -> Vect (S n) a\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:593
#, no-wrap
msgid ""
"   Use a similar proof as in exercise 4 to show that this\n"
"   behaves correctly.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:596
msgid ""
"Note: Functions `replaceVect` and `insertVect` are available from `Data."
"Vect` as `replaceAt` and `insertAt`."
msgstr ""

#. type: Title ##
#: ../src/Tutorial/Eq.md:597
#, no-wrap
msgid "Into the Void"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:612
msgid ""
"Remember function `onePlusOneWrong` from above? This was definitely a wrong "
"statement: One plus one does not equal three. Sometimes, we want to express "
"exactly this: That a certain statement is false and does not hold. Consider "
"for a moment what it means to proof a statement in Idris: Such a statement "
"(or proposition) is a type, and a proof of the statement is a value or "
"expression of this type: The type is said to be *inhabited*.  If a statement "
"is not true, there can be no value of the given type. We say, the given type "
"is *uninhabited*.  If we still manage to get our hands on a value of an "
"uninhabited type, that is a logical contradiction and from this, anything "
"follows (remember [ex falso quodlibet](https://en.wikipedia.org/wiki/"
"Principle_of_explosion))."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:617
msgid ""
"So this is how to express that a proposition does not hold: We state that if "
"it *would* hold, this would lead to a contradiction.  The most natural way "
"to express a contradiction in Idris is to return a value of type `Void`:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:618
#, no-wrap
msgid ""
"onePlusOneWrongProvably : the Nat 1 + 1 = 3 -> Void\n"
"onePlusOneWrongProvably Refl impossible\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:628
msgid ""
"See how this is a provably total implementation of the given type: A "
"function from `1 + 1 = 3` to `Void`. We implement this by pattern matching, "
"and there is only one constructor to match on, which leads to an impossible "
"case."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:633
msgid ""
"We can also use contradictory statements to proof other such statements. For "
"instance, here is a proof that if the lengths of two lists are not the same, "
"then the two list can't be the same either:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:634
#, no-wrap
msgid ""
"notSameLength1 : (List.length as = length bs -> Void) -> as = bs -> Void\n"
"notSameLength1 f prf = f (cong length prf)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:642
msgid ""
"This is cumbersome to write and pretty hard to read, so there is function "
"`Not` in the prelude to express the same thing more naturally:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:643
#, no-wrap
msgid ""
"notSameLength : Not (List.length as = length bs) -> Not (as = bs)\n"
"notSameLength f prf = f (cong length prf)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:651
msgid ""
"Actually, this is just a specialized version of the contraposition of "
"`cong`: If from `a = b` follows `f a = f b`, then from `not (f a = f b)` "
"follows `not (a = b)`:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:652
#, no-wrap
msgid ""
"contraCong : {0 f : _} -> Not (f a = f b) -> Not (a = b)\n"
"contraCong fun = fun . cong f\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Eq.md:657
#, no-wrap
msgid "Interface `Uninhabited`"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:664
msgid ""
"There is an interface in the *Prelude* for uninhabited types: `Uninhabited` "
"with its sole function `uninhabited`. Have a look at its documentation at "
"the REPL. You will see, that there is already an impressive number of "
"implementations available, many of which involve data type `Equal`."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:667
msgid ""
"We can use `Uninhabited`, to for instance express that the empty schema is "
"not equal to a non-empty schema:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:668
#, no-wrap
msgid ""
"Uninhabited (SameSchema [] (h :: t)) where\n"
"  uninhabited Same impossible\n"
"\n"
"Uninhabited (SameSchema (h :: t) []) where\n"
"  uninhabited Same impossible\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:678
msgid ""
"There is a related function you need to know about: `absurd`, which combines "
"`uninhabited` with `void`:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Eq.md:679
#, no-wrap
msgid ""
"Tutorial.Eq> :printdef absurd\n"
"Prelude.absurd : Uninhabited t => t -> a\n"
"absurd h = void (uninhabited h)\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Eq.md:685
#, no-wrap
msgid "Decidable Equality"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:703
#, no-wrap
msgid ""
"When we implemented `sameColType`, we got a proof that two\n"
"column types are indeed the same, from which we could figure out,\n"
"whether two schemata are identical. The types guarantee\n"
"we do not generate any false positives: If we generate a value\n"
"of type `SameSchema s1 s2`, we have a proof that `s1` and `s2`\n"
"are indeed identical.\n"
"However, `sameColType` and thus `sameSchema` could theoretically\n"
"still produce false negatives by returning `Nothing`\n"
"although the two values are identical. For instance,\n"
"we could implement `sameColType` in such a way that it\n"
"always returns `Nothing`. This would be in agreement with\n"
"the types, but definitely not what we want. So, here is\n"
"what we'd like to do in order to get yet stronger guarantees:\n"
"We'd either want to return a proof that the two schemata\n"
"are the same, or return a proof that the two schemata\n"
"are not the same. (Remember that `Not a` is an alias for `a -> Void`).\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:708
msgid ""
"We call a property, which either holds or leads to a contradiction a "
"*decidable property*, and the *Prelude* exports data type `Dec prop`, which "
"encapsulates this distinction."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:710
msgid "Here is a way to encode this for `ColType`:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:711
#, no-wrap
msgid ""
"decSameColType :  (c1,c2 : ColType) -> Dec (SameColType c1 c2)\n"
"decSameColType I64 I64         = Yes SameCT\n"
"decSameColType I64 Str         = No $ \\case SameCT impossible\n"
"decSameColType I64 Boolean     = No $ \\case SameCT impossible\n"
"decSameColType I64 Float       = No $ \\case SameCT impossible\n"
"\n"
"decSameColType Str I64         = No $ \\case SameCT impossible\n"
"decSameColType Str Str         = Yes SameCT\n"
"decSameColType Str Boolean     = No $ \\case SameCT impossible\n"
"decSameColType Str Float       = No $ \\case SameCT impossible\n"
"\n"
"decSameColType Boolean I64     = No $ \\case SameCT impossible\n"
"decSameColType Boolean Str     = No $ \\case SameCT impossible\n"
"decSameColType Boolean Boolean = Yes SameCT\n"
"decSameColType Boolean Float   = No $ \\case SameCT impossible\n"
"\n"
"decSameColType Float I64       = No $ \\case SameCT impossible\n"
"decSameColType Float Str       = No $ \\case SameCT impossible\n"
"decSameColType Float Boolean   = No $ \\case SameCT impossible\n"
"decSameColType Float Float     = Yes SameCT\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:741
msgid ""
"First, note how we could use a pattern match in a single argument lambda "
"directly. This is sometimes called the *lambda case* style, named after an "
"extension of the Haskell programming language. If we use the `SameCT` "
"constructor in the pattern match, Idris is forced to try and unify for "
"instance `Float` with `I64`. This is not possible, so the case as a whole is "
"impossible."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:749
msgid ""
"Yet, this was pretty cumbersome to implement. In order to convince Idris we "
"did not miss a case, there is no way around treating every possible pairing "
"of constructors explicitly.  However, we get *much* stronger guarantees out "
"of this: We can no longer create false positives *or* false negatives, and "
"therefore, `decSameColType` is provably correct."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:752
msgid ""
"Doing the same thing for schemata requires some utility functions, the types "
"of which we can figure out by placing some holes:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:753
#, no-wrap
msgid ""
"decSameSchema' :  (s1, s2 : Schema) -> Dec (SameSchema s1 s2)\n"
"decSameSchema' []        []        = Yes Same\n"
"decSameSchema' []        (y :: ys) = No ?decss1\n"
"decSameSchema' (x :: xs) []        = No ?decss2\n"
"decSameSchema' (x :: xs) (y :: ys) = case decSameColType x y of\n"
"  Yes SameCT => case decSameSchema' xs ys of\n"
"    Yes Same => Yes Same\n"
"    No  contra => No $ \\prf => ?decss3\n"
"  No  contra => No $ \\prf => ?decss4\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:770
#, no-wrap
msgid ""
"The first two cases are not too hard. The type of `decss1` is\n"
"`SameSchema [] (y :: ys) -> Void`, which you can easily verify\n"
"at the REPL. But that's just `uninhabited`, specialized to\n"
"`SameSchema [] (y :: ys)`, and this we already implemented\n"
"further above. The same goes for `decss2`.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:777
msgid ""
"The other two cases are harder, so I already filled in as much stuff as "
"possible. We know that we want to return a `No`, if either the heads or "
"tails are provably distinct. The `No` holds a function, so I already added a "
"lambda, leaving a hole only for the return value. Here are the type and - "
"more important - context of `decss3`:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Eq.md:778
#, no-wrap
msgid ""
"Tutorial.Relations> :t decss3\n"
"   y : ColType\n"
"   xs : List ColType\n"
"   ys : List ColType\n"
"   x : ColType\n"
"   contra : SameSchema xs ys -> Void\n"
"   prf : SameSchema (y :: xs) (y :: ys)\n"
"------------------------------\n"
"decss3 : Void\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:797
msgid ""
"The types of `contra` and `prf` are what we need here: If `xs` and `ys` are "
"distinct, then `y :: xs` and `y :: ys` must be distinct as well. This is the "
"contraposition of the following statement: If `x :: xs` is the same as `y :: "
"ys`, then `xs` and `ys` are the same as well. We must therefore implement a "
"lemma, which proves that the *cons* constructor is [*injective*](https://en."
"wikipedia.org/wiki/Injective_function):"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:798
#, no-wrap
msgid ""
"consInjective :  SameSchema (c1 :: cs1) (c2 :: cs2)\n"
"              -> (SameColType c1 c2, SameSchema cs1 cs2)\n"
"consInjective Same = (SameCT, Same)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:809
msgid ""
"We can now pass `prf` to `consInjective` to extract a value of type "
"`SameSchema xs ys`, which we then pass to `contra` in order to get the "
"desired value of type `Void`.  With these observations and utilities, we can "
"now implement `decSameSchema`:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:810
#, no-wrap
msgid ""
"decSameSchema :  (s1, s2 : Schema) -> Dec (SameSchema s1 s2)\n"
"decSameSchema []        []        = Yes Same\n"
"decSameSchema []        (y :: ys) = No absurd\n"
"decSameSchema (x :: xs) []        = No absurd\n"
"decSameSchema (x :: xs) (y :: ys) = case decSameColType x y of\n"
"  Yes SameCT => case decSameSchema xs ys of\n"
"    Yes Same   => Yes Same\n"
"    No  contra => No $ contra . snd . consInjective\n"
"  No  contra => No $ contra . fst . consInjective\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:825
msgid ""
"There is an interface called `DecEq` exported by module `Decidable.Equality` "
"for types for which we can implement a decision procedure for propositional "
"equality. We can implement this to figure out if two values are equal or not."
msgstr ""

#. type: Bullet: '1. '
#: ../src/Tutorial/Eq.md:830
msgid ""
"Show that there can be no non-empty vector of `Void` by writing a "
"corresponding implementation of uninhabited"
msgstr ""

#. type: Bullet: '2. '
#: ../src/Tutorial/Eq.md:832
msgid "Generalize exercise 1 for all uninhabited element types."
msgstr ""

#. type: Bullet: '3. '
#: ../src/Tutorial/Eq.md:835
msgid "Show that if `a = b` cannot hold, then `b = a` cannot hold either."
msgstr ""

#. type: Bullet: '4. '
#: ../src/Tutorial/Eq.md:838
msgid ""
"Show that if `a = b` holds, and `b = c` cannot hold, then `a = c` cannot "
"hold either."
msgstr ""

#. type: Bullet: '5. '
#: ../src/Tutorial/Eq.md:841
msgid ""
"Implement `Uninhabited` for `Crud i a`. Try to be as general as possible."
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:842 ../src/Tutorial/Folds.md:996
#: ../src/Tutorial/Functor.md:417 ../src/Tutorial/Traverse.md:285
#, no-wrap
msgid ""
"   data Crud : (i : Type) -> (a : Type) -> Type where\n"
"     Create : (value : a) -> Crud i a\n"
"     Update : (id : i) -> (value : a) -> Crud i a\n"
"     Read   : (id : i) -> Crud i a\n"
"     Delete : (id : i) -> Crud i a\n"
msgstr ""
"   data Crud : (i : Type) -> (a : Type) -> Type where\n"
"     Create : (value : a) -> Crud i a\n"
"     Update : (id : i) -> (value : a) -> Crud i a\n"
"     Read   : (id : i) -> Crud i a\n"
"     Delete : (id : i) -> Crud i a\n"

#. type: Bullet: '6. '
#: ../src/Tutorial/Eq.md:851
msgid "Implement `DecEq` for `ColType`."
msgstr ""

#. type: Bullet: '7. '
#: ../src/Tutorial/Eq.md:856
msgid ""
"Implementations such as the one from exercise 6 are cumbersome to write as "
"they require a quadratic number of pattern matches with relation to the "
"number of data constructors. Here is a trick how to make this more bearable."
msgstr ""

#. type: Bullet: '   1. '
#: ../src/Tutorial/Eq.md:859
msgid ""
"Implement a function `ctNat`, which assigns every value of type `ColType` a "
"unique natural number."
msgstr ""

#. type: Bullet: '   2. '
#: ../src/Tutorial/Eq.md:864
msgid ""
"Proof that `ctNat` is injective.  Hint: You will need to pattern match on "
"the `ColType` values, but four matches should be enough to satisfy the "
"coverage checker."
msgstr ""

#. type: Bullet: '   3. '
#: ../src/Tutorial/Eq.md:869
msgid ""
"In your implementation of `DecEq` for `ColType`, use `decEq` on the result "
"of applying both column types to `ctNat`, thus reducing it to only two lines "
"of code."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:877
#, no-wrap
msgid ""
"   We will later talk about `with` rules: Special forms of\n"
"   dependent pattern matches, that allow us to learn something\n"
"   about the shape of function arguments by performing\n"
"   computations on them. These will allow us to use\n"
"   a similar technique as shown here to implement `DecEq`\n"
"   requiring only `n` pattern matches\n"
"   for arbitrary sum types with `n` data constructors.\n"
msgstr ""

#. type: Title ##
#: ../src/Tutorial/Eq.md:878
#, no-wrap
msgid "Rewrite Rules"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:888
msgid ""
"One of the most important use cases of propositional equality is to replace "
"or *rewrite* existing types, which Idris can't unify automatically "
"otherwise. For instance, the following is no problem: Idris know that `0 + "
"n` equals `n`, because `plus` on natural numbers is implemented by pattern "
"matching on the first argument. The two vector lengths therefore unify just "
"fine."
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:889
#, no-wrap
msgid ""
"leftZero :  List (Vect n Nat)\n"
"         -> List (Vect (0 + n) Nat)\n"
"         -> List (Vect n Nat)\n"
"leftZero = (++)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:899
msgid ""
"However, the example below can't be implemented as easily (try id!), because "
"Idris can't figure out on its own that the two lengths unify."
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:900
#, no-wrap
msgid ""
"rightZero' :  List (Vect n Nat)\n"
"           -> List (Vect (n + 0) Nat)\n"
"           -> List (Vect n Nat)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:909
msgid ""
"Probably for the first time we realize, just how little Idris knows about "
"the laws of arithmetics. Idris is able to unify values when"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Eq.md:913
msgid "all values in a computation are known at compile time"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Eq.md:913
msgid ""
"one expression follows directly from the other due to the pattern matches "
"used in a function's implementation."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:917
msgid ""
"In expression `n + 0`, not all values are known (`n` is a variable), and "
"`(+)` is implemented by pattern matching on the first argument, about which "
"we know nothing here."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:923
msgid ""
"However, we can teach Idris. If we can proof that the two expressions are "
"equivalent, we can replace one expression for the other, so that the two "
"unify again. Here is a lemma and its proof, that `n + 0` equals `n`, for all "
"natural numbers `n`."
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:924
#, no-wrap
msgid ""
"addZeroRight : (n : Nat) -> n + 0 = n\n"
"addZeroRight 0     = Refl\n"
"addZeroRight (S k) = cong S $ addZeroRight k\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:935
msgid ""
"Note, how the base case is trivial: Since there are no variables left, Idris "
"can immediately figure out that `0 + 0 = 0`. In the recursive case, it can "
"be instructive to replace `cong S` with a hole and look at its type and "
"context to figure out how to proceed."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:940
msgid ""
"The *Prelude* exports function `replace` for substituting one variable in a "
"term by another, based on a proof of equality.  Make sure to inspect its "
"type first before looking at the example below:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:941
#, no-wrap
msgid ""
"replaceVect : Vect (n + 0) a -> Vect n a\n"
"replaceVect as = replace {p = \\k => Vect k a} (addZeroRight n) as\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:952
#, no-wrap
msgid ""
"As you can see, we *replace* a value of type `p x` with a value\n"
"of type `p y` based on a proof that `x = y`,\n"
"where `p` is a function from some type `t` to\n"
"`Type`, and `x` and `y` are values of type `t`. In our\n"
"`replaceVect` example, `t` equals `Nat`, `x` equals `n + 0`,\n"
"`y` equals `n`, and `p` equals `\\k => Vect k a`.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:960
msgid ""
"Using `replace` directly is not very convenient, because Idris can often not "
"infer the value of `p` on its own. Indeed, we had to give its type "
"explicitly in `replaceVect`.  Idris therefore provides special syntax for "
"such *rewrite rules*, which will get desugared to calls to `replace` with "
"all the details filled in for us. Here is an implementation of `replaceVect` "
"with a rewrite rule:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:961
#, no-wrap
msgid ""
"rewriteVect : Vect (n + 0) a -> Vect n a\n"
"rewriteVect as = rewrite sym (addZeroRight n) in as\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:970
msgid ""
"One source of confusion is that *rewrite* uses proofs of equality the other "
"way round: Given an `y = x` it replaces `p x` with `p y`. Hence the need to "
"call `sym` in our implementation above."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Eq.md:971
#, no-wrap
msgid "Use Case: Reversing Vectors"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:982
msgid ""
"Rewrite rules are often required when we perform interesting type-level "
"computations. For instance, we have already seen many interesting examples "
"of functions operating on `Vect`, which allowed us to keep track of the "
"exact lengths of the vectors involved, but one key functionality has been "
"missing from our discussions so far, and for good reasons: Function "
"`reverse`. Here is a possible implementation, which is how `reverse` is "
"implemented for lists:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Eq.md:984
#, no-wrap
msgid ""
"reverseOnto' : Vect m a -> Vect n a -> Vect (m + n) a\n"
"reverseOnto' xs []        = xs\n"
"reverseOnto' xs (x :: ys) = reverseOnto' (x :: xs) ys\n"
"\n"
"\n"
"reverseVect' : Vect n a -> Vect n a\n"
"reverseVect' = reverseOnto' []\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:997
msgid ""
"As you might have guessed, this will not compile as the length indices in "
"the two clauses of `reverseOnto'` do not unify."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:1001
msgid ""
"The *nil* case is a case we've already seen above: Here `n` is zero, because "
"the second vector is empty, so we have to convince Idris once again that `m "
"+ 0 = m`:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:1002
#, no-wrap
msgid ""
"reverseOnto : Vect m a -> Vect n a -> Vect (m + n) a\n"
"reverseOnto xs [] = rewrite addZeroRight m in xs\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:1013
msgid ""
"The second case is more complex. Here, Idris fails to unify `S (m + len)` "
"with `m + S len`, where `len` is the length of `ys`, the tail of the second "
"vector. Module `Data.Nat` provides many proofs about arithmetic operations "
"on natural numbers, one of which is `plusSuccRightSucc`. Here's its type:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Eq.md:1014
#, no-wrap
msgid ""
"Tutorial.Eq> :t plusSuccRightSucc\n"
"Data.Nat.plusSuccRightSucc :  (left : Nat)\n"
"                           -> (right : Nat)\n"
"                           -> S (left + right) = left + S right\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:1032
msgid ""
"In our case, we want to replace `S (m + len)` with `m + S len`, so we will "
"need the version with arguments flipped. However, there is one more "
"obstacle: We need to invoke `plusSuccRightSucc` with the length of `ys`, "
"which is not given as an implicit function argument of `reverseOnto`. We "
"therefore need to pattern match on `n` (the length of the second vector), in "
"order to bind the length of the tail to a variable. Remember, that we are "
"allowed to pattern match on an erased argument only if the constructor used "
"follows from a match on another, unerased, argument (`ys` in this case). "
"Here's the implementation of the second case:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:1033
#, no-wrap
msgid ""
"reverseOnto {n = S len} xs (x :: ys) =\n"
"  rewrite sym (plusSuccRightSucc m len) in reverseOnto (x :: xs) ys\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:1043
msgid ""
"I know from my own experience that this can be highly confusing at first. If "
"you use Idris as a general purpose programming language and not as a proof "
"assistant, you probably will not have to use rewrite rules too often. Still, "
"it is important to know that they exist, as they allow us to teach complex "
"equivalences to Idris."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Eq.md:1044
#, no-wrap
msgid "A Note on Erasure"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:1055
msgid ""
"Single value data types like `Unit`, `Equal`, or `SameSchema` have not "
"runtime relevance, as values of these types are always identical.  We can "
"therefore always use them as erased function arguments while still being "
"able to pattern match on these values.  For instance, when you look at the "
"type of `replace`, you will see that the equality proof is an erased "
"argument.  This allows us to run arbitrarily complex computations to produce "
"such values without fear of these computations slowing down the compiled "
"Idris program."
msgstr ""

#. type: Bullet: '1. '
#: ../src/Tutorial/Eq.md:1059
msgid "Implement `plusSuccRightSucc` yourself."
msgstr ""

#. type: Bullet: '2. '
#: ../src/Tutorial/Eq.md:1061
msgid "Proof that `minus n n` equals zero for all natural numbers `n`."
msgstr ""

#. type: Bullet: '3. '
#: ../src/Tutorial/Eq.md:1063
msgid "Proof that `minus n 0` equals n for all natural numbers `n`"
msgstr ""

#. type: Bullet: '4. '
#: ../src/Tutorial/Eq.md:1066
msgid "Proof that `n * 1 = n` and `1 * n = n` for all natural numbers `n`."
msgstr ""

#. type: Bullet: '5. '
#: ../src/Tutorial/Eq.md:1069
msgid "Proof that addition of natural numbers is commutative."
msgstr ""

#. type: Bullet: '6. '
#: ../src/Tutorial/Eq.md:1071
msgid "Implement a tail-recursive version of `map` for vectors."
msgstr ""

#. type: Bullet: '7. '
#: ../src/Tutorial/Eq.md:1073
msgid "Proof the following proposition:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:1074
#, no-wrap
msgid ""
"   mapAppend :  (f : a -> b)\n"
"             -> (xs : List a)\n"
"             -> (ys : List a)\n"
"             -> map f (xs ++ ys) = map f xs ++ map f ys\n"
msgstr ""

#. type: Bullet: '8. '
#: ../src/Tutorial/Eq.md:1084
msgid ""
"Use the proof from exercise 7 to implement again a function for zipping two "
"`Table`s, this time using a rewrite rule plus `Data.HList.(++)` instead of "
"custom function `appRows`."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:1096
msgid ""
"The concept of *types as propositions, values as proofs* is a very powerful "
"tool for writing provably correct programs. We will therefore spend some "
"more time defining data types for describing contracts between values, and "
"values of these types as proofs that the contracts hold. This will allow us "
"to describe necessary pre- and postconditions for our functions, thus "
"reducing the need to return a `Maybe` or other failure type, because due to "
"the restricted input, our functions can no longer fail."
msgstr ""

#. type: Title #
#: ../src/Tutorial/Folds.md:1
#, no-wrap
msgid "Recursion and Folds"
msgstr "再帰と畳み込み"

#. type: Plain text
#: ../src/Tutorial/Folds.md:12
msgid ""
"In this chapter, we are going to have a closer look at the computations we "
"typically perform with *container types*: Parameterized data types like "
"`List`, `Maybe`, or `Identity`, holding zero or more values of the "
"parameter's type. Many of these functions are recursive in nature, so we "
"start with a discourse about recursion in general, and tail recursion as an "
"important optimization technique in particular. Most recursive functions in "
"this part will describe pure iterations over lists."
msgstr ""
"この章では*容器型*を扱う際の典型的な計算について迫ります。\n"
"容器型とは`List`、`Maybe`、あるいは`Identity`といった引数を取るデータ型で、\n"
"引数の型の値をゼロ個以上保有するものです。\n"
"これらの機能は再帰に根差しているため、一般的な再帰についての議論、\n"
"特に重要な最適化技法としての末尾再帰の議論から始めます。\n"
"この部にあるほとんどの再帰関数はリスト上の純粋な繰り返しを記述します。"

#. type: Plain text
#: ../src/Tutorial/Folds.md:17
msgid ""
"It is recursive functions, for which totality is hard to determine, so we "
"will next have a quick look at the totality checker and learn, when it will "
"refuse to accept a function as being total and what to do about this."
msgstr ""
"再帰関数というものはその全域性が決定しづらいものなので、\n"
"次に全域性検査器を軽く見ていきます。\n"
"そして、いつ関数の全域性の承諾が拒まれるのか、そんなときどうすればよいのかに"
"ついて学びます。"

#. type: Plain text
#: ../src/Tutorial/Folds.md:22
msgid ""
"Finally, we will start looking for common patterns in the recursive "
"functions from the first part and will eventually introduce a new interface "
"for consuming container types: Interface `Foldable`."
msgstr ""
"最後に再帰関数においてよくある様式を見ていきます。\n"
"最初の部分から始まり、最終的には容器型を消費する新しいインターフェース"
"`Foldable`を導入します。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Folds.md:23
#, no-wrap
msgid ""
"module Tutorial.Folds\n"
"\n"
"import Data.List1\n"
"import Data.Maybe\n"
"import Data.Vect\n"
"import Debug.Trace\n"
"\n"
"%default total\n"
msgstr ""
"module Tutorial.Folds\n"
"\n"
"import Data.List1\n"
"import Data.Maybe\n"
"import Data.Vect\n"
"import Debug.Trace\n"
"\n"
"%default total\n"

#. type: Title ##
#: ../src/Tutorial/Folds.md:34
#, no-wrap
msgid "Recursion"
msgstr "再帰"

#. type: Plain text
#: ../src/Tutorial/Folds.md:38
msgid ""
"In this section, we are going to have a closer look at recursion in general "
"and at tail recursion in particular."
msgstr "この節で一般的な再帰と特に末尾再帰に迫ります。"

#. type: Plain text
#: ../src/Tutorial/Folds.md:47
msgid ""
"Recursive functions are functions, which call themselves to repeat a task or "
"calculation until a certain aborting condition (called the *base case*) "
"holds.  Please note, that it is recursive functions, which make it hard to "
"verify totality: Non-recursive functions, which are *covering* (they cover "
"all possible cases in their pattern matches) are automatically total if they "
"only invoke other total functions."
msgstr ""
"再帰関数とは、何らかの中断条件（*既定場合*と呼ばれます）が満たされる手前ま"
"で、\n"
"自分自身を呼び出してタスクや計算を繰り返す関数です。\n"
"注意していただきたいのですが、再帰関数が全域性を確証しづらくするものだという"
"ことです。\n"
"*網羅的*な（パターン照合で全ての可能な場合を押さえているような）非再帰関数"
"は、\n"
"他の全域関数を呼び出すときだけ、自動的に全域になります。"

#. type: Plain text
#: ../src/Tutorial/Folds.md:50
msgid ""
"Here is an example of a recursive function: It generates a list of the given "
"length filling it with identical values:"
msgstr ""
"以下は再帰関数の一例です。\n"
"同じ値でもって、与えられた長さのリストを生成します。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Folds.md:51
#, no-wrap
msgid ""
"replicateList : Nat -> a -> List a\n"
"replicateList 0     _ = []\n"
"replicateList (S k) x = x :: replicateList k x\n"
msgstr ""
"replicateList : Nat -> a -> List a\n"
"replicateList 0     _ = []\n"
"replicateList (S k) x = x :: replicateList k x\n"

#. type: Plain text
#: ../src/Tutorial/Folds.md:63
msgid ""
"As you can see (this module has the `%default total` pragma at the top), "
"this function is provably total. Idris verifies, that the `Nat` argument "
"gets *strictly smaller* in each recursive call, and that therefore, the "
"function *must* eventually come to an end. Of course, we can do the same "
"thing for `Vect`, where we can even show that the length of the resulting "
"vector matches the given natural number:"
msgstr ""
"見てみると（このモジュールの一番上に`%default total`がありますが）この関数は"
"全域であることが証明されています。\n"
"`Nat`引数がそれぞれの再帰呼び出しで*厳密に小さく*なることを、\n"
"そして関数が最終的に終わりに向かう*はず*だということを、\n"
"Idrisは確証しています。\n"
"もちろん同じことを`Vect`についても行えますが、\n"
"こちらについては結果のベクタの長さが与えられた自然数に合致することさえ示すこ"
"とができます。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Folds.md:64
#, no-wrap
msgid ""
"replicateVect : (n : Nat) -> a -> Vect n a\n"
"replicateVect 0     _ = []\n"
"replicateVect (S k) x = x :: replicateVect k x\n"
msgstr ""
"replicateVect : (n : Nat) -> a -> Vect n a\n"
"replicateVect 0     _ = []\n"
"replicateVect (S k) x = x :: replicateVect k x\n"

#. type: Plain text
#: ../src/Tutorial/Folds.md:73
msgid ""
"While we often use recursion to *create* values of data types like `List` or "
"`Vect`, we also use recursion, when we *consume* such values.  For instance, "
"here is a function for calculating the length of a list:"
msgstr ""
"よく再帰を使って`List`や`Vect`のようなデータ型の値を*つくり*ますが、\n"
"そのような値を*消費*するときにも再帰は使います。\n"
"例えば以下はリストの長さを計算する関数です。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Folds.md:74
#, no-wrap
msgid ""
"len : List a -> Nat\n"
"len []        = 0\n"
"len (_ :: xs) = 1 + len xs\n"
msgstr ""
"len : List a -> Nat\n"
"len []        = 0\n"
"len (_ :: xs) = 1 + len xs\n"

#. type: Plain text
#: ../src/Tutorial/Folds.md:82
msgid ""
"Again, Idris can verify that `len` is total, as the list we pass in the "
"recursive case is strictly smaller than the original list argument."
msgstr ""
"またもやIdrisは`len`が全域であると確証できますが、\n"
"これは再帰場合に渡したリストが元のリスト引数より厳密に小さくなるためです。"

#. type: Plain text
#: ../src/Tutorial/Folds.md:88
msgid ""
"But when is a recursive function non-total? Here is an example: The "
"following function creates a sequence of values until the given generation "
"function (`gen`) returns a `Nothing`. Note, how we use a *state* value (of "
"generic type `s`) and use `gen` to calculate a value together with the next "
"state:"
msgstr ""
"しかしいつ再帰関数は非全域なのでしょうか。\n"
"こちらがその一例です。\n"
"以下の関数は与えられた生成関数 (`gen`) が`Nothing`を返す手前まで値の並びをつ"
"くります。\n"
"（汎化型`s`の）*状態*値や次の状態とともに値を計算するための`gen`の使われかた"
"に注目してください。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Folds.md:89
#, no-wrap
msgid ""
"covering\n"
"unfold : (gen : s -> Maybe (s,a)) -> s -> List a\n"
"unfold gen vs = case gen vs of\n"
"  Just (vs',va) => va :: unfold gen vs'\n"
"  Nothing       => []\n"
msgstr ""
"covering\n"
"unfold : (gen : s -> Maybe (s,a)) -> s -> List a\n"
"unfold gen vs = case gen vs of\n"
"  Just (vs',va) => va :: unfold gen vs'\n"
"  Nothing       => []\n"

#. type: Plain text
#: ../src/Tutorial/Folds.md:103
msgid ""
"With `unfold`, Idris can't verify that any of its arguments is converging "
"towards the base case. It therefore rightfully refuses to accept that "
"`unfold` is total. And indeed, the following function produces an infinite "
"list (so please, don't try to inspect this at the REPL, as doing so will "
"consume all your computer's memory):"
msgstr ""
"`unfold`については、任意の引数が既定場合に向かっていくかどうか、Idrisは確証で"
"きません。\n"
"したがって当然`unfold`が全域であると認めることを拒みます。\n"
"そしてもちろん以下の関数は無尽蔵のリストを生成します。\n"
"（ですからどうかこれをREPLで調べようとしないでください。\n"
"そうしてしまうとコンピュータの全てのメモリを消費してしまうでしょうから。）"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Folds.md:104
#, no-wrap
msgid ""
"fiboHelper : (Nat,Nat) -> ((Nat,Nat),Nat)\n"
"fiboHelper (f0,f1) = ((f1, f0 + f1), f0)\n"
"\n"
"covering\n"
"fibonacci : List Nat\n"
"fibonacci = unfold (Just . fiboHelper) (1,1)\n"
msgstr ""
"fiboHelper : (Nat,Nat) -> ((Nat,Nat),Nat)\n"
"fiboHelper (f0,f1) = ((f1, f0 + f1), f0)\n"
"\n"
"covering\n"
"fibonacci : List Nat\n"
"fibonacci = unfold (Just . fiboHelper) (1,1)\n"

#. type: Plain text
#: ../src/Tutorial/Folds.md:117
msgid ""
"In order to safely create a (finite) sequence of Fibonacci numbers, we need "
"to make sure the function generating the sequence will stop after a finite "
"number of steps, for instance by limiting the length of the list:"
msgstr ""
"安全に（終端のある）フィボナッチ数の並びをつくるためには、\n"
"終端となる過程の数のあとに関数が並びの生成を停止することが確実でなくてはいけ"
"ません。\n"
"例えばリストの長さを制限すればよいです。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Folds.md:118
#, no-wrap
msgid ""
"unfoldTot : Nat -> (gen : s -> Maybe (s,a)) -> s -> List a\n"
"unfoldTot 0     _   _  = []\n"
"unfoldTot (S k) gen vs = case gen vs of\n"
"  Just (vs',va) => va :: unfoldTot k gen vs'\n"
"  Nothing       => []\n"
"\n"
"fibonacciN : Nat -> List Nat\n"
"fibonacciN n = unfoldTot n (Just . fiboHelper) (1,1)\n"
msgstr ""
"unfoldTot : Nat -> (gen : s -> Maybe (s,a)) -> s -> List a\n"
"unfoldTot 0     _   _  = []\n"
"unfoldTot (S k) gen vs = case gen vs of\n"
"  Just (vs',va) => va :: unfoldTot k gen vs'\n"
"  Nothing       => []\n"
"\n"
"fibonacciN : Nat -> List Nat\n"
"fibonacciN n = unfoldTot n (Just . fiboHelper) (1,1)\n"

#. type: Title ###
#: ../src/Tutorial/Folds.md:129
#, no-wrap
msgid "The Call Stack"
msgstr "呼び出しスタック"

#. type: Plain text
#: ../src/Tutorial/Folds.md:133
msgid ""
"In order to demonstrate what tail recursion is about, we require the "
"following `main` function:"
msgstr "末尾再帰がどんなものか実演するためには、以下の`main`関数が要ります。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Folds.md:134
#, no-wrap
msgid ""
"main : IO ()\n"
"main = printLn . len $ replicateList 10000 10\n"
msgstr ""
"main : IO ()\n"
"main = printLn . len $ replicateList 10000 10\n"

#. type: Plain text
#: ../src/Tutorial/Folds.md:144
msgid ""
"If you have [Node.js](https://nodejs.org/en/) installed on your system, you "
"might try the following experiment. Compile and run this module using the "
"*Node.js* backend of Idris instead of the default *Chez Scheme* backend and "
"run the resulting JavaScript source file with the Node.js binary:"
msgstr ""
"[Node.js](https://nodejs.org/en/)がシステムにインストールされていれば、\n"
"以下の実験をやってみることができます。\n"
"Idrisの既定の*Chez Schema*バックエンドの代わりに*Node.js*バックエンドを使って"
"このモジュールをコンパイルして走らせてください。\n"
"実行するには結果的に得られるJavaScriptソースファイルをNode.jsバイナリで走らせ"
"ます。"

#. type: Fenced code block (sh)
#: ../src/Tutorial/Folds.md:145
#, no-wrap
msgid ""
"idris2 --cg node -o test.js --find-ipkg -src/Tutorial/Folds.md\n"
"node build/exec/test.js\n"
msgstr ""
"idris2 --cg node -o test.js --find-ipkg -src/Tutorial/Folds.md\n"
"node build/exec/test.js\n"

#. type: Plain text
#: ../src/Tutorial/Folds.md:154
msgid ""
"Node.js will fail with the following error message and a lengthy stack "
"trace: `RangeError: Maximum call stack size exceeded`.  What's going on "
"here? How can it be that `main` fails with an exception although it is "
"provably total?"
msgstr ""
"Node.jsは以下のエラー文言と長々としたスタックトレース`RangeError: Maximum "
"call stack size exceeded`とともに失敗するでしょう。\n"
"ここで何が起こっているのでしょうか。\n"
"全域なことが証明されているのに、どうして`main`が例外で落ちることがありえるの"
"でしょうか。"

#. type: Plain text
#: ../src/Tutorial/Folds.md:169
msgid ""
"First, remember that a function being total means that it will eventually "
"produce a value of the given type in a finite amount of time, *given enough "
"resources like computer memory*. Here, `main` hasn't been given enough "
"resources as Node.js has a very small size limit on its call stack. The "
"*call stack* can be thought of as a stack data structure (first in, last "
"out), where nested function calls are put. In case of recursive functions, "
"the stack size increases by one with every recursive function call. In case "
"of our `main` function, we create and consume a list of length 10'000, so "
"the call stack will hold at least 10'000 function calls before they are "
"being invoked and the stack's size is reduced again. This exceeds Node.js's "
"stack size limit by far, hence the overflow error."
msgstr ""
"まず覚えておいてほしいことは、関数が全域であるということの意味は、\n"
"その関数が最終的に有限の時間量で与えられた型の値を生成することですが、\n"
"それは*コンピュータメモリのような充分な資源あってこそです*。\n"
"ここで`main`は充分なリソースを与えられていませんでしたが、\n"
"これはNode.jsが呼び出しスタックにとても小さい量での上限を設けているからで"
"す。\n"
"*呼び出しスタック*はスタックのデータ構造（先入れ後出し）のように考えられま"
"す。\n"
"この構造では入れ子の関数呼び出しが置かれます。\n"
"再帰関数の場合、スタックの大きさは再帰関数呼び出しのたびに1つ増えます。\n"
"ここでの`main`関数の場合、長さ10,000のリストを作って消費しているので、\n"
"コールスタックは呼び出される前に少なくとも10,000個の関数呼び出しを保有してお"
"り、\n"
"そこからスタックの大きさは減少に転じていきます。\n"
"これがNode.jsのスタックの大きさ上限を遥かに越えてしまっているので、オーバーフ"
"ローエラーになったのです。"

#. type: Plain text
#: ../src/Tutorial/Folds.md:180
msgid ""
"Now, before we look at a solution how to circumvent this issue, please note "
"that this is a very serious and limiting source of bugs when using the "
"JavaScript backends of Idris. In Idris, having no access to control "
"structures like `for` or `while` loops, we *always* have to resort to "
"recursion in order to describe iterative computations. Luckily (or should I "
"say \"unfortunately\", since otherwise this issue would already have been "
"addressed with all seriousness), the Scheme backends don't have this issue, "
"as their stack size limit is much larger and they perform all kinds of "
"optimizations internally to prevent the call stack from overflowing."
msgstr ""
"さて、この問題をどのように回避するかの解法を見る前に、\n"
"これがIdrisのJavaScriptバックエンドを使うときに、とても深刻でありつつも、\n"
"バグの温床を抑えていることを覚えておいてください。\n"
"Idrisでは`for`や`while`の繰返しのような制御構造を使うことができず、\n"
"反復計算を記述するためには*常に*再帰を使わざるを得ないのです。\n"
"幸運にも（あるいは「不運にも」と言うべきでしょうか、\n"
"というのもこの問題は既に全ての深刻性について対処されているためです）、\n"
"Schemeバックエンドにはこの問題を抱えておらず、\n"
"それはスタックの大きさ上限が遥かに大きく、\n"
"呼び出しスタックのオーバーフローを防ぐためにあらゆる類の内部的な最適化を施す"
"ためです。"

#. type: Title ###
#: ../src/Tutorial/Folds.md:181
#, no-wrap
msgid "Tail Recursion"
msgstr "末尾再帰"

#. type: Plain text
#: ../src/Tutorial/Folds.md:187
msgid ""
"A recursive function is said to be *tail recursive*, if all recursive calls "
"occur at *tail position*: The last function call in a (sub)expression. For "
"instance, the following version of `len` is tail recursive:"
msgstr ""
"再帰関数の中には*末尾再帰*であると言われるものがありますが、\n"
"これは全ての再帰呼び出しが*末尾位置*で起こるときに指します。\n"
"末尾位置とは（部分）式中の最後の関数です。\n"
"例えば以下の`len`のバージョンは末尾再帰です。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Folds.md:188
#, no-wrap
msgid ""
"lenOnto : Nat -> List a -> Nat\n"
"lenOnto k []        = k\n"
"lenOnto k (_ :: xs) = lenOnto (k + 1) xs\n"
msgstr ""
"lenOnto : Nat -> List a -> Nat\n"
"lenOnto k []        = k\n"
"lenOnto k (_ :: xs) = lenOnto (k + 1) xs\n"

#. type: Plain text
#: ../src/Tutorial/Folds.md:197
msgid ""
"Compare this to `len` as defined above: There, the last function call is an "
"invocation of operator `(+)`, and the recursive call happens in one of its "
"arguments:"
msgstr ""
"これを前に定義した`len`と比較してください。\n"
"`len`では最後の関数呼び出しが演算子`(+)`の呼び出しであり、\n"
"再帰呼び出しは引数のうちの1つで起こっていました。"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Folds.md:198
#, no-wrap
msgid "len (_ :: xs) = 1 + len xs\n"
msgstr "len (_ :: xs) = 1 + len xs\n"

#. type: Plain text
#: ../src/Tutorial/Folds.md:204
msgid ""
"We can use `lenOnto` as a utility to implement a tail recursive version of "
"`len` without the additional `Nat` argument:"
msgstr ""
"`lenOnto`から余分な`Nat`引数をなくし、`len`の末尾再帰版を実装するための小間物"
"として使えます。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Folds.md:205
#, no-wrap
msgid ""
"lenTR : List a -> Nat\n"
"lenTR = lenOnto 0\n"
msgstr ""
"lenTR : List a -> Nat\n"
"lenTR = lenOnto 0\n"

#. type: Plain text
#: ../src/Tutorial/Folds.md:215
msgid ""
"This is a common pattern when writing tail recursive functions: We typically "
"add an additional function argument for accumulating intermediary results, "
"which is then passed on explicitly at each recursive call. For instance, "
"here is a tail recursive version of `replicateList`:"
msgstr ""
"これは末尾再帰関数を書くときによくある様式です。\n"
"つまり、追加の関数引数を中間結果に累積するために追加するのが典型的です。\n"
"この引数はそれぞれの再帰呼び出しで明示的に渡されます。\n"
"例えば以下は`replicateList`の末尾再帰版です。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Folds.md:216
#, no-wrap
msgid ""
"replicateListTR : Nat -> a -> List a\n"
"replicateListTR n v = go Nil n\n"
"  where go : List a -> Nat -> List a\n"
"        go xs 0     = xs\n"
"        go xs (S k) = go (v :: xs) k\n"
msgstr ""
"replicateListTR : Nat -> a -> List a\n"
"replicateListTR n v = go Nil n\n"
"  where go : List a -> Nat -> List a\n"
"        go xs 0     = xs\n"
"        go xs (S k) = go (v :: xs) k\n"

#. type: Plain text
#: ../src/Tutorial/Folds.md:229
#, fuzzy
#| msgid ""
#| "The big advantage of tail recursive functions is, that they can be easily "
#| "converted to efficient, imperative loops by the Idris compiler, an are "
#| "thus *stack safe*: Recursive function calls are *not* added to the call "
#| "stack, thus avoiding the dreaded stack overflow errors."
msgid ""
"The big advantage of tail recursive functions is, that they can be easily "
"converted to efficient, imperative loops by the Idris compiler, and are thus "
"*stack safe*: Recursive function calls are *not* added to the call stack, "
"thus avoiding the dreaded stack overflow errors."
msgstr ""
"末尾再帰関数の大きな利点は、Idrisコンパイラによって効率的で命令的な、\n"
"すなわち*スタック安全*な繰返しに簡単に変換できることです。\n"
"再帰関数呼び出しは呼び出しスタックに加えられ*ません*ので、\n"
"悪夢のようなスタックオーバーフローエラーを避けられるのです。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Folds.md:230
#, no-wrap
msgid ""
"main1 : IO ()\n"
"main1 = printLn . lenTR $ replicateListTR 10000 10\n"
msgstr ""
"main1 : IO ()\n"
"main1 = printLn . lenTR $ replicateListTR 10000 10\n"

#. type: Plain text
#: ../src/Tutorial/Folds.md:240
msgid ""
"We can again run `main1` using the *Node.js* backend. This time, we use "
"slightly different syntax to execute a function other than `main` (Remember: "
"The dollar prefix is only there to distinghish a terminal command from its "
"output. It is not part of the command you enter in a terminal sesssion.):"
msgstr ""
"改めてを*Node.js*バックエンドを使って`main1`を走らせます。\n"
"今回は僅かに異なる構文を使って`main`以外の関数を実行しています。\n"
"（いいですか。ドル記号の前置は端末のコマンドとその結果を区別するためだけにあ"
"りますよ。\n"
"ドル記号は端末のセッションで入力するコマンドの一部ではありません。）"

#. type: Fenced code block (sh)
#: ../src/Tutorial/Folds.md:241
#, no-wrap
msgid ""
"$ idris2 --cg node --exec main1 --find-ipkg src/Tutorial/Folds.md\n"
"10000\n"
msgstr ""
"$ idris2 --cg node --exec main1 --find-ipkg src/Tutorial/Folds.md\n"
"10000\n"

#. type: Plain text
#: ../src/Tutorial/Folds.md:248
msgid ""
"As you can see, this time the computation finished without overflowing the "
"call stack."
msgstr ""
"見てとれるように今回は計算が呼び出しスタックが溢れることなしに終了しました。"

#. type: Plain text
#: ../src/Tutorial/Folds.md:253
msgid ""
"Tail recursive functions are allowed to consist of (possibly nested) pattern "
"matches, with recursive calls at tail position in several of the branches.  "
"Here is an example:"
msgstr ""
"末尾再帰関数を（入れ子になりうる）パターン照合で構成することも可能です。\n"
"パターン照合の複数の分岐それぞれで末尾位置での再帰呼び出しがあります。\n"
"以下は一例です。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Folds.md:254
#, no-wrap
msgid ""
"countTR : (a -> Bool) -> List a -> Nat\n"
"countTR p = go 0\n"
"  where go : Nat -> List a -> Nat\n"
"        go k []        = k\n"
"        go k (x :: xs) = case p x of\n"
"          True  => go (S k) xs\n"
"          False => go k xs\n"
msgstr ""
"countTR : (a -> Bool) -> List a -> Nat\n"
"countTR p = go 0\n"
"  where go : Nat -> List a -> Nat\n"
"        go k []        = k\n"
"        go k (x :: xs) = case p x of\n"
"          True  => go (S k) xs\n"
"          False => go k xs\n"

#. type: Plain text
#: ../src/Tutorial/Folds.md:266
msgid ""
"Note, how each invocation of `go` is in tail position in its branch of the "
"case expression."
msgstr ""
"それぞれの`go`の呼び出しがcase式の分岐の末尾位置にあることに着目してくださ"
"い。"

#. type: Title ###
#: ../src/Tutorial/Folds.md:267
#, no-wrap
msgid "Mutual Recursion"
msgstr "相互再帰"

#. type: Plain text
#: ../src/Tutorial/Folds.md:281
msgid ""
"It is sometimes convenient to implement several related functions, which "
"call each other recursively. In Idris, unlike in many other programming "
"languages, a function must be declared in a source file *before* it can be "
"called by other functions, as in general a function's implementation must be "
"available during type checking (because Idris has dependent types). There "
"are two ways around this, which actually result in the same internal "
"representation in the compiler. Our first option is to write down the "
"functions' declarations first with the implementations following after. "
"Here's a silly example:"
msgstr ""
"複数の関連する、すなわちお互いに再帰的に呼び出す関数を実装すると便利なときが"
"あります。\n"
"Idrisでは他の多くのプログラミング言語とは異なり、\n"
"関数は他の関数に呼び出されるより*前*にソースファイルで定義されなくてはいけま"
"せん。\n"
"というのも一般的に関数の実装が型検査中に利用できなくてはいけないからです。\n"
"（Idrisが依存型であるためです。）\n"
"これには2つの方法があり、実際にはコンパイラ中で同じ内部表現に落ち着きます。\n"
"最初の選択肢は関数の宣言を最初に書き下し、そのあとに実装が続くようにすること"
"です。\n"
"以下は他愛ない例です。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Folds.md:282
#, no-wrap
msgid ""
"even : Nat -> Bool\n"
"\n"
"odd : Nat -> Bool\n"
"\n"
"even 0     = True\n"
"even (S k) = odd k\n"
"\n"
"odd 0     = False\n"
"odd (S k) = even k\n"
msgstr ""
"even : Nat -> Bool\n"
"\n"
"odd : Nat -> Bool\n"
"\n"
"even 0     = True\n"
"even (S k) = odd k\n"
"\n"
"odd 0     = False\n"
"odd (S k) = even k\n"

#. type: Plain text
#: ../src/Tutorial/Folds.md:297
msgid ""
"As you can see, function `even` is allowed to call function `odd` in its "
"implementation, since `odd` has already been declared (but not yet "
"implemented)."
msgstr ""
"見ての通り、関数`even`は実装で関数`add`を呼ぶことができていますが、\n"
"これは`odd`が既に宣言されている（でも実装はまだ）からです。"

#. type: Plain text
#: ../src/Tutorial/Folds.md:302
msgid ""
"If you're like me and want to keep declarations and implementations next to "
"each other, you can introduce a `mutual` block, which has the same effect. "
"Like with other code blocks, functions in a `mutual` block must all be "
"indented by the same amount of whitespace:"
msgstr ""
"宣言と実装がお互いに隣り合っている状態を維持したければ、\n"
"`mutual`ブロックを導入することができます。\n"
"このブロックには上と同じ効果があります。\n"
"他のコードブロックと同様に`mutual`ブロック中の関数は全て同量の空白で字下げさ"
"れていなくてはなりません。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Folds.md:303
#, no-wrap
msgid ""
"mutual\n"
"  even' : Nat -> Bool\n"
"  even' 0     = True\n"
"  even' (S k) = odd' k\n"
"\n"
"  odd' : Nat -> Bool\n"
"  odd' 0     = False\n"
"  odd' (S k) = even' k\n"
msgstr ""
"mutual\n"
"  even' : Nat -> Bool\n"
"  even' 0     = True\n"
"  even' (S k) = odd' k\n"
"\n"
"  odd' : Nat -> Bool\n"
"  odd' 0     = False\n"
"  odd' (S k) = even' k\n"

#. type: Plain text
#: ../src/Tutorial/Folds.md:319
msgid ""
"Just like with single recursive functions, mutually recursive functions can "
"be optimized to imperative loops if all recursive calls occur at tail "
"position. This is the case with functions `even` and `odd`, as can again be "
"verified at the *Node.js* backend:"
msgstr ""
"ちょうど単一再帰関数と同じように、\n"
"相互再帰関数は再帰呼び出しが末尾位置で起こっているときに命令的な繰返しに最適"
"化することができます。\n"
"これは関数`even`や`odd`についても言え、\n"
"そのためここでも*Node.js*バックエンドで確かめることができます。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Folds.md:320
#, no-wrap
msgid ""
"main2 : IO ()\n"
"main2 =  printLn (even 100000)\n"
"      >> printLn (odd 100000)\n"
msgstr ""
"main2 : IO ()\n"
"main2 =  printLn (even 100000)\n"
"      >> printLn (odd 100000)\n"

#. type: Fenced code block (sh)
#: ../src/Tutorial/Folds.md:326
#, no-wrap
msgid ""
"$ idris2 --cg node --exec main2 --find-ipkg src/Tutorial/Folds.md\n"
"True\n"
"False\n"
msgstr ""
"$ idris2 --cg node --exec main2 --find-ipkg src/Tutorial/Folds.md\n"
"True\n"
"False\n"

#. type: Title ###
#: ../src/Tutorial/Folds.md:332
#, no-wrap
msgid "Final Remarks"
msgstr "総括"

#. type: Plain text
#: ../src/Tutorial/Folds.md:336
msgid ""
"In this section, we learned about several important aspects of recursion and "
"totality checking, which are summarized here:"
msgstr ""
"この節ではいくつかの重要な再帰と全域性検査の側面について学びました。\n"
"以下に要約します。"

#. type: Bullet: '* '
#: ../src/Tutorial/Folds.md:339
msgid ""
"In pure functional programming, recursion is the way to implement iterative "
"procedures."
msgstr "純粋関数型プログラミングでは再帰は繰返し手順を実装する手段である。"

#. type: Bullet: '* '
#: ../src/Tutorial/Folds.md:343
msgid ""
"Recursive functions pass the totality checker, if it can verify that one of "
"the arguments is getting strictly smaller in every recursive function call."
msgstr ""
"再帰関数が全域性検査器を通るのは、引数の1つが各再帰関数呼び出しで厳密に小さく"
"なることが確かめられるときである"

#. type: Bullet: '* '
#: ../src/Tutorial/Folds.md:346
msgid ""
"Arbitrary recursion can lead to stack overflow exceptions on backends with "
"small stack size limits."
msgstr ""
"小さいスタックの大きさ上限を持つバックエンドでは、任意の再帰はスタックオー"
"バーフロー例外に繋がりうる。"

#. type: Bullet: '* '
#: ../src/Tutorial/Folds.md:350
msgid ""
"The JavaScript backends of Idris perform mutual tail call optimization: Tail "
"recursive functions are converted to stack safe, imperative loops."
msgstr ""
"IdrisのJavaScriptバックエンドは相互末尾呼び出し最適化を実施する。\n"
"末尾再帰関数はスタック安全で命令的な繰返しに変換される。"

#. type: Plain text
#: ../src/Tutorial/Folds.md:354
msgid ""
"Note, that not all Idris backends you will come across in the wild will "
"perform tail call optimization. Please check the corresponding documentation."
msgstr ""
"なお、巷で遭遇する全てのIdrisバックエンドが末尾呼び出し最適化を施すとは限りま"
"せん。\n"
"対応するドキュメントを確認してください。"

#. type: Plain text
#: ../src/Tutorial/Folds.md:372
msgid ""
"Note also, that most recursive functions in the core libraries (*prelude* "
"and *base*) do not yet make use of tail recursion. There is an important "
"reason for this: In many cases, non-tail recursive functions are easier to "
"use in compile-time proofs, as they unify more naturally than their tail "
"recursive counterparts.  Compile-time proofs are an important aspect of "
"programming in Idris (as we will see in later chapters), so there is a "
"compromise to be made between what performs well at runtime and what works "
"well at compile time. Eventually, the way to go might be to provide two "
"implementations for most recursive functions with a *transform rule* telling "
"the compiler to use the optimized version at runtime whenever programmers "
"use the non-optimized version in their code.  Such transform rules have - "
"for instance - already been written for functions `pack` and `unpack` (which "
"use `fastPack` and `fastUnpack` at runtime; see the corresponding rules in "
"[the following source file](https://github.com/idris-lang/Idris2/blob/main/"
"libs/prelude/Prelude/Types.idr))."
msgstr ""
"これも注意ですが、中核ライブラリ（*prelude*と*base*）のほとんどの再帰関数はま"
"だ末尾再帰を活用していません。\n"
"これには大切な理由があります。\n"
"多くの場合、非末尾再帰関数はコンパイル時証明で使いやすいのですが、\n"
"これは末尾再帰で対応するものより自然に統合が行えるからです。\n"
"コンパイル時証明は（後の章で見ていくように）Idrisでプログラミングする上での重"
"要な側面であり、\n"
"実行時にいい感じに動くこととコンパイル時にいい感じに動くことの間には折り合い"
"があります。\n"
"ゆくゆく行き着くところは2つの実装を提供することでしょう。\n"
"ほとんどの再帰関数には*転轍規則*がついており、\n"
"コンパイラに実行時には最適化された版を使うように指示します。\n"
"これはプログラマがコードで最適化されていないバージョンを使うときは常に有効で"
"す。\n"
"そのような転轍規則は、例えば既に関数`pack`と`unpack`に書かれています。\n"
"（これらの関数では実行時に`fastPack`と`fastUnpack`を使います。\n"
"[リンク先のソースファイル](https://github.com/idris-lang/Idris2/blob/main/"
"libs/prelude/Prelude/Types.idr)中の対応する規則をご参照ください。）"

#. type: Plain text
#: ../src/Tutorial/Folds.md:379
msgid ""
"In these exercises you are going to implement several recursive functions. "
"Make sure to use tail recursion whenever possible and quickly verify the "
"correct behavior of all functions at the REPL."
msgstr ""
"この演習ではいくつかの再帰関数を実装していきます。\n"
"できる限り末尾再帰を使うようにし、REPLで全ての関数について正しい振舞いをする"
"ことを簡単に確かめてください。"

#. type: Bullet: '1. '
#: ../src/Tutorial/Folds.md:383
msgid ""
"Implement functions `anyList` and `allList`, which return `True` if any "
"element (or all elements in case of `allList`) in a list fulfills the given "
"predicate:"
msgstr ""
"関数`anyList`と`allList`を実装してください。\n"
"この関数はリスト中のどれか1つの要素（`allList`の場合は全ての要素）が所与の条"
"件を満足するとき`True`を返します。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Folds.md:384
#, no-wrap
msgid ""
"   anyList : (a -> Bool) -> List a -> Bool\n"
"\n"
"   allList : (a -> Bool) -> List a -> Bool\n"
msgstr ""
"   anyList : (a -> Bool) -> List a -> Bool\n"
"\n"
"   allList : (a -> Bool) -> List a -> Bool\n"

#. type: Bullet: '2. '
#: ../src/Tutorial/Folds.md:392
msgid ""
"Implement function `findList`, which returns the first value (if any) "
"fulfilling the given predicate:"
msgstr ""
"関数`findList`を実装してください。\n"
"この関数は（もしあれば）所与の条件を満足する最初の値を返します。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Folds.md:393
#, no-wrap
msgid "   findList : (a -> Bool) -> List a -> Maybe a\n"
msgstr "   findList : (a -> Bool) -> List a -> Maybe a\n"

#. type: Bullet: '3. '
#: ../src/Tutorial/Folds.md:399
msgid ""
"Implement function `collectList`, which returns the first value (if any), "
"for which the given function returns a `Just`:"
msgstr ""
"関数`collectList`を実装してください。\n"
"この関数は（もしあれば）所与の関数が`Just`を返すような最初の値を返します。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Folds.md:400
#, no-wrap
msgid "   collectList : (a -> Maybe b) -> List a -> Maybe b\n"
msgstr "   collectList : (a -> Maybe b) -> List a -> Maybe b\n"

#. type: Plain text
#: ../src/Tutorial/Folds.md:405
#, no-wrap
msgid "   Implement `lookupList` in terms of `collectList`:\n"
msgstr "   `collectList`を使って`lookupList`を実装してください。\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Folds.md:406
#, no-wrap
msgid "   lookupList : Eq a => a -> List (a,b) -> Maybe b\n"
msgstr "   lookupList : Eq a => a -> List (a,b) -> Maybe b\n"

#. type: Bullet: '4. '
#: ../src/Tutorial/Folds.md:423
msgid ""
"For functions like `map` or `filter`, which must loop over a list without "
"affecting the order of elements, it is harder to write a tail recursive "
"implementation.  The safest way to do so is by using a `SnocList` (a "
"*reverse* kind of list that's built from head to tail instead of from tail "
"to head) to accumulate intermediate results. Its two constructors are `Lin` "
"and `(:<)` (called the *snoc* operator).  Module `Data.SnocList` exports two "
"tail recursive operators called *fish* and *chips* (`(<><)` and `(<>>)`) for "
"going from `SnocList` to `List` and vice versa. Have a look at the types of "
"all new data constructors and operators before continuing with the exercise."
msgstr ""
"`map`や`filter`のような関数は要素の順番に影響を与えることなくリストを巡回しま"
"すが、\n"
"末尾再帰実装を書くことは難しいです。\n"
"末尾再帰にする最も安全な方法は`SnocList`\n"
"（リストの*逆*の類であり、尾鰭から先頭に向かって構築されるのではなく先頭から"
"尾鰭に向かって構築されます。）\n"
"を使うことで中間結果を累積することです。\n"
"この型の2つの構築子は`Lin`と`(:<)`（*snoc*演算子と呼ばれます）です。\n"
"モジュール`Data.SnocList`は*フィッシュ*と*チップス*（`(<><)`と`(<>>)`）\n"
"と呼ばれる2つの末尾再帰演算子を輸出します。\n"
"これは`SnocList`と`List`とを行き来するためのものです。\n"
"演習を続ける前に、全ての新しいデータ構築子と演算子の型を眺めてください。"

#. type: Plain text
#: ../src/Tutorial/Folds.md:428
#, no-wrap
msgid ""
"   Implement a tail recursive version of `map` for `List`\n"
"   by using a `SnocList` to reassemble the mapped list. Use then\n"
"   the *chips* operator with a `Nil` argument to\n"
"   in the end convert the `SnocList` back to a `List`.\n"
msgstr ""
"   `SnocList`を使って写されたリストを再編成することで、`List`に`map`の末尾再帰版を実装してください。\n"
"   それから最後に`Nil`引数つきの*チップス*演算子を使って`SnocList`を`List`に変換して戻してください。\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Folds.md:429
#, no-wrap
msgid "   mapTR : (a -> b) -> List a -> List b\n"
msgstr "   mapTR : (a -> b) -> List a -> List b\n"

#. type: Bullet: '5. '
#: ../src/Tutorial/Folds.md:437
msgid ""
"Implement a tail recursive version of `filter`, which only keeps those "
"values in a list, which fulfill the given predicate. Use the same technique "
"as described in exercise 4."
msgstr ""
"末尾再帰版の`filter`を実装してください。\n"
"この関数は、リスト中の所与の条件を満足する値だけを保持します。\n"
"演習4で記載したのと同じ技法を使ってください。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Folds.md:438
#, no-wrap
msgid "   filterTR : (a -> Bool) -> List a -> List a\n"
msgstr "   filterTR : (a -> Bool) -> List a -> List a\n"

#. type: Bullet: '6. '
#: ../src/Tutorial/Folds.md:445
msgid ""
"Implement a tail recursive version of `mapMaybe`, which only keeps those "
"values in a list, for which the given function argument returns a `Just`:"
msgstr ""
"`mapMaybe`の末尾再帰版を実装してください。\n"
"この関数はリスト中の、所与の関数引数が`Just`を返すような値のみを保持します。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Folds.md:446
#, no-wrap
msgid "   mapMaybeTR : (a -> Maybe b) -> List a -> List b\n"
msgstr "   mapMaybeTR : (a -> Maybe b) -> List a -> List b\n"

#. type: Plain text
#: ../src/Tutorial/Folds.md:451
#, no-wrap
msgid "   Implement `catMaybesTR` in terms of `mapMaybeTR`:\n"
msgstr "   `mapMaybeTR`を使って`catMaybesTR`を実装してください。\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Folds.md:452
#, no-wrap
msgid "   catMaybesTR : List (Maybe a) -> List a\n"
msgstr "   catMaybesTR : List (Maybe a) -> List a\n"

#. type: Bullet: '7. '
#: ../src/Tutorial/Folds.md:457
msgid "Implement a tail recursive version of list concatenation:"
msgstr "リスト連結の末尾再帰版を実装してください。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Folds.md:458
#, no-wrap
msgid "   concatTR : List a -> List a -> List a\n"
msgstr "   concatTR : List a -> List a -> List a\n"

#. type: Bullet: '8. '
#: ../src/Tutorial/Folds.md:464
msgid "Implement tail recursive versions of *bind* and `join` for `List`:"
msgstr "リストの*束縛*と`join`の末尾再帰版を実装してください。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Folds.md:465
#, no-wrap
msgid ""
"   bindTR : List a -> (a -> List b) -> List b\n"
"\n"
"   joinTR : List (List a) -> List a\n"
msgstr ""
"   bindTR : List a -> (a -> List b) -> List b\n"
"\n"
"   joinTR : List (List a) -> List a\n"

#. type: Title ##
#: ../src/Tutorial/Folds.md:471
#, no-wrap
msgid "A few Notes on Totality Checking"
msgstr "全域性検査について少々補足"

#. type: Plain text
#: ../src/Tutorial/Folds.md:482
msgid ""
"The totality checker in Idris verifies, that at least one (possibly erased!) "
"argument in a recursive call converges towards a base case. For instance, "
"with natural numbers, if the base case is zero (corresponding to data "
"constructor `Z`), and we continue with `k` after pattern matching on `S k`, "
"Idris can derive from `Nat`'s constructors, that `k` is strictly smaller "
"than `S k` and therefore the recursive call must converge towards a base "
"case.  Exactly the same reasoning is used when pattern matching on a list "
"and continuing only with its tail in the recursive call."
msgstr ""
"Idrisの全域性検査器が確証しているのは、\n"
"再帰呼び出しでの少なくとも1つの引数（消去されうるものです！）が、基底の場合に"
"向かって収束することです。\n"
"例えば自然数があったとき、基底の場合がゼロ（データ構築子`Z`に対応）であり、\n"
"`S k`でパターン照合したあとは`k`で続いているとします。\n"
"このときIdrisは`Nat`の構築子を以って、`k`が`S k`より厳密に小さいため、\n"
"再帰呼び出しは基底の場合に向かって収束するはずだと導出できるのです。\n"
"ちょうど同じ論拠が再帰呼び出しで尾鰭だけで続けるリストのパターン照合で用いら"
"れます。"

#. type: Plain text
#: ../src/Tutorial/Folds.md:487
msgid ""
"While this works in many cases, it doesn't always go as expected.  Below, "
"I'll show you a couple of examples where totality checking fails, although "
"*we* know, that the functions in question are definitely total."
msgstr ""
"これは多くの場合で機能しますが、常に期待通りにいくわけではありません。\n"
"以下では、*私達は*問題の関数が間違いなく全域だとわかるものの、\n"
"全域性検査が失敗する例をいくつかお見せします。"

#. type: Title ###
#: ../src/Tutorial/Folds.md:488
#, no-wrap
msgid "Case 1: Recursion over a Primitive"
msgstr "事例1：原始型での再帰"

#. type: Plain text
#: ../src/Tutorial/Folds.md:494
msgid ""
"Idris doesn't know anything about the internal structure of primitive data "
"types. So the following function, although being obviously total, will not "
"be accepted by the totality checker:"
msgstr ""
"Idrisは原始的なデータ型の内部構造について何も知りません。\n"
"なので以下の関数は明らかに全域ですが、全域性検査が受けつけようとしません。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Folds.md:495
#, no-wrap
msgid ""
"covering\n"
"replicatePrim : Bits32 -> a -> List a\n"
"replicatePrim 0 v = []\n"
"replicatePrim x v = v :: replicatePrim (x - 1) v\n"
msgstr ""
"covering\n"
"replicatePrim : Bits32 -> a -> List a\n"
"replicatePrim 0 v = []\n"
"replicatePrim x v = v :: replicatePrim (x - 1) v\n"

#. type: Plain text
#: ../src/Tutorial/Folds.md:514
msgid ""
"Unlike with natural numbers (`Nat`), which are defined as an inductive data "
"type and are only converted to integer primitives during compilation, Idris "
"can't tell that `x - 1` is strictly smaller than `x`, and so it fails to "
"verify that this must converge towards the base case.  (The reason is, that "
"`x - 1` is implemented in terms of primitive function `prim__sub_Bits32`, "
"which is built into the compiler and must be implemented by each backend "
"individually. The totality checker knows about data types, constructors, and "
"functions defined in Idris, but not about (primitive) functions and foreign "
"functions implemented at the backends. While it is theoretically possible to "
"also define and use laws for primitive and foreign functions, this hasn't "
"yet been done for most of them.)"
msgstr ""
"自然数 (`Nat`) は帰納的データ型として定義されコンパイル時にのみ整数の原始型に"
"変換されます。\n"
"これとは違い、Idrisには`x - 1`が厳密に`x`よりも小さいかがわからず、\n"
"そのためこれが基底の場合に向かって収束するはずだと確証するのに失敗するので"
"す。\n"
"（その理由は、`x - 1`が原始関数`prim__sub_Bits32`を使って実装されているからで"
"す。\n"
"この関数はコンパイラに備わっており、それぞれ個別のバックエンドで実装されてい"
"なくてはなりません。）\n"
"全域性検査器はIdrisで定義されたデータ型、構築子、関数について知っています"
"が、\n"
"バックエンドで実装された（原始）関数や異邦関数についてはその限りではありませ"
"ん。\n"
"理論的には原始型や異邦関数に法則を定義して使うこともできるのですが、\n"
"これはまだほとんどのものについて完了していません。"

#. type: Plain text
#: ../src/Tutorial/Folds.md:520
msgid ""
"Since non-totality is highly contagious (all functions invoking a partial "
"function are themselves considered to be partial by the totality checker), "
"there is utility function `assert_smaller`, which we can use to convince the "
"totality checker and still annotate our functions with the `total` keyword:"
msgstr ""
"非全域性はかなり感染力が高いため（部分関数を呼び出す全ての関数は全域性検査器"
"によって部分的だと見なされます）、\n"
"小間物関数`assert_smaller`があります。\n"
"この関数を使えば全域性検査器を説得し、さらに`total`キーワードを関数に註釈付け"
"ることができます。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Folds.md:521
#, no-wrap
msgid ""
"replicatePrim' : Bits32 -> a -> List a\n"
"replicatePrim' 0 v = []\n"
"replicatePrim' x v = v :: replicatePrim' (assert_smaller x $ x - 1) v\n"
msgstr ""
"replicatePrim' : Bits32 -> a -> List a\n"
"replicatePrim' 0 v = []\n"
"replicatePrim' x v = v :: replicatePrim' (assert_smaller x $ x - 1) v\n"

#. type: Plain text
#: ../src/Tutorial/Folds.md:532
msgid ""
"Please note, though, that whenever you use `assert_smaller` to silence the "
"totality checker, the burden of proving totality rests on your shoulders. "
"Failing to do so can lead to arbitrary and unpredictable program behavior "
"(which is the default with most other programming languages)."
msgstr ""
"ただし、全域性検査器を静かにさせるために`assert_smaller`を使うときは、\n"
"全域性を証明する責任が自分の肩にのしかかっていることに注意してください。\n"
"それをし損なうとありとあらゆる予期しないプログラムの振舞いに繋がる可能性があ"
"ります。\n"
"（これはほとんどの他のプログラミング言語でも言えます。）"

#. type: Title ####
#: ../src/Tutorial/Folds.md:533
#, no-wrap
msgid "Ex Falso Quodlibet"
msgstr "Ex Falso Quodlibet"

#. type: Plain text
#: ../src/Tutorial/Folds.md:543
msgid ""
"Below - as a demonstration - is a simple proof of `Void`.  `Void` is an "
"*uninhabited type*: a type with no values.  *Proofing `Void`* means, that we "
"implement a function accepted by the totality checker, which returns a value "
"of type `Void`, although this is supposed to be impossible as there is no "
"such value. Doing so allows us to completely disable the type system "
"together with all the guarantees it provides.  Here's the code and its dire "
"consequences:"
msgstr ""
"以下はとある実演で、素朴な`Void`の証明です。\n"
"`Void`は*傍若無人型*、つまりは値のない型です。\n"
"*`Void`を証明する*ことが意味するのは、全域性検査器に受け入れられる関数を実装"
"することであり、\n"
"そんな値はないので不可能でなくてはいけないにも関わらず、この関数は型`Void`の"
"値を返します。\n"
"そうすることで型システムと提供されていた全ての保証諸共、完全に無効にすること"
"ができます。\n"
"以下はコードとその惨憺たる結果です。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Folds.md:544
#, no-wrap
msgid ""
"-- In order to proof `Void`, we just loop forever, using\n"
"-- `assert_smaller` to silence the totality checker.\n"
"proofOfVoid : Bits8 -> Void\n"
"proofOfVoid n = proofOfVoid (assert_smaller n n)\n"
"\n"
"-- From a value of type `Void`, anything follows!\n"
"-- This function is safe and total, as there is no\n"
"-- value of type `Void`!\n"
"exFalsoQuodlibet : Void -> a\n"
"exFalsoQuodlibet _ impossible\n"
"\n"
"-- By passing our proof of void to `exFalsoQuodlibet`\n"
"-- (exported by the *Prelude* by the name of `void`), we\n"
"-- can coerce any value to a value of any other type.\n"
"-- This renders type checking completely useless, as\n"
"-- we can freely convert between values of different\n"
"-- types.\n"
"coerce : a -> b\n"
"coerce _ = exFalsoQuodlibet (proofOfVoid 0)\n"
"\n"
"-- Finally, we invoke `putStrLn` with a number instead\n"
"-- of a string. `coerce` allows us to do just that.\n"
"pain : IO ()\n"
"pain = putStrLn $ coerce 0\n"
msgstr ""
"-- `Void`を証明するためには、ただ無限ループさせればよいです。\n"
"-- `assert_smaller`を使って全域性検査器を大人しくさせます。\n"
"proofOfVoid : Bits8 -> Void\n"
"proofOfVoid n = proofOfVoid (assert_smaller n n)\n"
"\n"
"-- 型`Void`の値からはどんなことも従います！\n"
"-- 型`Void`の値はないので、この関数は安全で全域なのです！\n"
"exFalsoQuodlibet : Void -> a\n"
"exFalsoQuodlibet _ impossible\n"
"\n"
"-- voidの証明を`exFalsoQuodlibet`（`void`の名前で*Prelude*から輸出されています）に通すことで、\n"
"-- どんな値も別の型の値に押し込むことができます。\n"
"-- 異なる型の値に自由に変換できてしまっては、\n"
"-- 型検査が全くの役立たずになってしまいました。\n"
"coerce : a -> b\n"
"coerce _ = exFalsoQuodlibet (proofOfVoid 0)\n"
"\n"
"-- 最後に文字列の代わりに数字で`putStrLn`を呼び出します。\n"
"-- `coerce`があればそれさえできてしまいます。\n"
"pain : IO ()\n"
"pain = putStrLn $ coerce 0\n"

#. type: Plain text
#: ../src/Tutorial/Folds.md:576
msgid ""
"Please take a moment to marvel at provably total function `coerce`: It "
"claims to convert *any* value to a value of *any* other type.  And it is "
"completely safe, as it only uses total functions in its implementation. The "
"problem is - of course - that `proofOfVoid` should never ever have been a "
"total function."
msgstr ""
"しばし証明的に全域な関数`coerce`に嘆じましょう。\n"
"この関数は*いかなる*値も*いかなる*他の型の値に変換することができると主張して"
"いるのです。\n"
"そしてそれは完全に安全で、なぜなら実装で全域関数のみを使っているからです。\n"
"問題があるとすれば……もちろん……`proofOfVoid`はどんなことがあろうと全域関数では"
"ないことです。"

#. type: Plain text
#: ../src/Tutorial/Folds.md:581
msgid ""
"In `pain` we use `coerce` to conjure a string from an integer.  In the end, "
"we get what we deserve: The program crashes with an error.  While things "
"could have been much worse, it can still be quite time consuming and "
"annoying to localize the source of such an error."
msgstr ""
"`pain`で`coerce`を使って整数から文字列をでっち上げました。\n"
"最終的には自業自得となります。\n"
"要はプログラムがエラーでクラッシュするのです。\n"
"事態がこれよりさらに悪くなることもありえたでしょう。\n"
"実行にかなりの時間が費された挙句そのようなエラーの発生箇所を見つけ出すのが厄"
"介になる可能性がありますから。"

#. type: Fenced code block (sh)
#: ../src/Tutorial/Folds.md:582
#, no-wrap
msgid ""
"$ idris2 --cg node --exec pain --find-ipkg src/Tutorial/Folds.md\n"
"ERROR: No clauses\n"
msgstr ""
"$ idris2 --cg node --exec pain --find-ipkg src/Tutorial/Folds.md\n"
"ERROR: No clauses\n"

#. type: Plain text
#: ../src/Tutorial/Folds.md:590
msgid ""
"So, with a single thoughtless placement of `assert_smaller` we wrought havoc "
"within our pure and total codebase sacrificing totality and type safety in "
"one fell swoop. Therefore: Use at your own risk!"
msgstr ""
"というわけで、たった1つでも無考えに`assert_smaller`を置くと、\n"
"全域性と型安全性が犠牲にされた純粋で全域なコードベースの裡で一挙に大惨事に見"
"舞われるのです。\n"
"したがって、自己責任で使ってください！"

#. type: Plain text
#: ../src/Tutorial/Folds.md:594
msgid ""
"Note: I do not expect you to understand all the dark magic at work in the "
"code above. I'll explain the details in due time in another chapter."
msgstr ""
"補足：上のコード中で動いている全ての暗黒魔法を理解することは期待していませ"
"ん。\n"
"別の章でその時がきたら詳細をご説明しましょう。"

#. type: Plain text
#: ../src/Tutorial/Folds.md:602
msgid ""
"Second note: *Ex falso quodlibet*, also called [the principle of explosion]"
"(https://en.wikipedia.org/wiki/Principle_of_explosion)  is a law in "
"classical logic: From a contradiction, any statement can be proven.  In our "
"case, the contradiction was our proof of `Void`: The claim that we wrote a "
"total function producing such a value, although `Void` is an uninhabited "
"type.  You can verify this by inspecting `Void` at the REPL with `:doc "
"Void`: It has no data constructors."
msgstr ""
"2つめの補足：*Ex falso quodlibet*、またの名を[爆発の原理](https://en."
"wikipedia.org/wiki/Principle_of_explosion)は古典論理の法則の1つです。\n"
"矛盾からはいかなる記述も証明されたものにできるというものです。\n"
"今回の場合、矛盾は`Void`の証明にありました。\n"
"`Void`は傍若無人型なのに、そのような値を生み出す全域関数を書いたと主張するこ"
"とがこれにあたるのです。\n"
"このことは`Void`をREPLで`:doc Void`で調べれば確かめることができます。\n"
"これにはデータ構築子がないのです。"

#. type: Title ###
#: ../src/Tutorial/Folds.md:603
#, no-wrap
msgid "Case 2: Recursion via Function Calls"
msgstr "事例2：関数呼び出しを介した再帰"

#. type: Plain text
#: ../src/Tutorial/Folds.md:608
msgid ""
"Below is an implementation of a [*rose tree*](https://en.wikipedia.org/wiki/"
"Rose_tree).  Rose trees can represent search paths in computer algorithms, "
"for instance in graph theory."
msgstr ""
"以下は[*木薔薇*](https://en.wikipedia.org/wiki/Rose_tree)の実装です。\n"
"木薔薇はコンピュータアルゴリズムにおける探索経路を表現することができます。\n"
"グラフ理論がその一例です。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Folds.md:609
#, no-wrap
msgid ""
"record Tree a where\n"
"  constructor Node\n"
"  value  : a\n"
"  forest : List (Tree a)\n"
"\n"
"Forest : Type -> Type\n"
"Forest = List . Tree\n"
msgstr ""
"record Tree a where\n"
"  constructor Node\n"
"  value  : a\n"
"  forest : List (Tree a)\n"
"\n"
"Forest : Type -> Type\n"
"Forest = List . Tree\n"

#. type: Plain text
#: ../src/Tutorial/Folds.md:620
msgid "We could try and compute the size of such a tree as follows:"
msgstr "以下のようにそのような木の大きさの計算を試みることができます。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Folds.md:621
#, no-wrap
msgid ""
"covering\n"
"size : Tree a -> Nat\n"
"size (Node _ forest) = S . sum $ map size forest\n"
msgstr ""
"covering\n"
"size : Tree a -> Nat\n"
"size (Node _ forest) = S . sum $ map size forest\n"

#. type: Plain text
#: ../src/Tutorial/Folds.md:632
msgid ""
"In the code above, the recursive call happens within `map`. *We* know that "
"we are using only subtrees in the recursive calls (since we know how `map` "
"is implemented for `List`), but Idris can't know this (teaching a totality "
"checker how to figure this out on its own seems to be an open research "
"question). So it will refuse to accept the function as being total."
msgstr ""
"上のコードでは再帰呼び出しは`map`の内側で起こっており、\n"
"*私達は*再帰呼び出しで副木しか使っていないことがわかります。\n"
"（どのように`map`が`List`に実装されているか知っているからです。）\n"
"でもIdrisはこのことを知らないのです。\n"
"（全域性検査器に自力でこれを調べさせることは研究の余地がある問題のようで"
"す。）\n"
"だから関数が全域であるとして認めることを拒みます。"

#. type: Plain text
#: ../src/Tutorial/Folds.md:637
msgid ""
"There are two ways to handle the case above. If we don't mind writing a bit "
"of otherwise unneeded boilerplate code, we can use explicit recursion.  In "
"fact, since we often also work with search *forests*, this is the preferable "
"way here."
msgstr ""
"上記の場合に対処するには2つの方法があります。\n"
"少々の余計な紋切り型のコードを書くのが気にならなければ、明示的な再帰を使うこ"
"とができます。\n"
"実際*森*の探索に取り組むこともよくあるので、ここではより好ましい手段です。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Folds.md:638
#, no-wrap
msgid ""
"mutual\n"
"  treeSize : Tree a -> Nat\n"
"  treeSize (Node _ forest) = S $ forestSize forest\n"
"\n"
"  forestSize : Forest a -> Nat\n"
"  forestSize []        = 0\n"
"  forestSize (x :: xs) = treeSize x + forestSize xs\n"
msgstr ""
"mutual\n"
"  treeSize : Tree a -> Nat\n"
"  treeSize (Node _ forest) = S $ forestSize forest\n"
"\n"
"  forestSize : Forest a -> Nat\n"
"  forestSize []        = 0\n"
"  forestSize (x :: xs) = treeSize x + forestSize xs\n"

#. type: Plain text
#: ../src/Tutorial/Folds.md:652
msgid ""
"In the case above, Idris can verify that we don't blow up our trees behind "
"its back as we are explicit about what happens in each recursive step.  This "
"is the safe, preferable way of going about this, especially if you are new "
"to the language and totality checking in general."
msgstr ""
"上の場合、それぞれの再帰の工程で何が起こるのか明示しているので、\n"
"Idrisは陰で木が膨れ上がらないことを確かめられます。\n"
"本事例に向き合う上ではこれが安全で、より好ましい方法です。\n"
"この言語や全域性検査を始めたばかりなら特にそうです。"

#. type: Plain text
#: ../src/Tutorial/Folds.md:655
msgid ""
"However, sometimes the solution presented above is just too cumbersome to "
"write. For instance, here is an implementation of `Show` for rose trees:"
msgstr ""
"しかし時には上で示した解法を書くのがあまりにも億劫すぎることがあります。\n"
"例えば以下は木薔薇への`Show`の実装です。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Folds.md:656
#, no-wrap
msgid ""
"Show a => Show (Tree a) where\n"
"  showPrec p (Node v ts) =\n"
"    assert_total $ showCon p \"Node\" (showArg v ++ showArg ts)\n"
msgstr ""
"Show a => Show (Tree a) where\n"
"  showPrec p (Node v ts) =\n"
"    assert_total $ showCon p \"Node\" (showArg v ++ showArg ts)\n"

#. type: Plain text
#: ../src/Tutorial/Folds.md:667
msgid ""
"In this case, we'd have to manually reimplement `Show` for lists of trees: A "
"tedious task - and error-prone on its own. Instead, we resort to using the "
"mighty sledgehammer of totality checking: `assert_total`. Needless to say "
"that this comes with the same risks as `assert_smaller`, so be very careful."
msgstr ""
"この場合、木のリストに`Show`を手作業で再実装しなくてはなりません。\n"
"退屈な仕事であり……それ自体がエラーの温床になります。\n"
"代わりに全域性検査器を木っ端微塵にする手段を行使できます。\n"
"それが`assert_total`です。\n"
"言うまでもなくこれには`assert_smaller`と同じ危険性が付き纏うので、充分注意し"
"てください。"

#. type: Plain text
#: ../src/Tutorial/Folds.md:673
msgid ""
"Implement the following functions in a provably total way without \"cheating"
"\". Note: It is not necessary to implement these in a tail recursive way."
msgstr ""
"以下の関数を「ズル」せずに証明的に全域な風に実装してください。\n"
"補足：末尾再帰の方法で実装する必要はありません。"

#. type: Plain text
#: ../src/Tutorial/Folds.md:682
#, no-wrap
msgid ""
"<!-- textlint-disable terminology -->\n"
"1. Implement function `depth` for rose trees. This\n"
"   should return the maximal number of `Node` constructors\n"
"   from the current node to the farthest child node.\n"
"   For instance, the current node should be at depth one,\n"
"   all its direct child nodes are at depth two, their\n"
"   immediate child nodes at depth three and so on.\n"
"<!-- textlint-enable -->\n"
msgstr ""
"<!-- textlint-disable terminology -->\n"
"1. 木薔薇に関数`depth`を実装してください。\n"
"   これは現在のノードから最も遠くにある小ノードまでの`Node`構築子の最大数を返します。\n"
"   例えば現在のノードが深さ1のとき、全ての直接の小ノードは深さが2であり、\n"
"   それらの直接の子ノードは深さ3にある、などといった具合です。\n"
"<!-- textlint-enable -->\n"

#. type: Bullet: '2. '
#: ../src/Tutorial/Folds.md:684
msgid "Implement interface `Eq` for rose trees."
msgstr "インスタンス`Eq`を木薔薇に実装してください。"

#. type: Bullet: '3. '
#: ../src/Tutorial/Folds.md:686
msgid "Implement interface `Functor` for rose trees."
msgstr "インターフェース`Functor`を木薔薇に実装してください。"

#. type: Bullet: '4. '
#: ../src/Tutorial/Folds.md:688
msgid "For the fun of it: Implement interface `Show` for rose trees."
msgstr "インターフェース`Show`を木薔薇に実装しましょう。お楽しみください。"

#. type: Bullet: '5. '
#: ../src/Tutorial/Folds.md:692
msgid ""
"In order not to forget how to program with dependent types, implement "
"function `treeToVect` for converting a rose tree to a vector of the correct "
"size."
msgstr ""
"依存型でプログラムする方法を忘れないよう、\n"
"木薔薇を正しい大きさのベクタに変換する関数`treeToVect`を実装してください。"

#. type: Plain text
#: ../src/Tutorial/Folds.md:696
#, no-wrap
msgid ""
"   Hint: Make sure to follow the same recursion scheme as in\n"
"   the implementation of `treeSize`. Otherwise, this might be\n"
"   very hard to get to work.\n"
msgstr ""
"   ヒント：`treeSize`の実装と同じ再帰構造に従うようにしてください。\n"
"   さもないと取り掛かるのがとても難しいでしょうから。\n"

#. type: Title ##
#: ../src/Tutorial/Folds.md:697
#, no-wrap
msgid "Interface Foldable"
msgstr "インターフェースFoldable"

#. type: Plain text
#: ../src/Tutorial/Folds.md:707
#, fuzzy
#| msgid ""
#| "When looking back at all the exercises we solved in the section about "
#| "recursion, most tail recursive functions on lists where of the following "
#| "pattern: Iterate over all list elements from head to tail while passing "
#| "along some state for accumulating intermediate results. At the end of the "
#| "list, return the final state or convert it with an additional function "
#| "call."
msgid ""
"When looking back at all the exercises we solved in the section about "
"recursion, most tail recursive functions on lists were of the following "
"pattern: Iterate over all list elements from head to tail while passing "
"along some state for accumulating intermediate results. At the end of the "
"list, return the final state or convert it with an additional function call."
msgstr ""
"再帰についての節で解いた全演習を振り返ると、リストにおけるほとんどの末尾再帰"
"関数が次の様式になっています。\n"
"つまり、先頭から尾鰭までの全てのリストの要素を巡回しつつ、中間結果を累積する"
"何らかの状態を渡すというものです。\n"
"リストの終端では最終的な状態を返すか追加の関数呼び出しにより変換するかしま"
"す。"

#. type: Title ###
#: ../src/Tutorial/Folds.md:708
#, no-wrap
msgid "Left Folds"
msgstr "左畳み込み"

#. type: Plain text
#: ../src/Tutorial/Folds.md:719
#, no-wrap
msgid ""
"This is functional programming, and we'd like to abstract\n"
"over such reoccurring patterns. In order to tail recursively\n"
"iterate over a list, all we need is an accumulator function\n"
"and some initial state. But what should be the type of\n"
"the accumulator? Well, it combines the current state\n"
"with the list's next element and returns an updated\n"
"state: `state -> elem -> state`. Surely, we can come\n"
"up with a higher-order function to encapsulate this\n"
"behavior:\n"
msgstr ""
"ここでは関数型プログラミングをしており、そのような反復される様式は抽象化したいところです。\n"
"リストで末尾再帰的に巡回するためになくてはならないのは、\n"
"累積関数と何らかの初期状態だけです。\n"
"でも累積器の型はどうすべきなのでしょう？\n"
"そうですね、現在の状態とリストの次の要素をまとめて更新された状態を返すもの、つまり`state -> elem -> state`です。\n"
"もちろんこの振舞いを内蔵化する高階関数が頭に浮かびます。\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Folds.md:720
#, no-wrap
msgid ""
"leftFold : (acc : state -> el -> state) -> (st : state) -> List el -> state\n"
"leftFold _   st []        = st\n"
"leftFold acc st (x :: xs) = leftFold acc (acc st x) xs\n"
msgstr ""
"leftFold : (acc : state -> el -> state) -> (st : state) -> List el -> state\n"
"leftFold _   st []        = st\n"
"leftFold acc st (x :: xs) = leftFold acc (acc st x) xs\n"

#. type: Plain text
#: ../src/Tutorial/Folds.md:734
msgid ""
"We call this function a *left fold*, as it iterates over the list from left "
"to right (head to tail), collapsing (or *folding*) the list until just a "
"single value remains.  This new value might still be a list or other "
"container type, but the original list has been consumed from head to tail.  "
"Note how `leftFold` is tail recursive, and therefore all functions "
"implemented in terms of `leftFold` are tail recursive (and thus, stack "
"safe!) as well."
msgstr ""
"この関数を*左畳み込み*と呼びますが、\n"
"それはリストを左から右（先頭から尾鰭へ）巡回し、\n"
"たった1つの値が残るまでリストを押し潰す（あるいは*畳み込む*）からです。\n"
"この新しい値はリストのままでも他の容器型でもよいのですが、\n"
"元のリストは徹頭徹尾消費されます。\n"
"`leftFold`が末尾再帰なことに注目してください。\n"
"したがって`leftFold`を利用して実装された全ての関数もまた末尾再帰（なのでス"
"タック安全！）なのです。"

#. type: Plain text
#: ../src/Tutorial/Folds.md:736
msgid "Here are a few examples:"
msgstr "以下はいくつかの例です。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Folds.md:737
#, no-wrap
msgid ""
"sumLF : Num a => List a -> a\n"
"sumLF = leftFold (+) 0\n"
"\n"
"reverseLF : List a -> List a\n"
"reverseLF = leftFold (flip (::)) Nil\n"
"\n"
"-- this is more natural than `reverseLF`!\n"
"toSnocListLF : List a -> SnocList a\n"
"toSnocListLF = leftFold (:<) Lin\n"
msgstr ""
"sumLF : Num a => List a -> a\n"
"sumLF = leftFold (+) 0\n"
"\n"
"reverseLF : List a -> List a\n"
"reverseLF = leftFold (flip (::)) Nil\n"
"\n"
"-- this is more natural than `reverseLF`!\n"
"toSnocListLF : List a -> SnocList a\n"
"toSnocListLF = leftFold (:<) Lin\n"

#. type: Title ###
#: ../src/Tutorial/Folds.md:749
#, no-wrap
msgid "Right Folds"
msgstr "右畳み込み"

#. type: Plain text
#: ../src/Tutorial/Folds.md:760
msgid ""
"The example functions we implemented in terms of `leftFold` had to always "
"completely traverse the whole list, as every single element was required to "
"compute the result. This is not always necessary, however. For instance, if "
"you look at `findList` from the exercises, we could abort iterating over the "
"list as soon as our search was successful. It is *not* possible to implement "
"this more efficient behavior in terms of `leftFold`: There, the result will "
"only be returned when our pattern match reaches the `Nil` case."
msgstr ""
"`leftFold`を利用して実装した関数の例では常にリスト全体を完璧に巡回する必要が"
"ありましたが、\n"
"それは結果を計算するのに全ての要素1つ1つが必要だからです。\n"
"しかし私達にとっていつも必要とは限りません。\n"
"例えば演習の`findList`を見ると探索が成功するやいなやリストの巡回を中断できま"
"した。\n"
"`leftFold`を使っていてはより効率的な振舞いを実装することは*不*可能です。\n"
"というのも、結果が返されるおはパターン照合が`Nil`の場合に到達したときだけだか"
"らです。"

#. type: Plain text
#: ../src/Tutorial/Folds.md:765
msgid ""
"Interestingly, there is another, non-tail recursive fold, which reflects the "
"list structure more naturally, we can use for breaking out early from an "
"iteration. We call this a *right fold*. Here is its implementation:"
msgstr ""
"興味深いことに別の非末尾再帰な再帰畳み込みがあります。\n"
"より自然にリストの構造を反映しており、\n"
"これを使えば巡回中に早い時点で中断することができます。\n"
"*右畳み込み*と呼ばれるもので、以下がその実装です。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Folds.md:766
#, no-wrap
msgid ""
"rightFold : (acc : el -> state -> state) -> state -> List el -> state\n"
"rightFold acc st []        = st\n"
"rightFold acc st (x :: xs) = acc x (rightFold acc st xs)\n"
msgstr ""
"rightFold : (acc : el -> state -> state) -> state -> List el -> state\n"
"rightFold acc st []        = st\n"
"rightFold acc st (x :: xs) = acc x (rightFold acc st xs)\n"

#. type: Plain text
#: ../src/Tutorial/Folds.md:775
msgid ""
"Now, it might not immediately be obvious how this differs from `leftFold`.  "
"In order to see this, we will have to talk about lazy evaluation first."
msgstr ""
"さて、すぐにはこれが`leftFold`とどう違うのかはっきりしないでしょう。\n"
"それを知るにはまず、遅延評価についてお話ししなくてはなりません。"

#. type: Title ####
#: ../src/Tutorial/Folds.md:776
#, no-wrap
msgid "Lazy Evaluation in Idris"
msgstr "Idrisでの遅延評価"

#. type: Plain text
#: ../src/Tutorial/Folds.md:784
msgid ""
"For some computations, it is not necessary to evaluate all function "
"arguments in order to return a result. For instance, consider boolean "
"operator `(&&)`: If the first argument evaluates to `False`, we already know "
"that the result is `False` without even looking at the second argument. In "
"such a case, we don't want to unnecessarily evaluate the second argument, as "
"this might include a lengthy computation."
msgstr ""
"計算の中には、結果を返すために全ての関数の引数を評価する必要がないものもあり"
"ます。\n"
"例えば真偽値演算子`(&&)`を考えましょう。\n"
"最初の引数が`False`に評価されたら、もう2つの引数を見向きもせず結果が`False`な"
"のがわかります。\n"
"そのような場合、不要な2つ目の引数の評価はしたくありません。\n"
"長い計算が含まれているかもしれないからです。"

#. type: Plain text
#: ../src/Tutorial/Folds.md:786
msgid "Consider the following REPL session:"
msgstr "以下のREPLセッションについて考えましょう。"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Folds.md:787
#, no-wrap
msgid ""
"Tutorial.Folds> False && (length [1..10000000000] > 100)\n"
"False\n"
msgstr ""
"Tutorial.Folds> False && (length [1..10000000000] > 100)\n"
"False\n"

#. type: Plain text
#: ../src/Tutorial/Folds.md:797
msgid ""
"If the second argument were evaluated, this computation would most certainly "
"blow up your computer's memory, or at least take a very long time to run to "
"completion. However, in this case, the result `False` is printed "
"immediately. If you look at the type of `(&&)`, you'll see the following:"
msgstr ""
"2つ目の引数が評価されるなら、この計算はきっとコンピュータのメモリを吹っ飛ばし"
"てしまうか、\n"
"少なくとも計算を走らせるのにとても長い時間が掛かるでしょう。\n"
"しかしこの場合、結果の`False`が直ちに印字されます。\n"
"`(&&)`の方を見ると以下とあることがわかります。"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Folds.md:798
#, no-wrap
msgid ""
"Tutorial.Folds> :t (&&)\n"
"Prelude.&& : Bool -> Lazy Bool -> Bool\n"
msgstr ""
"Tutorial.Folds> :t (&&)\n"
"Prelude.&& : Bool -> Lazy Bool -> Bool\n"

#. type: Plain text
#: ../src/Tutorial/Folds.md:816
msgid ""
"As you can see, the second argument is wrapped in a `Lazy` type constructor. "
"This is a built-in type, and the details are handled by Idris automatically "
"most of the time. For instance, when passing arguments to `(&&)`, we don't "
"have to manually wrap the values in some data constructor.  A lazy function "
"argument will only be evaluated at the moment it is *required* in the "
"function's implementation, for instance, because it is being pattern matched "
"on, or it is being passed as a strict argument to another function. In the "
"implementation of `(&&)`, the pattern match happens on the first argument, "
"so the second will only be evaluated if the first argument is `True` and the "
"second is returned as the function's (strict) result."
msgstr ""
"見てとれるように、2つ目の引数は`Lazy`型構築子に包まれています。\n"
"これは組み込み型で、ほとんどの場合はIdrisが自動的に細々としたことを制御しま"
"す。\n"
"例えば引数を`(&&)`に渡したとき、値を何らかのデータ構築子に手作業で包む必要は"
"ありません。\n"
"遅延関数引数は関数の実装で*必要とされる*瞬間にのみ評価されます。\n"
"例えばパターン照合されたり他の関数の厳密な引数に渡されたりするときです。\n"
"`(&&)`の実装では最初の引数でパターン照合が起こっているので、\n"
"2つ目の引数が評価されるのは最初の引数が`True`のときだけで、\n"
"関数の（正格な）結果として返されます。"

#. type: Plain text
#: ../src/Tutorial/Folds.md:821
#, fuzzy
#| msgid ""
#| "There are two utility functions for working with lazy evaluation: "
#| "Function `delay` wraps a value in the `Lazy` data type. Note, that the "
#| "argument of `lazy` is strict, so the following might take several seconds "
#| "to print its result:"
msgid ""
"There are two utility functions for working with lazy evaluation: Function "
"`delay` wraps a value in the `Lazy` data type. Note, that the argument of "
"`delay` is strict, so the following might take several seconds to print its "
"result:"
msgstr ""
"遅延評価に取り組む上で2つの小間物関数があります。\n"
"関数`delay`は値を`Lazy`データ型に包みます。\n"
"なお、`lazy`の引数は正格なので、以下は結果を印字するのに数秒掛かるかもしれま"
"せん。"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Folds.md:822
#, no-wrap
msgid ""
"Tutorial.Folds> False && (delay $ length [1..10000] > 100)\n"
"False\n"
msgstr ""
"Tutorial.Folds> False && (delay $ length [1..10000] > 100)\n"
"False\n"

#. type: Plain text
#: ../src/Tutorial/Folds.md:829
msgid ""
"In addition, there is function `force`, which forces evaluation of a `Lazy` "
"value."
msgstr "加えて関数`force`があり、これは`Lazy`値の評価を強制します。"

#. type: Title ####
#: ../src/Tutorial/Folds.md:830
#, no-wrap
msgid "Lazy Evaluation and Right Folds"
msgstr "遅延評価と右畳み込み"

#. type: Plain text
#: ../src/Tutorial/Folds.md:838
msgid ""
"We will now learn how to make use of `rightFold` and lazy evaluation to "
"implement folds, which can break out from iteration early.  Note, that in "
"the implementation of `rightFold` the result of folding over the remainder "
"of the list is passed as an argument to the accumulator (instead of the "
"result of invoking the accumulator being used in the recursive call):"
msgstr ""
"これで繰返しから早期に中断できる畳み込みを実装するための`rightFold`と遅延評価"
"の使いかたがわかりました。\n"
"なお`rightFold`の実装では残りのリストを畳み込む結果が累積器に渡されていま"
"す。\n"
"（再帰呼び出しで使われる累積器を呼び出した結果ではありません。）"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Folds.md:839
#, no-wrap
msgid "rightFold acc st (x :: xs) = acc x (rightFold acc st xs)\n"
msgstr "rightFold acc st (x :: xs) = acc x (rightFold acc st xs)\n"

#. type: Plain text
#: ../src/Tutorial/Folds.md:846
msgid ""
"If the second argument of `acc` were lazily evaluated, it would be possible "
"to abort the computation of `acc`'s result without having to iterate till "
"the end of the list:"
msgstr ""
"`acc`の2つ目の引数が遅延評価されるなら、\n"
"リストの終端まで繰り返すことなく`acc`の結果の計算を中断することが可能です。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Folds.md:847
#, no-wrap
msgid ""
"foldHead : List a -> Maybe a\n"
"foldHead = force . rightFold first Nothing\n"
"  where first : a -> Lazy (Maybe a) -> Lazy (Maybe a)\n"
"        first v _ = Just v\n"
msgstr ""
"foldHead : List a -> Maybe a\n"
"foldHead = force . rightFold first Nothing\n"
"  where first : a -> Lazy (Maybe a) -> Lazy (Maybe a)\n"
"        first v _ = Just v\n"

#. type: Plain text
#: ../src/Tutorial/Folds.md:858
msgid ""
"Note, how Idris takes care of the bookkeeping of laziness most of the time. "
"(It doesn't handle the curried invocation of `rightFold` correctly, though, "
"so we either must pass on the list argument of `foldHead` explicitly, or "
"compose the curried function with `force` to get the types right.)"
msgstr ""
"Idrisがほとんどの場合で遅延の予約を取り付けているところに注目してください。\n"
"（ただ`rightFold`のカリー化された呼び出しを正しく扱ってはいません。\n"
"なので`foldHead`のリスト引数に明示的に渡すか、\n"
"カリー化された関数に`force`をくっつけて型を正しくするかしないといけません。）"

#. type: Plain text
#: ../src/Tutorial/Folds.md:865
msgid ""
"In order to verify that this works correctly, we need a debugging utility "
"called `trace` from module `Debug.Trace`. This \"function\" allows us to "
"print debugging messages to the console at certain points in our pure code. "
"Please note, that this is for debugging purposes only and should never be "
"left lying around in production code, as, strictly speaking, printing stuff "
"to the console breaks referential transparency."
msgstr ""
"これが正しく動いていることを確かめるにはモジュール`Debug.trace`の`trace`と呼"
"ばれるデバッグ用の小間物が必要です。\n"
"この「関数」があれば純粋なコード中のどこかの時点で端末にデバッグ文言を印字さ"
"せられます。\n"
"ただしこれはデバッグ用途でのみのものであり、製品コードには決してあるべきでは"
"ありません。\n"
"というのも、厳密に言えば端末に何か印字することは参照透過性を壊しているからで"
"す。"

#. type: Plain text
#: ../src/Tutorial/Folds.md:868
msgid ""
"Here is an adjusted version of `foldHead`, which prints \"folded\" to "
"standard output every time utility function `first` is being invoked:"
msgstr ""
"以下は`foldHead`を調整した版です。\n"
"これは小間物関数`first`が呼び出されたときに毎回 \"folded\" と標準出力に印字し"
"ます。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Folds.md:869
#, no-wrap
msgid ""
"foldHeadTraced : List a -> Maybe a\n"
"foldHeadTraced = force . rightFold first Nothing\n"
"  where first : a -> Lazy (Maybe a) -> Lazy (Maybe a)\n"
"        first v _ = trace \"folded\" (Just v)\n"
msgstr ""
"foldHeadTraced : List a -> Maybe a\n"
"foldHeadTraced = force . rightFold first Nothing\n"
"  where first : a -> Lazy (Maybe a) -> Lazy (Maybe a)\n"
"        first v _ = trace \"folded\" (Just v)\n"

#. type: Plain text
#: ../src/Tutorial/Folds.md:879
msgid ""
"In order to test this at the REPL, we need to know that `trace` uses "
"`unsafePerformIO` internally and therefore will not reduce during "
"evaluation. We have to resort to the `:exec` command to see this in action "
"at the REPL:"
msgstr ""
"これをREPLで試すには、`trace`が内部的に`unsafePerformIO`を使っており、\n"
"したがって評価の最中は簡約されることがないことを知っておかねばなりません。\n"
"この動作をREPLで見るには`:exec`コマンドを行使する必要があります。"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Folds.md:880
#, no-wrap
msgid ""
"Tutorial.Folds> :exec printLn $ foldHeadTraced [1..10]\n"
"folded\n"
"Just 1\n"
msgstr ""
"Tutorial.Folds> :exec printLn $ foldHeadTraced [1..10]\n"
"folded\n"
"Just 1\n"

#. type: Plain text
#: ../src/Tutorial/Folds.md:888
msgid ""
"As you can see, although the list holds ten elements, `first` is only called "
"once resulting in a considerable increase of efficiency."
msgstr ""
"見てわかるようにリストには10個の要素がありますが、`first`は1度しか呼ばれてお"
"らず、\n"
"結果としてかなりの効率性の向上となっています。"

#. type: Plain text
#: ../src/Tutorial/Folds.md:891
msgid ""
"Let's see what happens, if we change the implementation of `first` to use "
"strict evaluation:"
msgstr ""
"`first`の実装を正格評価を使うように変えると何が起こるのか見てみましょう。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Folds.md:892
#, no-wrap
msgid ""
"foldHeadTracedStrict : List a -> Maybe a\n"
"foldHeadTracedStrict = rightFold first Nothing\n"
"  where first : a -> Maybe a -> Maybe a\n"
"        first v _ = trace \"folded\" (Just v)\n"
msgstr ""
"foldHeadTracedStrict : List a -> Maybe a\n"
"foldHeadTracedStrict = rightFold first Nothing\n"
"  where first : a -> Maybe a -> Maybe a\n"
"        first v _ = trace \"folded\" (Just v)\n"

#. type: Plain text
#: ../src/Tutorial/Folds.md:903
msgid ""
"Although we don't use the second argument in the implementation of `first`, "
"it is still being evaluated before evaluating the body of `first`, because "
"Idris - unlike Haskell! - defaults to use strict semantics. Here's how this "
"behaves at the REPL:"
msgstr ""
"2つ目の引数を`first`の実装で使っていませんが、\n"
"`frst`本体を評価する前にこの引数が評価されてしまっています。\n"
"これはIdrisが……Haskellとは違って！……既定で正格な意味論を使っているからで"
"す。\n"
"以下はこれのREPLでの振舞いです。"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Folds.md:904
#, no-wrap
msgid ""
"Tutorial.Folds> :exec printLn $ foldHeadTracedStrict [1..10]\n"
"folded\n"
"folded\n"
"folded\n"
"folded\n"
"folded\n"
"folded\n"
"folded\n"
"folded\n"
"folded\n"
"folded\n"
"Just 1\n"
msgstr ""
"Tutorial.Folds> :exec printLn $ foldHeadTracedStrict [1..10]\n"
"folded\n"
"folded\n"
"folded\n"
"folded\n"
"folded\n"
"folded\n"
"folded\n"
"folded\n"
"folded\n"
"folded\n"
"Just 1\n"

#. type: Plain text
#: ../src/Tutorial/Folds.md:925
msgid ""
"While this technique can sometimes lead to very elegant code, always "
"remember that `rightFold` is not stack safe in the general case. So, unless "
"your accumulator is not guaranteed to return a result after not too many "
"iterations, consider implementing your function tail recursively with an "
"explicit pattern match. Your code will be slightly more verbose, but with "
"the guaranteed benefit of stack safety."
msgstr ""
"この技法はときに大変流麗なコードに導いてくれますが、\n"
"`rightFold`が一般的な場合ではスタック安全でないことをいつも頭の片隅に置いてお"
"いてください。\n"
"なので、累積器がそれほど多くない反復の末に結果を返す保証がない、といったこと"
"がない限りは、\n"
"関数を明示的なパターン照合で末尾再帰に実装するよう検討してください。\n"
"コードは僅かにより冗長になるでしょうが、スタック安全という保証された利点が付"
"いてきます。"

#. type: Title ###
#: ../src/Tutorial/Folds.md:926
#, no-wrap
msgid "Folds and Monoids"
msgstr "畳み込みとモノイド"

#. type: Plain text
#: ../src/Tutorial/Folds.md:934
msgid ""
"Left and right folds share a common pattern: In both cases, we start with an "
"initial *state* value and use an accumulator function for combining the "
"current state with the current element. This principle of *combining values* "
"after starting from an *initial value* lies at the heart of an interface "
"we've already learned about: `Monoid`.  It therefore makes sense to fold a "
"list over a monoid:"
msgstr ""
"左右の畳み込みはよくある様式を共有しています。\n"
"両方とも初期*状態*値から始まり累積器関数を使って現在の状態に現在の要素を組み"
"合わせるのです。\n"
"この*初期値*から開始したあとに*値を組み合わせ*る*原理*は既に学んだインター"
"フェースの核心をついています。\n"
"それは`Monoid`です。\n"
"したがってモノイド上でリストを畳み込むことは納得がいきます。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Folds.md:935
#, no-wrap
msgid ""
"foldMapList : Monoid m => (a -> m) -> List a -> m\n"
"foldMapList f = leftFold (\\vm,va => vm <+> f va) neutral\n"
msgstr ""
"foldMapList : Monoid m => (a -> m) -> List a -> m\n"
"foldMapList f = leftFold (\\vm,va => vm <+> f va) neutral\n"

#. type: Plain text
#: ../src/Tutorial/Folds.md:946
msgid ""
"Note how, with `foldMapList`, we no longer need to pass an accumulator "
"function. All we need is a conversion from the element type to a type with "
"an implementation of `Monoid`. As we have already seen in the chapter about "
"[interfaces](Interfaces.md), there are *many* monoids in functional "
"programming, and therefore, `foldMapList` is an incredibly useful function."
msgstr ""
"なお、`foldMapList`ではもはや累積器関数を渡す必要がないようになっています。\n"
"しなければいけないことは要素の型から`Monoid`の実装された型への変換だけで"
"す。\n"
"[インターフェース](Interfaces.md)の章で既に見たように、関数型プログラミングに"
"は*数多くの*モノイドがあります。\n"
"したがって`foldMapList`はもの凄く便利な関数です。"

#. type: Plain text
#: ../src/Tutorial/Folds.md:950
msgid ""
"We could make this even shorter: If the elements in our list already are of "
"a type with a monoid implementation, we don't even need a conversion "
"function to collapse the list:"
msgstr ""
"これをもっと短くできます。\n"
"もしリストの要素の型がモノイドの実装を持っていたら、リストを押し潰すのに変換"
"関数さえも必要ではなくなります。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Folds.md:951
#, no-wrap
msgid ""
"concatList : Monoid m => List m -> m\n"
"concatList = foldMapList id\n"
msgstr ""
"concatList : Monoid m => List m -> m\n"
"concatList = foldMapList id\n"

#. type: Title ###
#: ../src/Tutorial/Folds.md:956
#, no-wrap
msgid "Stop Using `List` for Everything"
msgstr "どこでも`List`を使うのは止めよう"

#. type: Plain text
#: ../src/Tutorial/Folds.md:971
msgid ""
"And here we are, finally, looking at a large pile of utility functions all "
"dealing in some way with the concept of collapsing (or folding)  a list of "
"values into a single result. But all of these folding functions are just as "
"useful when working with vectors, with non-empty lists, with rose trees, "
"even with single-value containers like `Maybe`, `Either e`, or `Identity`. "
"Heck, for the sake of completeness, they are even useful when working with "
"zero-value containers like `Control.Applicative.Const e`! And since there "
"are so many of these functions, we'd better look out for an essential set of "
"them in terms of which we can implement all the others, and wrap up the "
"whole bunch in an interface. This interface is called `Foldable`, and is "
"available from the `Prelude`. When you look at its definition in the REPL (`:"
"doc Foldable`), you'll see that it consists of six essential functions:"
msgstr ""
"ついにここまで来ました。\n"
"山程の小間物関数を見てきました。\n"
"これらには全て何らかの方法で値のリストを単一の結果に押し潰す（または折り畳"
"む）着想がありました。\n"
"しかしこれら全ての折り畳み関数はリスト以外の型に取り組む際も同じように便利な"
"のです。\n"
"ベクタ、非空のリスト、木薔薇、\n"
"果ては`Maybe`、`Either e`、`Identity`といった単一値の容器がそうです。\n"
"まあ完全を期すなら、\n"
"`Control.Applicative.Const e`のようなゼロ個の値の容器に取り組むときさえも便利"
"なんですけどね！\n"
"そしてとても多くのこうした関数があるため、\n"
"それらの中から必要不可欠な集合を考えたほうがいいかもしれません。\n"
"それを使えば他の全てを実装でき、全体を1つのインターフェースに包むのに使えま"
"す。\n"
"このインターフェースは`Foldable`と呼ばれており、\n"
"`Prelude`で手に入ります。\n"
"REPLで定義を見ると (`:doc Foldable`) 6つの必須の関数が含まれていることがわか"
"ります。"

#. type: Bullet: '* '
#: ../src/Tutorial/Folds.md:978
msgid "`foldr`, for folds from the right"
msgstr "`foldr`: 右からの畳み込み用"

#. type: Bullet: '* '
#: ../src/Tutorial/Folds.md:978
msgid "`foldl`, for folds from the left"
msgstr "`foldl`: 左からの畳み込み用"

#. type: Bullet: '* '
#: ../src/Tutorial/Folds.md:978
msgid "`null`, for testing if the container is empty or not"
msgstr "`null`: 容器が空かどうかの確認用"

#. type: Bullet: '* '
#: ../src/Tutorial/Folds.md:978
#, fuzzy
#| msgid "`foldM`, for effectful folds in a monad"
msgid "`foldlM`, for effectful folds in a monad"
msgstr "`foldM`: モナドでの作用付き畳み込み用"

#. type: Bullet: '* '
#: ../src/Tutorial/Folds.md:978
msgid "`toList`, for converting the container to a list of values"
msgstr "`toList`: 容器から値のリストへの変換用"

#. type: Bullet: '* '
#: ../src/Tutorial/Folds.md:978
msgid "`foldMap`, for folding over a monoid"
msgstr "`foldMap`: モノイド上での畳み込み用"

#. type: Plain text
#: ../src/Tutorial/Folds.md:987
msgid ""
"For a minimal implementation of `Foldable`, it is sufficient to only "
"implement `foldr`. However, consider implementing all six functions "
"manually, because folds over container types are often performance critical "
"operations, and each of them should be optimized accordingly.  For instance, "
"implementing `toList` in terms of `foldr` for `List` just makes no sense, as "
"this is a non-tail recursive function running in linear time complexity, "
"while a hand-written implementation can just return its argument without any "
"modifications."
msgstr ""
"`Foldable`の最小の実装としては`foldr`を実装するだけで充分です。\n"
"しかし6つの関数を手作業で実装することを検討してください。\n"
"なぜなら容器型を折り畳むことはよく効率上致命的な操作となり、\n"
"それぞれ最適化されているべきだからです。\n"
"例えば`List`に`foldr`を使って`toList`を実装するのは単純に無意味です。\n"
"というのはこれが線形時間の複雑度で走る非末尾再帰関数だからです。\n"
"一方で手で書いた実装では引数を変更することなく返すだけでよいのです。"

#. type: Plain text
#: ../src/Tutorial/Folds.md:993
msgid ""
"In these exercises, you are going to implement `Foldable` for different data "
"types. Make sure to try and manually implement all six functions of the "
"interface."
msgstr ""
"この演習では`Foldable`を様々のデータ型で実装してきます。\n"
"インターフェースの6つの関数全てを手作業で頑張って実装してください。"

#. type: Bullet: '1. '
#: ../src/Tutorial/Folds.md:995
msgid "Implement `Foldable` for `Crud i`:"
msgstr "`Foldable`を`Crud i`に実装してください。"

#. type: Bullet: '2. '
#: ../src/Tutorial/Folds.md:1005
msgid "Implement `Foldable` for `Response e i`:"
msgstr "`Foldable`を`Response e i`に実装してください。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Folds.md:1006 ../src/Tutorial/Functor.md:429
#: ../src/Tutorial/Traverse.md:295
#, no-wrap
msgid ""
"   data Response : (e, i, a : Type) -> Type where\n"
"     Created : (id : i) -> (value : a) -> Response e i a\n"
"     Updated : (id : i) -> (value : a) -> Response e i a\n"
"     Found   : (values : List a) -> Response e i a\n"
"     Deleted : (id : i) -> Response e i a\n"
"     Error   : (err : e) -> Response e i a\n"
msgstr ""
"   data Response : (e, i, a : Type) -> Type where\n"
"     Created : (id : i) -> (value : a) -> Response e i a\n"
"     Updated : (id : i) -> (value : a) -> Response e i a\n"
"     Found   : (values : List a) -> Response e i a\n"
"     Deleted : (id : i) -> Response e i a\n"
"     Error   : (err : e) -> Response e i a\n"

#. type: Bullet: '3. '
#: ../src/Tutorial/Folds.md:1018
msgid ""
"Implement `Foldable` for `List01`. Use tail recursion in the implementations "
"of `toList`, `foldMap`, and `foldl`."
msgstr ""
"`List01`に`Foldable`を実装してください。\n"
"`toList`、`foldMap`、`foldl`の実装では末尾再帰を使ってください。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Folds.md:1019 ../src/Tutorial/IO.md:753
#: ../src/Tutorial/Traverse.md:267
#, no-wrap
msgid ""
"   data List01 : (nonEmpty : Bool) -> Type -> Type where\n"
"     Nil  : List01 False a\n"
"     (::) : a -> List01 False a -> List01 ne a\n"
msgstr ""
"   data List01 : (nonEmpty : Bool) -> Type -> Type where\n"
"     Nil  : List01 False a\n"
"     (::) : a -> List01 False a -> List01 ne a\n"

#. type: Bullet: '4. '
#: ../src/Tutorial/Folds.md:1030
msgid ""
"Implement `Foldable` for `Tree`. There is no need to use tail recursion in "
"your implementations, but your functions must be accepted by the totality "
"checker, and you are not allowed to cheat by using `assert_smaller` or "
"`assert_total`."
msgstr ""
"`Foldable`を`Tree`に実装してください。\n"
"実装では末尾再帰を使う必要はありませんが、\n"
"関数は全域性検査器が受け付けるものでなくてはいけません。\n"
"また`assert_smaller`や`assert_total`を使ってズルすることも許しません。"

#. type: Plain text
#: ../src/Tutorial/Folds.md:1034
#, no-wrap
msgid ""
"   Hint: You can test the correct behavior of your implementations\n"
"   by running the same folds on the result of `treeToVect` and\n"
"   verify that the outcome is the same.\n"
msgstr ""
"   ヒント：実装が正しく振る舞うか試すには、\n"
"   同じ畳み込みを`treeToVect`の結果に走らせて出力が同じことを確かめればよいです。\n"

#. type: Bullet: '5. '
#: ../src/Tutorial/Folds.md:1039
msgid ""
"Like `Functor` and `Applicative`, `Foldable` composes: The product and "
"composition of two foldable container types are again foldable container "
"types. Proof this by implementing `Foldable` for `Comp` and `Product`:"
msgstr ""
"`Functor`や`Applicative`と同様に、`Foldable`は組み合わさります。\n"
"つまり、2つの折り畳みできる容器型の積や合成もまた折り畳みできる容器型なので"
"す。\n"
"これを、`Foldable`を`Comp`と`Product`に実装することで証明してください。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Folds.md:1040 ../src/Tutorial/Traverse.md:308
#, no-wrap
msgid ""
"   record Comp (f,g : Type -> Type) (a : Type) where\n"
"     constructor MkComp\n"
"     unComp  : f (g a)\n"
"\n"
"   record Product (f,g : Type -> Type) (a : Type) where\n"
"     constructor MkProduct\n"
"     fst : f a\n"
"     snd : g a\n"
msgstr ""
"   record Comp (f,g : Type -> Type) (a : Type) where\n"
"     constructor MkComp\n"
"     unComp  : f (g a)\n"
"\n"
"   record Product (f,g : Type -> Type) (a : Type) where\n"
"     constructor MkProduct\n"
"     fst : f a\n"
"     snd : g a\n"

#. type: Plain text
#: ../src/Tutorial/Folds.md:1058
msgid ""
"We learned a lot about recursion, totality checking, and folds in this "
"chapter, all of which are important concepts in pure functional programming "
"in general. Wrapping one's head around recursion takes time and experience. "
"Therefore - as usual - try to solve as many exercises as you can."
msgstr ""
"この章で再帰、全域性検査、そして畳み込みについて多くのことを学びました。\n"
"これら全ては一般に純粋関数型プログラミングで重要です。\n"
"再帰を会得するには時間と経験を要すものです。\n"
"したがって……いつも通り……できるだけ多くの演習を解いてみてください。"

#. type: Plain text
#: ../src/Tutorial/Folds.md:1062
msgid ""
"In the next chapter, we are taking the concept of iterating over container "
"types one step further and look at effectful data traversals."
msgstr ""
"次の章では容器型を反復する上での概念についてもう一歩踏み込み、作用つきデータ"
"の巡回についても見ていきます。"

#. type: Title #
#: ../src/Tutorial/Functions1.md:1
#, no-wrap
msgid "Functions Part 1"
msgstr "関数 その1"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:12
msgid ""
"Idris is a *functional* programming language. This means, that functions are "
"its main form of abstraction (unlike for instance in an object oriented "
"language like Java, where *objects* and *classes* are the main form of "
"abstraction). It also means that we expect Idris to make it very easy for us "
"to compose and combine functions to create new functions. In fact, in Idris "
"functions are *first class*: Functions can take other functions as arguments "
"and can return functions as their results."
msgstr ""
"Idrisは *関数型* プログラミング言語です。\n"
"つまり、関数は抽象化の主な形式です（例えばJavaのようなオブジェクト指向言語と"
"は違います。\n"
"オブジェクト指向言語では *オブジェクト* や *クラス* が主な抽象化の形式で"
"す）。\n"
"また、関数型であるということから、\n"
"Idrisではとても簡単に関数を構成・結合して新しい関数をつくれるということがわか"
"ります。\n"
"実際、Idrisの関数は *第一級* です。\n"
"関数は他の関数を引数に取ることができますし、関数の結果として関数を返すことも"
"できます。"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:16
msgid ""
"We already learned about the basic shape of top level function declarations "
"in Idris in the [introduction](Intro.md), so we will continue from what we "
"learned there."
msgstr ""
"[導入](Intro.md)でIdrisでの最上位での関数宣言の基本形を学んできたので、\n"
"そこまでで学んできたことから続きをやりましょう。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions1.md:17
#, no-wrap
msgid "module Tutorial.Functions1\n"
msgstr "module Tutorial.Functions1\n"

#. type: Title ##
#: ../src/Tutorial/Functions1.md:21
#, no-wrap
msgid "Functions with more than one Argument"
msgstr "1つ以上の引数を持つ関数"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:28
msgid ""
"Let's implement a function, which checks if its three `Integer` arguments "
"form a [Pythagorean triple](https://en.wikipedia.org/wiki/"
"Pythagorean_triple).  We get to use a new operator for this: `==`, the "
"equality operator."
msgstr ""
"ある関数を実装してみましょう。\n"
"ここでは3つの `Integer` 型の引数が\n"
"[ピタゴラスの三つ組（訳註：ピタゴラスの定理を満たす3つの整数）](https://en."
"wikipedia.org/wiki/Pythagorean_triple)\n"
"になっているかを検査するものとします。\n"
"このために新しい演算子 `==` を使います。\n"
"相等性のための演算子です。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions1.md:29
#, no-wrap
msgid ""
"isTriple : Integer -> Integer -> Integer -> Bool\n"
"isTriple x y z = x * x + y * y == z * z\n"
msgstr ""
"isTriple : Integer -> Integer -> Integer -> Bool\n"
"isTriple x y z = x * x + y * y == z * z\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:36
msgid ""
"Let's give this a spin at the REPL before we talk a bit about the types:"
msgstr ""
"この演算子の型について軽く話しますが、\n"
"その前にREPLで動かしてみましょう。"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions1.md:37
#, no-wrap
msgid ""
"Tutorial.Functions1> isTriple 1 2 3\n"
"False\n"
"Tutorial.Functions1> isTriple 3 4 5\n"
"True\n"
msgstr ""
"Tutorial.Functions1> isTriple 1 2 3\n"
"False\n"
"Tutorial.Functions1> isTriple 3 4 5\n"
"True\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:49
#, no-wrap
msgid ""
"As can be seen from this example, the type of a function\n"
"of several arguments consists just of a sequence\n"
"of argument types (also called *input types*)\n"
"chained by function arrows (`->`), which\n"
"is terminated by an output type (`Bool` in this case).\n"
msgstr ""
"この例からわかるように、\n"
"複数の引数を持つ関数の型は、\n"
"引数の型（*入力の型*とも言います）の連なりが関数の矢印 (`->`) で繋がっており、\n"
"出力の型（この場合 `Bool` です）で終わるようになっています。\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:61
msgid ""
"The implementation looks a bit like a mathematical equation: We list the "
"arguments on the left hand side of `=` and describe the computation(s) to "
"perform with them on the right hand side. Function implementations in "
"functional programming languages often have this more mathematical look "
"compared to implementations in imperative languages, which often describe "
"not *what* to compute, but *how* to compute it by describing an algorithm as "
"a sequence of imperative statements. We will later see that this imperative "
"style is also available in Idris, but whenever possible we prefer the "
"declarative style."
msgstr ""
"この実装はちょっと数学的な等式に似ています。\n"
"`=` の左側に引数のリストを書き、\n"
"右側でこれの引数を使った計算を記述するのです。\n"
"関数型プログラミング言語での関数の実装は、手続き型言語での実装に比べてより数"
"学的です。\n"
"関数型プログラミング言語では *何を* 計算するのかを記述しますが、\n"
"手続き型言語では手続き文の連なりとしてのアルゴリズムによって *どのように* 計"
"算するのかを記述します。\n"
"あとでIdrisでもこの手続き的な書き方ができることを見ていきますが、\n"
"できるなら宣言的な書き方のほうがいいですね。"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:68
msgid ""
"As can be seen in the REPL example, functions can be invoked by passing the "
"arguments separated by whitespace. No parentheses are necessary unless one "
"of the expressions we pass as the function's arguments contains itself "
"additional whitespace.  This comes in very handy when we apply functions "
"only partially (see later in this chapter)."
msgstr ""
"REPLでの実行例からわかるように、\n"
"関数は空白区切りの引数を渡すことで呼び出せます。\n"
"基本的に括弧は必要ではありません。\n"
"ただし、ある引数が既に空白を含む関数とその引数であった場合は、その引数を括弧"
"でくくります。\n"
"この空白区切りの書き方ができることで、部分的に関数を適用するのがとても楽にな"
"ります（この章で後述します）。"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:74
msgid ""
"Note that, unlike `Integer` or `Bits8`, `Bool` is not a primitive data type "
"built into the Idris language but just a custom data type that you could "
"have written yourself. We will learn more about declaring new data types in "
"the next chapter."
msgstr ""
"また実は `Integer` や `Bits8` とは違って、\n"
"`Bool` はIdris言語に組込まれた原始的なデータ型ではなく、\n"
"自前で書けるただのカスタムデータ型なのです。\n"
"新しいデータ型を宣言することについては次の章で学びましょう。"

#. type: Title ##
#: ../src/Tutorial/Functions1.md:75
#, no-wrap
msgid "Function Composition"
msgstr "関数結合"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:79
msgid ""
"Functions can be combined in several ways, the most direct probably being "
"the dot operator:"
msgstr ""
"関数はいくつかのやり方で組み合わせられます。\n"
"もっとも直接的なのは恐らくドット演算子でしょう。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions1.md:80
#, no-wrap
msgid ""
"square : Integer -> Integer\n"
"square n = n * n\n"
"\n"
"times2 : Integer -> Integer\n"
"times2 n = 2 * n\n"
"\n"
"squareTimes2 : Integer -> Integer\n"
"squareTimes2 = times2 . square\n"
msgstr ""
"square : Integer -> Integer\n"
"square n = n * n\n"
"\n"
"times2 : Integer -> Integer\n"
"times2 n = 2 * n\n"
"\n"
"squareTimes2 : Integer -> Integer\n"
"squareTimes2 = times2 . square\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:92
msgid "Give this a try at the REPL! Does it do what you'd expect?"
msgstr ""
"REPLで試してみてください！\n"
"予想した通りになりましたか？"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:95
msgid ""
"We could have implemented `squareTimes2` without using the dot operator as "
"follows:"
msgstr ""
"以下のようにドット演算子を使わずに `squareTimes2` を実装することもできます。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions1.md:96
#, no-wrap
msgid ""
"squareTimes2' : Integer -> Integer\n"
"squareTimes2' n = times2 (square n)\n"
msgstr ""
"squareTimes2' : Integer -> Integer\n"
"squareTimes2' n = times2 (square n)\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:105
#, no-wrap
msgid ""
"It is important to note, that functions chained by the dot\n"
"operator are invoked from right to left: `times2 . square`\n"
"is the same as `\\n => times2 (square n)` and not\n"
"`\\n => square (times2 n)`.\n"
msgstr ""
"大事なことですが、\n"
"ドット演算子で連鎖している関数は右から左に実行されます。\n"
"`times2 . square` は `\\n => times2 (square n)` と同じですが、\n"
"`\\n => square (times2 n)` ではありません。\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:108
msgid ""
"We can conveniently chain several functions using the dot operator to write "
"more complex functions:"
msgstr ""
"いくつかの関数をドット演算子を使って連鎖させて、\n"
"もっと複雑な関数を簡便に書くことができます。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions1.md:109
#, no-wrap
msgid ""
"dotChain : Integer -> String\n"
"dotChain = reverse . show . square . square . times2 . times2\n"
msgstr ""
"dotChain : Integer -> String\n"
"dotChain = reverse . show . square . square . times2 . times2\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:119
msgid ""
"This will first multiply the argument by four, then square it twice before "
"converting it to a string (`show`) and reversing the resulting `String` "
"(functions `show` and `reverse` are part of the Idris *Prelude* and as such "
"are available in every Idris program)."
msgstr ""
"この関数はまず引数を4倍して、\n"
"2回平方を取って、\n"
"文字列に変換して (`show`)、\n"
"そして `String` を逆向きにします（関数 `show`, `reverse` はIdrisの *Prelude* "
"の一部に含まれているので、\n"
"全てのIdrisのプログラムから使えます）。"

#. type: Title ##
#: ../src/Tutorial/Functions1.md:120
#, no-wrap
msgid "Higher-order Functions"
msgstr "高階関数"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:126
msgid ""
"Functions can take other functions as arguments. This is an incredibly "
"powerful concept and we can go crazy with this very easily. But for sanity's "
"sake, we'll start slowly:"
msgstr ""
"関数は他の関数を引数に取れます。\n"
"これは非常に強力な概念で、\n"
"それ故におかしなことになりやすくもあります。\n"
"とはいえ正気を保つために、まずはゆっくり進みましょう。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions1.md:127
#, no-wrap
msgid ""
"isEven : Integer -> Bool\n"
"isEven n = mod n 2 == 0\n"
"\n"
"testSquare : (Integer -> Bool) -> Integer -> Bool\n"
"testSquare fun n = fun (square n)\n"
msgstr ""
"isEven : Integer -> Bool\n"
"isEven n = mod n 2 == 0\n"
"\n"
"testSquare : (Integer -> Bool) -> Integer -> Bool\n"
"testSquare fun n = fun (square n)\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:142
msgid ""
"First `isEven` uses the `mod` function to check, whether an integer is "
"divisible by two. But the interesting function is `testSquare`. It takes two "
"arguments: The first argument is of type *function from `Integer` to "
"`Bool`*, and the second of type `Integer`. This second argument is squared "
"before being passed to the first argument. Again, give this a go at the REPL:"
msgstr ""
"まず `isEven` は `mod` 関数を使った検査をしています。\n"
"検査の内容は整数が2で割れるかどうかです。\n"
"しかし、興味深い関数は `testSquare` のほうです。\n"
"この関数は2つの引数を取ります。\n"
"1つ目の引数は *`Integer` から `Bool` への関数* であり、\n"
"2つ目の引数は `Integer` 型です。\n"
"この2つ目の引数は最初の引数に渡される前に平方を取られます。\n"
"繰り返しになりますが、\n"
"REPLでやってみましょう。"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions1.md:143
#, no-wrap
msgid ""
"Tutorial.Functions1> testSquare isEven 12\n"
"True\n"
msgstr ""
"Tutorial.Functions1> testSquare isEven 12\n"
"True\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:154
msgid ""
"Take your time to understand what's going on here. We pass function `isEven` "
"as an argument to `testSquare`. The second argument is an integer, which "
"will first be squared and then passed to `isEven`. While this is not very "
"interesting, we will see lots of use cases for passing functions as "
"arguments to other functions."
msgstr ""
"時間を掛けて、何が起こっているのか理解しましょう。\n"
"ここでは `testSquare` に関数 `isEven` を引数として渡しています。\n"
"2つ目の引数は整数で、\n"
"平方を取られた後に `isEven` に渡されます。\n"
"これはあまり面白くない例かもしれませんが、\n"
"関数を引数として他の関数に渡す沢山の活用例を目にするでしょう。"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:157
msgid ""
"I said above, we could go crazy pretty easily.  Consider for instance the "
"following example:"
msgstr ""
"前に述べたように、\n"
"簡単におかしなことになりがちです。\n"
"例えば次のを考えてみましょう。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions1.md:158
#, no-wrap
msgid ""
"twice : (Integer -> Integer) -> Integer -> Integer\n"
"twice f n = f (f n)\n"
msgstr ""
"twice : (Integer -> Integer) -> Integer -> Integer\n"
"twice f n = f (f n)\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:164 ../src/Tutorial/Functions1.md:227
#: ../src/Tutorial/Interfaces.md:504 ../src/Tutorial/Predicates.md:461
#: ../src/Tutorial/Prim.md:646
msgid "And at the REPL:"
msgstr "そしてREPLで……。"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions1.md:165
#, no-wrap
msgid ""
"Tutorial.Functions1> twice square 2\n"
"16\n"
"Tutorial.Functions1> (twice . twice) square 2\n"
"65536\n"
"Tutorial.Functions1> (twice . twice . twice . twice) square 2\n"
"*** huge number ***\n"
msgstr ""
"Tutorial.Functions1> twice square 2\n"
"16\n"
"Tutorial.Functions1> (twice . twice) square 2\n"
"65536\n"
"Tutorial.Functions1> (twice . twice . twice . twice) square 2\n"
"*** 巨大な数字 ***\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:177
msgid ""
"You might be surprised about this behavior, so we'll try and break it down. "
"The following two expressions are identical in their behavior:"
msgstr ""
"この結果にはびっくりしたかもしれません。\n"
"なのでときほぐしていきましょう。\n"
"以下の2つの式は振舞いについて等価です。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions1.md:178
#, no-wrap
msgid ""
"expr1 : Integer -> Integer\n"
"expr1 = (twice . twice . twice . twice) square\n"
"\n"
"expr2 : Integer -> Integer\n"
"expr2 = twice (twice (twice (twice square)))\n"
msgstr ""
"expr1 : Integer -> Integer\n"
"expr1 = (twice . twice . twice . twice) square\n"
"\n"
"expr2 : Integer -> Integer\n"
"expr2 = twice (twice (twice (twice square)))\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:194
msgid ""
"So, `square` raises its argument to the 2nd power, `twice square` raises it "
"to its 4th power (by invoking `square` twice in succession), `twice (twice "
"square)` raises it to its 16th power (by invoking `twice square` twice in "
"succession), and so on, until `twice (twice (twice (twice square)))` raises "
"it to its 65536th power resulting in an impressively huge result."
msgstr ""
"つまり、 `square` は引数を2乗します。\n"
"`twice square` は（`square` を2回連続で呼び出すので）4乗します。\n"
"`twice (twice square)` は（`twice square` を2回連続で呼び出すので）16乗しま"
"す。\n"
"そんな感じで続くと、\n"
"`twice (twice (twice (twice square)))` は65536乗することとなり、\n"
"度肝を抜くほど巨大な結果になるのです。"

#. type: Title ##
#: ../src/Tutorial/Functions1.md:195
#, no-wrap
msgid "Currying"
msgstr "カリー化"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:201
msgid ""
"Once we start using higher-order functions, the concept of partial function "
"application (also called *currying* after mathematician and logician Haskell "
"Curry) becomes very important."
msgstr ""
"ひとたび高階関数を使いはじめると、\n"
"部分関数適用（またの名を *カリー化* と呼びます。数学者であり論理学者でもあっ"
"たHaskell Curryに因みます）はとても大切な概念となります。"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:203
msgid "Load this file in a REPL session and try the following:"
msgstr "このファイルをREPLセッションに読み込んで以下を試してみましょう。"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions1.md:204
#, no-wrap
msgid ""
"Tutorial.Functions1> :t testSquare isEven\n"
"testSquare isEven : Integer -> Bool\n"
"Tutorial.Functions1> :t isTriple 1\n"
"isTriple 1 : Integer -> Integer -> Bool\n"
"Tutorial.Functions1> :t isTriple 1 2\n"
"isTriple 1 2 : Integer -> Bool\n"
msgstr ""
"Tutorial.Functions1> :t testSquare isEven\n"
"testSquare isEven : Integer -> Bool\n"
"Tutorial.Functions1> :t isTriple 1\n"
"isTriple 1 : Integer -> Integer -> Bool\n"
"Tutorial.Functions1> :t isTriple 1 2\n"
"isTriple 1 2 : Integer -> Bool\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:220
#, no-wrap
msgid ""
"Note, how in Idris we can partially apply a function\n"
"with more than one argument and as a result get a new function\n"
"back. For instance, `isTriple 1` applies argument `1` to function\n"
"`isTriple` and as a result returns a new function of\n"
"type `Integer -> Integer -> Bool`. We can even\n"
"use the result of such a partially applied function in\n"
"a new top level definition:\n"
msgstr ""
"注目すべきところは、\n"
"Idrisでは1つ以上の引数に部分的に関数を適用すると、\n"
"結果として新しい関数が返ってくるところです。\n"
"例えば、 `isTriple 1` は引数1が関数 `isTriple` にあてがわれており、\n"
"結果として型が `Integer -> Integer -> Bool` な新しい関数が返ってきています。\n"
"このような部分的に適用された関数を新しく最上位の定義に使うことさえできます。\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions1.md:221
#, no-wrap
msgid ""
"partialExample : Integer -> Bool\n"
"partialExample = isTriple 3 4\n"
msgstr ""
"partialExample : Integer -> Bool\n"
"partialExample = isTriple 3 4\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions1.md:228
#, no-wrap
msgid ""
"Tutorial.Functions1> partialExample 5\n"
"True\n"
msgstr ""
"Tutorial.Functions1> partialExample 5\n"
"True\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:236
msgid ""
"We already used partial function application in our `twice` examples above "
"to get some impressive results with very little code."
msgstr ""
"もう `twice` の例でも部分関数適用を使いましたし、\n"
"そこではとても小さなコードで度肝を抜くような結果が得られたのでした。"

#. type: Title ##
#: ../src/Tutorial/Functions1.md:237
#, no-wrap
msgid "Anonymous Functions"
msgstr "匿名関数"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:245
msgid ""
"Sometimes we'd like to pass a small custom function to a higher-order "
"function without bothering to write a top level definition. For instance, in "
"the following example, function `someTest` is very specific and probably not "
"very useful in general, but we'd still like to pass it to higher-order "
"function `testSquare`:"
msgstr ""
"ときどき、最上位の定義を書くことなしに、小さな自前の関数を高階関数に渡したい"
"ときがあります。\n"
"例えば、以下の関数 `someTest` はとても局所的な用途で一般的にはあまり有用では"
"ないのですが、\n"
"とはいえ `testSquare` 高階関数に渡したいのだとします。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions1.md:246
#, no-wrap
msgid ""
"someTest : Integer -> Bool\n"
"someTest n = n >= 3 || n <= 10\n"
msgstr ""
"someTest : Integer -> Bool\n"
"someTest n = n >= 3 || n <= 10\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:252
msgid "Here's, how to pass it to `testSquare`:"
msgstr "`testSquare` に渡すとこうなります。"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions1.md:253
#, no-wrap
msgid ""
"Tutorial.Functions1> testSquare someTest 100\n"
"True\n"
msgstr ""
"Tutorial.Functions1> testSquare someTest 100\n"
"True\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:260
msgid ""
"Instead of defining and using `someTest`, we can use an anonymous function:"
msgstr ""
"`someTest` を定義して使う代わりに、\n"
"匿名関数を使うことができます。"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions1.md:261
#, no-wrap
msgid ""
"Tutorial.Functions1> testSquare (\\n => n >= 3 || n <= 10) 100\n"
"True\n"
msgstr ""
"Tutorial.Functions1> testSquare (\\n => n >= 3 || n <= 10) 100\n"
"True\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:277
#, no-wrap
msgid ""
"Anonymous functions are sometimes also called *lambdas* (from\n"
"[lambda calculus](https://en.wikipedia.org/wiki/Lambda_calculus)),\n"
"and the backslash is chosen since it resembles the Greek\n"
"letter *lambda*. The `\\n =>` syntax introduces a new anonymous\n"
"function of one argument called `n`, the implementation of\n"
"which is on the right hand side of the function arrow.\n"
"Like other top level functions, lambdas can have more\n"
"than one arguments, separated by commas: `\\x,y => x * x + y`.\n"
"When we pass lambdas as arguments to higher-order functions,\n"
"they typically need to be wrapped in parentheses or separated\n"
"by the dollar operator `($)` (see the next section about this).\n"
msgstr ""
"匿名関数はときどき *ラムダ式* とも呼ばれます。\n"
"（ラムダ式は[ラムダ計算](https://en.wikipedia.org/wiki/Lambda_calculus)から来ています。）\n"
"バックスラッシュが使われていますが、\n"
"これはギリシャ文字の *lambda* に似ているためです。\n"
"`\\n =>` という文法により、1つの引数 `n` を取る新しい匿名関数が導入され、\n"
"関数の矢印の右側にその実装があります。\n"
"他の最上位の関数と同様に、\n"
"ラムダ式は1つ以上の引数を取ることができ、\n"
"引数はコンマ区切りです。\n"
"ラムダ式を高階関数の引数に渡したいときは、\n"
"だいたい括弧でくくったり、\n"
"ドル演算子 `($)` で区切ったりする必要があります。\n"
"（ドル演算子は次の節を参照してください。）\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:280
msgid ""
"Note that, in a lambda, arguments are not annotated with types, so Idris has "
"to be able to infer them from the current context."
msgstr ""
"注意すべき点として、\n"
"ラムダ式では引数は型で註釈することができないということです。\n"
"なので、Idrisがそこでの文脈から型を推論できるようでないといけません。"

#. type: Title ##
#: ../src/Tutorial/Functions1.md:281
#, no-wrap
msgid "Operators"
msgstr "演算子"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:288
msgid ""
"In Idris, infix operators like `.`, `*` or `+` are not built into the "
"language, but are just regular Idris function with some special support for "
"using them in infix notation.  When we don't use operators in infix "
"notation, we have to wrap them in parentheses."
msgstr ""
"`.` や `*` や `+` のようなIdrisの中置演算子は言語に組込まれてはいません。\n"
"これらの演算子は通常のIdrisの関数に、いくらかの中置記法で使うための特別なサ"
"ポートが付いたものです。\n"
"演算子を中置記法で使わないときは、括弧でくるまねばなりません。"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:291
#, no-wrap
msgid ""
"As an example, let us define a custom operator for sequencing\n"
"functions of type `Bits8 -> Bits8`:\n"
msgstr "例として、型が `Bits8 -> Bits8` の関数を連ねる自前の演算子を定義してみましょう。\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions1.md:292
#, no-wrap
msgid ""
"infixr 4 >>>\n"
"\n"
"(>>>) : (Bits8 -> Bits8) -> (Bits8 -> Bits8) -> Bits8 -> Bits8\n"
"f1 >>> f2 = f2 . f1\n"
"\n"
"foo : Bits8 -> Bits8\n"
"foo n = 2 * n + 3\n"
"\n"
"test : Bits8 -> Bits8\n"
"test = foo >>> foo >>> foo >>> foo\n"
msgstr ""
"infixr 4 >>>\n"
"\n"
"(>>>) : (Bits8 -> Bits8) -> (Bits8 -> Bits8) -> Bits8 -> Bits8\n"
"f1 >>> f2 = f2 . f1\n"
"\n"
"foo : Bits8 -> Bits8\n"
"foo n = 2 * n + 3\n"
"\n"
"test : Bits8 -> Bits8\n"
"test = foo >>> foo >>> foo >>> foo\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:311
#, no-wrap
msgid ""
"In addition to declaring and defining the operator\n"
"itself, we also have to specify its fixity: `infixr 4 >>>` means,\n"
"that `(>>>)` associates to the right (meaning, that\n"
"`f >>> g >>> h` is to be interpreted as `f >>> (g >>> h)`)\n"
"with a priority of `4`. You can also have a look at the fixity\n"
"of operators exported by the *Prelude* in the REPL:\n"
msgstr ""
"演算子自体を宣言・定義することに加えて、\n"
"結合の向きを指定せねばなりません。\n"
"`infixr 4 >>>` は、 `(>>>)` が右結合\n"
"（というのは、 `f >>> g >>> h` は `f >>> (g >>> h)` として解釈されるということです）\n"
"で優先度4であることを意味します。\n"
"*Prelude* から公開されている演算子の結合についてREPLで見ることができます。\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions1.md:312
#, no-wrap
msgid ""
"Tutorial.Functions1> :doc (.)\n"
"Prelude.. : (b -> c) -> (a -> b) -> a -> c\n"
"  Function composition.\n"
"  Totality: total\n"
"  Fixity Declaration: infixr operator, level 9\n"
msgstr ""
"Tutorial.Functions1> :doc (.)\n"
"Prelude.. : (b -> c) -> (a -> b) -> a -> c\n"
"  Function composition.\n"
"  Totality: total\n"
"  Fixity Declaration: infixr operator, level 9\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:325
msgid ""
"When you mix infix operators in an expression, those with a higher priority "
"bind more tightly. For instance, `(+)` is left associated with a priority of "
"8, while `(*)` is left associated with a priority of 9. Hence, `a * b + c` "
"is the same as `(a * b) + c` instead of `a * (b + c)`."
msgstr ""
"式で複数の演算子が混在するような場合は、\n"
"より高い優先度を持つ演算子がより強く結び付きます。\n"
"たとえば、 `(+)` は左結合で優先度が8、\n"
"`(*)` は左結合で優先度が9です。\n"
"したがって `a * b + c` は `a * (b + c)` ではなく、\n"
"`(a * b) + c` と同じです。"

#. type: Title ###
#: ../src/Tutorial/Functions1.md:326
#, no-wrap
msgid "Operator Sections"
msgstr "演算子節"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:332
msgid ""
"Operators can be partially applied just like regular functions. In this "
"case, the whole expression has to be wrapped in parentheses and is called an "
"*operator section*. Here are two examples:"
msgstr ""
"演算子は通常の関数と同様に部分適用できます。\n"
"このとき、全体の式は括弧にくるまれている必要があります。\n"
"そしてこの式を *演算子節* と呼びます。\n"
"2つ例を挙げます。"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions1.md:333
#, no-wrap
msgid ""
"Tutorial.Functions1> testSquare (< 10) 5\n"
"False\n"
"Tutorial.Functions1> testSquare (10 <) 5\n"
"True\n"
msgstr ""
"Tutorial.Functions1> testSquare (< 10) 5\n"
"False\n"
"Tutorial.Functions1> testSquare (10 <) 5\n"
"True\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:344
#, no-wrap
msgid ""
"As you can see, there is a difference between `(< 10)`\n"
"and `(10 <)`. The first tests, whether its argument is\n"
"less than 10, the second, whether 10 is less than its\n"
"argument.\n"
msgstr ""
"例から見てとれるように、\n"
"`(< 10)` と `(10 <)` には違いがあります。\n"
"前者は引数が10より小さいかの検査で、\n"
"後者は10が引数より小さいかの検査です。\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:348
msgid ""
"One exception where operator sections will not work is with the *minus* "
"operator `(-)`. Here is an example to demonstrate this:"
msgstr ""
"演算子節がうまくいかない例外の1つは*負符号*演算子`(-)`です。\n"
"以下はこのことを実演する例です。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions1.md:349
#, no-wrap
msgid ""
"applyToTen : (Integer -> Integer) -> Integer\n"
"applyToTen f = f 10\n"
msgstr ""
"applyToTen : (Integer -> Integer) -> Integer\n"
"applyToTen f = f 10\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:357
msgid ""
"This is just a higher-order function applying the number ten to its function "
"argument. This works very well in the following example:"
msgstr ""
"これは単に高階関数を数字の10に関数の引数として適用しているだけです。\n"
"以下の例では実にうまくいきます。"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions1.md:358
#, no-wrap
msgid ""
"Tutorial.Functions1> applyToThen (* 2)\n"
"20\n"
msgstr ""
"Tutorial.Functions1> applyToThen (* 2)\n"
"20\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:365
msgid "However, if we want to subtract five from ten, the following will fail:"
msgstr "しかし、10から5を引こうとして以下のように失敗します。"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions1.md:366
#, no-wrap
msgid ""
"Tutorial.Functions1> applyToTen (- 5)\n"
"Error: Can't find an implementation for Num (Integer -> Integer).\n"
"\n"
"(Interactive):1:12--1:17\n"
" 1 | applyToTen (- 5)\n"
msgstr ""
"Tutorial.Functions1> applyToTen (- 5)\n"
"Error: Can't find an implementation for Num (Integer -> Integer).\n"
"\n"
"(Interactive):1:12--1:17\n"
" 1 | applyToTen (- 5)\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:377
msgid ""
"The problem here is, that Idris treats `- 5` as an integer literal instead "
"of an operator section. In this special case, we therefore have to use an "
"anonymous function instead:"
msgstr ""
"ここでの問題は、Idrisが`- 5`を演算子節ではなく整数リテラルとして扱うというこ"
"とです。\n"
"この特別な場合においては、代わりに匿名関数を使わねばなりません。"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions1.md:378
#, no-wrap
msgid ""
"Tutorial.Functions1> applyToTen (\\x => x - 5)\n"
"5\n"
msgstr ""
"Tutorial.Functions1> applyToTen (\\x => x - 5)\n"
"5\n"

#. type: Title ###
#: ../src/Tutorial/Functions1.md:383
#, no-wrap
msgid "Infix Notation for Non-Operators"
msgstr "演算子ではない関数のための中置記法"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:390
msgid ""
"In Idris, it is possible to use infix notation for regular binary functions, "
"by wrapping them in backticks.  It is even possible to define a precedence "
"(fixity) for these and use them in operator sections, just like regular "
"operators:"
msgstr ""
"Idrisでは通常の2引数関数も、バッククォートにくるむことで中置記法することがで"
"きます。\n"
"優先度（と結合の向き）を定義して、演算子節で使うこともできます。\n"
"ちょうど通常の演算子のように。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions1.md:391
#, no-wrap
msgid ""
"infixl 8 `plus`\n"
"\n"
"infixl 9 `mult`\n"
"\n"
"plus : Integer -> Integer -> Integer\n"
"plus = (+)\n"
"\n"
"mult : Integer -> Integer -> Integer\n"
"mult = (*)\n"
"\n"
"arithTest : Integer\n"
"arithTest = 5 `plus` 10 `mult` 12\n"
"\n"
"arithTest' : Integer\n"
"arithTest' = 5 + 10 * 12\n"
msgstr ""
"infixl 8 `plus`\n"
"\n"
"infixl 9 `mult`\n"
"\n"
"plus : Integer -> Integer -> Integer\n"
"plus = (+)\n"
"\n"
"mult : Integer -> Integer -> Integer\n"
"mult = (*)\n"
"\n"
"arithTest : Integer\n"
"arithTest = 5 `plus` 10 `mult` 12\n"
"\n"
"arithTest' : Integer\n"
"arithTest' = 5 + 10 * 12\n"

#. type: Title ###
#: ../src/Tutorial/Functions1.md:409
#, no-wrap
msgid "Operators exported by the *Prelude*"
msgstr "*Prelude* から公開されている演算子"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:419
msgid ""
"Here is a list of important operators exported by the *Prelude*.  Most of "
"these are *constrained*, that is they work only for types implementing a "
"certain *interface*. Don't worry about this right now. We will learn about "
"interfaces in due time, and the operators behave as they intuitively "
"should.  For instance, addition and multiplication work for all numeric "
"types, comparison operators work for almost all types in the *Prelude* with "
"the exception of functions."
msgstr ""
"以下は *Prelude* から公開されている重要な演算子の一覧です。\n"
"これらのうちほとんどは *制約付き* のものです。\n"
"制約付きというのは、特定の *インターフェース* を実装した型に対してのみ使え"
"る、ということです。\n"
"今は心配しなくて大丈夫。\n"
"その時が来たらインターフェースについて学びましょう。\n"
"インターフェースを知らずとも、演算子は直感的に振舞うことでしょう。\n"
"たとえば加算と乗算は全ての数値型に対してはたらきますし、\n"
"比較演算子は *Prelude* の関数以外のほぼ全ての型に対してはたらきます。"

#. type: Bullet: '* '
#: ../src/Tutorial/Functions1.md:429
msgid "`(.)`: Function composition"
msgstr "`(.)`: 関数結合"

#. type: Bullet: '* '
#: ../src/Tutorial/Functions1.md:429
msgid "`(+)`: Addition"
msgstr "`(+)`: 加算"

#. type: Bullet: '* '
#: ../src/Tutorial/Functions1.md:429
msgid "`(*)`: Multiplication"
msgstr "`(*)`: 乗算"

#. type: Bullet: '* '
#: ../src/Tutorial/Functions1.md:429
msgid "`(-)`: Subtraction"
msgstr "`(-)`: 減算"

#. type: Bullet: '* '
#: ../src/Tutorial/Functions1.md:429
msgid "`(/)`: Division"
msgstr "`(/)`: 除算"

#. type: Bullet: '* '
#: ../src/Tutorial/Functions1.md:429
msgid "`(==)` : True, if two values are equal"
msgstr "`(==)` : 2つの値が等しいとき真"

#. type: Bullet: '* '
#: ../src/Tutorial/Functions1.md:429
msgid "`(/=)` : True, if two values are not equal"
msgstr "`(/=)` : 2つの値が異なるとき真"

#. type: Bullet: '* '
#: ../src/Tutorial/Functions1.md:429
msgid "`(<=)`, `(>=)`, `(<)`, and `(>)` : Comparison operators"
msgstr "`(<=)`, `(>=)`, `(<)`, `(>)` : 比較演算子"

#. type: Bullet: '* '
#: ../src/Tutorial/Functions1.md:429
msgid "`($)`: Function application"
msgstr "`($)`: 関数適用"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:440
msgid ""
"The most special of the above is the last one. It has a priority of 0, so "
"all other operators bind more tightly.  In addition, function application "
"binds more tightly, so this can be used to reduce the number of parentheses "
"required. For instance, instead of writing `isTriple 3 4 (2 + 3 * 1)` we can "
"write `isTriple 3 4 $ 2 + 3 * 1`, which is exactly the same. Sometimes, this "
"helps readability, sometimes, it doesn't. The important thing to remember is "
"that `fun $ x y` is just the same as `fun (x y)`."
msgstr ""
"上記のうち最も特別なのは最後の演算子です。\n"
"優先度が0なので、他の全ての演算子はより強く結び付きます。\n"
"加えて、関数適用はそれよりさらに強く結び付くので、\n"
"この演算子によって必要な括弧の数を減らすことができます。\n"
"例えば、 `isTriple 3 4 (2 + 3 * 1)` と書くところを、\n"
"`isTriple 3 4 $ 2 + 3 * 1` とでき、\n"
"これは全く同じ意味です。\n"
"この演算子で可読性が上がることもあれば、下がることもあります。\n"
"覚えておくべきことは、\n"
"`fun $ x y` が `fun (x y)` と同じであるということです。"

#. type: Title ###
#: ../src/Tutorial/Functions1.md:441 ../src/Tutorial/Functions2.md:339
#, no-wrap
msgid "Exercises"
msgstr "演習"

#. type: Bullet: '1. '
#: ../src/Tutorial/Functions1.md:450
msgid ""
"Reimplement functions `testSquare` and `twice` by using the dot operator and "
"dropping the second arguments (have a look at the implementation of "
"`squareTimes2` to get an idea where this should lead you). This highly "
"concise way of writing function implementations is sometimes called *point-"
"free style* and is often the preferred way of writing small utility "
"functions."
msgstr ""
"ドット演算子を使い、2つ目の引数を省くことで、関数 `testSquare` と `twice` を"
"再実装してください。\n"
"（`squareTimes2` の実装を見れば方針が見えてきます。）\n"
"この高度に簡潔な関数の実装の書き方はしばしば *ポイントフリースタイル* と呼ば"
"れ、\n"
"小間物的な関数を書くときによく好まれます。"

#. type: Bullet: '2. '
#: ../src/Tutorial/Functions1.md:453
msgid ""
"Declare and implement function `isOdd` by combining functions `isEven` from "
"above and `not` (from the Idris *Prelude*). Use point-free style."
msgstr ""
"前述の関数 `isEven` と `not` （Idrisの *Prelude* 由来）を組み合わせて\n"
"`isOdd` を宣言・実装してください。\n"
"なお、ポイントフリースタイルを使ってください。"

#. type: Bullet: '3. '
#: ../src/Tutorial/Functions1.md:456
msgid ""
"Declare and implement function `isSquareOf`, which checks whether its first "
"`Integer` argument is the square of the second argument."
msgstr ""
"`isSquareOf` 関数を宣言・定義してください。\n"
"この関数は最初の `Integer` な引数が2つ目の引数の平方であるか検査します。"

#. type: Bullet: '4. '
#: ../src/Tutorial/Functions1.md:460
msgid ""
"Declare and implement function `isSmall`, which checks whether its `Integer` "
"argument is less than or equal to 100. Use one of the comparison operators "
"`<=` or `>=` in your implementation."
msgstr ""
"関数 `isSmall` を宣言・実装してください。\n"
"この関数は `Integer` な引数が100以下かどうか検査します。\n"
"実装では比較演算子 `<=` または `>=` を使ってください。"

#. type: Bullet: '5. '
#: ../src/Tutorial/Functions1.md:465
msgid ""
"Declare and implement function `absIsSmall`, which checks whether the "
"absolute value of its `Integer` argument is less than or equal to 100.  Use "
"functions `isSmall` and `abs` (from the Idris *Prelude*) in your "
"implementation, which should be in point-free style."
msgstr ""
"関数 `absIsSmall` を宣言・定義してください。\n"
"この関数は `Integer` な引数の絶対値を取ったものが100以下かどうか検査しま"
"す。\n"
"実装では関数 `isSmall` と `abs` （Idrisの *Prelude* 由来）を使ってくださ"
"い。\n"
"また、ポイントフリースタイルを使ってください。"

#. type: Bullet: '6. '
#: ../src/Tutorial/Functions1.md:471
msgid ""
"In this slightly extended exercise we are going to implement some utilities "
"for working with `Integer` predicates (functions from `Integer` to `Bool`). "
"Implement the following higher-order functions (use boolean operators `&&`, "
"`||`, and function `not` in your implementations):"
msgstr ""
"ちょっと発展的な演習として、 `Integer` に関する命題を扱う小間物を実装していき"
"ます。\n"
"（ここでの命題とは、 `Integer` を取って `Bool` を返す関数です。）\n"
"以下の高階関数を実装してください。\n"
"（実装では真偽値演算子 `&&`, `||` と関数 `not` を使ってください。）"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions1.md:472
#, no-wrap
msgid ""
"   -- return true, if and only if both predicates hold\n"
"   and : (Integer -> Bool) -> (Integer -> Bool) -> Integer -> Bool\n"
"\n"
"   -- return true, if and only if at least one predicate holds\n"
"   or : (Integer -> Bool) -> (Integer -> Bool) -> Integer -> Bool\n"
"\n"
"   -- return true, if the predicate does not hold\n"
"   negate : (Integer -> Bool) -> Integer -> Bool\n"
msgstr ""
"   -- 両方の命題が満たされているときに限り真\n"
"   and : (Integer -> Bool) -> (Integer -> Bool) -> Integer -> Bool\n"
"\n"
"   -- 少なくとも一方の命題が満たされているときに限り真\n"
"   or : (Integer -> Bool) -> (Integer -> Bool) -> Integer -> Bool\n"
"\n"
"   -- 命題が満たされないときに真\n"
"   negate : (Integer -> Bool) -> Integer -> Bool\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:487
#, no-wrap
msgid ""
"   After solving this exercise, give it a go in the REPL. In the\n"
"   example below, we use binary function `and` in infix notation\n"
"   by wrapping it in backticks. This is just a syntactic convenience\n"
"   to make certain function applications more readable:\n"
msgstr ""
"   この演習を解いたら、\n"
"   REPLを立ち上げてください。\n"
"   以下の例では2引数関数 `and` をバッククォートでくるんだ中置記法にして使っています。\n"
"   これは単に文法的に便利だからで、\n"
"   こうすることで関数適用がより読みやすくなることがあります。\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions1.md:488
#, no-wrap
msgid ""
"   Tutorial.Functions1> negate (isSmall `and` isOdd) 73\n"
"   False\n"
msgstr ""
"   Tutorial.Functions1> negate (isSmall `and` isOdd) 73\n"
"   False\n"

#. type: Bullet: '7. '
#: ../src/Tutorial/Functions1.md:500
msgid ""
"As explained above, Idris allows us to define our own infix operators.  Even "
"better, Idris supports *overloading* of function names, that is, two "
"functions or operators can have the same name, but different types and "
"implementations.  Idris will make use of the types to distinguish between "
"equally named operators and functions."
msgstr ""
"前述したように、\n"
"Idrisでは自前の中置演算子を定義できます。\n"
"さらにいいことにIdrisでは関数名の *オーバーロード* ができます。\n"
"というのは、2つ以上の関数や演算子が違う型と実装を持ちつつ同じ名前を持つことが"
"できるということです。\n"
"Idrisは同じ名前を持つ演算子と関数を型で見分けます。"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:504
#, no-wrap
msgid ""
"   This allows us, to reimplement functions `and`, `or`, and `negate`\n"
"   from Exercise 6 by using the existing operator and function\n"
"   names from boolean algebra:\n"
msgstr ""
"   これにより、真偽値計算での既存の演算子と関数の名前を使いつつ、\n"
"   演習6から関数 `and`, `or`, `negate` を再実装することができます。\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions1.md:505
#, no-wrap
msgid ""
"   -- return true, if and only if both predicates hold\n"
"   (&&) : (Integer -> Bool) -> (Integer -> Bool) -> Integer -> Bool\n"
"   x && y = and x y\n"
"\n"
"   -- return true, if and only if at least one predicate holds\n"
"   (||) : (Integer -> Bool) -> (Integer -> Bool) -> Integer -> Bool\n"
"\n"
"   -- return true, if the predicate does not hold\n"
"   not : (Integer -> Bool) -> Integer -> Bool\n"
msgstr ""
"   -- 両方の命題が満たされているときに限り真\n"
"   (&&) : (Integer -> Bool) -> (Integer -> Bool) -> Integer -> Bool\n"
"   x && y = and x y\n"
"\n"
"   -- 少なくとも1つの命題が満たされているときに限り真\n"
"   (||) : (Integer -> Bool) -> (Integer -> Bool) -> Integer -> Bool\n"
"\n"
"   -- 命題が満たされていないとき真\n"
"   not : (Integer -> Bool) -> Integer -> Bool\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:518
#, no-wrap
msgid "   Implement the other two functions and test them at the REPL:\n"
msgstr "   残りの2つの関数 `(||)` と `not` を実装してREPLで試してください。\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions1.md:519
#, no-wrap
msgid ""
"   Tutorial.Functions1> not (isSmall && isOdd) 73\n"
"   False\n"
msgstr ""
"   Tutorial.Functions1> not (isSmall && isOdd) 73\n"
"   False\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:527
msgid "What we learned in this chapter:"
msgstr "この章で学んだことは以下です。"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:530
#, no-wrap
msgid ""
"* A function in Idris can take an arbitrary number of arguments,\n"
"separated by `->` in the function's type.\n"
msgstr ""
"Idrisの関数はいくつでも引数を取ることができます。\n"
"引数は関数の型で `->` で区切られています。\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:534
#, no-wrap
msgid ""
"* Functions can be combined\n"
"sequentially using the dot operator, which leads to highly\n"
"concise code.\n"
msgstr ""
"* ドット演算子を連続して使うことで関数を組み合わせることができます。\n"
"こうすることでかなり簡潔なコードになります。\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:539
#, no-wrap
msgid ""
"* Functions can be partially applied by passing them fewer\n"
"arguments than they expect. The result is a new function\n"
"expecting the remaining arguments. This technique is called\n"
"*currying*.\n"
msgstr ""
"* 関数が期待するより少ない引数を渡すことで、\n"
"関数の部分適用ができます。\n"
"部分適用の結果は残りの引数を期待する新しい関数になります。\n"
"この技法は *カリー化* と呼ばれます。\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:543
#, no-wrap
msgid ""
"* Functions can be passed as arguments to other functions, which\n"
"allows us to easily combine small coding units to create\n"
"more complex behavior.\n"
msgstr ""
"* 関数は他の関数の引数に渡すことができます。\n"
"これにより、小さなコードの部品を組み合わせることで、\n"
"簡単により複雑な振舞いを生み出すことができます。\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:547
#, no-wrap
msgid ""
"* We can pass anonymous functions (*lambdas*) to higher-order\n"
"functions, if writing a corresponding top level\n"
"function would be too cumbersome.\n"
msgstr ""
"* 匿名関数（*ラムダ式*）を高階関数に渡すことができます。\n"
"匿名関数は、これに対応する最上位の関数を書くのがまどろっこしいときに使います。\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:551
#, no-wrap
msgid ""
"* Idris allows us to define our own infix operators. These\n"
"have to be written in parentheses unless they are being used\n"
"in infix notation.\n"
msgstr ""
"* Idrisでは自前の中置演算子を定義することができます。\n"
"中置記法で使われないときは、中置演算子は括弧の中に書く必要があります。\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:556
#, no-wrap
msgid ""
"* Infix operators can also be partially applied. These *operator sections*\n"
"have to be wrapped in parentheses, and the position of the\n"
"argument determines, whether it is used as the operator's first\n"
"or second argument.\n"
msgstr ""
"* 中置演算子は部分適用することもできます。\n"
"この *演算子節* は括弧でくるまれていなければいけません。\n"
"そして、演算子節での引数の位置は、\n"
"演算子の1つ目の引数か2つ目の引数かを決めます。\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:560
#, no-wrap
msgid ""
"* Idris supports name overloading: Functions can have the same\n"
"names but different implementations. Idris will decide, which function\n"
"to used based to the types involved.\n"
msgstr ""
"* Idrisでは名前のオーバーロードができます。\n"
"関数は同じ名前を持ちつつ違う実装を持つことができます。\n"
"Idrisはどちらの関数を使うべきかを型から決めます。\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:567
msgid ""
"Please note, that function and operator names in a module must be unique. In "
"order to define two functions with the same name, they have to be declared "
"in distinct modules. If Idris is not able to decide, which of the two "
"functions to use, we can help name resolution by prefixing a function with "
"(a part of) its *namespace*:"
msgstr ""
"注意したいことは、\n"
"1つのモジュール内の関数と演算子の名前は一意であるということです。\n"
"同じ名前の2つの関数を定義するには、\n"
"別々のモジュールで宣言する必要があります。\n"
"Idrisがどちらを使うべきか判断できないときは、\n"
"関数に（部分的にでも） *名前空間* を前置することで、名前解決できるようになり"
"ます。"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions1.md:568
#, no-wrap
msgid ""
"Tutorial.Functions1> :t Prelude.not\n"
"Prelude.not : Bool -> Bool\n"
"Tutorial.Functions1> :t Functions1.not\n"
"Tutorial.Functions1.not : (Integer -> Bool) -> (Integer -> Bool) -> Integer -> Bool\n"
msgstr ""
"Tutorial.Functions1> :t Prelude.not\n"
"Prelude.not : Bool -> Bool\n"
"Tutorial.Functions1> :t Functions1.not\n"
"Tutorial.Functions1.not : (Integer -> Bool) -> (Integer -> Bool) -> Integer -> Bool\n"

#. type: Plain text
#: ../src/Tutorial/Functions1.md:581
msgid ""
"In the [next section](DataTypes.md), we will learn how to define our own "
"data types and how to construct and deconstruct values of these new types. "
"We will also learn about generic types and functions."
msgstr ""
"[次節](DataTypes.md)では、\n"
"自前のデータ型を定義する方法と、\n"
"この新しい型の値を構築したり分解したりする方法を学びます。\n"
"汎化型と汎化関数についても学びます。"

#. type: Title #
#: ../src/Tutorial/Functions2.md:1
#, no-wrap
msgid "Functions Part 2"
msgstr "関数 その2"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:9
msgid ""
"So far, we learned about the core features of the Idris language, which it "
"has in common with several other pure, strongly typed programming languages "
"like Haskell: (Higher order) Functions, algebraic data types, pattern "
"matching, parametric polymorphism (generic types and functions), and ad hoc "
"polymorphism (interfaces and constrained functions)."
msgstr ""
"これまでIdris言語の核となる特徴について学びました。\n"
"この特徴はHaskellのような他の純粋で強く型付けされたプログラミング言語でもよく"
"見られます。\n"
"（高階）関数、代数的データ型、パターン照合、パラメトリック多相（汎化型と汎化"
"関数）、\n"
"そしてアドホック多相（インターフェースと制約付き関数）です。"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:15
msgid ""
"In this chapter, we start to dissect Idris functions and their types for "
"real. We learn about implicit arguments, named arguments, as well as erasure "
"and quantities. But first, we'll look at `let` bindings and `where` blocks, "
"which help us implement functions too complex to fit on a single line of "
"code. Let's get started!"
msgstr ""
"この章ではIdrisの実践上の関数とその型を解剖し始めます。\n"
"暗黙引数、名前付き引数、そして型消去と数量的型を学びます。\n"
"しかしまずは`let`束縛と`where`ブロックを見ていきます。\n"
"これらのおかげで、複雑すぎて単一行のコードに収まりきらない関数も、\n"
"実装することができるようになります。\n"
"始めましょう！"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:16
#, no-wrap
msgid ""
"module Tutorial.Functions2\n"
"\n"
"%default total\n"
msgstr ""
"module Tutorial.Functions2\n"
"\n"
"%default total\n"

#. type: Title ##
#: ../src/Tutorial/Functions2.md:22
#, no-wrap
msgid "Let Bindings and Local Definitions"
msgstr "let束縛と局所定義"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:31
msgid ""
"The functions we looked at so far were simple enough to be implemented "
"directly via pattern matching without the need of additional auxiliary "
"functions or variables. This is not always the case, and there are two "
"important language constructs for introducing and reusing new local "
"variables and functions. We'll look at these in two case studies."
msgstr ""
"これまで見てきた関数はパターン照合で直接実装できる程度には単純なものでし"
"た。\n"
"追加の付属関数ないし変数を必要としませんでした。\n"
"いつもこういうわけではなくて、\n"
"新しい局所変数と局所関数を導入したり再利用したりするための、\n"
"2つの大事な言語的構築要素があります。\n"
"これらを2つの事例の観察から見ていきましょう。"

#. type: Title ###
#: ../src/Tutorial/Functions2.md:32
#, no-wrap
msgid "Use Case 1: Arithmetic Mean and Standard Deviation"
msgstr "使用例1：算術平均と標準偏差"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:37
msgid ""
"In this example, we'd like to calculate the arithmetic mean and the standard "
"deviation of a list of floating point values.  There are several things we "
"need to consider."
msgstr ""
"この例では算術平均と標準偏差を浮動小数点数値のリストから計算することを考えま"
"す。"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:41
msgid ""
"First, we need a function for calculating the sum of a list of numeric "
"values. The *Prelude* exports function `sum` for this:"
msgstr ""
"まず総和を数値のリストから計算する関数が必要です。\n"
"*Prelude*はこのための関数`sum`を公開しています。"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions2.md:42
#, no-wrap
msgid ""
"Main> :t sum\n"
"Prelude.sum : Num a => Foldable t => t a -> a\n"
msgstr ""
"Main> :t sum\n"
"Prelude.sum : Num a => Foldable t => t a -> a\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:51
msgid ""
"This is - of course - similar to `sumList` from Exercise 10 of the [last "
"section](Interfaces.md), but generalized to all container types with a "
"`Foldable` implementation. We will learn about interface `Foldable` in a "
"later section."
msgstr ""
"これは、もちろんのこと、[直前の節](Interfaces.md)の演習10での`sumList`に似た"
"ものです。\n"
"しかし`Foldable`の実装がある全ての積載型に汎化されています。\n"
"インターフェース`Foldable`については後の節で学びましょう。"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:62
msgid ""
"In order to also calculate the variance, we need to convert every value in "
"the list to a new value, as we have to subtract the mean from every value in "
"the list and square the result. In the previous section's exercises, we "
"defined function `mapList` for this. The *Prelude* - of course - already "
"exports a similar function called `map`, which is again more general and "
"works also like our `mapMaybe` for `Maybe` and `mapEither` for `Either e`. "
"Here's its type:"
msgstr ""
"分散を計算するためにはリストの全ての値を新しい値に計算する必要もあります。\n"
"なぜならリスト中の全ての値から平均を引いて結果を平方する必要があるからで"
"す。\n"
"前の節の演習でこのための関数`mapList`を定義しました。\n"
"*Prelude*は、当然、既に似たような関数`map`を公開しています。\n"
"これもまたより汎用的で自前の`Maybe`のための`mapMaybe`や`Either e`のための"
"`mapEither`としても動きます。\n"
"以下が型です。"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions2.md:63
#, no-wrap
msgid ""
"Main> :t map\n"
"Prelude.map : Functor f => (a -> b) -> f a -> f b\n"
msgstr ""
"Main> :t map\n"
"Prelude.map : Functor f => (a -> b) -> f a -> f b\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:70
msgid "Interface `Functor` is another one we'll talk about in a later section."
msgstr "インターフェース`Functor`についても後の節でお話しします。"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:73
msgid ""
"Finally, we need a way to calculate the length of a list of values. We use "
"function `length` for this:"
msgstr ""
"最後に値のリストの長さを計算する方法が必要です。\n"
"これには関数`length`を使います。"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions2.md:74
#, no-wrap
msgid ""
"Main> :t List.length\n"
"Prelude.List.length : List a -> Nat\n"
msgstr ""
"Main> :t List.length\n"
"Prelude.List.length : List a -> Nat\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:87
#, no-wrap
msgid ""
"Here, `Nat` is the type of natural numbers\n"
"(unbounded, unsigned integers). `Nat` is actually not a primitive data\n"
"type but a sum type defined in the *Prelude* with\n"
"data constructors `Z : Nat` (for zero)\n"
"and `S : Nat -> Nat` (for successor). It might seem highly inefficient\n"
"to define natural numbers this way, but the Idris compiler\n"
"treats these and several other *number-like* types specially, and\n"
"replaces them with primitive integers during code generation.\n"
msgstr ""
"ここで`Nat`は自然数型です。\n"
"（範囲がなく、符号なしです。）\n"
"`Nat`は実のところ原始的なデータ型ではなくて、\n"
"*Prelude*で定義された直和型で、\n"
"データ構築子`Z : Nat`（ゼロ）と`S : Nat -> Nat`（それ以上）からなります。\n"
"自然数をこうして定義するのはかなり非効率に思えますが、\n"
"Idrisはこうしたものといくつかの他の*数のような*型を特別に扱い、\n"
"コード生成の段階で原始的な整数に置き換えます。\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:93
msgid ""
"We are now ready to give the implementation of `mean` a go.  Since this is "
"Idris, and we care about clear semantics, we will quickly define a custom "
"record type instead of just returning a tuple of `Double`s. This makes it "
"clearer, which floating point number corresponds to which statistic entity:"
msgstr ""
"これで`mean`の実装を与えられるようになります。\n"
"これはIdrisであり、明白な意味論に気をつけているので、\n"
"単に`Double`のタプルを返すのではなく、ささっと自前のレコード型を定義しま"
"す。\n"
"こうすることでより明白になるのは、どちらの小数点数がどちらの統計的な実態に対"
"応するのかということです。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:94
#, no-wrap
msgid ""
"square : Double -> Double\n"
"square n = n * n\n"
"\n"
"record Stats where\n"
"  constructor MkStats\n"
"  mean      : Double\n"
"  variance  : Double\n"
"  deviation : Double\n"
"\n"
"stats : List Double -> Stats\n"
"stats xs =\n"
"  let len      := cast (length xs)\n"
"      mean     := sum xs / len\n"
"      variance := sum (map (\\x => square (x - mean)) xs) / len\n"
"   in MkStats mean variance (sqrt variance)\n"
msgstr ""
"square : Double -> Double\n"
"square n = n * n\n"
"\n"
"record Stats where\n"
"  constructor MkStats\n"
"  mean      : Double\n"
"  variance  : Double\n"
"  deviation : Double\n"
"\n"
"stats : List Double -> Stats\n"
"stats xs =\n"
"  let len      := cast (length xs)\n"
"      mean     := sum xs / len\n"
"      variance := sum (map (\\x => square (x - mean)) xs) / len\n"
"   in MkStats mean variance (sqrt variance)\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:113
msgid "As usual, we first try this at the REPL:"
msgstr "いつも通り、まずはREPLで試してみます。"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions2.md:114
#, no-wrap
msgid ""
"Tutorial.Functions2> stats [2,4,4,4,5,5,7,9]\n"
"MkStats 5.0 4.0 2.0\n"
msgstr ""
"Tutorial.Functions2> stats [2,4,4,4,5,5,7,9]\n"
"MkStats 5.0 4.0 2.0\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:133
msgid ""
"Seems to work, so let's digest this step by step.  We introduce several new "
"local variables (`len`, `mean`, and `variance`), which all will be used more "
"than once in the remainder of the implementation. To do so, we use a `let` "
"binding. This consists of the `let` keyword, followed by one or more "
"variable assignments, followed by the final expression, which has to be "
"prefixed by `in`. Note, that whitespace is significant again: We need to "
"properly align the three variable names. Go ahead, and try out what happens "
"if you remove a space in front of `mean` or `variance`.  Note also, that the "
"alignment of assignment operators `:=` is optional. I do this, since I "
"thinks it helps readability."
msgstr ""
"動いているようなので1つずつ紐解いていきましょう。\n"
"いくつかの局所変数 (`len`, `mean`, `variance`) を導入し、\n"
"それら全ては実装の残りの部分で1度以上使われます。\n"
"これには`let`束縛を使います。\n"
"順に、`let`キーワード、1つ以上の変数代入が続き、最後の式には`in`が後置してい"
"なければいけません。\n"
"空白はここでも重要ですよ。\n"
"3つの変数名は適切に整列していなくてはいけません。\n"
"さあ、`mean`や`variance`の前の空白を削除すると何が起こるのかやってみましょ"
"う。\n"
"ただし、代入演算子`:=`は整列していなくても大丈夫です。\n"
"こうしたのは可読性がよくなると思っているからです。"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:149
msgid ""
"Let's also quickly look at the different variables and their types. `len` is "
"the length of the list cast to a `Double`, since this is what's needed later "
"on, where we divide other values of type `Double` by the length. Idris is "
"very strict about this: We are not allowed to mix up numeric types without "
"explicit casts. Please note, that in this case Idris is able to *infer* the "
"type of `len` from the surrounding context. `mean` is straight forward: We "
"`sum` up the values stored in the list and divide by the list's length. "
"`variance` is the most involved of the three: We map each item in the list "
"to a new value using an anonymous function to subtract the mean and square "
"the result. We then sum up the new terms and divide again by the number of "
"values."
msgstr ""
"それぞれの変数とその型についてもさくっと見ていきましょう。\n"
"`len`はリストの長さで、のちのちのために`Double`に嵌め込まれています。\n"
"というのは、`Double`な他の値を長さで割ることになるからです。\n"
"Idrisはこうしたことに大変厳格です。\n"
"明示的な嵌め込みなくして、数値型を混在させることはできません。\n"
"注意していただきたいのは、この場合はIdrisが`len`の型を周囲の文脈から*推論*す"
"ることができているということです。\n"
"`mean`は直感的です。\n"
"リストに保管された値を`sum`で合計し、リストの長さで割っています。\n"
"`variance`は3つの中でもっとも込み入っています。\n"
"リストのそれぞれの要素について、\n"
"匿名関数を使って平均を引いたのちに、その平方を取っています。\n"
"そうしてできた値を合計し、再度値の数で割ります。"

#. type: Title ###
#: ../src/Tutorial/Functions2.md:150
#, no-wrap
msgid "Use Case 2: Simulating a Simple Web Server"
msgstr "使用例2：簡素なWebサーバを模擬する"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:156
msgid ""
"In the second use case, we are going to write a slightly larger application. "
"This should give you an idea about how to design data types and functions "
"around some business logic you'd like to implement."
msgstr ""
"2つ目の使用例ではもうちょっと大きいアプリケーションを書いていきます。\n"
"実装したいビジネスロジックに対して、データ型と関数をどのように設計すればよい"
"かを考えられるようになるでしょう。"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:161
msgid ""
"Assume we run a music streaming web server, where users can buy whole albums "
"and listen to them online. We'd like to simulate a user connecting to the "
"server and getting access to one of the albums they bought."
msgstr ""
"音楽配信webサーバを稼動させているのだとします。\n"
"そこでは利用者はアルバム一式を買ってオンラインで聴くことができます。\n"
"サーバに接続して購入したアルバムの1つにアクセスする利用者を模擬したいところで"
"す。"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:163
msgid "We first define a bunch of record types:"
msgstr "まず沢山のレコード型を定義します。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:164
#, no-wrap
msgid ""
"record Artist where\n"
"  constructor MkArtist\n"
"  name : String\n"
"\n"
"record Album where\n"
"  constructor MkAlbum\n"
"  name   : String\n"
"  artist : Artist\n"
"\n"
"record Email where\n"
"  constructor MkEmail\n"
"  value : String\n"
"\n"
"record Password where\n"
"  constructor MkPassword\n"
"  value : String\n"
"\n"
"record User where\n"
"  constructor MkUser\n"
"  name     : String\n"
"  email    : Email\n"
"  password : Password\n"
"  albums   : List Album\n"
msgstr ""
"record Artist where\n"
"  constructor MkArtist\n"
"  name : String\n"
"\n"
"record Album where\n"
"  constructor MkAlbum\n"
"  name   : String\n"
"  artist : Artist\n"
"\n"
"record Email where\n"
"  constructor MkEmail\n"
"  value : String\n"
"\n"
"record Password where\n"
"  constructor MkPassword\n"
"  value : String\n"
"\n"
"record User where\n"
"  constructor MkUser\n"
"  name     : String\n"
"  email    : Email\n"
"  password : Password\n"
"  albums   : List Album\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:202
msgid ""
"Most of these should be self-explanatory. Note, however, that in several "
"cases (`Email`, `Artist`, `Password`) we wrap a single value in a new record "
"type. Of course, we *could* have used the unwrapped `String` type instead, "
"but we'd have ended up with many `String` fields, which can be hard to "
"disambiguate.  In order not to confuse an email string with a password "
"string, it can therefore be helpful to wrap both of them in a new record "
"type to drastically increase type safety at the cost of having to "
"reimplement some interfaces.  Utility function `on` from the *Prelude* is "
"very useful for this. Don't forget to inspect its type at the REPL, and try "
"to understand what's going on here."
msgstr ""
"これらはほぼ見ればわかります。\n"
"ただし、いくつかのレコード型（`Email`, `Artist`, `Password`）で単一の値を新し"
"いレコード型で梱包しているところに注目です。\n"
"当然、剥き出しの`String`型を代わりに使うことも*できはします*が、\n"
"そうすると最終的に`String`のフィールドが沢山あることになるため、\n"
"見分けがつきにくくなるかもしれません。\n"
"Eメールの文字列とパスワードの文字列を混同するなんてことがないように、\n"
"両方を新しいレコード型で梱包しておくと助けになります。\n"
"いくつかのインターフェースを再実装しなければいけない負担と引き換えに、型安全"
"性を劇的に高めますから。\n"
"*Prelude*由来の小間物関数`on`はこうしたとき大変役に立ちます。\n"
"型をREPLで調べて、何をするものなのか理解するのをお忘れなく。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:203
#, no-wrap
msgid ""
"Eq Artist where (==) = (==) `on` name\n"
"\n"
"Eq Email where (==) = (==) `on` value\n"
"\n"
"Eq Password where (==) = (==) `on` value\n"
"\n"
"Eq Album where (==) = (==) `on` \\a => (a.name, a.artist)\n"
msgstr ""
"Eq Artist where (==) = (==) `on` name\n"
"\n"
"Eq Email where (==) = (==) `on` value\n"
"\n"
"Eq Password where (==) = (==) `on` value\n"
"\n"
"Eq Album where (==) = (==) `on` \\a => (a.name, a.artist)\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:216
msgid ""
"In case of `Album`, we wrap the two fields of the record in a `Pair`, which "
"already comes with an implementation of `Eq`.  This allows us to again use "
"function `on`, which is very convenient."
msgstr ""
"`Album`の場合、レコードの2つのフィールドを`Pair`で梱包しています。\n"
"`Pair`には既に`Eq`の実装が付属しています。\n"
"なのでここでも関数`on`を使います。\n"
"とっても便利。"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:219
msgid ""
"Next, we have to define the data types representing server requests and "
"responses:"
msgstr "次に、サーバへの要求とサーバからの応答を表現するデータ型を定義します。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:220
#, no-wrap
msgid ""
"record Credentials where\n"
"  constructor MkCredentials\n"
"  email    : Email\n"
"  password : Password\n"
"\n"
"record Request where\n"
"  constructor MkRequest\n"
"  credentials : Credentials\n"
"  album       : Album\n"
"\n"
"data Response : Type where\n"
"  UnknownUser     : Email -> Response\n"
"  InvalidPassword : Response\n"
"  AccessDenied    : Email -> Album -> Response\n"
"  Success         : Album -> Response\n"
msgstr ""
"record Credentials where\n"
"  constructor MkCredentials\n"
"  email    : Email\n"
"  password : Password\n"
"\n"
"record Request where\n"
"  constructor MkRequest\n"
"  credentials : Credentials\n"
"  album       : Album\n"
"\n"
"data Response : Type where\n"
"  UnknownUser     : Email -> Response\n"
"  InvalidPassword : Response\n"
"  AccessDenied    : Email -> Album -> Response\n"
"  Success         : Album -> Response\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:243
msgid ""
"For server responses, we use a custom sum type encoding the possible "
"outcomes of a client request. In practice, the `Success` case would return "
"some kind of connection to start the actual album stream, but we just wrap "
"up the album we found to simulate this behavior."
msgstr ""
"サーバの応答については、自前の直和型を使って、顧客の要求に対するありうる出力"
"を符号化します。\n"
"実践の場では、`Success`のときには実際にアルバム配信を開始するための何らかの接"
"続を返すのでしょうが、\n"
"この振舞いを模擬するために、ここでは単に見付かったアルバムを梱包することにし"
"ます。"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:248
msgid ""
"We can now go ahead and simulate the handling of a request at the server. To "
"emulate our user data base, a simple list of users will do. Here's the type "
"of the function we'd like to implement:"
msgstr ""
"これで準備万端、サーバへの要求の制御を模擬できます。\n"
"利用者のデータベースを真似るには、利用者のリストがあれば事足ります。\n"
"こちらが実装したい関数の型です。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:249
#, no-wrap
msgid ""
"DB : Type\n"
"DB = List User\n"
"\n"
"handleRequest : DB -> Request -> Response\n"
msgstr ""
"DB : Type\n"
"DB = List User\n"
"\n"
"handleRequest : DB -> Request -> Response\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:265
msgid ""
"Note, how we defined a short alias for `List User` called `DB`.  This is "
"often useful to make lengthy type signatures more readable and communicate "
"the meaning of a type in the given context. However, this will *not* "
"introduce a new type, nor will it increase type safety: `DB` is *identical* "
"to `List User`, and as such, a value of type `DB` can be used wherever a "
"`List User` is expected and vice versa. In more complex programs it is "
"therefore usually preferable to define new types by wrapping values in "
"single-field records."
msgstr ""
"`DB`という名前で`List User`に短い別名を定義しましたね。\n"
"長めの型処方をより読みやすく、そこでの文脈に即した型の意味を教えてくれるもの"
"にするために、こうしておくと役に立つことがよくあります。\n"
"しかし、これはけして新しい型を導入して*いない*ので、\n"
"型安全性を増すこともありません。\n"
"`DB`と`List User`は*同一*であり、額面通りの意味で型`DB`の値は`List User`の値"
"が入るよう場所ならどこでも使えますし、逆もまた然りです。\n"
"したがって、より複雑なプログラムではたいてい単一フィールドレコードに値をくる"
"んで新しい型を定義するほうが好ましいです。"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:274
msgid ""
"The implementation will proceed as follows: It will first try and lookup a "
"`User` by is email address in the data base. If this is successful, it will "
"compare the provided password with the user's actual password. If the two "
"match, it will lookup the requested album in the user's list of albums.  If "
"all of these steps succeed, the result will be an `Album` wrapped in a "
"`Success`. If any of the steps fails, the result will describe exactly what "
"went wrong."
msgstr ""
"この関数の実装での処理は以下のように進行します。\n"
"まずEメールアドレスでデータベースから`User`を見付けだそうとします。\n"
"もしこれが成功したら、与えられたパスワードと利用者の実際のパスワードと比較し"
"ます。\n"
"もし2つが一致したら、利用者のアルバムのリストから要求されたアルバムを見付けだ"
"します。\n"
"もしこれらの過程の全てが成功したら、結果は`Success`にくるまれた`Album`になり"
"ます。\n"
"もしどれか1つでも過程が失敗したら、正確に何が起こったのかを表現する結果を返し"
"ます。"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:276
msgid "Here's a possible implementation:"
msgstr "考えられる実装はこちらです。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:277
#, no-wrap
msgid ""
"handleRequest db (MkRequest (MkCredentials email pw) album) =\n"
"  case lookupUser db of\n"
"    Just (MkUser _ _ password albums)  =>\n"
"      if password == pw then lookupAlbum albums else InvalidPassword\n"
"\n"
"    Nothing => UnknownUser email\n"
"\n"
"  where lookupUser : List User -> Maybe User\n"
"        lookupUser []        = Nothing\n"
"        lookupUser (x :: xs) =\n"
"          if x.email == email then Just x else lookupUser xs\n"
"\n"
"        lookupAlbum : List Album -> Response\n"
"        lookupAlbum []        = AccessDenied email album\n"
"        lookupAlbum (x :: xs) =\n"
"          if x == album then Success album else lookupAlbum xs\n"
msgstr ""
"handleRequest db (MkRequest (MkCredentials email pw) album) =\n"
"  case lookupUser db of\n"
"    Just (MkUser _ _ password albums)  =>\n"
"      if password == pw then lookupAlbum albums else InvalidPassword\n"
"\n"
"    Nothing => UnknownUser email\n"
"\n"
"  where lookupUser : List User -> Maybe User\n"
"        lookupUser []        = Nothing\n"
"        lookupUser (x :: xs) =\n"
"          if x.email == email then Just x else lookupUser xs\n"
"\n"
"        lookupAlbum : List Album -> Response\n"
"        lookupAlbum []        = AccessDenied email album\n"
"        lookupAlbum (x :: xs) =\n"
"          if x == album then Success album else lookupAlbum xs\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:305
msgid ""
"I'd like to point out several things in this example. First, note how we can "
"extract values from nested records in a single pattern match.  Second, we "
"defined two *local* functions in a `where` block: `lookupUser`, and "
"`lookupAlbum`. Both of these have access to all variables in the surrounding "
"scope. For instance, `lookupUser` uses the `album` variable from the pattern "
"match in the implementation's first line. Likewise, `lookupAlbum` makes use "
"of the `album` variable."
msgstr ""
"この例にあるいくつかの点について指摘したいと思います。\n"
"まず、1回のパターン照合で入れ子のレコードから値を抽出することができます。\n"
"2つ目に2つの*局所*関数を`where`ブロック内に定義しました。\n"
"`lookupUser`と`lookupAlbum`です。\n"
"両方の関数は囲まれたスコープにある全ての変数にアクセスできます。\n"
"例えば`lookupUser`は実装の最初の行にあるパターン照合から`album`変数を使いま"
"す。\n"
"同様に`lookupAlbum`も`album`変数を使用します。"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:310
msgid ""
"A `where` block introduces new local definitions, accessible only from the "
"surrounding scope and from other functions defined later in the same `where` "
"block. These need to be explicitly typed and indented by the same amount of "
"whitespace."
msgstr ""
"`where`ブロックは新しい局所定義を導入し、\n"
"`where`がある周囲のスコープと同じ`where`ブロックにある後に定義された他の関数"
"からのみ、\n"
"この定義にアクセスできます。\n"
"これらの定義は明示的に型付けされ同量の空白で字下げされていなければいけませ"
"ん。"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:318
msgid ""
"Local definitions can also be introduce *before* a function's implementation "
"by using the `let` keyword. This usage of `let` is not to be confused with "
"*let bindings* described above, which are used to bind and reuse the results "
"of intermediate computations. Below is how we could have implemented "
"`handleRequest` with local definitions introduced by the `let` keyword. "
"Again, all definitions have to be properly typed and indented:"
msgstr ""
"局所定義は`let`キーワードを用いて関数の実装の*前*で導入しても構いません。\n"
"この`let`の使用法は前述した*let束縛*と混同しないようにしてください。\n"
"let束縛は一時的な計算の結果を束縛して再利用するものでした。\n"
"以下では`handleRequest`を`let`キーワードにより導入された局所定義でどのように"
"実装できるかを示しています。\n"
"繰り返しますが、全ての定義は適切に型付けされ、字下げされている必要がありま"
"す。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:319
#, no-wrap
msgid ""
"handleRequest' : DB -> Request -> Response\n"
"handleRequest' db (MkRequest (MkCredentials email pw) album) =\n"
"  let lookupUser : List User -> Maybe User\n"
"      lookupUser []        = Nothing\n"
"      lookupUser (x :: xs) =\n"
"        if x.email == email then Just x else lookupUser xs\n"
"\n"
"      lookupAlbum : List Album -> Response\n"
"      lookupAlbum []        = AccessDenied email album\n"
"      lookupAlbum (x :: xs) =\n"
"        if x == album then Success album else lookupAlbum xs\n"
"\n"
"   in case lookupUser db of\n"
"        Just (MkUser _ _ password albums)  =>\n"
"          if password == pw then lookupAlbum albums else InvalidPassword\n"
"\n"
"        Nothing => UnknownUser email\n"
msgstr ""
"handleRequest' : DB -> Request -> Response\n"
"handleRequest' db (MkRequest (MkCredentials email pw) album) =\n"
"  let lookupUser : List User -> Maybe User\n"
"      lookupUser []        = Nothing\n"
"      lookupUser (x :: xs) =\n"
"        if x.email == email then Just x else lookupUser xs\n"
"\n"
"      lookupAlbum : List Album -> Response\n"
"      lookupAlbum []        = AccessDenied email album\n"
"      lookupAlbum (x :: xs) =\n"
"        if x == album then Success album else lookupAlbum xs\n"
"\n"
"   in case lookupUser db of\n"
"        Just (MkUser _ _ password albums)  =>\n"
"          if password == pw then lookupAlbum albums else InvalidPassword\n"
"\n"
"        Nothing => UnknownUser email\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:345
msgid ""
"The exercises in this section are supposed to increase you experience in "
"writing purely functional code. In some cases it might be useful to use "
"`let` expressions or `where` blocks, but this will not always be required."
msgstr ""
"この節の演習で純粋関数型のコードを書く経験値が上がるでしょう。\n"
"場合によっては`let`式や`where`ブロックを使うと便利かもしれませんが、\n"
"いつも必要というわけではありません。"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:350
msgid ""
"Exercise 3 is again of utmost importance. `traverseList` is a specialized "
"version of the more general `traverse`, one of the most powerful and "
"versatile functions available in the *Prelude* (check out its type!)."
msgstr ""
"演習3はまたもや最重要です。\n"
"`traverseList`はより汎用的な`traverse`の特殊版です。\n"
"`traverse`は最も強力で多芸な関数の1つで、*Prelude*にあります（型を確認しま"
"しょう！）。"

#. type: Bullet: '1. '
#: ../src/Tutorial/Functions2.md:355
msgid ""
"Module `Data.List` in *base* exports functions `find` and `elem`.  Inspect "
"their types and use these in the implementation of `handleRequest`. This "
"should allow you to completely get rid of the `where` block."
msgstr ""
"*base*のモジュール`Data.List`は関数`find`と`elemBy`を公開しています。\n"
"型を調べた上で、`handleRequest`の実装で使ってください。\n"
"これで完全に`where`ブロックを排除できます。"

#. type: Bullet: '2. '
#: ../src/Tutorial/Functions2.md:365
msgid ""
"Define an enumeration type listing the four [nucleobases](https://en."
"wikipedia.org/wiki/Nucleobase)  occurring in DNA strands. Define also a type "
"alias `DNA` for lists of nucleobases.  Declare and implement function "
"`readBase` for converting a single character (type `Char`) to a nucleobase.  "
"You can use character literals in your implementation like so: `'A'`, `'a'`. "
"Note, that this function might fail, so adjust the result type accordingly."
msgstr ""
"DND鎖に表れる4つの[核酸塩基](https://en.wikipedia.org/wiki/Nucleobase)をリス"
"トにした列挙型を定義してください。\n"
"核酸塩基のリストについて、型別称`DNA`も定義してください。\n"
"単一文字（型`Char`）を核酸塩基に変換する関数`readBase`を宣言・実装してくださ"
"い。\n"
"実装では`'A'`, `'a'`のように文字リテラルが使えます。\n"
"この関数は失敗するかもしれないので、\n"
"結果の型をそれにしたがって調整してください。"

#. type: Bullet: '3. '
#: ../src/Tutorial/Functions2.md:371
msgid ""
"Implement the following function, which tries to convert all values in a "
"list with a function, which might fail. The result should be a `Just` "
"holding the list of converted values in unmodified order, if and only if "
"every single conversion was successful."
msgstr ""
"次の関数を実装してください。\n"
"リスト中の全ての値を関数で変換しようとするものです。\n"
"ただし、関数は失敗するかもしれません。\n"
"全ての変換が成功したときに限って、\n"
"結果は同じ順序で変換後の値のリストが入った`Just`になります。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:372
#, no-wrap
msgid "   traverseList : (a -> Maybe b) -> List a -> Maybe (List b)\n"
msgstr "   traverseList : (a -> Maybe b) -> List a -> Maybe (List b)\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:378
#, no-wrap
msgid ""
"   You can verify, that the function behaves correctly with\n"
"   the following test: `traverseList Just [1,2,3] = Just [1,2,3]`.\n"
msgstr ""
"   関数が正しく振る舞うことを以下の検査で確かめられます。\n"
"   `traverseList Just [1,2,3] = Just [1,2,3]`\n"

#. type: Bullet: '4. '
#: ../src/Tutorial/Functions2.md:382
msgid ""
"Implement function `readDNA : String -> Maybe DNA` using the functions and "
"types defined in exercises 2 and 3.  You will also need function `unpack` "
"from the *Prelude*."
msgstr ""
"演習2と3で定義した関数と型を使って、関数`readDNA : String -> Maybe DNA`を実装"
"してください。\n"
"*Prelude*の関数*unpack*も要ることでしょう。"

#. type: Bullet: '5. '
#: ../src/Tutorial/Functions2.md:385
msgid ""
"Implement function `complement : DNA -> DNA` to calculate the complement of "
"a strand of DNA."
msgstr "DNA鎖の転写を計算する関数`complement : DNA -> DNA`を実装してください。"

#. type: Title ##
#: ../src/Tutorial/Functions2.md:386
#, no-wrap
msgid "The Truth about Function Arguments"
msgstr "関数引数の真実"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:390
msgid ""
"So far, when we defined a top level function, it looked something like the "
"following:"
msgstr "ここまで、最上位で定義された関数は以下のような見た目をしていました。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:391
#, no-wrap
msgid ""
"zipEitherWith : (a -> b -> c) -> Either e a -> Either e b -> Either e c\n"
"zipEitherWith f (Right va) (Right vb) = Right (f va vb)\n"
"zipEitherWith f (Left e)   _          = Left e\n"
"zipEitherWith f _          (Left e)   = Left e\n"
msgstr ""
"zipEitherWith : (a -> b -> c) -> Either e a -> Either e b -> Either e c\n"
"zipEitherWith f (Right va) (Right vb) = Right (f va vb)\n"
"zipEitherWith f (Left e)   _          = Left e\n"
"zipEitherWith f _          (Left e)   = Left e\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:401
msgid ""
"Function `zipEitherWith` is a generic higher-order function combining the "
"values stored in two `Either`s via a binary function. If either of the "
"`Either` arguments is a `Left`, the result is also a `Left`."
msgstr ""
"関数`zipEitherWith`は汎化高階関数で、2つの`Either`に保管された値を2引数関数を"
"介して結合します。\n"
"どちらかの`Either`引数が`Left`なら、結果もまた`Left`です。"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:407
msgid ""
"This is a *generic function* with *type parameters* `a`, `b`, `c`, and `e`.  "
"However, there is a more verbose type for `zipEitherWith`, which is visible "
"in the REPL when entering `:ti zipEitherWith` (the `i` here tells Idris to "
"include `implicit` arguments). You will get a type similar to this:"
msgstr ""
"これは*汎化関数*で*型変数*`a`, `b`, `c`, `e`を取ります。\n"
"しかし、もっと冗長な型が`zipEitherWith`にはあります。\n"
"この型はREPLで見ることができ、`:ti zipEitherWith`と入力すればよいです（ここで"
"`i`はIdrisが`implicit`（訳註：暗黙の）引数を含めるようにという意味です）。\n"
"こんな感じの型になります。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:408
#, no-wrap
msgid ""
"zipEitherWith' :  {0 a : Type}\n"
"               -> {0 b : Type}\n"
"               -> {0 c : Type}\n"
"               -> {0 e : Type}\n"
"               -> (a -> b -> c)\n"
"               -> Either e a\n"
"               -> Either e b\n"
"               -> Either e c\n"
msgstr ""
"zipEitherWith' :  {0 a : Type}\n"
"               -> {0 b : Type}\n"
"               -> {0 c : Type}\n"
"               -> {0 e : Type}\n"
"               -> (a -> b -> c)\n"
"               -> Either e a\n"
"               -> Either e b\n"
"               -> Either e c\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:421
msgid ""
"In order to understand what's going on here, we will have to talk about "
"named arguments, implicit arguments, and quantities."
msgstr ""
"何が起こっているのかを理解するには、\n"
"名前付き引数、暗黙引数、そして数量子についてお話しせねばなりません。"

#. type: Title ###
#: ../src/Tutorial/Functions2.md:422
#, no-wrap
msgid "Named Arguments"
msgstr "名前付き引数"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:425
msgid "In a function type, we can give each argument a name. Like so:"
msgstr ""
"関数の型ではそれぞれの引数に名前を付けられます。\n"
"こんな感じ。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:426
#, no-wrap
msgid ""
"fromMaybe : (deflt : a) -> (ma : Maybe a) -> a\n"
"fromMaybe deflt Nothing = deflt\n"
"fromMaybe _    (Just x) = x\n"
msgstr ""
"fromMaybe : (deflt : a) -> (ma : Maybe a) -> a\n"
"fromMaybe deflt Nothing = deflt\n"
"fromMaybe _    (Just x) = x\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:439
msgid ""
"Here, the first argument is given name `deflt`, the second `ma`. These names "
"can be reused in a function's implementation, as was done for `deflt`, but "
"this is not mandatory: We are free to use different names in the "
"implementation. There are several reasons, why we'd choose to name our "
"arguments: It can serve as documentation, but it also allows us to pass the "
"arguments to a function in arbitrary order when using the following syntax:"
msgstr ""
"ここで最初の引数は`deflt`と名付けられており、2つ目のほうは`ma`です。\n"
"これらの名前は関数の実装で再利用することができ、\n"
"実際に`deflt`がそうなっています。\n"
"でもこれは必須ではありません。\n"
"実装で違う名前を使うことも自由です。\n"
"なぜ引数のための名前を選ぶのかということには、いくつかの理由があります。\n"
"名前はドキュメントとして機能しますが、\n"
"加えて以下の構文を使うときは任意の順序で関数に引数を渡せます。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:440
#, no-wrap
msgid ""
"extractBool : Maybe Bool -> Bool\n"
"extractBool v = fromMaybe { ma = v, deflt = False }\n"
msgstr ""
"extractBool : Maybe Bool -> Bool\n"
"extractBool v = fromMaybe { ma = v, deflt = False }\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:446
msgid "Or even :"
msgstr "さらに言えば以下です。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:447
#, no-wrap
msgid ""
"extractBool2 : Maybe Bool -> Bool\n"
"extractBool2 = fromMaybe { deflt = False }\n"
msgstr ""
"extractBool2 : Maybe Bool -> Bool\n"
"extractBool2 = fromMaybe { deflt = False }\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:454
msgid ""
"The arguments in a record's constructor are automatically named in "
"accordance with the field names:"
msgstr ""
"レコード構築子内の引数はフィールド名にしたがって自動的に名付けられます。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:455
#, no-wrap
msgid ""
"record Dragon where\n"
"  constructor MkDragon\n"
"  name      : String\n"
"  strength  : Nat\n"
"  hitPoints : Int16\n"
"\n"
"gorgar : Dragon\n"
"gorgar = MkDragon { strength = 150, name = \"Gorgar\", hitPoints = 10000 }\n"
msgstr ""
"record Dragon where\n"
"  constructor MkDragon\n"
"  name      : String\n"
"  strength  : Nat\n"
"  hitPoints : Int16\n"
"\n"
"gorgar : Dragon\n"
"gorgar = MkDragon { strength = 150, name = \"Gorgar\", hitPoints = 10000 }\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:471
msgid ""
"For the use cases described above, named arguments are merely a convenience "
"and completely optional. However, Idris is a *dependently typed* programming "
"language: Types can be calculated from and depend on values. For instance, "
"the *result type* of a function can *depend* on the *value* of one of its "
"arguments. Here's a contrived example:"
msgstr ""
"上で述べた使用例では、名前付き引数は単に便利というだけで完全にあってもなくて"
"もよいものでした。\n"
"しかし、Idrisは*依存型*プログラミング言語です。\n"
"つまり、型は値から計算することができ、型は値に依存することができます。\n"
"たとえば、関数の*結果の型*はその引数のうちの1つの*値*に*依存*するようにできま"
"す。\n"
"以下はわざとらしい例です。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:472
#, no-wrap
msgid ""
"IntOrString : Bool -> Type\n"
"IntOrString True  = Integer\n"
"IntOrString False = String\n"
"\n"
"intOrString : (v : Bool) -> IntOrString v\n"
"intOrString False = \"I'm a String\"\n"
"intOrString True  = 1000\n"
msgstr ""
"IntOrString : Bool -> Type\n"
"IntOrString True  = Integer\n"
"IntOrString False = String\n"
"\n"
"intOrString : (v : Bool) -> IntOrString v\n"
"intOrString False = \"I'm a String\"\n"
"intOrString True  = 1000\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:489
msgid ""
"If you see such a thing for the first time, it can be hard to understand "
"what's going on here. First, function `IntOrString` computes a `Type` from a "
"`Bool` value: If the argument is `True`, it returns type `Integer`, if the "
"argument is `False` it returns `String`. We use this to calculate the return "
"type of function `intOrString` based on its boolean argument `v`: If `v` is "
"`True`, the return type is (in accordance with `IntOrString True = Integer`) "
"`Integer`, otherwise it is `String`."
msgstr ""
"初めてこれを見ると、何が起こっているのか理解しにくいことでしょう。\n"
"まず、関数`IntOrString`は`Type`を`Bool`値から算出します。\n"
"引数が`True`なら返る型は`Integer`で、引数が`False`なら`String`が返ります。\n"
"これを、真偽値引数`v`に基づいて、関数`intOrString`の返却型を計算するのに使っ"
"ています。\n"
"`v`が`True`なら返却型は`Integer`で（`IntOrString True = Integer`に従っていま"
"す）、そうでなければ`String`です。"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:493
msgid ""
"Note, how in the type signature of `intOrString`, we *must* give the "
"argument of type `Bool` a name (`v`) in order to reference it in the result "
"type `IntOrString v`."
msgstr ""
"ここで、`intOrString`の型処方では型`Bool`の引数に名前(`v`)を与える*必要*があ"
"りますね。\n"
"返却型`IntOrString v`で参照するためです。"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:500
msgid ""
"You might wonder at this moment, why this is useful and why we would ever "
"want to define a function with such a strange type. We will see lots of very "
"useful examples in due time! For now, suffice to say that in order to "
"express dependent function types, we need to name at least some of the "
"function's arguments and refer to them by name in the types of other "
"arguments."
msgstr ""
"今の時点では、どうしてこれが便利なのか、どうしてまたそんな妙な型の関数を定義"
"したくなるものか、と怪訝に思われるかもしれません。\n"
"来たるべき時に、とても有用な例を沢山見ていきましょう！\n"
"依存型の関数の型を表現するために、\n"
"少なくともいくつかの関数の引数に名前を付けたり、\n"
"他の引数の型で名付けた引数の名前を参照したりする必要があるのだ、\n"
"ということが伝われば充分です。"

#. type: Title ###
#: ../src/Tutorial/Functions2.md:501
#, no-wrap
msgid "Implicit Arguments"
msgstr "暗黙引数"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:509
msgid ""
"Implicit arguments are arguments, the values of which the compiler should "
"infer and fill in for us automatically. For instance, in the following "
"function signature, we expect the compiler to infer the value of type "
"parameter `a` automatically from the types of the other arguments (ignore "
"the 0 quantity for the moment; I'll explain it in the next subsection):"
msgstr ""
"暗黙引数とは、\n"
"コンパイラが推論して自動的に記入してくれるような値の引数を指します。\n"
"たとえば、以下の関数処方では、コンパイラが型変数`a`の値を他の引数の型から自動"
"的に推定してくれるようになっています。\n"
"（0数量子はここでは無視してください。\n"
"次の小節で説明します。）"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:510
#, no-wrap
msgid ""
"maybeToEither : {0 a : Type} -> Maybe a -> Either String a\n"
"maybeToEither Nothing  = Left \"Nope\"\n"
"maybeToEither (Just x) = Right x\n"
"\n"
"-- Please remember, that the above is\n"
"-- equivalent to the following:\n"
"maybeToEither' : Maybe a -> Either String a\n"
"maybeToEither' Nothing  = Left \"Nope\"\n"
"maybeToEither' (Just x) = Right x\n"
msgstr ""
"maybeToEither : {0 a : Type} -> Maybe a -> Either String a\n"
"maybeToEither Nothing  = Left \"Nope\"\n"
"maybeToEither (Just x) = Right x\n"
"\n"
"-- Please remember, that the above is\n"
"-- equivalent to the following:\n"
"maybeToEither' : Maybe a -> Either String a\n"
"maybeToEither' Nothing  = Left \"Nope\"\n"
"maybeToEither' (Just x) = Right x\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:527
msgid ""
"As you can see, implicit arguments are wrapped in curly braces, unlike "
"explicit named arguments, which are wrapped in parentheses.  Inferring the "
"value of an implicit argument is not always possible.  For instance, if we "
"enter the following at the REPL, Idris will fail with an error:"
msgstr ""
"見てとれるように、暗黙引数は波括弧に囲まれており、明示的な名前付き引数とは違"
"います。\n"
"名前付き引数では丸括弧に囲まれていたのでした。\n"
"暗黙引数の値を推論することはいつもできるわけではありません。\n"
"たとえば、以下をREPLに入力すると、Idrisはエラーを出して実行に失敗します。"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions2.md:528
#, no-wrap
msgid ""
"Tutorial.Functions2> show (maybeToEither Nothing)\n"
"Error: Can't find an implementation for Show (Either String ?a).\n"
msgstr ""
"Tutorial.Functions2> show (maybeToEither Nothing)\n"
"Error: Can't find an implementation for Show (Either String ?a).\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:540
msgid ""
"Idris is unable to find an implementation of `Show (Either String a)` "
"without knowing what `a` actually is.  Note the question mark in front of "
"the type parameter: `?a`.  If this happens, there are several ways to help "
"the type checker.  We could, for instance, pass a value for the implicit "
"argument explicitly. Here's the syntax to do this:"
msgstr ""
"Idrisは`a`が実際に何であるかを知らずに`Show (Either String a)`の実装を見つけ"
"ることはできません。\n"
"型変数の前の疑問符がありますね。\n"
"`?a`となっています。\n"
"こうなったら型検査器を手助けする方法がいくつかあります。\n"
"たとえば暗黙引数に値を明示的に渡すことができます。\n"
"以下がそうするための構文です。"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions2.md:541
#, no-wrap
msgid ""
"Tutorial.Functions2> show (maybeToEither {a = Int8} Nothing)\n"
"\"Left \"Nope\"\"\n"
msgstr ""
"Tutorial.Functions2> show (maybeToEither {a = Int8} Nothing)\n"
"\"Left \"Nope\"\"\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:549
msgid ""
"As you can see, we use the same syntax as shown above for explicit named "
"arguments and the two forms of argument passing can be mixed."
msgstr ""
"見てとれるように明示的な名前付き引数のところで前に見たのと同じ文法を使ってい"
"ます。\n"
"また、2種の引数の渡し方は混在させられます。"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:552
msgid ""
"We could also specify the type of the whole expression using utility "
"function `the` from the *Prelude*:"
msgstr ""
"*Prelude*由来の小間物関数`the`を使って、全体の式の型を指定することもできま"
"す。"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions2.md:553
#, no-wrap
msgid ""
"Tutorial.Functions2> show (the (Either String Int8) (maybeToEither Nothing))\n"
"\"Left \"Nope\"\"\n"
msgstr ""
"Tutorial.Functions2> show (the (Either String Int8) (maybeToEither Nothing))\n"
"\"Left \"Nope\"\"\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:559
msgid "It is instructive to have a look at the type of `the`:"
msgstr "`the`の型を見てみるとわかりやすいです。"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions2.md:560
#, no-wrap
msgid ""
"Tutorial.Functions2> :ti the\n"
"Prelude.the : (0 a : Type) -> a -> a\n"
msgstr ""
"Tutorial.Functions2> :ti the\n"
"Prelude.the : (0 a : Type) -> a -> a\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:566
msgid "Compare this with the identity function `id`:"
msgstr "小間物関数`id`と比較してみましょう。"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions2.md:567
#, no-wrap
msgid ""
"Tutorial.Functions2> :ti id\n"
"Prelude.id : {0 a : Type} -> a -> a\n"
msgstr ""
"Tutorial.Functions2> :ti id\n"
"Prelude.id : {0 a : Type} -> a -> a\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:581
msgid ""
"The only difference between the two: In case of `the`, the type parameter "
"`a` is an *explicit* argument, while in case of `id`, it is an *implicit* "
"argument. Although the two functions have almost identical types (and "
"implementations!), they serve quite different purposes: `the` is used to "
"help type inference, while `id` is used whenever we'd like to return an "
"argument without modifying it at all (which, in the presence of higher-order "
"functions, happens surprisingly often)."
msgstr ""
"唯一の2つの違いはというと、\n"
"`the`の場合型変数`a`が*明示的な*引数であるのに対し、\n"
"`id`の場合*暗黙の*引数であることです。\n"
"2つの関数はほぼ同じ型（と実装！）であるにも関わらず、\n"
"かなり異なる目的で使われます。\n"
"`the`は型推論を助けるために使われますが、\n"
"`id`は引数を全く変更することなしに返したいようなときに使います。\n"
"（`id`は高階関数があるときは驚くほどよく使います。）"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:585
msgid ""
"Both ways to improve type inference shown above are used quite often, and "
"must be understood by Idris programmers."
msgstr ""
"上で見た型推論を向上する両方の手段はかなりよく使います。\n"
"Idrisのプログラマは理解しておく必要があります。"

#. type: Title ###
#: ../src/Tutorial/Functions2.md:586
#, no-wrap
msgid "Multiplicities"
msgstr "多重度"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:593
msgid ""
"Finally, we need to talk about the zero multiplicity, which appeared in "
"several of the type signatures in this section. Idris 2, unlike its "
"predecessor Idris 1, is based on a core language called *quantitative type "
"theory* (QTT): Every variable in Idris 2 is associated with one of three "
"possible multiplicities:"
msgstr ""
"最後にゼロ多重度について話さねばなりません。\n"
"ゼロ多重度は本節の型処方でちらほら出ていました。\n"
"Idris 2は前作のIdris 1とは異なり、*数量的型理論* (quantitative type theory; "
"QTT) と呼ばれる中核言語に基づいています。\n"
"つまり、Idris 2での全ての変数には以下の3つの多重度のうち1つが関係するのです。"

#. type: Bullet: '* '
#: ../src/Tutorial/Functions2.md:598
msgid "`0`, meaning that the variable is *erased* at runtime."
msgstr "`0`、これは変数が実行時に*消去*されるという意味です。"

#. type: Bullet: '* '
#: ../src/Tutorial/Functions2.md:598
msgid "`1`, meaning that the variable is used *exactly once* at runtime."
msgstr "`1`、これは変数が実行時に*ちょうど1回だけ*使われるという意味です。"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:598
#, no-wrap
msgid ""
"* *Unrestricted* (the default), meaning that the variable is used\n"
"   an arbitrary number of times at runtime.\n"
msgstr "* *制限なし*（既定値）、これは変数が実行時に際限なく使えるという意味です。\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:604
msgid ""
"We will not talk about the most complex of the three, multiplicity `1`, "
"here.  We are, however, often interested in multiplicity `0`: A variable "
"with multiplicity `0` is only relevant at *compile time*. It will not make "
"any appearance at runtime, and the computation of such a variable will never "
"affect a program's runtime performance."
msgstr ""
"3つの中で最も複雑な多重度`1`についてはここでは触れません。\n"
"しかし、多重度`0`はよく着目されます。\n"
"多重度`0`の変数は*コンパイル時*のみに関係があります。\n"
"実行時には姿を見せず、その変数の計算はプログラムの実行時効率に何ら影響があり"
"ません。"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:609
msgid ""
"In the type signature of `maybeToEither` we see that type parameter `a` has "
"multiplicity `0`, and will therefore be erased and is only relevant at "
"compile time, while the `Maybe a` argument has *unrestricted* multiplicity."
msgstr ""
"`maybeToEither`の型処方では型変数`a`が多重度`0`を持っていましたが、\n"
"それはつまり型変数が消去されコンパイル時にのみ関係するということなのです。\n"
"一方で`Maybe a`引数は*制限なし*多重度です。"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:613
msgid ""
"It is also possible to annotate explicit arguments with multiplicities, in "
"which case the argument must again be put in parentheses. For an example, "
"look again at the type signature of `the`."
msgstr ""
"明示的に引数に多重度を註釈することもできます。\n"
"その場合ここでも引数は括弧内になくてはいけません。\n"
"例えば`the`の型処方をもう一度見てみてください。"

#. type: Title ###
#: ../src/Tutorial/Functions2.md:614
#, no-wrap
msgid "Underscores"
msgstr "下線文字"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:623
msgid ""
"It is often desirable, to only write as little code as necessary and let "
"Idris figure out the rest.  We have already learned about one such occasion: "
"Catch-all patterns.  If a variable in a pattern match is not used on the "
"right hand side, we can't just drop it, as this would make it impossible for "
"Idris, which of several arguments we were planning to drop, but we can use "
"an underscore as a placeholder instead:"
msgstr ""
"必要最小限のコードだけを書いて、残りをIdrisに調べさせたいことはよくありま"
"す。\n"
"既にそのような状況について学びました。\n"
"全部堰き止めるパターンです。\n"
"パターン照合の変数が右側で使われなければ、\n"
"単に省略するだけということはできないものの（複数の引数のうちどれを省くつもり"
"なのかをIdrisが推定できません）、\n"
"代わりに下線文字で場所取りをすることができます。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:624
#, no-wrap
msgid ""
"isRight : Either a b -> Bool\n"
"isRight (Right _) = True\n"
"isRight _         = False\n"
msgstr ""
"isRight : Either a b -> Bool\n"
"isRight (Right _) = True\n"
"isRight _         = False\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:633
msgid ""
"But when we look at the type signature of `isRight`, we will note that type "
"parameters `a` and `b` are also only used once, and are therefore of no "
"importance. Let's get rid of them:"
msgstr ""
"しかし`isRight`の型処方を見れば、型変数`a`と`b`も1度のみ使われており、\n"
"したがって特に重要ではないことに気付きます。\n"
"型変数を省きましょう。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:634
#, no-wrap
msgid ""
"isRight' : Either _ _ -> Bool\n"
"isRight' (Right _) = True\n"
"isRight' _         = False\n"
msgstr ""
"isRight' : Either _ _ -> Bool\n"
"isRight' (Right _) = True\n"
"isRight' _         = False\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:645
#, no-wrap
msgid ""
"In the detailed type signature of `zipEitherWith`, it should\n"
"be obvious for Idris that the implicit arguments are of type `Type`.\n"
"After all, all of them are later on applied to the `Either` type\n"
"constructor, which is of type `Type -> Type -> Type`. Let's get rid\n"
"of them:\n"
msgstr ""
"`zipEitherWith`の詳細な型処方では、Idrisにとって暗黙引数が型`Type`なことは明らかでしょう。\n"
"とどのつまり、全部あとで`Either`型構築子に適用されるのです。\n"
"この型構築子は型が`Type -> Type -> Type`です。\n"
"省いてみましょう。\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:646
#, no-wrap
msgid ""
"zipEitherWith'' :  {0 a : _}\n"
"                -> {0 b : _}\n"
"                -> {0 c : _}\n"
"                -> {0 e : _}\n"
"                -> (a -> b -> c)\n"
"                -> Either e a\n"
"                -> Either e b\n"
"                -> Either e c\n"
msgstr ""
"zipEitherWith'' :  {0 a : _}\n"
"                -> {0 b : _}\n"
"                -> {0 c : _}\n"
"                -> {0 e : _}\n"
"                -> (a -> b -> c)\n"
"                -> Either e a\n"
"                -> Either e b\n"
"                -> Either e c\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:658
msgid "Consider the following contrived example:"
msgstr "以下のわざとらしい例について考えましょう。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:659
#, no-wrap
msgid ""
"foo : Integer -> String\n"
"foo n = show (the (Either String Integer) (Right n))\n"
msgstr ""
"foo : Integer -> String\n"
"foo n = show (the (Either String Integer) (Right n))\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:669
msgid ""
"Since we wrap an `Integer` in a `Right`, it is obvious that the second "
"argument in `Either String Integer` is `Integer`. Only the `String` argument "
"can't be inferred by Idris. Even better, the `Either` itself is obvious! "
"Let's get rid of the unnecessary noise:"
msgstr ""
"`Integer`を`Right`の中にくるんでいるので、\n"
"`Either String Integer`の2つ目の引数が`Integer`であることは自明です。\n"
"`String`だけIdrisは推論できません。\n"
"さらにいいことに`Either`自体も明らかなのです！\n"
"不必要な雑音を消しましょう。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:670
#, no-wrap
msgid ""
"foo' : Integer -> String\n"
"foo' n = show (the (_ String _) (Right n))\n"
msgstr ""
"foo' : Integer -> String\n"
"foo' n = show (the (_ String _) (Right n))\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:680
msgid ""
"Please note, that using underscores as in `foo'` is not always desirable, as "
"it can quite drastically obfuscate the written code. Always use a syntactic "
"convenience to make code more readable, and not to show people how clever "
"you are."
msgstr ""
"注意していただきたいのは、`foo`でのように下線文字を使うことはいつも望ましいも"
"のとは限らないということです。\n"
"書かれたコードをかなり劇的に朧気なものにしてしまいかねないからです。\n"
"文法的に便利なものを使うのは常にコードを読みやすくするためにし、\n"
"人々にあなたの賢さを誇示しないようにしましょう。"

#. type: Title ##
#: ../src/Tutorial/Functions2.md:681
#, no-wrap
msgid "Programming with Holes"
msgstr "穴開きプログラミング"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:696
msgid ""
"Solved all the exercises so far? Got angry at the type checker for always "
"complaining and never being really helpful? It's time to change that. Idris "
"comes with several highly useful interactive editing features. Sometimes, "
"the compiler is able to implement complete functions for us (if the types "
"are specific enough). Even if that's not possible, there's an incredibly "
"useful and important feature, which can help us when the types are getting "
"too complicated: Holes.  Holes are variables, the names of which are "
"prefixed with a question mark.  We can use them as placeholders whenever we "
"plan to implement a piece of functionality at a later time. In addition, "
"their types and the types and quantities of all other variables in scope can "
"be inspected at the REPL (or in your editor, if you setup the necessary "
"plugin).  Let's see them holes in action."
msgstr ""
"ここまでの演習を全部解いてきましたか？\n"
"型検査器にいつも小言をくらっていて本当は役に立っていないと腹を立てているで"
"しょうか？\n"
"今それが変わります。\n"
"Idrisにはいくつかの大変役に立つ対話的な編集機能が備わっています。\n"
"（型が充分に特定のものであれば）時々コンパイラは完全な関数を実装できることが"
"あります。\n"
"それができない場合であっても、非常に有用で重要な特徴がIdrisにはあります。\n"
"型が複雑になりすぎたときに手助けしてくれるもの、それが穴です。\n"
"穴は変数で、変数名は疑問符が前に付きます。\n"
"あとで機能の一部を実装するつもりの場所であればどこにでも、穴を仮置場として使"
"えます。\n"
"加えて穴の型と穴のスコープにある他の全ての変数の型と数量子をREPLで（あるいは"
"必要なプラグインが設定できていればエディタで）調べることができます。\n"
"穴あきを実際に見てみましょう。"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:704
msgid ""
"Remember the `traverseList` example from an Exercise earlier in this "
"section? If this was your first encounter with applicative list traversals, "
"this might have been a nasty bit of work. Well, let's just make it a wee bit "
"harder still. We'd like to implement the same piece of functionality for "
"functions returning `Either e`, where `e` is a type with a `Semigroup` "
"implementation, and we'd like to accumulate the values in all `Left`s we "
"meet along the way."
msgstr ""
"本節の前のほうの演習の`traverseList`の例を覚えていますか。\n"
"初めて適用的リスト巡回に出喰わしたのだとしたら、仕組みがちょっと腑に落ちな"
"かったかもしれません。\n"
"そうですね、もう少しつぶさに見てみることにしましょう。\n"
"`Either e`を返す同じ機能の関数を実装することを考えます。\n"
"ここで`e`は`Semigroup`の実装を持つ型であり、\n"
"巡回の道中にある`Left`の全ての値を積み重ねます。"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:706
msgid "Here's the type of the function:"
msgstr "以下が関数の型です。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:707
#, no-wrap
msgid ""
"traverseEither :  Semigroup e\n"
"               => (a -> Either e b)\n"
"               -> List a\n"
"               -> Either e (List b)\n"
msgstr ""
"traverseEither :  Semigroup e\n"
"               => (a -> Either e b)\n"
"               -> List a\n"
"               -> Either e (List b)\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:718
msgid ""
"Now, in order to follow along, you might want to start your own Idris source "
"file, load it into a REPL session and adjust the code as described here. The "
"first thing we'll do, is write a skeleton implementation with a hole on the "
"right hand side:"
msgstr ""
"さて、読み進めていくにあたって、\n"
"読者のみなさんは自分でIdrisのソースファイルを書き始めてREPLセッションに読み込"
"まれるとよいでしょう。\n"
"コードはこちらで記述されている内容にしたがって調整していきます。\n"
"最初にすることは右側に穴あきの実装の骨組を書くことです。"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions2.md:719
#, no-wrap
msgid "traverseEither fun as = ?impl\n"
msgstr "traverseEither fun as = ?impl\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:725
msgid ""
"When you now go to the REPL and reload the file using command `:r`, you can "
"enter `:m` to list all the *metavariables*:"
msgstr ""
"そうしたらREPLに向かい、コマンド`:r`を使ってファイルを再読み込みします。\n"
"そして`:m`とすれば全ての*メタ変数*が列挙されます。"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions2.md:726
#, no-wrap
msgid ""
"Tutorial.Functions2> :m\n"
"1 hole:\n"
"  Tutorial.Functions2.impl : Either e (List b)\n"
msgstr ""
"Tutorial.Functions2> :m\n"
"1 hole:\n"
"  Tutorial.Functions2.impl : Either e (List b)\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:734
msgid ""
"Next, we'd like to display the hole's type (including all variables in the "
"surrounding context plus their types):"
msgstr ""
"次は穴の型を表示したいところです。\n"
"（加えて周囲の文脈にある全ての変数とその型も。）"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions2.md:735
#, no-wrap
msgid ""
"Tutorial.Functions2> :t impl\n"
" 0 b : Type\n"
" 0 a : Type\n"
" 0 e : Type\n"
"   as : List a\n"
"   fun : a -> Either e b\n"
"------------------------------\n"
"impl : Either e (List b)\n"
msgstr ""
"Tutorial.Functions2> :t impl\n"
" 0 b : Type\n"
" 0 a : Type\n"
" 0 e : Type\n"
"   as : List a\n"
"   fun : a -> Either e b\n"
"------------------------------\n"
"impl : Either e (List b)\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:750
msgid ""
"So, we have some erased type parameters (`a`, `b`, and `e`), a value of type "
"`List a` called `as`, and a function from `a` to `Either e b` called `fun`. "
"Our goal is to come up with a value of type `Either a (List b)`."
msgstr ""
"というわけで、消去された型変数 (`a`, `b`, `e`)、\n"
"型`List a`の`as`という名前の値、\n"
"そして`a`から`Either e b`への関数で名前が`fun`のものがあります。\n"
"目標は型`Either a (List b)`の値を思い付くことです。"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:754
msgid ""
"We *could* just return a `Right []`, but that only make sense if our input "
"list is indeed the empty list. We therefore should start with a pattern "
"match on the list:"
msgstr ""
"単に`Right []`を返すことも*できなくはない*のですが、\n"
"それは入力のリストがまさしく空リストのときのみ当てはまります。\n"
"したがってリストに関してパターン照合するところから始めるとよいでしょう。"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions2.md:755
#, no-wrap
msgid ""
"traverseEither fun []        = ?impl_0\n"
"traverseEither fun (x :: xs) = ?impl_1\n"
msgstr ""
"traverseEither fun []        = ?impl_0\n"
"traverseEither fun (x :: xs) = ?impl_1\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:762
msgid ""
"The result is two holes, which must be given distinct names. When inspecting "
"`impl_0`, we get the following result:"
msgstr ""
"結果は2つの穴で、\n"
"それぞれ別の名前でなくてはいけません。\n"
"`impl_0`を調べると以下の結果になります。"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions2.md:763
#, no-wrap
msgid ""
"Tutorial.Functions2> :t impl_0\n"
" 0 b : Type\n"
" 0 a : Type\n"
" 0 e : Type\n"
"   fun : a -> Either e b\n"
"------------------------------\n"
"impl_0 : Either e (List b)\n"
msgstr ""
"Tutorial.Functions2> :t impl_0\n"
" 0 b : Type\n"
" 0 a : Type\n"
" 0 e : Type\n"
"   fun : a -> Either e b\n"
"------------------------------\n"
"impl_0 : Either e (List b)\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:779
msgid ""
"Now, this is an interesting situation. We are supposed to come up with a "
"value of type `Either e (List b)` with nothing to work with. We know nothing "
"about `a`, so we can't provide an argument with which to invoke `fun`.  "
"Likewise, we know nothing about `e` or `b` either, so we can't produce any "
"values of these either. The *only* option we have is to replace `impl_0` "
"with an empty list wrapped in a `Right`:"
msgstr ""
"さあ、ここが面白いところです。\n"
"何にも手を付けることなく型`Either e (List b)`の値を思い付かなければいけませ"
"ん。\n"
"`a`については何も知らないので、その値を`fun`を呼び出すための引数に渡せないの"
"です。\n"
"同様に`e`や`b`についても全然わからないため、\n"
"これらの値はいずれも生み出すことができません。\n"
"取るべき*唯一の*選択肢は`impl_0`を`Right`でくるまれた空リストで置き換えること"
"です。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:780
#, no-wrap
msgid "traverseEither fun []        = Right []\n"
msgstr "traverseEither fun []        = Right []\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:786
msgid ""
"The non-empty case is of course slightly more involved. Here's the context "
"of `?impl_1`:"
msgstr ""
"非空の場合はもちろんこれより少しだけ込み入っています。\n"
"以下が`?impl_1`の文脈です。"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions2.md:787
#, no-wrap
msgid ""
"Tutorial.Functions2> :t impl_1\n"
" 0 b : Type\n"
" 0 a : Type\n"
" 0 e : Type\n"
"   x : a\n"
"   xs : List a\n"
"   fun : a -> Either e b\n"
"------------------------------\n"
"impl_1 : Either e (List b)\n"
msgstr ""
"Tutorial.Functions2> :t impl_1\n"
" 0 b : Type\n"
" 0 a : Type\n"
" 0 e : Type\n"
"   x : a\n"
"   xs : List a\n"
"   fun : a -> Either e b\n"
"------------------------------\n"
"impl_1 : Either e (List b)\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:810
msgid ""
"Since `x` is of type `a`, we can either use it as an argument to `fun` or "
"drop and ignore it. `xs`, on the other hand, is the remainder of the list of "
"type `List a`. We could again drop it or process it further by invoking "
"`traverseEither` recursively. Since the goal is to try and convert *all* "
"values, we should drop neither. Since in case of two `Left`s we are supposed "
"to accumulate the values, we eventually need to run both computations anyway "
"(invoking `fun`, and recursively calling `traverseEither`). We therefore can "
"do both at the same time and analyze the results in a single pattern match "
"by wrapping both in a `Pair`:"
msgstr ""
"`x`は型が`a`であるため、\n"
"`fun`の引数に使ったり、\n"
"無視してしまったりできます。\n"
"他方で`xs`はリストの残り部分で型が`List a`です。\n"
"これも使わずにおいたり`traverseEither`をさらに再帰的に呼び出したりできま"
"す。\n"
"目標は*全ての*値を変換しようとすることですから、いずれも欠かせないことになり"
"ます。\n"
"2つが`Left`な場合は値を積み重ねなければいけないため、\n"
"何にせよ結局は両方の計算をする必要があります。\n"
"（`fun`を実行し、そして再帰的に`traverseEither`を呼び出します。）\n"
"したがって両方を同時に行い、\n"
"`Pair`に両方をくるむことで1つのパターン照合により結果を分析できます。"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions2.md:811
#, no-wrap
msgid ""
"traverseEither fun (x :: xs) =\n"
"  case (fun x, traverseEither fun xs) of\n"
"   p => ?impl_2\n"
msgstr ""
"traverseEither fun (x :: xs) =\n"
"  case (fun x, traverseEither fun xs) of\n"
"   p => ?impl_2\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:818
msgid "Once again, we inspect the context:"
msgstr "もう一度文脈を調べます。"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions2.md:819
#, no-wrap
msgid ""
"Tutorial.Functions2> :t impl_2\n"
" 0 b : Type\n"
" 0 a : Type\n"
" 0 e : Type\n"
"   xs : List a\n"
"   fun : a -> Either e b\n"
"   x : a\n"
"   p : (Either e b, Either e (List b))\n"
"------------------------------\n"
"impl_2 : Either e (List b)\n"
msgstr ""
"Tutorial.Functions2> :t impl_2\n"
" 0 b : Type\n"
" 0 a : Type\n"
" 0 e : Type\n"
"   xs : List a\n"
"   fun : a -> Either e b\n"
"   x : a\n"
"   p : (Either e b, Either e (List b))\n"
"------------------------------\n"
"impl_2 : Either e (List b)\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:834
msgid ""
"We'll definitely need to pattern match on pair `p` next to figure out, which "
"of the two computations succeeded:"
msgstr ""
"間違いなく実装の解明には対`p`をパターン照合する必要があります。\n"
"この対は2つの計算が成功したかを表します。"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions2.md:835
#, no-wrap
msgid ""
"traverseEither fun (x :: xs) =\n"
"  case (fun x, traverseEither fun xs) of\n"
"    (Left y, Left z)   => ?impl_6\n"
"    (Left y, Right _)  => ?impl_7\n"
"    (Right _, Left z)  => ?impl_8\n"
"    (Right y, Right z) => ?impl_9\n"
msgstr ""
"traverseEither fun (x :: xs) =\n"
"  case (fun x, traverseEither fun xs) of\n"
"    (Left y, Left z)   => ?impl_6\n"
"    (Left y, Right _)  => ?impl_7\n"
"    (Right _, Left z)  => ?impl_8\n"
"    (Right y, Right z) => ?impl_9\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:847
msgid ""
"At this point we might have forgotten what we actually wanted to do (at "
"least to me, this happens annoyingly often), so we'll just quickly check "
"what our goal is:"
msgstr ""
"この時点で実際何をしたかったのかお忘れかもしれません。\n"
"（少なくとも私は、厄介なことにこうしたことがよくあります。）\n"
"なので目標をさくっと確認しましょう。"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions2.md:848
#, no-wrap
msgid ""
"Tutorial.Functions2> :t impl_6\n"
" 0 b : Type\n"
" 0 a : Type\n"
" 0 e : Type\n"
"   xs : List a\n"
"   fun : a -> Either e b\n"
"   x : a\n"
"   y : e\n"
"   z : e\n"
"------------------------------\n"
"impl_6 : Either e (List b)\n"
msgstr ""
"Tutorial.Functions2> :t impl_6\n"
" 0 b : Type\n"
" 0 a : Type\n"
" 0 e : Type\n"
"   xs : List a\n"
"   fun : a -> Either e b\n"
"   x : a\n"
"   y : e\n"
"   z : e\n"
"------------------------------\n"
"impl_6 : Either e (List b)\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:868
msgid ""
"So, we are still looking for a value of type `Either e (List b)`, and we "
"have two values of type `e` in scope. According to the spec we want to "
"accumulate these using `e`s `Semigroup` implementation.  We can proceed for "
"the other cases in a similar manner, remembering that we should return a "
"`Right`, if and only if all conversions where successful:"
msgstr ""
"つまり、ここでも型`Either e (List b)`の値を追い求めており、\n"
"範疇には型`e`の2つの値があります。\n"
"仕様にしたがうと`e`の`Semigroup`実装を使って積み重ねたいところです。\n"
"他の場合も同様のやり方で進めることができます。\n"
"全ての変換が成功したときに限って`Right`を返す、ということを記憶に留めつつ。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:869
#, no-wrap
msgid ""
"traverseEither fun (x :: xs) =\n"
"  case (fun x, traverseEither fun xs) of\n"
"    (Left y, Left z)   => Left (y <+> z)\n"
"    (Left y, Right _)  => Left y\n"
"    (Right _, Left z)  => Left z\n"
"    (Right y, Right z) => Right (y :: z)\n"
msgstr ""
"traverseEither fun (x :: xs) =\n"
"  case (fun x, traverseEither fun xs) of\n"
"    (Left y, Left z)   => Left (y <+> z)\n"
"    (Left y, Right _)  => Left y\n"
"    (Right _, Left z)  => Left z\n"
"    (Right y, Right z) => Right (y :: z)\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:879
msgid "To reap the fruits of our labour, let's show off with a small example:"
msgstr "これまでの労働の成果をものにするために、小さな例をお見せします。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:880
#, no-wrap
msgid ""
"data Nucleobase = Adenine | Cytosine | Guanine | Thymine\n"
"\n"
"readNucleobase : Char -> Either (List String) Nucleobase\n"
"readNucleobase 'A' = Right Adenine\n"
"readNucleobase 'C' = Right Cytosine\n"
"readNucleobase 'G' = Right Guanine\n"
"readNucleobase 'T' = Right Thymine\n"
"readNucleobase c   = Left [\"Unknown nucleobase: \" ++ show c]\n"
"\n"
"DNA : Type\n"
"DNA = List Nucleobase\n"
"\n"
"readDNA : String -> Either (List String) DNA\n"
"readDNA = traverseEither readNucleobase . unpack\n"
msgstr ""
"data Nucleobase = Adenine | Cytosine | Guanine | Thymine\n"
"\n"
"readNucleobase : Char -> Either (List String) Nucleobase\n"
"readNucleobase 'A' = Right Adenine\n"
"readNucleobase 'C' = Right Cytosine\n"
"readNucleobase 'G' = Right Guanine\n"
"readNucleobase 'T' = Right Thymine\n"
"readNucleobase c   = Left [\"Unknown nucleobase: \" ++ show c]\n"
"\n"
"DNA : Type\n"
"DNA = List Nucleobase\n"
"\n"
"readDNA : String -> Either (List String) DNA\n"
"readDNA = traverseEither readNucleobase . unpack\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:898
msgid "Let's try this at the REPL:"
msgstr "REPLで試してみましょう。"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions2.md:899
#, no-wrap
msgid ""
"Tutorial.Functions2> readDNA \"CGTTA\"\n"
"Right [Cytosine, Guanine, Thymine, Thymine, Adenine]\n"
"Tutorial.Functions2> readDNA \"CGFTAQ\"\n"
"Left [\"Unknown nucleobase: 'F'\", \"Unknown nucleobase: 'Q'\"]\n"
msgstr ""
"Tutorial.Functions2> readDNA \"CGTTA\"\n"
"Right [Cytosine, Guanine, Thymine, Thymine, Adenine]\n"
"Tutorial.Functions2> readDNA \"CGFTAQ\"\n"
"Left [\"Unknown nucleobase: 'F'\", \"Unknown nucleobase: 'Q'\"]\n"

#. type: Title ###
#: ../src/Tutorial/Functions2.md:906
#, no-wrap
msgid "Interactive Editing"
msgstr "対話的編集"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:916
msgid ""
"There are plugins available for several editors and programming "
"environments, which facilitate interacting with the Idris compiler when "
"implementing your functions.  One editor, which is well supported in the "
"Idris community, is Neovim. Since I am a Neovim user myself, I added some "
"examples of what's possible to the [appendix](../Appendices/Neovim.md). Now "
"would be a good time to start using the utilities discussed there."
msgstr ""
"いくつかのエディタやプログラミング環境ではプラグインが入手でき、\n"
"関数を実装するときにIdrisコンパイラとのやり取りを手助けしてくれます。\n"
"Idrisコミュニティでよく保証されているエディタの1つはNeovimです。\n"
"私自身Neovim利用者なので、\n"
"[補遺](../Appendices/Neovim.md)にどんなことができるのかについて幾つかの例を加"
"えました。\n"
"そろそろそちらで記載した実用品を使い始めていい頃合いです。"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:923
msgid ""
"If you use a different editor, probably with less support for the Idris "
"programming language, you should at the very least have a REPL session open "
"all the time, where the source file you are currently working on is loaded. "
"This allows you to introduce new metavariables and inspect their types and "
"context as you develop your code."
msgstr ""
"他のエディタを使っているなら、\n"
"Idrisプログラミング言語をするにはやや保証が薄いかもしれませんが、\n"
"少なくとも常時REPLセッションを開いておくべきです。\n"
"このセッションでは現在取り組んでいるソースファイルを読み込んでおきます。\n"
"こうすればコードを開発しつつ新しいメタ変数を導入しその方と文脈を調べられま"
"す。"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:929
msgid ""
"We again covered a lot of ground in this section. I can't stress enough that "
"you should get yourselves accustomed to programming with holes and let the "
"type checker help you figure out what to do next."
msgstr ""
"繰り返しになりますが本節では様々な領域の話題を述べました。\n"
"どんなに強調しても足りませんが、\n"
"ぜひ穴あきプログラミングに体を慣らして、\n"
"型検査器に次何をすればよいのかを教えてもらうようにしましょう。"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:932
#, no-wrap
msgid ""
"* When in need of local utility functions, consider defining them\n"
"as local definitions in a *where block*.\n"
msgstr ""
"* 局所小間物関数が必要なときは、\n"
"  *whereブロック*中の局所定義に書くことを検討してください。\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Functions2.md:934
msgid "Use *let expressions* to define and reuse local variables."
msgstr "*let式*を使って局所変数を定義・再利用してください。"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:938
#, no-wrap
msgid ""
"* Function arguments can be given a name, which can serve as documentation,\n"
"can be used to pass arguments in any order, and is used to refer to\n"
"them in dependent types.\n"
msgstr ""
"* 関数の引数には名前を付けられます。\n"
"  こうすればドキュメントとして残すことができ、\n"
"  好きな順序で引数を渡すのに使え、\n"
"  そして依存型で参照するのに使えます。\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:942
#, no-wrap
msgid ""
"* Implicit arguments are wrapped in curly braces. The compiler is\n"
"supposed to infer them from the context. If that's not possible,\n"
"they can be passed explicitly as other named arguments.\n"
msgstr ""
"* 暗黙引数は波括弧にくるまれます。\n"
"  コンパイラは文脈から型推論できなくてはいけません。\n"
"  それができないときは、明示的に他の名前付き引数として渡すことができます。\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:945
#, no-wrap
msgid ""
"* Whenever possible, Idris adds implicit erased arguments for all\n"
"type parameters automatically.\n"
msgstr "* 可能なときはできるだけIdrisは自動的に全ての型変数について暗黙の消去済み引数を加えようとします。\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:948
#, no-wrap
msgid ""
"* Quantities allow us to track how often a function argument is\n"
"used. Quantity 0 means, the argument is erased at runtime.\n"
msgstr ""
"* 数量子はどのくらいの頻度で関数の引数が使われるのかを追跡することができます。\n"
"  数量子0は引数が実行時に消去されることを意味します。\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:953
#, no-wrap
msgid ""
"* Use *holes* as placeholders for pieces of code you plan to fill\n"
"in at a later time. Use the REPL (or your editor) to inspect\n"
"the types of holes together with the names, types, and quantities of all\n"
"variables in their context.\n"
msgstr ""
"* *穴*をあとで埋める予定のコード片の場所取りに使ってください。\n"
"  REPL（もしくはエディタ）を使って、穴の型とその文脈にある全ての変数の名前、型、数量子を調べてください。\n"

#. type: Plain text
#: ../src/Tutorial/Functions2.md:962
msgid ""
"In the [next chapter](Dependent.md)  we'll start using dependent types to "
"help us write provably correct code.  Having a good understanding of how to "
"read Idris' type signatures will be of paramount importance there. Whenever "
"you feel lost, add one or more holes and inspect their context to decide "
"what to do next."
msgstr ""
"[次節](Dependent.md)では依存型を使い始め、証明的に正しいコードを書くのに使い"
"ます。\n"
"Idrisの型処方の読み方をよく理解しておくことは、そこでは最重要となります。\n"
"道を見失ったように感じたら、いくつか穴を加えてみてその文脈を調べ、次何をすべ"
"きかを決めましょう。"

#. type: Title #
#: ../src/Tutorial/Functor.md:1
#, no-wrap
msgid "Functor and Friends"
msgstr "関手と仲間達"

#. type: Plain text
#: ../src/Tutorial/Functor.md:6
msgid ""
"Programming, like mathematics, is about abstraction. We try to model parts "
"of the real world, reusing recurring patterns by abstracting over them."
msgstr ""
"プログラミングとは、数学がそうであるように、抽象化そのものです。\n"
"現実世界の一部をモデル化しようとし、抽象化によって繰り返されるパターンを再利"
"用します。"

#. type: Plain text
#: ../src/Tutorial/Functor.md:17
msgid ""
"In this chapter, we will learn about several related interfaces, which are "
"all about abstraction and therefore can be hard to understand at the "
"beginning. Especially figuring out *why* they are useful and *when* to use "
"them will take time and experience. This chapter therefore comes with tons "
"of exercises, most of which can be solved with only a few short lines of "
"code. Don't skip them.  Come back to them several times until these things "
"start feeling natural to you. You will then realize that their initial "
"complexity has vanished."
msgstr ""
"この章ではいくつかの関連し合うインターフェースについて学びます。\n"
"これらは全て抽象化についてのものなので、最初のうちは理解するのが難しいかもし"
"れません。\n"
"特に*なぜ*役に立つのか、*いつ*使うのかがわかるには時間と経験が必要です。\n"
"したがってこの章は山ほど演習が付属しており、\n"
"ほとんどはごく少ない行のコードで解くことができます。\n"
"演習を飛ばさないでください。\n"
"内容が自然に感じられるまで何度も立ち返ってください。\n"
"そうすれば当初感じていた複雑さが消えていることに気付くでしょう。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:18
#, no-wrap
msgid ""
"module Tutorial.Functor\n"
"\n"
"import Data.List1\n"
"import Data.String\n"
"import Data.Vect\n"
"\n"
"%default total\n"
msgstr ""
"module Tutorial.Functor\n"
"\n"
"import Data.List1\n"
"import Data.String\n"
"import Data.Vect\n"
"\n"
"%default total\n"

#. type: Title ##
#: ../src/Tutorial/Functor.md:28
#, no-wrap
msgid "Functor"
msgstr "関手"

#. type: Plain text
#: ../src/Tutorial/Functor.md:42
#, no-wrap
msgid ""
"What do type constructors like `List`, `List1`, `Maybe`, or\n"
"`IO` have in common? First, all of them are of type\n"
"`Type -> Type`. Second, they all put values of a given type\n"
"in a certain *context*. With `List`,\n"
"the *context* is *non-determinism*: We know there to\n"
"be zero or more values, but we don't know the exact number\n"
"until we start taking the list apart by pattern matching\n"
"on it. Likewise for `List1`, though we know for sure that\n"
"there is at least one value. For `Maybe`, we are still not\n"
"sure about how many values there are, but the possibilities\n"
"are much smaller: Zero or one. With `IO`, the context is a different one:\n"
"Arbitrary side effects.\n"
msgstr ""
"一般に、`List`、`List1`、`Maybe`、`IO`のような型構築子はどのような型を持っているのでしたっけ。\n"
"一つ目に、すべて型`Type -> Type`です。\n"
"二つ目に、すべて与えられた型の値を何らかの*文脈*の中に入れます。\n"
"`List`については、*文脈*は*非決定論的*です。\n"
"つまり、ゼロ以上の値があることはわかりますが、\n"
"パターン照合によってリストを分解しない限り正確な数はわかりません。\n"
"`List1`も同様ですが、こちらは1つは値があることが確かです。\n"
"`Maybe`についても何個の値があるのかは定かではありませんが、選択肢はずっと小さく、ゼロか1です。\n"
"`IO`についての文脈は違ったものであり、それはあらゆる副作用です。\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:49
msgid ""
"Although the type constructors discussed above are quite different in how "
"they behave and when they are useful, there are certain operations that keep "
"coming up when working with them. The first such operation is *mapping a "
"pure function over the data type, without affecting its underlying "
"structure*."
msgstr ""
"上で議論した型構築子は振舞いや便利になるときがかなり異なりますが、\n"
"これらに取り組んでいると何らかの操作は頭に上ってきます。\n"
"そのような操作の1つ目は*土台の構造に影響することなく、純粋な関数をデータ型に"
"写す*ことです。"

#. type: Plain text
#: ../src/Tutorial/Functor.md:53
msgid ""
"For instance, given a list of numbers, we'd like to multiply each number by "
"two, without changing their order or removing any values:"
msgstr ""
"例えば数字のリストが与えられたとき、順番や値の削除なしに、それぞれの数を2倍し"
"たいとします。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:54
#, no-wrap
msgid ""
"multBy2List : Num a => List a -> List a\n"
"multBy2List []        = []\n"
"multBy2List (x :: xs) = 2 * x :: multBy2List xs\n"
msgstr ""
"multBy2List : Num a => List a -> List a\n"
"multBy2List []        = []\n"
"multBy2List (x :: xs) = 2 * x :: multBy2List xs\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:62
msgid ""
"But we might just as well convert every string in a list of strings to upper "
"case characters:"
msgstr ""
"でもちょうど同じように文字列リスト中の全ての文字列を大文字に変換したいかもし"
"れません。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:63
#, no-wrap
msgid ""
"toUpperList : List String -> List String\n"
"toUpperList []        = []\n"
"toUpperList (x :: xs) = toUpper x :: toUpperList xs\n"
msgstr ""
"toUpperList : List String -> List String\n"
"toUpperList []        = []\n"
"toUpperList (x :: xs) = toUpper x :: toUpperList xs\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:72
msgid ""
"Sometimes, the type of the stored value changes. In the next example, we "
"calculate the lengths of the strings stored in a list:"
msgstr ""
"保管している値の種類が変わることもあります。\n"
"次の例ではリストに保管されている文字列の長さを計算しています。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:73
#, no-wrap
msgid ""
"toLengthList : List String -> List Nat\n"
"toLengthList []        = []\n"
"toLengthList (x :: xs) = length x :: toLengthList xs\n"
msgstr ""
"toLengthList : List String -> List Nat\n"
"toLengthList []        = []\n"
"toLengthList (x :: xs) = length x :: toLengthList xs\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:83
msgid ""
"I'd like you to appreciate, just how boring these functions are. They are "
"almost identical, with the only interesting part being the function we apply "
"to each element. Surely, there must be a pattern to abstract over:"
msgstr ""
"これらの関数がどれほど退屈かよくお分かりいただけたでしょう。\n"
"ほとんど同じものであり、関心がある部分はそれぞれの要素に適用している関数なの"
"です。\n"
"もちろんこれを抽象化するパターンがあるはずです。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:84
#, no-wrap
msgid ""
"mapList : (a -> b) -> List a -> List b\n"
"mapList f []        = []\n"
"mapList f (x :: xs) = f x :: mapList f xs\n"
msgstr ""
"mapList : (a -> b) -> List a -> List b\n"
"mapList f []        = []\n"
"mapList f (x :: xs) = f x :: mapList f xs\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:94
msgid ""
"This is often the first step of abstraction in functional programming: Write "
"a (possibly generic) higher-order function.  We can now concisely implement "
"all examples shown above in terms of `mapList`:"
msgstr ""
"これはよく関数型プログラミングで行われる抽象化の初めの一歩です。\n"
"つまり高階関数（汎化も可）を書くということです。\n"
"これで上で示した全ての例を`mapList`を使って簡潔に実装することができます。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:95
#, no-wrap
msgid ""
"multBy2List' : Num a => List a -> List a\n"
"multBy2List' = mapList (2 *)\n"
"\n"
"toUpperList' : List String -> List String\n"
"toUpperList' = mapList toUpper\n"
"\n"
"toLengthList' : List String -> List Nat\n"
"toLengthList' = mapList length\n"
msgstr ""
"multBy2List' : Num a => List a -> List a\n"
"multBy2List' = mapList (2 *)\n"
"\n"
"toUpperList' : List String -> List String\n"
"toUpperList' = mapList toUpper\n"
"\n"
"toLengthList' : List String -> List Nat\n"
"toLengthList' = mapList length\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:110
msgid ""
"But surely we'd like to do the same kind of thing with `List1` and `Maybe`! "
"After all, they are just container types like `List`, the only difference "
"being some detail about the number of values they can or can't hold:"
msgstr ""
"しかしきっと同じ類のことを`List1`や`Maybe`でもしたいでしょう！\n"
"結局はちょうど`List`のような容器型なのです。\n"
"単に値の数で保管できたりできなかったりする違いがあるだけで。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:111
#, no-wrap
msgid ""
"mapMaybe : (a -> b) -> Maybe a -> Maybe b\n"
"mapMaybe f Nothing  = Nothing\n"
"mapMaybe f (Just v) = Just (f v)\n"
msgstr ""
"mapMaybe : (a -> b) -> Maybe a -> Maybe b\n"
"mapMaybe f Nothing  = Nothing\n"
"mapMaybe f (Just v) = Just (f v)\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:125
msgid ""
"Even with `IO`, we'd like to be able to map pure functions over effectful "
"computations. The implementation is a bit more involved, due to the nested "
"layers of data constructors, but if in doubt, the types will surely guide "
"us. Note, however, that `IO` is not publicly exported, so its data "
"constructor is unavailable to us. We can use functions `toPrim` and "
"`fromPrim`, however, for converting `IO` from and to `PrimIO`, which we can "
"freely dissect:"
msgstr ""
"`IO`であっても純粋な関数を作用付き計算に写せるようにしたいです。\n"
"入れ子の層になったデータ構築子があるため、実装はもう少し込み入っています"
"が、\n"
"疑問に思ったときは型がきっと導いてくれます。\n"
"ただしかし、`IO`は公に公開されていないので、データ構築子は使えません。\n"
"ですが`IO`を`PrimIO`と相互に変換するために関数`toPrim`や`fromPrim`を使えるの"
"で、\n"
"これらを使えば自由に解剖できます。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:126
#, no-wrap
msgid ""
"mapIO : (a -> b) -> IO a -> IO b\n"
"mapIO f io = fromPrim $ mapPrimIO (toPrim io)\n"
"  where mapPrimIO : PrimIO a -> PrimIO b\n"
"        mapPrimIO prim w =\n"
"          let MkIORes va w2 = prim w\n"
"           in MkIORes (f va) w2\n"
msgstr ""
"mapIO : (a -> b) -> IO a -> IO b\n"
"mapIO f io = fromPrim $ mapPrimIO (toPrim io)\n"
"  where mapPrimIO : PrimIO a -> PrimIO b\n"
"        mapPrimIO prim w =\n"
"          let MkIORes va w2 = prim w\n"
"           in MkIORes (f va) w2\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:138
msgid ""
"From the concept of *mapping a pure function over values in a context* "
"follow some derived functions, which are often useful. Here are some of them "
"for `IO`:"
msgstr ""
"*純粋な関数を文脈に写す*という概念からいくつか派生する関数が出てきますが、便"
"利なことがよくあります。\n"
"以下は`IO`からいくつか取ってきたものです。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:139
#, no-wrap
msgid ""
"mapConstIO : b -> IO a -> IO b\n"
"mapConstIO = mapIO . const\n"
"\n"
"forgetIO : IO a -> IO ()\n"
"forgetIO = mapConstIO ()\n"
msgstr ""
"mapConstIO : b -> IO a -> IO b\n"
"mapConstIO = mapIO . const\n"
"\n"
"forgetIO : IO a -> IO ()\n"
"forgetIO = mapConstIO ()\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:151
msgid ""
"Of course, we'd want to implement `mapConst` and `forget` as well for "
"`List`, `List1`, and `Maybe` (and dozens of other type constructors with "
"some kind of mapping function), and they'd all look the same and be equally "
"boring."
msgstr ""
"もちろん`mapConst`や`forget`を\n"
"`List`、`List1`、`Maybe`（そして他にも山程ある何らかの類の写す関数がある型構"
"築子）にも同様に実装したいですし、\n"
"見た目が全部同じなのでこれもまた退屈です。"

#. type: Plain text
#: ../src/Tutorial/Functor.md:161
#, no-wrap
msgid ""
"When we come upon a recurring class of functions with\n"
"several useful derived functions, we should consider defining\n"
"an interface. But how should we go about this here?\n"
"When you look at the types of `mapList`, `mapMaybe`, and `mapIO`,\n"
"you'll see that it's the `List`, `List1`, and `IO` types we\n"
"need to get rid of. These are not of type `Type` but of type\n"
"`Type -> Type`. Luckily, there is nothing preventing us\n"
"from parametrizing an interface over something else than\n"
"a `Type`.\n"
msgstr ""
"関数といくつかの派生した有用な関数の集まりが繰り返される場面に出喰わしたときは、\n"
"インターフェースを定義することを検討すべきです。\n"
"しかしここではどのようにすればよいのでしょうか。\n"
"`mapList`、`mapMaybe`、`mapIO`の型を見ると、除去する必要があるのは`List`、`List1`、`IO`型であるとわかります。\n"
"これらは型`Type`ではなく型`Type -> Type`です。\n"
"運が良いことにインターフェースが`Type`以外の何かを変数に取るようにするのに支障はありません。\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:166
msgid ""
"The interface we are looking for is called `Functor`.  Here is its "
"definition and an example implementation (I appended a tick at the end of "
"the names for them not to overlap with the interface and functions exported "
"by the *Prelude*):"
msgstr ""
"探しているインターフェースは`Functor`と呼ばれます。\n"
"以下はその定義と実装例です。\n"
"（名前のあとに印を付けて*Prelude*から輸出されているインターフェースと関数と重"
"ならないようにしました。）"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:167
#, no-wrap
msgid ""
"interface Functor' (0 f : Type -> Type) where\n"
"  map' : (a -> b) -> f a -> f b\n"
"\n"
"implementation Functor' Maybe where\n"
"  map' _ Nothing  = Nothing\n"
"  map' f (Just v) = Just $ f v\n"
msgstr ""
"interface Functor' (0 f : Type -> Type) where\n"
"  map' : (a -> b) -> f a -> f b\n"
"\n"
"implementation Functor' Maybe where\n"
"  map' _ Nothing  = Nothing\n"
"  map' f (Just v) = Just $ f v\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:179
msgid ""
"Note, that we had to give the type of parameter `f` explicitly, and in that "
"case it needs to be annotated with quantity zero if you want it to be erased "
"at runtime (which you almost always want)."
msgstr ""
"なお、変数`f`の型を明示的に与えなくてはいけず、\n"
"その場合実行時に消去されていてほしければ数量子ゼロで註釈を付ける必要がありま"
"す。\n"
"（ほぼ常にそうであってほしいものです。）"

#. type: Plain text
#: ../src/Tutorial/Functor.md:186
msgid ""
"Now, reading type signatures consisting only of type parameters like the one "
"of `map'` can take some time to get used to, especially when some type "
"parameters are applied to other parameters as in `f a`. It can be very "
"helpful to inspect these signatures together with all implicit arguments at "
"the REPL (I formatted the output to make it more readable):"
msgstr ""
"さて、`map'`のように型変数のみからなる型処方を読むのは慣れるまで時間が掛かる"
"かもしれません。\n"
"`f a`のように型変数が他の変数に提供されているときは特にそうです。\n"
"REPLでこれらの処方を全ての暗黙子とともに調べると大変理解の助けになります。\n"
"（出力を読みやすいように整形しました。）"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functor.md:187
#, no-wrap
msgid ""
"Tutorial.Functor> :ti map'\n"
"Tutorial.Functor.map' :  {0 b : Type}\n"
"                      -> {0 a : Type}\n"
"                      -> {0 f : Type -> Type}\n"
"                      -> Functor' f\n"
"                      => (a -> b)\n"
"                      -> f a\n"
"                      -> f b\n"
msgstr ""
"Tutorial.Functor> :ti map'\n"
"Tutorial.Functor.map' :  {0 b : Type}\n"
"                      -> {0 a : Type}\n"
"                      -> {0 f : Type -> Type}\n"
"                      -> Functor' f\n"
"                      => (a -> b)\n"
"                      -> f a\n"
"                      -> f b\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:200
msgid ""
"It can also be helpful to replace type parameter `f` with a concrete value "
"of the same type:"
msgstr "型変数`f`を同じ型の形がある値に置き換えるのもよいかもしれません。"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functor.md:201
#, no-wrap
msgid ""
"Tutorial.Functor> :t map' {f = Maybe}\n"
"map' : (?a -> ?b) -> Maybe ?a -> Maybe ?b\n"
msgstr ""
"Tutorial.Functor> :t map' {f = Maybe}\n"
"map' : (?a -> ?b) -> Maybe ?a -> Maybe ?b\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:209
msgid ""
"Remember, being able to interpret type signatures is paramount to "
"understanding what's going on in an Idris declaration. You *must* practice "
"this and make use of the tools and utilities given to you."
msgstr ""
"覚えておいてほしいのですが、型処方を解釈できることはIdrisの宣言で起こっている"
"ことを理解する上での最重要事項です。\n"
"これを練習し与えられたツールや小間物を活用する*必要*があります。"

#. type: Title ###
#: ../src/Tutorial/Functor.md:210
#, no-wrap
msgid "Derived Functions"
msgstr "導出される関数"

#. type: Plain text
#: ../src/Tutorial/Functor.md:215
msgid ""
"There are several functions and operators directly derivable from interface "
"`Functor`. Eventually, you should know and remember all of them as they are "
"highly useful. Here they are together with their types:"
msgstr ""
"インターフェース`Functor`から直接導出できる関数や演算子はいくつかあります。\n"
"これらは大変有用なので、最終的には全てを知り記憶するべきです。\n"
"以下は型と共に見たものです。"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functor.md:216
#, no-wrap
msgid ""
"Tutorial.Functor> :t (<$>)\n"
"Prelude.<$> : Functor f => (a -> b) -> f a -> f b\n"
"\n"
"Tutorial.Functor> :t (<&>)\n"
"Prelude.<&> : Functor f => f a -> (a -> b) -> f b\n"
"\n"
"Tutorial.Functor> :t ($>)\n"
"Prelude.$> : Functor f => f a -> b -> f b\n"
"\n"
"Tutorial.Functor> :t (<$)\n"
"Prelude.<$ : Functor f => b -> f a -> f b\n"
"\n"
"Tutorial.Functor> :t ignore\n"
"Prelude.ignore : Functor f => f a -> f ()\n"
msgstr ""
"Tutorial.Functor> :t (<$>)\n"
"Prelude.<$> : Functor f => (a -> b) -> f a -> f b\n"
"\n"
"Tutorial.Functor> :t (<&>)\n"
"Prelude.<&> : Functor f => f a -> (a -> b) -> f b\n"
"\n"
"Tutorial.Functor> :t ($>)\n"
"Prelude.$> : Functor f => f a -> b -> f b\n"
"\n"
"Tutorial.Functor> :t (<$)\n"
"Prelude.<$ : Functor f => b -> f a -> f b\n"
"\n"
"Tutorial.Functor> :t ignore\n"
"Prelude.ignore : Functor f => f a -> f ()\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:235
#, no-wrap
msgid ""
"`(<$>)` is an operator alias for `map` and allows you to sometimes\n"
"drop some parentheses. For instance:\n"
msgstr ""
"`(<$>)`は`map`の演算子別称で括弧を省略できるときがあります。\n"
"例えば以下。\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:236
#, no-wrap
msgid ""
"tailShowReversNoOp : Show a => List1 a -> List String\n"
"tailShowReversNoOp xs = map (reverse . show) (tail xs)\n"
"\n"
"tailShowReverse : Show a => List1 a -> List String\n"
"tailShowReverse xs = reverse . show <$> tail xs\n"
msgstr ""
"tailShowReversNoOp : Show a => List1 a -> List String\n"
"tailShowReversNoOp xs = map (reverse . show) (tail xs)\n"
"\n"
"tailShowReverse : Show a => List1 a -> List String\n"
"tailShowReverse xs = reverse . show <$> tail xs\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:249
#, no-wrap
msgid ""
"`(<&>)` is an alias for `(<$>)` with the arguments flipped.\n"
"The other three (`ignore`, `($>)`, and `(<$)`) are all used\n"
"to replace the values in a context with a constant. They are often useful\n"
"when you don't care about the values themselves but\n"
"want to keep the underlying structure.\n"
msgstr ""
"`(<&>)`は引数が入れ替わっていることを除けば`(<$>)`の別称と言えます。\n"
"他の3つ (`ignore`, `($>)`, `(<$)`) は全て、定数で文脈中の値を置き換えるために使われます。\n"
"値そのものには関心がないものの土台の構造を維持したいときによく使います。\n"

#. type: Title ###
#: ../src/Tutorial/Functor.md:250
#, no-wrap
msgid "Functors with more than one Type Parameter"
msgstr "1つ以上の型変数がある関手"

#. type: Plain text
#: ../src/Tutorial/Functor.md:259
#, fuzzy, no-wrap
#| msgid ""
#| "The type constructors we looked at so far where all\n"
#| "of type `Type -> Type`. However, we can also implement `Functor`\n"
#| "for other type constructors. The only prerequisite is that\n"
#| "the type parameter we'd like to change with function `map` must\n"
#| "be the last in the argument list. For instance, here is the\n"
#| "`Functor` implementation for `Either e` (note, that `Either e`\n"
#| "has of course type `Type -> Type` as required):\n"
msgid ""
"The type constructors we looked at so far were all\n"
"of type `Type -> Type`. However, we can also implement `Functor`\n"
"for other type constructors. The only prerequisite is that\n"
"the type parameter we'd like to change with function `map` must\n"
"be the last in the argument list. For instance, here is the\n"
"`Functor` implementation for `Either e` (note, that `Either e`\n"
"has of course type `Type -> Type` as required):\n"
msgstr ""
"これまで見てきた型構築子は全て型が`Type -> Type`でした。\n"
"しかし`Functor`を他の型構築子に実装することもできます。\n"
"唯一の事前要件は、関数`map`で変化させたい型変数が引数リストの最後になければいけないことです。\n"
"例えば以下が`Either e`のための`Functor`の実装です。\n"
"（なお、`Either e`はもちろん必要とされている型`Type -> Type`を持ちます。）\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:260
#, no-wrap
msgid ""
"implementation Functor' (Either e) where\n"
"  map' _ (Left ve)  = Left ve\n"
"  map' f (Right va) = Right $ f va\n"
msgstr ""
"implementation Functor' (Either e) where\n"
"  map' _ (Left ve)  = Left ve\n"
"  map' f (Right va) = Right $ f va\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:269
#, no-wrap
msgid ""
"Here is another example, this time for a type constructor of\n"
"type `Bool -> Type -> Type` (you might remember this from\n"
"the exercises in the [last chapter](IO.md)):\n"
msgstr ""
"以下は別の例で、この場合型構築子は`Bool -> Type -> Type`です。\n"
"（[直近の章](IO.md)の演習でこれを覚えているかもしれません。）\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:270
#, no-wrap
msgid ""
"data List01 : (nonEmpty : Bool) -> Type -> Type where\n"
"  Nil  : List01 False a\n"
"  (::) : a -> List01 False a -> List01 ne a\n"
"\n"
"implementation Functor (List01 ne) where\n"
"  map _ []        = []\n"
"  map f (x :: xs) = f x :: map f xs\n"
msgstr ""
"data List01 : (nonEmpty : Bool) -> Type -> Type where\n"
"  Nil  : List01 False a\n"
"  (::) : a -> List01 False a -> List01 ne a\n"
"\n"
"implementation Functor (List01 ne) where\n"
"  map _ []        = []\n"
"  map f (x :: xs) = f x :: map f xs\n"

#. type: Title ###
#: ../src/Tutorial/Functor.md:280
#, no-wrap
msgid "Functor Composition"
msgstr "関手の組み合わせ"

#. type: Plain text
#: ../src/Tutorial/Functor.md:284
msgid ""
"The nice thing about functors is how they can be paired and nested with "
"other functors and the results are functors again:"
msgstr ""
"関手の良いところは他の関手と対にしたり入れ子にしたりできることで、結果もまた"
"関手になります。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:285
#, no-wrap
msgid ""
"record Product (f,g : Type -> Type) (a : Type) where\n"
"  constructor MkProduct\n"
"  fst : f a\n"
"  snd : g a\n"
"\n"
"implementation Functor f => Functor g => Functor (Product f g) where\n"
"  map f (MkProduct l r) = MkProduct (map f l) (map f r)\n"
msgstr ""
"record Product (f,g : Type -> Type) (a : Type) where\n"
"  constructor MkProduct\n"
"  fst : f a\n"
"  snd : g a\n"
"\n"
"implementation Functor f => Functor g => Functor (Product f g) where\n"
"  map f (MkProduct l r) = MkProduct (map f l) (map f r)\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:297
msgid ""
"The above allows us to conveniently map over a pair of functors. Note, "
"however, that Idris needs some help with inferring the types involved:"
msgstr ""
"上のコードにより、便利に関手の対の上で写せます。\n"
"ただしかし、Idrisが関係する型を推論するのに手助けが要ることがあります。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:298
#, no-wrap
msgid ""
"toPair : Product f g a -> (f a, g a)\n"
"toPair (MkProduct fst snd) = (fst, snd)\n"
"\n"
"fromPair : (f a, g a) -> Product f g a\n"
"fromPair (x,y) = MkProduct x y\n"
"\n"
"productExample :  Show a\n"
"               => (Either e a, List a)\n"
"               -> (Either e String, List String)\n"
"productExample = toPair . map show . fromPair {f = Either e, g = List}\n"
msgstr ""
"toPair : Product f g a -> (f a, g a)\n"
"toPair (MkProduct fst snd) = (fst, snd)\n"
"\n"
"fromPair : (f a, g a) -> Product f g a\n"
"fromPair (x,y) = MkProduct x y\n"
"\n"
"productExample :  Show a\n"
"               => (Either e a, List a)\n"
"               -> (Either e String, List String)\n"
"productExample = toPair . map show . fromPair {f = Either e, g = List}\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:313
msgid ""
"More often, we'd like to map over several layers of nested functors at once. "
"Here's how to do this with an example:"
msgstr ""
"もっとよくあるのは一度に何層かの入れ子になった関手の上で写したいときです。\n"
"以下は一例です。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:314
#, no-wrap
msgid ""
"record Comp (f,g : Type -> Type) (a : Type) where\n"
"  constructor MkComp\n"
"  unComp  : f (g a)\n"
"\n"
"implementation Functor f => Functor g => Functor (Comp f g) where\n"
"  map f (MkComp v) = MkComp $ map f <$> v\n"
"\n"
"compExample :  Show a => List (Either e a) -> List (Either e String)\n"
"compExample = unComp . map show . MkComp {f = List, g = Either e}\n"
msgstr ""
"record Comp (f,g : Type -> Type) (a : Type) where\n"
"  constructor MkComp\n"
"  unComp  : f (g a)\n"
"\n"
"implementation Functor f => Functor g => Functor (Comp f g) where\n"
"  map f (MkComp v) = MkComp $ map f <$> v\n"
"\n"
"compExample :  Show a => List (Either e a) -> List (Either e String)\n"
"compExample = unComp . map show . MkComp {f = List, g = Either e}\n"

#. type: Title ####
#: ../src/Tutorial/Functor.md:326
#, no-wrap
msgid "Named Implementations"
msgstr "名前付き実装"

#. type: Plain text
#: ../src/Tutorial/Functor.md:334
msgid ""
"Sometimes, there are more ways to implement an interface for a given type. "
"For instance, for numeric types we can have a `Monoid` representing addition "
"and one representing multiplication.  Likewise, for nested functors, `map` "
"can be interpreted as a mapping over only the first layer of values, or a "
"mapping over several layers of values."
msgstr ""
"時には与えられた型により多くの実装方法があることがあります。\n"
"例えば数値型については、加算を表現する`Monoid`と乗算を表現するものを用意でき"
"ます。\n"
"同様に入れ子の関手については`map`の解釈として値の最初の層の上のみで写すこと"
"も、\n"
"値のいくつかの層の上で写すこともできます。"

#. type: Plain text
#: ../src/Tutorial/Functor.md:339
msgid ""
"One way to go about this is to define single-field wrappers as shown with "
"data type `Comp` above. However, Idris also allows us to define additional "
"interface implementations, which must then be given a name. For instance:"
msgstr ""
"こうするための1つの方法は単一フィールドの梱包を定義することで、上で見たデータ"
"型`Comp`のような感じです。\n"
"しかしIdrisでは追加のインターフェース実装を定義することもでき、\n"
"それには名前が与えられている必要があります。\n"
"例えば以下。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:340
#, no-wrap
msgid ""
"[Compose'] Functor f => Functor g => Functor (f . g) where\n"
"  map f = (map . map) f\n"
msgstr ""
"[Compose'] Functor f => Functor g => Functor (f . g) where\n"
"  map f = (map . map) f\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:350
msgid ""
"Note, that this defines a new implementation of `Functor`, which will *not* "
"be considered during implicit resolution in order to avoid ambiguities. "
"However, it is possible to explicitly choose to use this implementation by "
"passing it as an explicit argument to `map`, prefixed with an `@`:"
msgstr ""
"なお、これは`Functor`の新しい実装を定義していますが、\n"
"曖昧さを回避するための暗黙裡に行われる解決中には考慮され*ません*。\n"
"しかし、この実装を明示的に選ぶことはでき、\n"
"明示的な引数として`map`に渡せばよいです。\n"
"この引数には`@`が前置されます。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:351
#, no-wrap
msgid ""
"compExample2 :  Show a => List (Either e a) -> List (Either e String)\n"
"compExample2 = map @{Compose} show\n"
msgstr ""
"compExample2 :  Show a => List (Either e a) -> List (Either e String)\n"
"compExample2 = map @{Compose} show\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:358
msgid ""
"In the example above, we used `Compose` instead of `Compose'`, since the "
"former is already exported by the *Prelude*."
msgstr ""
"上の例では`Compose'`の代わりに`Compose`を使いました。\n"
"なぜなら前者は既に*Prelude*により輸出されているからです。"

#. type: Title ###
#: ../src/Tutorial/Functor.md:359
#, no-wrap
msgid "Functor Laws"
msgstr "関手則"

#. type: Plain text
#: ../src/Tutorial/Functor.md:365
msgid ""
"Implementations of `Functor` are supposed to adhere to certain laws, just "
"like implementations of `Eq` or `Ord`. Again, these laws are not verified by "
"Idris, although it would be possible (and often cumbersome) to do so."
msgstr ""
"ちょうど`Eq`や`Ord`の実装と同じように、`Functor`の実装にはある法則の遵守が必"
"要です。\n"
"繰り返しますがこれらの法則はIdrisによって検証されません。\n"
"可能（で、よくややこしくなる）ではあるでしょうけれども。"

#. type: Plain text
#: ../src/Tutorial/Functor.md:370
#, no-wrap
msgid ""
"1. `map id = id`: Mapping the identity function over a functor\n"
"    must not have any visible effect such as changing a container's\n"
"    structure or affecting the side effects perfomed when\n"
"    running an `IO` action.\n"
msgstr ""
"1. `map id = id`：関手の上で同一関数を写すことで、\n"
"   容器の構造を変えたり`IO`アクションを走らせるときに生じる副作用で影響を与えたりするような、\n"
"   目に見えるいかなる作用もあってはならない。\n"

#. type: Bullet: '2. '
#: ../src/Tutorial/Functor.md:373
msgid ""
"`map (f . g) = map f . map g`: Sequencing two mappings must be identical to "
"a single mapping using the composition of the two functions."
msgstr ""
"`map (f . g) = map f . map g`：2回の写しの連続は、\n"
"2つの関数の組合せを使って1回で写すことと同一でなければいけない。"

#. type: Plain text
#: ../src/Tutorial/Functor.md:380
msgid ""
"Both of these laws request, that `map` is preserving the *structure* of "
"values. This is easier to understand with container types like `List`, "
"`Maybe`, or `Either e`, where `map` is not allowed to add or remove any "
"wrapped value, nor - in case of `List` - change their order. With `IO`, this "
"can best be described as `map` not performing additional side effects."
msgstr ""
"これら両方の法則が要求しているのは、\n"
"`map`が値の*構造*を保存しているということです。\n"
"`List`, `Maybe`, `Either e`のような容器型だとより理解しやすいです。\n"
"ここで`map`は梱包された値に追加したりそこから削除したりすることは許しておら"
"ず、\n"
"`List`の場合は順番を変えることもできません。\n"
"`IO`については`map`により余剰の副作用を生じないことがこれをよく表しています。"

#. type: Bullet: '1. '
#: ../src/Tutorial/Functor.md:385
msgid ""
"Write your own implementations of `Functor'` for `Maybe`, `List`, `List1`, "
"`Vect n`, `Either e`, and `Pair a`."
msgstr ""
"`Maybe`, `List`, `List1`, `Vect n`, `Either e`, `Pair a`に対して、\n"
"自力で`Functor'`のの実装を書いてください。"

#. type: Bullet: '2. '
#: ../src/Tutorial/Functor.md:388
msgid ""
"Write a named implementation of `Functor` for pairs of functors (similar to "
"the one implemented for `Product`)."
msgstr ""
"関手の対について、`Functor`の名前付き実装を書いてください。\n"
"（`Product`に実装したものと似ています。）"

#. type: Bullet: '3. '
#: ../src/Tutorial/Functor.md:391
msgid ""
"Implement `Functor` for data type `Identity` (which is available from "
"`Control.Monad.Identity` in *base*):"
msgstr ""
"データ型`Identity`に`Functor`を実装してください。\n"
"（これは*base*の`Control.Monad.Identity`から手に入ります。）"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:392
#, no-wrap
msgid ""
"   record Identity a where\n"
"     constructor Id\n"
"     value : a\n"
msgstr ""
"   record Identity a where\n"
"     constructor Id\n"
"     value : a\n"

#. type: Bullet: '4. '
#: ../src/Tutorial/Functor.md:404
msgid ""
"Here is a curious one: Implement `Functor` for `Const e` (which is also "
"available from `Control.Applicative.Const` in *base*). You might be confused "
"about the fact that the second type parameter has absolutely no relevance at "
"runtime, as there is no value of that type. Such types are sometimes called "
"*phantom types*. They can be quite useful for tagging values with additional "
"typing information."
msgstr ""
"これは興味深い問題です：`Const e`に`Functor`を実装してください。\n"
"（これも*base*の`Control.Application.Const`から手に入ります。）\n"
"2つ目の型変数が絶対に実行時に関係しないところに当惑されるかもしれません、\n"
"というのはその型の値が1つもないからです。\n"
"そのような型は*幽霊型*と呼ばれるときがあります。\n"
"幽霊型は値に追加の型情報を札付けするのにかなり便利です。"

#. type: Plain text
#: ../src/Tutorial/Functor.md:407
#, no-wrap
msgid ""
"   Don't let the above confuse you: There is only one possible implementation.\n"
"   As usual, use holes and let the compiler guide you if you get lost.\n"
msgstr ""
"   上記で混乱しないようにしてください。\n"
"   可能な実装は1つしかありません。\n"
"   いつも通り穴開きを使い、道を見失ったときはコンパイラに導いてもらいましょう。\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:408
#, no-wrap
msgid ""
"   record Const (e,a : Type) where\n"
"     constructor MkConst\n"
"     value : e\n"
msgstr ""
"   record Const (e,a : Type) where\n"
"     constructor MkConst\n"
"     value : e\n"

#. type: Bullet: '5. '
#: ../src/Tutorial/Functor.md:416
msgid ""
"Here is a sum type for describing CRUD operations (Create, Read, Update, and "
"Delete) in a data store:"
msgstr ""
"以下はデータ保管所でのCRUD操作（Create, Read, Update, Delete）を記述する直和"
"型です。"

#. type: Plain text
#: ../src/Tutorial/Functor.md:426
#, no-wrap
msgid "   Implement `Functor` for `Crud i`.\n"
msgstr "   `Functor`を`Crud i`に実装してください。\n"

#. type: Bullet: '6. '
#: ../src/Tutorial/Functor.md:428
msgid "Here is a sum type for describing responses from a data server:"
msgstr "以下はデータサーバからの応答を記述する直和型です。"

#. type: Plain text
#: ../src/Tutorial/Functor.md:439
#, no-wrap
msgid "   Implement `Functor` for `Repsonse e i`.\n"
msgstr "   `Functor`を`Response e i`に実装してください。\n"

#. type: Bullet: '7. '
#: ../src/Tutorial/Functor.md:441
msgid "Implement `Functor` for `Validated e`:"
msgstr "`Functor`を`Vaidated e`に実装してください。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:442
#, no-wrap
msgid ""
"   data Validated : (e,a : Type) -> Type where\n"
"     Invalid : (err : e) -> Validated e a\n"
"     Valid   : (val : a) -> Validated e a\n"
msgstr ""
"   data Validated : (e,a : Type) -> Type where\n"
"     Invalid : (err : e) -> Validated e a\n"
"     Valid   : (val : a) -> Validated e a\n"

#. type: Title ##
#: ../src/Tutorial/Functor.md:448
#, no-wrap
msgid "Applicative"
msgstr "アプリカティブ"

#. type: Plain text
#: ../src/Tutorial/Functor.md:453
msgid ""
"While `Functor` allows us to map a pure, unary function over a value in a "
"context, it doesn't allow us to combine n such values under an n-ary "
"function."
msgstr ""
"`Functor`は純粋な1引数関数で文脈中の1つの値を写すことができますが、\n"
"n個のそのような値をn引数関数に結び付けることはできません。"

#. type: Plain text
#: ../src/Tutorial/Functor.md:455
msgid "For instance, consider the following functions:"
msgstr "例えば以下の関数を考えてください。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:456
#, no-wrap
msgid ""
"liftMaybe2 : (a -> b -> c) -> Maybe a -> Maybe b -> Maybe c\n"
"liftMaybe2 f (Just va) (Just vb) = Just $ f va vb\n"
"liftMaybe2 _ _         _         = Nothing\n"
"\n"
"liftVect2 : (a -> b -> c) -> Vect n a -> Vect n b -> Vect n c\n"
"liftVect2 _ []        []        = []\n"
"liftVect2 f (x :: xs) (y :: ys) = f x y :: liftVect2 f xs ys\n"
"\n"
"liftIO2 : (a -> b -> c) -> IO a -> IO b -> IO c\n"
"liftIO2 f ioa iob = fromPrim $ go (toPrim ioa) (toPrim iob)\n"
"  where go : PrimIO a -> PrimIO b -> PrimIO c\n"
"        go pa pb w =\n"
"          let MkIORes va w2 = pa w\n"
"              MkIORes vb w3 = pb w2\n"
"           in MkIORes (f va vb) w3\n"
msgstr ""
"liftMaybe2 : (a -> b -> c) -> Maybe a -> Maybe b -> Maybe c\n"
"liftMaybe2 f (Just va) (Just vb) = Just $ f va vb\n"
"liftMaybe2 _ _         _         = Nothing\n"
"\n"
"liftVect2 : (a -> b -> c) -> Vect n a -> Vect n b -> Vect n c\n"
"liftVect2 _ []        []        = []\n"
"liftVect2 f (x :: xs) (y :: ys) = f x y :: liftVect2 f xs ys\n"
"\n"
"liftIO2 : (a -> b -> c) -> IO a -> IO b -> IO c\n"
"liftIO2 f ioa iob = fromPrim $ go (toPrim ioa) (toPrim iob)\n"
"  where go : PrimIO a -> PrimIO b -> PrimIO c\n"
"        go pa pb w =\n"
"          let MkIORes va w2 = pa w\n"
"              MkIORes vb w3 = pb w2\n"
"           in MkIORes (f va vb) w3\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:478
msgid ""
"This behavior is not covered by `Functor`, yet it is a very common thing to "
"do. For instance, we might want to read two numbers from standard input "
"(both operations might fail), calculating the product of the two. Here's the "
"code:"
msgstr ""
"この振舞いは`Functor`が押さえていないものの、とてもよく見かけるものです。\n"
"例えば2つの数字を標準入力から読んで（両方とも操作は失敗しえます）、2つの積を"
"計算したいかもしれません。\n"
"以下がそのコードです。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:479
#, no-wrap
msgid ""
"multNumbers : Num a => Neg a => IO (Maybe a)\n"
"multNumbers = do\n"
"  s1 <- getLine\n"
"  s2 <- getLine\n"
"  pure $ liftMaybe2 (*) (parseInteger s1) (parseInteger s2)\n"
msgstr ""
"multNumbers : Num a => Neg a => IO (Maybe a)\n"
"multNumbers = do\n"
"  s1 <- getLine\n"
"  s2 <- getLine\n"
"  pure $ liftMaybe2 (*) (parseInteger s1) (parseInteger s2)\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:490
msgid ""
"And it won't stop here. We might just as well want to have `liftMaybe3` for "
"ternary functions and three `Maybe` arguments and so on, for arbitrary "
"numbers of arguments."
msgstr ""
"そしてここで終わりではありません。\n"
"同様にして、3つの`Maybe`な引数を取る3引数関数のための`liftMaybe3`など、\n"
"好きな個数の引数についての関数が欲しくなります。"

#. type: Plain text
#: ../src/Tutorial/Functor.md:493
msgid ""
"But there is more: We'd also like to lift pure values into the context in "
"question. With this, we could do the following:"
msgstr ""
"でもまだあります。\n"
"純粋な値を問題の文脈に持ち上げたくもあるのです。\n"
"以下のようにできます。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:494
#, no-wrap
msgid ""
"liftMaybe3 : (a -> b -> c -> d) -> Maybe a -> Maybe b -> Maybe c -> Maybe d\n"
"liftMaybe3 f (Just va) (Just vb) (Just vc) = Just $ f va vb vc\n"
"liftMaybe3 _ _         _         _         = Nothing\n"
"\n"
"pureMaybe : a -> Maybe a\n"
"pureMaybe = Just\n"
"\n"
"multAdd100 : Num a => Neg a => String -> String -> Maybe a\n"
"multAdd100 s t = liftMaybe3 calc (parseInteger s) (parseInteger t) (pure 100)\n"
"  where calc : a -> a -> a -> a\n"
"        calc x y z = x * y + z\n"
msgstr ""
"liftMaybe3 : (a -> b -> c -> d) -> Maybe a -> Maybe b -> Maybe c -> Maybe d\n"
"liftMaybe3 f (Just va) (Just vb) (Just vc) = Just $ f va vb vc\n"
"liftMaybe3 _ _         _         _         = Nothing\n"
"\n"
"pureMaybe : a -> Maybe a\n"
"pureMaybe = Just\n"
"\n"
"multAdd100 : Num a => Neg a => String -> String -> Maybe a\n"
"multAdd100 s t = liftMaybe3 calc (parseInteger s) (parseInteger t) (pure 100)\n"
"  where calc : a -> a -> a -> a\n"
"        calc x y z = x * y + z\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:511
msgid ""
"As you'll of course already know, I am now going to present a new interface "
"to encapsulate this behavior. It's called `Applicative`.  Here is its "
"definition and an example implementation:"
msgstr ""
"もちろん既にお察しの通り、これからこの振舞いを内蔵化する新しいインターフェー"
"スをお見せします。\n"
"それは`Applicative`と呼ばれます。\n"
"以下はその定義と実装例です。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:512
#, no-wrap
msgid ""
"interface Functor' f => Applicative' f where\n"
"  app   : f (a -> b) -> f a -> f b\n"
"  pure' : a -> f a\n"
"\n"
"implementation Applicative' Maybe where\n"
"  app (Just fun) (Just val) = Just $ fun val\n"
"  app _          _          = Nothing\n"
"\n"
"  pure' = Just\n"
msgstr ""
"interface Functor' f => Applicative' f where\n"
"  app   : f (a -> b) -> f a -> f b\n"
"  pure' : a -> f a\n"
"\n"
"implementation Applicative' Maybe where\n"
"  app (Just fun) (Just val) = Just $ fun val\n"
"  app _          _          = Nothing\n"
"\n"
"  pure' = Just\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:527
#, no-wrap
msgid ""
"Interface `Applicative` is of course already exported by the *Prelude*.\n"
"There, function `app` is an operator sometimes called *app* or *apply*:\n"
"`(<*>)`.\n"
msgstr ""
"`Applicative`インターフェースはもちろんもう*Prelude*から輸出されています。\n"
"ここでは関数`app`は時々*app*や*apply*と呼ばれる`(<*>)`演算子の姿を取ります。\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:530
msgid ""
"You may wonder, how functions like `liftMaybe2` or `liftIO3` are related to "
"operator *apply*. Let me demonstrate this:"
msgstr ""
"どうして`liftMaybe2`や`liftIO3`のような関数が*適用*演算子に関係あるのか、不思"
"議に思われるかもしれません。\n"
"次のように実演してみます。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:531
#, no-wrap
msgid ""
"liftA2 : Applicative f => (a -> b -> c) -> f a -> f b -> f c\n"
"liftA2 fun fa fb = pure fun <*> fa <*> fb\n"
"\n"
"liftA3 : Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d\n"
"liftA3 fun fa fb fc = pure fun <*> fa <*> fb <*> fc\n"
msgstr ""
"liftA2 : Applicative f => (a -> b -> c) -> f a -> f b -> f c\n"
"liftA2 fun fa fb = pure fun <*> fa <*> fb\n"
"\n"
"liftA3 : Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d\n"
"liftA3 fun fa fb fc = pure fun <*> fa <*> fb <*> fc\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:544
#, no-wrap
msgid ""
"It is really important for you to understand what's going on here, so let's\n"
"break these down. If we specialize `liftA2` to use `Maybe` for `f`,\n"
"`pure fun` is of type `Maybe (a -> b -> c)`. Likewise, `pure fun <*> fa`\n"
"is of type `Maybe (b -> c)`, as `(<*>)` will apply the value stored\n"
"in `fa` to the function stored in `pure fun` (currying!).\n"
msgstr ""
"ここで起こっていることを理解するのは本当に大切ですから、これらを分解していきましょう。\n"
"`liftA2`について`f`を`Maybe`に特化させると、`pure fun`は型`Maybe (a -> b -> c)`になります。\n"
"同様に`pure fun <*> fa`は型`Maybe (b -> c)`ですが、\n"
"これは`(<*>)`が`fa`の中に格納された値を`pure fun`に格納された関数に適用しているからです。\n"
"（カリー化ですね！）\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:550
msgid ""
"You'll often see such chains of applications of *apply*, the number of "
"*applies* corresponding to the arity of the function we lift.  You'll "
"sometimes also see the following, which allows us to drop the initial call "
"to `pure`, and use the operator version of `map` instead:"
msgstr ""
"そのような*apply*の適用の連鎖はよく見掛けることになるでしょうが、\n"
"*適用*している数は持ち上げている関数の引数の数に一致するのです。\n"
"時々以下を見掛けることもあるでしょうが、\n"
"こうすると最初の`pure`の呼び出しを省けて、代わりに`map`の演算子版を使うことが"
"できます。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:551
#, no-wrap
msgid ""
"liftA2' : Applicative f => (a -> b -> c) -> f a -> f b -> f c\n"
"liftA2' fun fa fb = fun <$> fa <*> fb\n"
"\n"
"liftA3' : Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d\n"
"liftA3' fun fa fb fc = fun <$> fa <*> fb <*> fc\n"
msgstr ""
"liftA2' : Applicative f => (a -> b -> c) -> f a -> f b -> f c\n"
"liftA2' fun fa fb = fun <$> fa <*> fb\n"
"\n"
"liftA3' : Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d\n"
"liftA3' fun fa fb fc = fun <$> fa <*> fb <*> fc\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:564
msgid ""
"So, interface `Applicative` allows us to lift values (and functions!)  into "
"computational contexts and apply them to values in the same contexts. Before "
"we will see an extended example why this is useful, I'll quickly introduce "
"some syntactic sugar for working with applicative functors."
msgstr ""
"というわけで、インターフェース`Applicative`があると値（と関数も！）計算上の文"
"脈に持ち上げることができ、\n"
"同じ文脈で値に適用させることができるのです。\n"
"より大きな例でなぜこれが便利なのかを見る前に、\n"
"アプリカティブ関手に取り組む際のいくつかの糖衣構文を手短かにご紹介します。"

#. type: Title ###
#: ../src/Tutorial/Functor.md:565
#, no-wrap
msgid "Idiom Brackets"
msgstr "慣用括弧"

#. type: Plain text
#: ../src/Tutorial/Functor.md:571
msgid ""
"The programming style used for implementing `liftA2'` and `liftA3'` is also "
"referred to as *applicative style* and is used a lot in Haskell for "
"combining several effectful computations with a single pure function."
msgstr ""
"`liftA2`や`liftA3`を実装するのに使ったプログラミングの流儀は*アプリカティブス"
"タイル*としても知られ、\n"
"Haskellで複数の作用のある計算を単一の純粋な関数で結合するために多用されます。"

#. type: Plain text
#: ../src/Tutorial/Functor.md:575
msgid ""
"In Idris, there is an alternative to using such chains of operator "
"applications: Idiom brackets. Here's another reimplementation of `liftA2` "
"and `liftA3`:"
msgstr ""
"Idrisではそのような演算子適用の連鎖を使う代わりの方法があります。\n"
"慣用括弧です。\n"
"以下は`liftA2`と`liftA3`の別の再実装です。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:576
#, no-wrap
msgid ""
"liftA2'' : Applicative f => (a -> b -> c) -> f a -> f b -> f c\n"
"liftA2'' fun fa fb = [| fun fa fb |]\n"
"\n"
"liftA3'' : Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d\n"
"liftA3'' fun fa fb fc = [| fun fa fb fc |]\n"
msgstr ""
"liftA2'' : Applicative f => (a -> b -> c) -> f a -> f b -> f c\n"
"liftA2'' fun fa fb = [| fun fa fb |]\n"
"\n"
"liftA3'' : Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d\n"
"liftA3'' fun fa fb fc = [| fun fa fb fc |]\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:590
#, no-wrap
msgid ""
"The above implementations will be desugared to the one given\n"
"for `liftA2` and `liftA3`, again *before disambiguating,\n"
"type checking, and filling in of implicit values*. Like with the\n"
"*bind* operator, we can therefore write custom implementations\n"
"for `pure` and `(<*>)`, and Idris will use these if it\n"
"can disambiguate between the overloaded function names.\n"
msgstr ""
"上記の実装は`liftA2`や`liftA3`に与えた実装と同じように脱糖されます。\n"
"繰り返しますが、この脱糖は*曖昧解決や型検査、そして暗黙の値を埋める前*に行われます。\n"
"*束縛*演算子と同じように、`pure`や`(<*>)`のための自前の実装を書くことができ、\n"
"その場合オーバーロードされた関数名の曖昧解決ができればIdrisはその実装を使います。\n"

#. type: Title ###
#: ../src/Tutorial/Functor.md:591
#, no-wrap
msgid "Use Case: CSV Reader"
msgstr "用例：CSV読取器"

#. type: Plain text
#: ../src/Tutorial/Functor.md:604
msgid ""
"In order to understand the power and versatility that comes with applicative "
"functors, we will look at a slightly extended example. We are going to write "
"some utilities for parsing and decoding content from CSV files. These are "
"files where each line holds a list of values separated by commas (or some "
"other delimiter). Typically, they are used to store tabular data, for "
"instance from spread sheet applications. What we would like to do is convert "
"lines in a CSV file and store the result in custom records, where each "
"record field corresponds to a column in the table."
msgstr ""
"アプリカティブ関手の持つ強力さと多芸さを実感するために、ほんの少し大きめの例"
"を見ていきます。\n"
"CSVファイルから内容をパースしたりデコードしたりする小間物です。\n"
"ここでのCSVファイルはそれぞれの行にコンマ（あるいは他の区切文字）で区切られた"
"値のリストがあるものです。\n"
"よくあるのがこれらを表のデータを格納するのに使うというもので、\n"
"例えばスプレッドシートアプリケーションから用います。\n"
"やりたいことはCSVファイル中の行を変換して自前のレコードに保管するというもの"
"で、\n"
"それぞれのレコードのフィールドは表中の列に対応します。"

#. type: Plain text
#: ../src/Tutorial/Functor.md:609
msgid ""
"For instance, here is a simple example file, containing tabular user "
"information from a web store: First name, last name, age (optional), email "
"address, gender, and password."
msgstr ""
"例えば以下は単純なファイルの例で、webストアの利用者情報の表が含まれていま"
"す。\n"
"まず名前があり、名字、年齢（空欄可）、Eメールアドレス、性別、そしてパスワード"
"があります。"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functor.md:610
#, no-wrap
msgid ""
"Jon,Doe,42,jon@doe.ch,m,weijr332sdk\n"
"Jane,Doe,,jane@doe.ch,f,aa433sd112\n"
"Stefan,Hoeck,,nope@goaway.ch,m,password123\n"
msgstr ""
"Jon,Doe,42,jon@doe.ch,m,weijr332sdk\n"
"Jane,Doe,,jane@doe.ch,f,aa433sd112\n"
"Stefan,Hoeck,,nope@goaway.ch,m,password123\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:621
msgid ""
"And here are the Idris data types necessary to hold this information at "
"runtime. We use again custom string wrappers for increased type safety and "
"because it will allow us to define for each data type what we consider to be "
"valid input:"
msgstr ""
"そして以下がこの情報を実行時に持つのに必要なIdrisのデータ型です。\n"
"ここでも型安全性を向上させるために自前の文字列の梱包を使いましたが、\n"
"こうすることでそれぞれのデータ型について妥当と考えられる入力を定義できます。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:622
#, no-wrap
msgid ""
"data Gender = Male | Female | Other\n"
"\n"
"record Name where\n"
"  constructor MkName\n"
"  value : String\n"
"\n"
"record Email where\n"
"  constructor MkEmail\n"
"  value : String\n"
"\n"
"record Password where\n"
"  constructor MkPassword\n"
"  value : String\n"
"\n"
"record User where\n"
"  constructor MkUser\n"
"  firstName : Name\n"
"  lastName  : Name\n"
"  age       : Maybe Nat\n"
"  email     : Email\n"
"  gender    : Gender\n"
"  password  : Password\n"
msgstr ""
"data Gender = Male | Female | Other\n"
"\n"
"record Name where\n"
"  constructor MkName\n"
"  value : String\n"
"\n"
"record Email where\n"
"  constructor MkEmail\n"
"  value : String\n"
"\n"
"record Password where\n"
"  constructor MkPassword\n"
"  value : String\n"
"\n"
"record User where\n"
"  constructor MkUser\n"
"  firstName : Name\n"
"  lastName  : Name\n"
"  age       : Maybe Nat\n"
"  email     : Email\n"
"  gender    : Gender\n"
"  password  : Password\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:650
msgid ""
"We start by defining an interface for reading fields in a CSV file and "
"writing implementations for the data types we'd like to read:"
msgstr ""
"CSVファイル中のフィールドを読むのにインターフェースを定義することから始め、\n"
"読み込みたいデータ型に実装を書いていきます。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:651
#, no-wrap
msgid ""
"interface CSVField a where\n"
"  read : String -> Maybe a\n"
msgstr ""
"interface CSVField a where\n"
"  read : String -> Maybe a\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:659
msgid ""
"Below are implementations for `Gender` and `Bool`. I decided to in these "
"cases encode each value with a single lower case character:"
msgstr ""
"以下は`Gender`と`Bool`向けの実装です。\n"
"それぞれ小文字1文字でそれぞれの値を符号化することに決めました。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:660
#, no-wrap
msgid ""
"CSVField Gender where\n"
"  read \"m\" = Just Male\n"
"  read \"f\" = Just Female\n"
"  read \"o\" = Just Other\n"
"  read _   = Nothing\n"
"\n"
"CSVField Bool where\n"
"  read \"t\" = Just True\n"
"  read \"f\" = Just False\n"
"  read _   = Nothing\n"
msgstr ""
"CSVField Gender where\n"
"  read \"m\" = Just Male\n"
"  read \"f\" = Just Female\n"
"  read \"o\" = Just Other\n"
"  read _   = Nothing\n"
"\n"
"CSVField Bool where\n"
"  read \"t\" = Just True\n"
"  read \"f\" = Just False\n"
"  read _   = Nothing\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:675
msgid "For numeric types, we can use the parsing functions from `Data.String`:"
msgstr "数値型については`Data.String`由来のパースする関数が使えます。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:676
#, no-wrap
msgid ""
"CSVField Nat where\n"
"  read = parsePositive\n"
"\n"
"CSVField Integer where\n"
"  read = parseInteger\n"
"\n"
"CSVField Double where\n"
"  read = parseDouble\n"
msgstr ""
"CSVField Nat where\n"
"  read = parsePositive\n"
"\n"
"CSVField Integer where\n"
"  read = parseInteger\n"
"\n"
"CSVField Double where\n"
"  read = parseDouble\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:692
#, no-wrap
msgid ""
"For optional values, the stored type must itself\n"
"come with an instance of `CSVField`. We can then treat\n"
"the empty string `\"\"` as `Nothing`, while a non-empty\n"
"string will be passed to the encapsulated type's field reader.\n"
"(Remember that `(<$>)` is an alias for `map`.)\n"
msgstr ""
"オプショナルな値については、格納される型自身が`CSVField`のインスタンスでなければいけません。\n"
"そこで空文字列`\"\"`を`Nothing`として扱うことにし、\n"
"非空文字列を内蔵化された型のフィールドの読取器に渡すことにします。\n"
"（`(<$>)`が`map`の別称なことを思い出してください。）\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:693
#, no-wrap
msgid ""
"CSVField a => CSVField (Maybe a) where\n"
"  read \"\" = Just Nothing\n"
"  read s  = Just <$> read s\n"
msgstr ""
"CSVField a => CSVField (Maybe a) where\n"
"  read \"\" = Just Nothing\n"
"  read s  = Just <$> read s\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:703
msgid ""
"Finally, for our string wrappers, we need to decide what we consider to be "
"valid values. For simplicity, I decided to limit the length of allowed "
"strings and the set of valid characters."
msgstr ""
"最後に文字列の梱包について、妥当な値だと考えられるものを決める必要がありま"
"す。\n"
"簡単のために許される文字列の長さと妥当な文字集合で制限することに決めました。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:704
#, no-wrap
msgid ""
"readIf : (String -> Bool) -> (String -> a) -> String -> Maybe a\n"
"readIf p mk s = if p s then Just (mk s) else Nothing\n"
"\n"
"isValidName : String -> Bool\n"
"isValidName s =\n"
"  let len = length s\n"
"   in 0 < len && len <= 100 && all isAlpha (unpack s)\n"
"\n"
"CSVField Name where\n"
"  read = readIf isValidName MkName\n"
"\n"
"isEmailChar : Char -> Bool\n"
"isEmailChar '.' = True\n"
"isEmailChar '@' = True\n"
"isEmailChar c   = isAlphaNum c\n"
"\n"
"isValidEmail : String -> Bool\n"
"isValidEmail s =\n"
"  let len = length s\n"
"   in 0 < len && len <= 100 && all isEmailChar (unpack s)\n"
"\n"
"CSVField Email where\n"
"  read = readIf isValidEmail MkEmail\n"
"\n"
"isPasswordChar : Char -> Bool\n"
"isPasswordChar ' ' = True\n"
"isPasswordChar c   = not (isControl c) && not (isSpace c)\n"
"\n"
"isValidPassword : String -> Bool\n"
"isValidPassword s =\n"
"  let len = length s\n"
"   in 8 < len && len <= 100 && all isPasswordChar (unpack s)\n"
"\n"
"CSVField Password where\n"
"  read = readIf isValidPassword MkPassword\n"
msgstr ""
"readIf : (String -> Bool) -> (String -> a) -> String -> Maybe a\n"
"readIf p mk s = if p s then Just (mk s) else Nothing\n"
"\n"
"isValidName : String -> Bool\n"
"isValidName s =\n"
"  let len = length s\n"
"   in 0 < len && len <= 100 && all isAlpha (unpack s)\n"
"\n"
"CSVField Name where\n"
"  read = readIf isValidName MkName\n"
"\n"
"isEmailChar : Char -> Bool\n"
"isEmailChar '.' = True\n"
"isEmailChar '@' = True\n"
"isEmailChar c   = isAlphaNum c\n"
"\n"
"isValidEmail : String -> Bool\n"
"isValidEmail s =\n"
"  let len = length s\n"
"   in 0 < len && len <= 100 && all isEmailChar (unpack s)\n"
"\n"
"CSVField Email where\n"
"  read = readIf isValidEmail MkEmail\n"
"\n"
"isPasswordChar : Char -> Bool\n"
"isPasswordChar ' ' = True\n"
"isPasswordChar c   = not (isControl c) && not (isSpace c)\n"
"\n"
"isValidPassword : String -> Bool\n"
"isValidPassword s =\n"
"  let len = length s\n"
"   in 8 < len && len <= 100 && all isPasswordChar (unpack s)\n"
"\n"
"CSVField Password where\n"
"  read = readIf isValidPassword MkPassword\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:745
msgid ""
"In a later chapter, we will learn about refinement types and how to store an "
"erased proof of validity together with a validated value."
msgstr ""
"後の章で、精錬型と、消去される妥当性の証明を検証された値とともに保管する方法"
"とを学びます。"

#. type: Plain text
#: ../src/Tutorial/Functor.md:749
msgid ""
"We can now start to decode whole lines in a CSV file.  In order to do so, we "
"first introduce a custom error type encapsulating how things can go wrong:"
msgstr ""
"これでCSVファイルの行全体を復号化し始められます。\n"
"そうするためにまず自前のエラー型を導入して、どう物事が失敗しうるかを内蔵化し"
"ます。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:750
#, no-wrap
msgid ""
"data CSVError : Type where\n"
"  FieldError           : (line, column : Nat) -> (str : String) -> CSVError\n"
"  UnexpectedEndOfInput : (line, column : Nat) -> CSVError\n"
"  ExpectedEndOfInput   : (line, column : Nat) -> CSVError\n"
msgstr ""
"data CSVError : Type where\n"
"  FieldError           : (line, column : Nat) -> (str : String) -> CSVError\n"
"  UnexpectedEndOfInput : (line, column : Nat) -> CSVError\n"
"  ExpectedEndOfInput   : (line, column : Nat) -> CSVError\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:760
msgid ""
"We can now use `CSVField` to read a single field at a given line and "
"position in a CSV file, and return a `FieldError` in case of a failure."
msgstr ""
"これで`CSVField`を使って、CSVファイル中の与えられた行と位置での単一のフィール"
"ドを読み、\n"
"失敗したときは`FieldError`を返します。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:761
#, no-wrap
msgid ""
"readField : CSVField a => (line, column : Nat) -> String -> Either CSVError a\n"
"readField line col str =\n"
"  maybe (Left $ FieldError line col str) Right (read str)\n"
msgstr ""
"readField : CSVField a => (line, column : Nat) -> String -> Either CSVError a\n"
"readField line col str =\n"
"  maybe (Left $ FieldError line col str) Right (read str)\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:772
msgid ""
"If we know in advance the number of fields we need to read, we can try and "
"convert a list of strings to a `Vect` of the given length. This facilitates "
"reading record values of a known number of fields, as we get the correct "
"number of string variables when pattern matching on the vector:"
msgstr ""
"予め読み込む必要があるフィールドの数を知っていれば、\n"
"文字列のリストを与えられた長さの`Vect`に変換を試みることができます。\n"
"こうすることで既知の数のフィールド分のレコード値を円滑に読み込むことができま"
"すが、\n"
"それはベクタにパターン照合するときに正しい数の文字列変数を得られるからです。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:773
#, no-wrap
msgid ""
"toVect : (n : Nat) -> (line, col : Nat) -> List a -> Either CSVError (Vect n a)\n"
"toVect 0     line _   []        = Right []\n"
"toVect 0     line col _         = Left (ExpectedEndOfInput line col)\n"
"toVect (S k) line col []        = Left (UnexpectedEndOfInput line col)\n"
"toVect (S k) line col (x :: xs) = (x ::) <$> toVect k line (S col) xs\n"
msgstr ""
"toVect : (n : Nat) -> (line, col : Nat) -> List a -> Either CSVError (Vect n a)\n"
"toVect 0     line _   []        = Right []\n"
"toVect 0     line col _         = Left (ExpectedEndOfInput line col)\n"
"toVect (S k) line col []        = Left (UnexpectedEndOfInput line col)\n"
"toVect (S k) line col (x :: xs) = (x ::) <$> toVect k line (S col) xs\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:783
msgid ""
"Finally, we can implement function `readUser` to try and convert a single "
"line in a CSV-file to a value of type `User`:"
msgstr ""
"最後にCSVファイル中の単一行を型`User`の値に変換しようとする関数`readUser`を実"
"装することができます。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:784
#, no-wrap
msgid ""
"readUser' : (line : Nat) -> List String -> Either CSVError User\n"
"readUser' line ss = do\n"
"  [fn,ln,a,em,g,pw] <- toVect 6 line 0 ss\n"
"  [| MkUser (readField line 1 fn)\n"
"            (readField line 2 ln)\n"
"            (readField line 3 a)\n"
"            (readField line 4 em)\n"
"            (readField line 5 g)\n"
"            (readField line 6 pw) |]\n"
"\n"
"readUser : (line : Nat) -> String -> Either CSVError User\n"
"readUser line = readUser' line . forget . split (',' ==)\n"
msgstr ""
"readUser' : (line : Nat) -> List String -> Either CSVError User\n"
"readUser' line ss = do\n"
"  [fn,ln,a,em,g,pw] <- toVect 6 line 0 ss\n"
"  [| MkUser (readField line 1 fn)\n"
"            (readField line 2 ln)\n"
"            (readField line 3 a)\n"
"            (readField line 4 em)\n"
"            (readField line 5 g)\n"
"            (readField line 6 pw) |]\n"
"\n"
"readUser : (line : Nat) -> String -> Either CSVError User\n"
"readUser line = readUser' line . forget . split (',' ==)\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:800 ../src/Tutorial/Traverse.md:122
msgid "Let's give this a go at the REPL:"
msgstr "ちょっとREPLで動かしてみましょう。"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functor.md:801
#, no-wrap
msgid ""
"Tutorial.Functor> readUser 1 \"Joe,Foo,46,j@f.ch,m,pw1234567\"\n"
"Right (MkUser (MkName \"Joe\") (MkName \"Foo\")\n"
"  (Just 46) (MkEmail \"j@f.ch\") Male (MkPassword \"pw1234567\"))\n"
"Tutorial.Functor> readUser 7 \"Joe,Foo,46,j@f.ch,m,shortPW\"\n"
"Left (FieldError 7 6 \"shortPW\")\n"
msgstr ""
"Tutorial.Functor> readUser 1 \"Joe,Foo,46,j@f.ch,m,pw1234567\"\n"
"Right (MkUser (MkName \"Joe\") (MkName \"Foo\")\n"
"  (Just 46) (MkEmail \"j@f.ch\") Male (MkPassword \"pw1234567\"))\n"
"Tutorial.Functor> readUser 7 \"Joe,Foo,46,j@f.ch,m,shortPW\"\n"
"Left (FieldError 7 6 \"shortPW\")\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:816
msgid ""
"Note, how in the implementation of `readUser'` we used an idiom bracket to "
"map a function of six arguments (`MkUser`)  over six values of type `Either "
"CSVError`. This will automatically succeed, if and only if all of the "
"parsings have succeeded. It would have been notoriously cumbersome resulting "
"in much less readable code to implement `readUser'` with a succession of six "
"nested pattern matches."
msgstr ""
"なお、`readUser'`の実装で慣用括弧を使い、6引数関数 (`MkUser`) を型`Either "
"CSVError`の6つの値に写しました。\n"
"これは全てのパースが成功したとき、またそのときに限って、自動的に成功しま"
"す。\n"
"もし立て続けに6重に入れ子になったパターン照合で`readUser'`を実装していた"
"ら、\n"
"考えるまでもなく面倒ではるかに読みづらいコードになっていたでしょう。"

#. type: Plain text
#: ../src/Tutorial/Functor.md:819
msgid ""
"However, the idiom bracket above looks still quite repetitive.  Surely, we "
"can do better?"
msgstr ""
"しかし上の慣用括弧はまだかなり繰り返しがあります。\n"
"きっと、もっと良くできますよね？"

#. type: Title ####
#: ../src/Tutorial/Functor.md:820
#, no-wrap
msgid "A Case for Heterogeneous Lists"
msgstr "混成リストの用例"

#. type: Plain text
#: ../src/Tutorial/Functor.md:827
msgid ""
"It is time to learn about a family of types, which can be used as a generic "
"representation for record types, and which will allow us to represent and "
"read rows in heterogeneous tables with a minimal amount of code: "
"Heterogeneous lists."
msgstr ""
"型族を学ぶときが来ました。\n"
"型族はレコード型の汎化表現として使うことができ、\n"
"また最小量のコードで混成になっている表中の行を表現したり読み取ったりすること"
"ができます。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:828
#, no-wrap
msgid ""
"namespace HList\n"
"  public export\n"
"  data HList : (ts : List Type) -> Type where\n"
"    Nil  : HList Nil\n"
"    (::) : (v : t) -> (vs : HList ts) -> HList (t :: ts)\n"
msgstr ""
"namespace HList\n"
"  public export\n"
"  data HList : (ts : List Type) -> Type where\n"
"    Nil  : HList Nil\n"
"    (::) : (v : t) -> (vs : HList ts) -> HList (t :: ts)\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:841
msgid ""
"A heterogeneous list is a list type indexed over a *list of types*.  This "
"allows us to at each position store a value of the type at the same position "
"in the list index. For instance, here is a variant, which stores three "
"values of types `Bool`, `Nat`, and `Maybe String` (in that order):"
msgstr ""
"混成リストは*型のリスト*で指標付けされたリスト型です。\n"
"これによりそれぞれの位置にリストの指標中の同じ位置にある型の値を格納すること"
"ができます。\n"
"例えば以下の例では型`Bool`、`Nat`、`Maybe String`の3つの値を（この順で）格納"
"します。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:842
#, no-wrap
msgid ""
"hlist1 : HList [Bool, Nat, Maybe String]\n"
"hlist1 = [True, 12, Nothing]\n"
msgstr ""
"hlist1 : HList [Bool, Nat, Maybe String]\n"
"hlist1 = [True, 12, Nothing]\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:854
msgid ""
"You could argue that heterogeneous lists are just tuples storing values of "
"the given types. That's right, of course, however, as you'll learn the hard "
"way in the exercises, we can use the list index to perform compile-time "
"computations on `HList`, for instance when concatenating two such lists to "
"keep track of the types stored in the result at the same time."
msgstr ""
"混成リストは与えられた型の値を格納するただのタプルだと言い張ることもできるで"
"しょう。\n"
"それはもちろん正しいのですが、演習で苦しみながら学ぶことになるように、\n"
"リスト指標を使って`HList`についてのコンパイル時計算を行うことができるので"
"す。\n"
"例えば2つのリストを結合するときに、同時に結果で保管される型へ追従するなどで"
"す。"

#. type: Plain text
#: ../src/Tutorial/Functor.md:859
msgid ""
"But first, we'll make use of `HList` as a means to concisely parse CSV-"
"lines. In order to do that, we need to introduce a new interface for types "
"corresponding to whole lines in a CSV-file:"
msgstr ""
"しかしまずは`HList`を簡潔にCSVの行をパースする手段として活用します。\n"
"そうするためにはCSVファイル中の全行に対応する型のための、新しいインターフェー"
"スを導入する必要があります。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:860
#, no-wrap
msgid ""
"interface CSVLine a where\n"
"  decodeAt : (line, col : Nat) -> List String -> Either CSVError a\n"
msgstr ""
"interface CSVLine a where\n"
"  decodeAt : (line, col : Nat) -> List String -> Either CSVError a\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:871
msgid ""
"We'll now write two implementations of `CSVLine` for `HList`: One for the "
"`Nil` case, which will succeed if and only if the current list of strings is "
"empty. The other for the *cons* case, which will try and read a single field "
"from the head of the list and the remainder from its tail. We use again an "
"idiom bracket to concatenate the results:"
msgstr ""
"これから`HList`のための`CSVLine`の2つの実装を書いていきます。\n"
"1つは`Nil`の場合のもので、文字列からなる現在のリストが空のとき、またそのとき"
"に限り成功します。\n"
"もう1つは*cons*の場合のもので、リストの先頭と尾っぽの残りから単一のフィールド"
"を読もうとします。\n"
"ここでも結果を結合するのに慣用括弧を使います。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:872
#, no-wrap
msgid ""
"CSVLine (HList []) where\n"
"  decodeAt _ _ [] = Right Nil\n"
"  decodeAt l c _  = Left (ExpectedEndOfInput l c)\n"
"\n"
"CSVField t => CSVLine (HList ts) => CSVLine (HList (t :: ts)) where\n"
"  decodeAt l c []        = Left (UnexpectedEndOfInput l c)\n"
"  decodeAt l c (s :: ss) = [| readField l c s :: decodeAt l (S c) ss |]\n"
msgstr ""
"CSVLine (HList []) where\n"
"  decodeAt _ _ [] = Right Nil\n"
"  decodeAt l c _  = Left (ExpectedEndOfInput l c)\n"
"\n"
"CSVField t => CSVLine (HList ts) => CSVLine (HList (t :: ts)) where\n"
"  decodeAt l c []        = Left (UnexpectedEndOfInput l c)\n"
"  decodeAt l c (s :: ss) = [| readField l c s :: decodeAt l (S c) ss |]\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:887
msgid ""
"And that's it! All we need to add is two utility function for decoding whole "
"lines before they have been split into tokens, one of which is specialized "
"to `HList` and takes an erased list of types as argument to make it more "
"convenient to use at the REPL:"
msgstr ""
"これでおしまいです！\n"
"加える必要があるのは2つの小間物関数だけです。\n"
"いずれも字句に分割されたあとに行全体を復号化するもので、\n"
"一方は`HList`に特化されており、引数に消去されたリスト型を取ります。\n"
"これはREPLで使うのにより便利にするものです。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:888
#, no-wrap
msgid ""
"decode : CSVLine a => (line : Nat) -> String -> Either CSVError a\n"
"decode line = decodeAt line 1 . forget . split (',' ==)\n"
"\n"
"hdecode :  (0 ts : List Type)\n"
"        -> CSVLine (HList ts)\n"
"        => (line : Nat)\n"
"        -> String\n"
"        -> Either CSVError (HList ts)\n"
"hdecode _ = decode\n"
msgstr ""
"decode : CSVLine a => (line : Nat) -> String -> Either CSVError a\n"
"decode line = decodeAt line 1 . forget . split (',' ==)\n"
"\n"
"hdecode :  (0 ts : List Type)\n"
"        -> CSVLine (HList ts)\n"
"        => (line : Nat)\n"
"        -> String\n"
"        -> Either CSVError (HList ts)\n"
"hdecode _ = decode\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:902
msgid ""
"It's time to reap the fruits of our labour and give this a go at the REPL:"
msgstr "骨折りの成果を得るために、REPLで試すときが来ました。"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functor.md:903
#, no-wrap
msgid ""
"Tutorial.Functor> hdecode [Bool,Nat,Double] 1 \"f,100,12.123\"\n"
"Right [False, 100, 12.123]\n"
"Tutorial.Functor> hdecode [Name,Name,Gender] 3 \"Idris,,f\"\n"
"Left (FieldError 3 2 \"\")\n"
msgstr ""
"Tutorial.Functor> hdecode [Bool,Nat,Double] 1 \"f,100,12.123\"\n"
"Right [False, 100, 12.123]\n"
"Tutorial.Functor> hdecode [Name,Name,Gender] 3 \"Idris,,f\"\n"
"Left (FieldError 3 2 \"\")\n"

#. type: Title ###
#: ../src/Tutorial/Functor.md:910
#, no-wrap
msgid "Applicative Laws"
msgstr "アプリカティブ則"

#. type: Plain text
#: ../src/Tutorial/Functor.md:914
msgid ""
"Again, `Applicative` implementations must follow certain laws. Here they are:"
msgstr ""
"繰り返しになりますが、`Applicative`の実装もいくつかの法則に従います。\n"
"以下の通りです。"

#. type: Bullet: '* '
#: ../src/Tutorial/Functor.md:917
msgid ""
"`pure id <*> fa = fa`: Lifting and applying the identity function has no "
"visible effect."
msgstr ""
"`pure id <*> fa = fa`: 持ち上げて同値関数を適用しても目に見える効果はない。"

#. type: Bullet: '* '
#: ../src/Tutorial/Functor.md:922
msgid ""
"`[| f . g |] <*> v = f <*> (g <*> v)`: I must not matter, whether we compose "
"our functions first and then apply them, or whether we apply our functions "
"first and then compose them."
msgstr ""
"`[| f . g |] <*> v = f <*> (g <*> v)`: 関数を合成してから適用しても、関数を適"
"用してから合成しても同じである。"

#. type: Plain text
#: ../src/Tutorial/Functor.md:925
#, no-wrap
msgid ""
"  The above might be hard to understand, so here\n"
"  they are again with explicit types and implementations:\n"
msgstr ""
"  上記は理解しづらいかもしれないので、\n"
"  以下に再びはっきりした型と実装を置いておきます。\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:926
#, no-wrap
msgid ""
"  compL : Maybe (b -> c) -> Maybe (a -> b) -> Maybe a -> Maybe c\n"
"  compL f g v = [| f . g |] <*> v\n"
"\n"
"  compR : Maybe (b -> c) -> Maybe (a -> b) -> Maybe a -> Maybe c\n"
"  compR f g v = f <*> (g <*> v)\n"
msgstr ""
"  compL : Maybe (b -> c) -> Maybe (a -> b) -> Maybe a -> Maybe c\n"
"  compL f g v = [| f . g |] <*> v\n"
"\n"
"  compR : Maybe (b -> c) -> Maybe (a -> b) -> Maybe a -> Maybe c\n"
"  compR f g v = f <*> (g <*> v)\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:936
#, no-wrap
msgid ""
"  The second applicative law states, that the two implementations\n"
"  `compL` and `compR` should behave identically.\n"
msgstr "  2つ目のアプリカティブ則が主張しているのは、2つの実装`compL`と`compR`が等価に振る舞うということです。\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Functor.md:939
msgid ""
"`pure f <*> pure x = pure (f x)`. This is also called the *homomorphism* "
"law. It should be pretty self-explaining."
msgstr ""
"`pure f <*> pure x = pure (f x)`。これは*準同型写像*の法則とも呼ばれます。\n"
"これ自体はかなりわかりやすいでしょう。"

#. type: Bullet: '* '
#: ../src/Tutorial/Functor.md:942
msgid ""
"`f <*> pure v = pure ($ v) <*> f`. This is called the law of *interchange*."
msgstr "`f <*> pure v = pure ($ v) <*> f`。これは*交換*の法則と呼ばれます。"

#. type: Plain text
#: ../src/Tutorial/Functor.md:944
#, no-wrap
msgid "  This should again be explained with a concrete example:\n"
msgstr "  これも具体例で説明します。\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:945
#, no-wrap
msgid ""
"  interL : Maybe (a -> b) -> a -> Maybe b\n"
"  interL f v = f <*> pure v\n"
"\n"
"  interR : Maybe (a -> b) -> a -> Maybe b\n"
"  interR f v = pure ($ v) <*> f\n"
msgstr ""
"  interL : Maybe (a -> b) -> a -> Maybe b\n"
"  interL f v = f <*> pure v\n"
"\n"
"  interR : Maybe (a -> b) -> a -> Maybe b\n"
"  interR f v = pure ($ v) <*> f\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:957
#, no-wrap
msgid ""
"  Note, that `($ v)` has type `(a -> b) -> b`, so this\n"
"  is a function type being applied to `f`, which has\n"
"  a function of type `a -> b` wrapped in a `Maybe`\n"
"  context.\n"
msgstr ""
"  なお、`($ v)`は型`(a -> b) -> b`なので、`f`に適用される関数型です。\n"
"  `f`は型`a -> b`の関数が`Maybe`の文脈に包まれたものです。\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:961
#, no-wrap
msgid ""
"  The law of interchange states that it must not matter\n"
"  whether we apply a pure value from the left or\n"
"  right of the *apply* operator.\n"
msgstr "  交換法則が主張していることは、純粋な値を*適用*演算子の左右どちらから適用しても変わってはいけないということです。\n"

#. type: Bullet: '1. '
#: ../src/Tutorial/Functor.md:965
msgid "Implement `Applicative'` for `Either e` and `Identity`."
msgstr "`Applicative`を`Either e`と`Identity`に実装してください。"

#. type: Bullet: '2. '
#: ../src/Tutorial/Functor.md:970
msgid ""
"Implement `Applicative'` for `Vect n`. Note: In order to implement `pure`, "
"the length must be known at runtime.  This can be done by passing it as an "
"unerased implicit to the interface implementation:"
msgstr ""
"`Applicative`を`Vect n`に実装してください。\n"
"補足：`pure`を実装するためには、実行時に長さがわかっていなくてはいけませ"
"ん。\n"
"これは長さを消去されない暗黙子としてインターフェースの実装に渡すことでできま"
"す。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:971
#, no-wrap
msgid "   implementation {n : _} -> Applicative' (Vect n) where\n"
msgstr "   implementation {n : _} -> Applicative' (Vect n) where\n"

#. type: Bullet: '3. '
#: ../src/Tutorial/Functor.md:977
msgid ""
"Implement `Applicative'` for `Pair e`, with `e` having a `Monoid` constraint."
msgstr ""
"`Applicative`を`Pair e`に実装してください。\n"
"ただし`e`は`Monoid`制約を満たします。"

#. type: Bullet: '4. '
#: ../src/Tutorial/Functor.md:980
msgid ""
"Implement `Applicative` for `Const e`, with `e` having a `Monoid` constraint."
msgstr ""
"`Const e`に`Applicative`を実装してください。\n"
"ただし`e`は`Monoid`制約を満たします。"

#. type: Bullet: '5. '
#: ../src/Tutorial/Functor.md:985
msgid ""
"Implement `Applicative` for `Validated e`, with `e` having a `Semigroup` "
"constraint. This will allow us to use `(<+>)` to accumulate errors in case "
"of two `Invalid` values in the implementation of *apply*."
msgstr ""
"`Applicative`を`Validated e`に実装してください。\n"
"ただし`e`は`Semigroup`制約を満たします。\n"
"これがあると*apply*の実装で2つの`Invalid`な値になったときに、`(<+>)`を使って"
"エラーを積み重ねることができます。"

#. type: Bullet: '6. '
#: ../src/Tutorial/Functor.md:990
msgid ""
"Add an additional data constructor of type `CSVError -> CSVError -> "
"CSVError` to `CSVError` and use this to implement `Semigroup` for `CSVError`."
msgstr ""
"型が`CSVError -> CSVError -> CSVError`のデータ構築子を追加し、\n"
"これを使って`Semigroup`を`CSVError`に実装してください。"

#. type: Bullet: '7. '
#: ../src/Tutorial/Functor.md:994
msgid ""
"Refactor our CSV-parsers and all related functions so that they return "
"`Validated` instead of `Either`. This will only work, if you solved exercise "
"6."
msgstr ""
"CSVパーサと全ての関係する関数を、`Either`の代わりに`Validated`を返すようにし"
"てリファクタしてください。\n"
"これは演習6を解いたあとでないと動きません。"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1000
#, no-wrap
msgid ""
"   Two things to note: You will have to adjust very little of\n"
"   the existing code, as we can still use applicative syntax\n"
"   with `Validated`. Also, with this change, we enhanced our CSV-parsers\n"
"   with the ability of error accumulation. Here are some examples\n"
"   from a REPL session:\n"
msgstr ""
"   2点補足：既存のコードを調整する必要があるのはごく一部ですが、\n"
"   これは`Validated`のアプリカティブ構文をそのまま使うことができるからです。\n"
"   また、この変更によりCSVパーサのエラー累積能力を向上させることができます。\n"
"   以下はREPLセッションでのいくつかの例です。\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functor.md:1001
#, no-wrap
msgid ""
"   Solutions.Functor> hdecode [Bool,Nat,Gender] 1 \"t,12,f\"\n"
"   Valid [True, 12, Female]\n"
"   Solutions.Functor> hdecode [Bool,Nat,Gender] 1 \"o,-12,f\"\n"
"   Invalid (App (FieldError 1 1 \"o\") (FieldError 1 2 \"-12\"))\n"
"   Solutions.Functor> hdecode [Bool,Nat,Gender] 1 \"o,-12,foo\"\n"
"   Invalid (App (FieldError 1 1 \"o\")\n"
"     (App (FieldError 1 2 \"-12\") (FieldError 1 3 \"foo\")))\n"
msgstr ""
"   Solutions.Functor> hdecode [Bool,Nat,Gender] 1 \"t,12,f\"\n"
"   Valid [True, 12, Female]\n"
"   Solutions.Functor> hdecode [Bool,Nat,Gender] 1 \"o,-12,f\"\n"
"   Invalid (App (FieldError 1 1 \"o\") (FieldError 1 2 \"-12\"))\n"
"   Solutions.Functor> hdecode [Bool,Nat,Gender] 1 \"o,-12,foo\"\n"
"   Invalid (App (FieldError 1 1 \"o\")\n"
"     (App (FieldError 1 2 \"-12\") (FieldError 1 3 \"foo\")))\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1015
#, no-wrap
msgid ""
"   Behold the power of applicative functors and heterogeneous lists: With\n"
"   only a few lines of code we wrote a pure, type-safe, and total\n"
"   parser with error accumulation for lines in CSV-files, which is\n"
"   very convenient to use at the same time!\n"
msgstr ""
"   アプリカティブ関手と混成リストの強力さにご注目。\n"
"   たった数行のコードだけで、CSVファイル中の行にあるエラーの累積を含む、\n"
"   純粋で、型安全で、全域なパーサを書きました。\n"
"   それにこのパーサはとても使いやすいです！\n"

#. type: Bullet: '8. '
#: ../src/Tutorial/Functor.md:1018
msgid ""
"Since we introduced heterogeneous lists in this chapter, it would be a pity "
"not to experiment with them a little."
msgstr "この章で混成リストを紹介したので、ちょっと実験してみないと損でしょう。"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1027
#, no-wrap
msgid ""
"   This exercise is meant to sharpen your skills in type wizardry.\n"
"   It therefore comes with very few hints. Try to decide yourself\n"
"   what behavior you'd expect from a given function, how to express\n"
"   this in the types, and how to implement it afterwards.\n"
"   If your types are correct and precise enough, the implementations\n"
"   will almost come for free. Don't give up too early if you get stuck.\n"
"   Only if you truly run out of ideas should you have a glance\n"
"   at the solutions (and then, only at the types at first!)\n"
msgstr ""
"   この演習の目的は型の妙義における読者の技能を研ぎ澄ますことです。\n"
"   したがって解決の糸口はほとんど付属しません。\n"
"   自力で与えられた関数からどんな振舞いが期待されるか、\n"
"   その振舞いをどう型で表現するか、そしてその後でどう実装するか、決めてみてください。\n"
"   型が正しく充分に精緻であれば、実装は実質無料で手に入ります。\n"
"   行き詰まっても早々に諦めないでください。\n"
"   本当に万策尽きたときだけ解法を一瞥すること。\n"
"   （そのときは、まずは型だけ見るようにしてください！）\n"

#. type: Bullet: '   1. '
#: ../src/Tutorial/Functor.md:1029
msgid "Implement `head` for `HList`."
msgstr "`head`を`HList`に実装してください。"

#. type: Bullet: '   2. '
#: ../src/Tutorial/Functor.md:1031
msgid "Implement `tail` for `HList`."
msgstr "`tail`を`HList`に実装してください。"

#. type: Bullet: '   3. '
#: ../src/Tutorial/Functor.md:1033
msgid "Implement `(++)` for `HList`."
msgstr "`(++)`を`HList`に実装してください。"

#. type: Bullet: '   4. '
#: ../src/Tutorial/Functor.md:1037
msgid ""
"Implement `index` for `HList`. This might be harder than the other three.  "
"Go back and look how we implemented `indexList` in an [earlier exercise]"
"(Dependent.md) and start from there."
msgstr ""
"`index`を`HList`に実装してください。\n"
"これは他の3つより歯応えがあるかもしれません。\n"
"[前の演習](Dependent.md)でいかにして`indexList`を実装したかに立ち返り、そこか"
"ら始めましょう。"

#. type: Bullet: '   5. '
#: ../src/Tutorial/Functor.md:1043
msgid ""
"Package *contrib*, which is part of the Idris project, provides `Data.HVect."
"HVect`, a data type for heterogeneous vectors. The only difference to our "
"own `HList` is, that `HVect` is indexed over a vector of types instead of a "
"list of types. This makes it easier to express certain operations at the "
"type level."
msgstr ""
"パッケージ*contrib*……これはIdrisプロジェクトの一部ですが……\n"
"は混成ベクタのデータ型である`Data.HVect.HVect`を提供します。\n"
"私達の`HList`との唯一の相違点は`HVect`が型リストの代わりに型ベクタに指標付け"
"られていることです。\n"
"これによりいくつかの操作を型段階で表現することがより簡単になっています。"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1046
#, no-wrap
msgid ""
"      Write your own implementation of `HVect` together with functions\n"
"      `head`, `tail`, `(++)`, and `index`.\n"
msgstr "      自力で`HVect`と関数`head`、`tail`、`(++)`、そして`index`関数の実装を書いてください。\n"

#. type: Bullet: '   6. '
#: ../src/Tutorial/Functor.md:1050
msgid ""
"For a real challenge, try implementing a function for transposing a `Vect m "
"(HVect ts)`. You'll first have to be creative about how to even express this "
"in the types."
msgstr ""
"真の挑戦として、`Vect m (HVect ts)`を転地する関数を実装してみてください。\n"
"まずはこの型をどのようにさえすれば表現できるかというところから思索することに"
"なるでしょう。"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1057
#, no-wrap
msgid ""
"      Note: In order to implement this, you'll need to pattern match\n"
"      on an erased argument in at least one case to help Idris with\n"
"      type inference. Pattern matching on erased arguments is forbidden\n"
"      (they are erased after all, so we can't inspect them at runtime),\n"
"      *unless* the structure of the value being matched on can be derived\n"
"      from another, un-erased argument.\n"
msgstr ""
"      補足：これを実装するには、少なくとも1つの場合分けでIdrisの型推論を手助けするために、\n"
"      消去される引数でのパターン照合が必要になるでしょう。\n"
"      消去される引数でパターン照合することは禁止されていますが、\n"
"      その照合される値の構造が他所の消去されない引数から導出できる場合は*その限りではありません*。\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1061
#, no-wrap
msgid ""
"      Also, don't worry if you get stuck on this one. It took me several\n"
"      tries to figure it out. But I enjoyed the experience, so I just *had*\n"
"      to include it here. :-)\n"
msgstr ""
"      また、この問題で行き詰まっても心配しないでください。\n"
"      筆者も理解するまで何度も試行しましたから。\n"
"      でもこの体験は楽しかったので、ここに含めない*わけにはいきません*でした。:-)\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1065
#, no-wrap
msgid ""
"      Note, however, that such a function might be useful when working with\n"
"      CSV-files, as it allows us to convert a table represented as\n"
"      rows (a vector of tuples) to one represented as columns (a tuple of vectors).\n"
msgstr ""
"      ただ、このような関数がCSVファイルを扱うのに便利であろうことには頭に入れておきましょう。\n"
"      行の集まりからなる表（タプルのベクタ）を列の集まりからなる表（ベクタのタプル）に変換できるからです。\n"

#. type: Bullet: '9. '
#: ../src/Tutorial/Functor.md:1069
msgid ""
"Show, that the composition of two applicative functors is again an "
"applicative functor by implementing `Applicative` for `Comp f g`."
msgstr ""
"アプリカティブ関手の合成がこれまたアプリカティブ関手になることを、\n"
"`Applicative`を`Comp f g`に実装することで示してください。"

#. type: Bullet: '10. '
#: ../src/Tutorial/Functor.md:1073
msgid ""
"Show, that the product of two applicative functors is again an applicative "
"functor by implementing `Applicative` for `Prod f g`."
msgstr ""
"2つのアプリカティブ関手の積がこれまたアプリカティブ関手になることを、\n"
"`Applicative`を`Prod f g`に実装することで示してください。"

#. type: Title ##
#: ../src/Tutorial/Functor.md:1074
#, no-wrap
msgid "Monad"
msgstr "モナド"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1081
#, no-wrap
msgid ""
"Finally, `Monad`. A lot of ink has been spilled about this one.\n"
"However, after what we already saw in the [chapter about `IO`](IO.md),\n"
"there is not much left to discuss here. `Monad` extends\n"
"`Applicative` and adds two new related functions: The *bind*\n"
"operator (`(>>=)`) and function `join`. Here is its definition:\n"
msgstr ""
"ついに`Monad`です。\n"
"これには多くの紙幅が割かれてきたものでした。\n"
"しかし既に[`IO`についての章](IO.md)で見てきたあとであり、\n"
"ここでお伝えすべきことはそれほど残っていません。\n"
"`Monad`は`Applicative`を拡張し2つの新しい関連する関数を追加します。\n"
"*束縛*演算子 (`(>>=)`) と関数`join`です。\n"
"以下がその定義です。\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:1082
#, no-wrap
msgid ""
"interface Applicative' m => Monad' m where\n"
"  bind  : m a -> (a -> m b) -> m b\n"
"  join' : m (m a) -> m a\n"
msgstr ""
"interface Applicative' m => Monad' m where\n"
"  bind  : m a -> (a -> m b) -> m b\n"
"  join' : m (m a) -> m a\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1091
#, no-wrap
msgid ""
"Implementers of `Monad` are free to choose to either implement\n"
"`(>>=)` or `join` or both. You will show in an exercise, how\n"
"`join` can be implemented in terms of *bind* and vice versa.\n"
msgstr ""
"`Monad`の実装者は`(>>=)`と`join`のどちらを実装するか、もしくは両方を実装するかを自由に選べます。\n"
"どうやって`join`が*束縛*を使って実装されるのか、またその逆については、演習で見ることになるでしょう。\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1099
msgid ""
"The big difference between `Monad` and `Applicative` is, that the former "
"allows a computation to depend on the result of an earlier computation. For "
"instance, we could decide based on a string read from standard input whether "
"to delete a file or play a song. The result of the first `IO` action "
"(reading some user input) will affect, which `IO` action to run next.  This "
"is not possible with the *apply* operator:"
msgstr ""
"`Monad`と`Applicative`の大きな違いは、\n"
"前者では何らかの計算がその前の計算の結果に依存することができる点にありま"
"す。\n"
"例えば標準入力から読んだ文字列に基づいてファイルを削除するか歌を流すかを決め"
"ることができます。\n"
"最初の`IO`行動（利用者の入力を読む）が、次に走る`IO`行動に影響するのです。\n"
"これは*適用*演算子ではできません。"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functor.md:1100
#, no-wrap
msgid "(<*>) : IO (a -> b) -> IO a -> IO b\n"
msgstr "(<*>) : IO (a -> b) -> IO a -> IO b\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1115
#, no-wrap
msgid ""
"The two `IO` actions have already been decided on when they\n"
"are being passed as arguments to `(<*>)`. The result of the first\n"
"cannot - in the general case - affect which computation to\n"
"run in the second. (Actually, with `IO` this would theoretically be\n"
"possible via side effects: The first action could write some\n"
"command to a file or overwrite some mutable state, and the\n"
"second action could read from that file or state, thus\n"
"deciding on the next thing to do. But this is a speciality\n"
"of `IO`, not of applicative functors in general. If the functor in\n"
"question was `Maybe`, `List`, or `Vector`, no such thing\n"
"would be possible.)\n"
msgstr ""
"`(<*>)`への引数として渡される時分には、2つの`IO`行動は既に決定されています。\n"
"1つ目の結果は……一般的な場合において……2つ目に走る計算に影響することはありません。\n"
"（実は`IO`については副作用を介せば理論上可能です。\n"
"最初の行動が何らかの命令をファイルまたは何らかの可変な状態に上書きすれば、\n"
"2つ目の行動がそのファイルや状態から読むことができるので、次にすべきことを決定することができるのです。\n"
"しかしこれは`IO`に限った話であって、アプリカティブ関手一般の話ではありません。\n"
"もし問題の関手が`Maybe`や`List`や`Vector`だったら、そのようなことはできません。）\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1121
msgid ""
"Let's demonstrate the difference with an example. Assume we'd like to "
"enhance our CSV-reader with the ability to decode a line of tokens to a sum "
"type. For instance, we'd like to decode CRUD requests from the lines of a "
"CSV-file:"
msgstr ""
"例で相違点を実演しましょう。\n"
"CSV読み取り機を改善して字句からなる行を直和型に復号化できるようにしたいとしま"
"す。\n"
"例えばCSVファイルの行からCRUDリクエストを復号化したいとしましょう。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:1122
#, no-wrap
msgid ""
"data Crud : (i : Type) -> (a : Type) -> Type where\n"
"  Create : (value : a) -> Crud i a\n"
"  Update : (id : i) -> (value : a) -> Crud i a\n"
"  Read   : (id : i) -> Crud i a\n"
"  Delete : (id : i) -> Crud i a\n"
msgstr ""
"data Crud : (i : Type) -> (a : Type) -> Type where\n"
"  Create : (value : a) -> Crud i a\n"
"  Update : (id : i) -> (value : a) -> Crud i a\n"
"  Read   : (id : i) -> Crud i a\n"
"  Delete : (id : i) -> Crud i a\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1134
msgid ""
"We need a way to on each line decide, which data constructor to choose for "
"our decoding. One way to do this is to put the name of the data constructor "
"(or some other tag of identification) in the first column of the CSV-file:"
msgstr ""
"それぞれの行で復号にどのデータ構築子を選ぶべきか決める方法が必要です。\n"
"1つの方法はデータ構築子の名前（やその他の識別用の札）をCSVファイルの最初の行"
"に置いておくことです。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:1135
#, no-wrap
msgid ""
"hlift : (a -> b) -> HList [a] -> b\n"
"hlift f [x] = f x\n"
"\n"
"hlift2 : (a -> b -> c) -> HList [a,b] -> c\n"
"hlift2 f [x,y] = f x y\n"
"\n"
"decodeCRUD :  CSVField i\n"
"           => CSVField a\n"
"           => (line : Nat)\n"
"           -> (s    : String)\n"
"           -> Either CSVError (Crud i a)\n"
"decodeCRUD l s =\n"
"  let h ::: t = split (',' ==) s\n"
"   in do\n"
"     MkName n <- readField l 1 h\n"
"     case n of\n"
"       \"Create\" => hlift  Create  <$> decodeAt l 2 t\n"
"       \"Update\" => hlift2 Update  <$> decodeAt l 2 t\n"
"       \"Read\"   => hlift  Read    <$> decodeAt l 2 t\n"
"       \"Delete\" => hlift  Delete  <$> decodeAt l 2 t\n"
"       _        => Left (FieldError l 1 n)\n"
msgstr ""
"hlift : (a -> b) -> HList [a] -> b\n"
"hlift f [x] = f x\n"
"\n"
"hlift2 : (a -> b -> c) -> HList [a,b] -> c\n"
"hlift2 f [x,y] = f x y\n"
"\n"
"decodeCRUD :  CSVField i\n"
"           => CSVField a\n"
"           => (line : Nat)\n"
"           -> (s    : String)\n"
"           -> Either CSVError (Crud i a)\n"
"decodeCRUD l s =\n"
"  let h ::: t = split (',' ==) s\n"
"   in do\n"
"     MkName n <- readField l 1 h\n"
"     case n of\n"
"       \"Create\" => hlift  Create  <$> decodeAt l 2 t\n"
"       \"Update\" => hlift2 Update  <$> decodeAt l 2 t\n"
"       \"Read\"   => hlift  Read    <$> decodeAt l 2 t\n"
"       \"Delete\" => hlift  Delete  <$> decodeAt l 2 t\n"
"       _        => Left (FieldError l 1 n)\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1164
msgid ""
"I added two utility function for helping with type inference and to get "
"slightly nicer syntax. The important thing to note is, how we pattern match "
"on the result of the first parsing function to decide on the data "
"constructor and thus the next parsing function to use."
msgstr ""
"2つの小間物関数を加えて型推論を手助けしたり若干いい感じの構文になるようにしま"
"した。\n"
"大事なのは、いかにして最初の構文解析関数の結果でパターン照合し、\n"
"データ構築子と次に使う構文解析関数を決定しているか、というところです。"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1166
msgid "Here's how this works at the REPL:"
msgstr "以下はREPLで動かした様子です。"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functor.md:1167
#, no-wrap
msgid ""
"Tutorial.Functor> decodeCRUD {i = Nat} {a = Email} 1 \"Create,jon@doe.ch\"\n"
"Right (Create (MkEmail \"jon@doe.ch\"))\n"
"Tutorial.Functor> decodeCRUD {i = Nat} {a = Email} 1 \"Update,12,jane@doe.ch\"\n"
"Right (Update 12 (MkEmail \"jane@doe.ch\"))\n"
"Tutorial.Functor> decodeCRUD {i = Nat} {a = Email} 1 \"Delete,jon@doe.ch\"\n"
"Left (FieldError 1 2 \"jon@doe.ch\")\n"
msgstr ""
"Tutorial.Functor> decodeCRUD {i = Nat} {a = Email} 1 \"Create,jon@doe.ch\"\n"
"Right (Create (MkEmail \"jon@doe.ch\"))\n"
"Tutorial.Functor> decodeCRUD {i = Nat} {a = Email} 1 \"Update,12,jane@doe.ch\"\n"
"Right (Update 12 (MkEmail \"jane@doe.ch\"))\n"
"Tutorial.Functor> decodeCRUD {i = Nat} {a = Email} 1 \"Delete,jon@doe.ch\"\n"
"Left (FieldError 1 2 \"jon@doe.ch\")\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1184
msgid ""
"To conclude, `Monad`, unlike `Applicative`, allows us to chain computations "
"sequentially, where intermediary results can affect the behavior of later "
"computations.  So, if you have n unrelated effectful computations and want "
"to combine them under a pure, n-ary function, `Applicative` will be "
"sufficient. If, however, you want to decide based on the result of an "
"effectful computation what computation to run next, you need a `Monad`."
msgstr ""
"まとめると`Monad`は`Applicative`とは異なり計算を順番に連鎖させられます。\n"
"この連鎖では中間結果が後の計算に影響を与えられます。\n"
"なので、もしn個の関連のない作用付き計算があり、純粋でn引数の関数のもとに束ね"
"たいなら、\n"
"`Applicative`で充分でしょう。\n"
"しかしもし、ある作用付き計算の結果に基づいて次にどの計算を走らせるか決めたい"
"ときは、`Monad`を使う必要があります。"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1190
msgid ""
"Note, however, that `Monad` has one important drawback compared to "
"`Applicative`: In general, monads don't compose.  For instance, there is no "
"`Monad` instance for `Either e . IO`.  We will later learn about monad "
"transformers, which can be composed with other monads."
msgstr ""
"しかし注意ですが、`Monad`は`Applicative`に比べて重要な欠点があります。\n"
"一般にモナドは組み合わさりません。\n"
"例えば`Either e . IO`への`Monad`インスタンスはありません。\n"
"あとでモナド変換子について学びますが、これがあると他のモナドと組み合わせられ"
"ます。"

#. type: Title ###
#: ../src/Tutorial/Functor.md:1191
#, no-wrap
msgid "Monad Laws"
msgstr "モナド則"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1194
msgid "Without further ado, here are the laws for `Monad`:"
msgstr "早速ですが以下が`Monad`の法則です。"

#. type: Bullet: '* '
#: ../src/Tutorial/Functor.md:1198
msgid ""
"`ma >>= pure = ma` and `pure v >>= f = f v`.  These are monad's identity "
"laws. Here they are as concrete examples:"
msgstr ""
"`ma >>= pure = ma`と`pure v >>= f = f v`。\n"
"これらはモナドの等価法則です。\n"
"以下が具体例です。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:1199
#, no-wrap
msgid ""
"  id1L : Maybe a -> Maybe a\n"
"  id1L ma = ma >>= pure\n"
"\n"
"  id2L : a -> (a -> Maybe b) -> Maybe b\n"
"  id2L v f = pure v >>= f\n"
"\n"
"  id2R : a -> (a -> Maybe b) -> Maybe b\n"
"  id2R v f = f v\n"
msgstr ""
"  id1L : Maybe a -> Maybe a\n"
"  id1L ma = ma >>= pure\n"
"\n"
"  id2L : a -> (a -> Maybe b) -> Maybe b\n"
"  id2L v f = pure v >>= f\n"
"\n"
"  id2R : a -> (a -> Maybe b) -> Maybe b\n"
"  id2R v f = f v\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1212
#, no-wrap
msgid ""
"  These two laws state that `pure` should behave\n"
"  neutrally w.r.t. *bind*.\n"
msgstr "  これら2つの法則は`pure`が*束縛*に対して中立にはたらくべきだと主張しています。\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Functor.md:1218
#, fuzzy
#| msgid ""
#| "(m >>= f) >>= g = m >>= (f >=> g)  This is the law of associativity for "
#| "monad.  You might not have seen the second operator `(>=>)`.  It can be "
#| "used to sequence effectful computations and has the following type:"
msgid ""
"`(m >>= f) >>= g = m >>= (f >=> g)`.  This is the law of associativity for "
"monad.  You might not have seen the second operator `(>=>)`.  It can be used "
"to sequence effectful computations and has the following type:"
msgstr ""
"`(m >>= f) >>= g = m >>= (f >=> g)`。\n"
"これはモナドの結合性の法則です。\n"
"2つ目の演算子`(>=>)`を見掛けたことがないかもしれません。\n"
"これは作用付き計算を連接するのに使え、以下の型を持ちます。"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functor.md:1219
#, no-wrap
msgid ""
"  Tutorial.Functor> :t (>=>)\n"
"  Prelude.>=> : Monad m => (a -> m b) -> (b -> m c) -> a -> m c\n"
msgstr ""
"  Tutorial.Functor> :t (>=>)\n"
"  Prelude.>=> : Monad m => (a -> m b) -> (b -> m c) -> a -> m c\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1229
#, no-wrap
msgid ""
"The above are the *official* monad laws. However, we need to\n"
"consider a third one, given that in Idris (and Haskell)\n"
"`Monad` extends `Applicative`: As `(<*>)` can be implemented\n"
"in terms of `(>>=)`, the actual implementation of `(<*>)`\n"
"must behave the same as the implementation in terms of `(>>=)`:\n"
msgstr ""
"上記は*公式の*モナド則です。\n"
"しかし、Idris（やHaskell）では`Monad`が`Applicative`を拡張していることからすれば、\n"
"3つ目の法則についても考える必要があります。\n"
"`(<*>)`が`(>>=)`を使って実装できるため、\n"
"`(<*>)`の実際の実装は`(>>=)`を使って実装と同じように振る舞わなくてはいけません。\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Functor.md:1231
msgid "`mf <*> ma = mf >>= (\\fun => map (fun $) ma)`."
msgstr "`mf <*> ma = mf >>= (\\fun => map (fun $) ma)`"

#. type: Bullet: '1. '
#: ../src/Tutorial/Functor.md:1237
msgid ""
"`Applicative` extends `Functor`, because every `Applicative` is also a "
"`Functor`. Proof this by implementing `map` in terms of `pure` and `(<*>)`."
msgstr ""
"あらゆる`Applicative`は`Functor`でもあるので、`Applicative`は`Functor`の拡張"
"です。\n"
"このことを`map`を`pure`と`(<*>)`を使って実装することで証明してください。"

#. type: Bullet: '2. '
#: ../src/Tutorial/Functor.md:1241
msgid ""
"`Monad` extends `Applicative`, because every `Monad` is also an "
"`Applicative`. Proof this by implementing `(<*>)` in terms of `(>>=)` and "
"`pure`."
msgstr ""
"あらゆる`Monad`は`Applicative`でもあるので、`Monad`は`Applicative`の拡張で"
"す。\n"
"このことを`(<*>)`を`(>>=)`と`pure`を使って実装することで証明してください。"

#. type: Bullet: '3. '
#: ../src/Tutorial/Functor.md:1244
msgid ""
"Implement `(>>=)` in terms of `join` and other functions in the `Monad` "
"hierarchy."
msgstr ""
"`(>>=)`を`join`と`Monad`に階層的に含まれる他の関数を使って実装してください。"

#. type: Bullet: '4. '
#: ../src/Tutorial/Functor.md:1247
msgid ""
"Implement `join` in terms of `(>>=)` and other functions in the `Monad` "
"hierarchy."
msgstr ""
"`join`を`(>>=)`と`Monad`に階層的に含まれる他の関数を使って実装してください。"

#. type: Bullet: '5. '
#: ../src/Tutorial/Functor.md:1250
msgid "There is no lawful `Monad` implementation for `Validated e`.  Why?"
msgstr ""
"`Validated e`への合法な`Monad`実装はありません。\n"
"なぜですか？"

#. type: Bullet: '6. '
#: ../src/Tutorial/Functor.md:1256
msgid ""
"In this slightly extended exercise, we are going to simulate CRUD operations "
"on a data store. We will use a mutable reference (imported from `Data.IORef` "
"from the *base* library)  holding a list of `User`s paired with a unique ID "
"of type `Nat` as our user data base:"
msgstr ""
"この若干発展的な演習では、データ保管所でのCRUD操作を模擬していきます。\n"
"可変参照（*base*ライブラリの`Data.IORef`からインポートされます）を使い、\n"
"利用者データベースとして`User`とこれに紐付く一意の`Nat`型のIDのリストを保持し"
"ます。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:1257
#, no-wrap
msgid ""
"   DB : Type\n"
"   DB = IORef (List (Nat,User))\n"
msgstr ""
"   DB : Type\n"
"   DB = IORef (List (Nat,User))\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1267
#, no-wrap
msgid ""
"   Most operations on a database come with a risk of failure:\n"
"   When we try to update or delete a user, the entry in question\n"
"   might no longer be there. When we add a new user, a user\n"
"   with the given email address might already exist. Here is\n"
"   a custom error type to deal with this:\n"
msgstr ""
"  データベース上のほとんどの操作は失敗する危険性が付いて回ります。\n"
"  利用者を更新したり削除したりしようとするときには、\n"
"  対象のエントリがもはやそこにいないかもしれません。\n"
"  新しい利用者を加える際、与えられたEmailアドレスを持つ利用者が既に存在するかもしれません。\n"
"  以下がこれを扱う自前のエラー型です。\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:1268
#, no-wrap
msgid ""
"   data DBError : Type where\n"
"     UserExists        : Email -> Nat -> DBError\n"
"     UserNotFound      : Nat -> DBError\n"
"     SizeLimitExceeded : DBError\n"
msgstr ""
"   data DBError : Type where\n"
"     UserExists        : Email -> Nat -> DBError\n"
"     UserNotFound      : Nat -> DBError\n"
"     SizeLimitExceeded : DBError\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1277
#, no-wrap
msgid ""
"   In general, our functions will therefore have a\n"
"   type similar to the following:\n"
msgstr "  したがって一般にここでの関数は以下のような型を持ちます。\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:1278
#, no-wrap
msgid "   someDBProg : arg1 -> arg2 -> DB -> IO (Either DBError a)\n"
msgstr "   someDBProg : arg1 -> arg2 -> DB -> IO (Either DBError a)\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1284
#, no-wrap
msgid ""
"   We'd like to abstract over this, by introducing a new wrapper\n"
"   type:\n"
msgstr "  新しい梱包型を導入することで、これを抽象化したいと思います。\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:1285
#, no-wrap
msgid ""
"   record Prog a where\n"
"     constructor MkProg\n"
"     runProg : DB -> IO (Either DBError a)\n"
msgstr ""
"   record Prog a where\n"
"     constructor MkProg\n"
"     runProg : DB -> IO (Either DBError a)\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1294
#, no-wrap
msgid ""
"   We are now ready to write us some utility functions. Make sure\n"
"   to follow the following business rules when implementing the\n"
"   functions below:\n"
msgstr ""
"  これでいくつかの小間物関数を書く準備ができました。\n"
"  以下の関数を実装するときには次の取り決めにしたがうようにしてください。\n"

#. type: Bullet: '   * '
#: ../src/Tutorial/Functor.md:1297
msgid ""
"Email addresses in the DB must be unique. (Consider implementing `Eq Email` "
"to verify this)."
msgstr ""
"DB中のEmailアドレスは一意でなくてはならない。\n"
"（これを検証するために`Eq Email`を実装することを検討してください。）"

#. type: Bullet: '   * '
#: ../src/Tutorial/Functor.md:1299
msgid "The size limit of 1000 entries must not be exceeded."
msgstr "上限1000項目の大きさを超過してはいけない。"

#. type: Bullet: '   * '
#: ../src/Tutorial/Functor.md:1303
msgid ""
"Operations trying to lookup a user by their ID must fail with `UserNotFound` "
"in case no entry was found in the DB."
msgstr ""
"利用者をIDで見付けだそうとする操作は、DBに項目が見付からなかった場合は"
"`UserNotFound`で失敗しなければいけない。"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1308
#, no-wrap
msgid ""
"   You'll need the following functions from `Data.IORef` when working\n"
"   with mutable references: `newIORef`, `readIORef`, and `writeIORef`.\n"
"   In addition, functions `Data.List.lookup` and `Data.List.find` might\n"
"   be useful to implement some of the functions below.\n"
msgstr ""
"  可変参照を扱う際は`Data.IORef`の次の関数が必要になるでしょう。\n"
"  すなわち、`newIORef`、`readIORef`、そして`writeIORef`です。\n"
"  加えて関数`Data.List.lookup`と`Data.List.find`は以降の関数を実装するのに便利なことなことがあります。\n"

#. type: Bullet: '   1. '
#: ../src/Tutorial/Functor.md:1310
msgid "Implement interfaces `Functor`, `Applicative`, and `Monad` for `Prog`."
msgstr ""
"インターフェース`Functor`、`Applicative`、`Monad`を`Prog`に実装してください。"

#. type: Bullet: '   2. '
#: ../src/Tutorial/Functor.md:1312
msgid "Implement interface `HasIO` for `Prog`."
msgstr "インターフェース`HasIO`を`Prog`に実装してください。"

#. type: Bullet: '   3. '
#: ../src/Tutorial/Functor.md:1314
msgid "Implement the following utility functions:"
msgstr "以下の小間物関数を実装してください。"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1317
#, no-wrap
msgid ""
"      ```idris\n"
"      throw : DBError -> Prog a\n"
msgstr ""
"      ```idris\n"
"      throw : DBError -> Prog a\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1319
#, no-wrap
msgid "      getUsers : Prog (List (Nat,User))\n"
msgstr "      getUsers : Prog (List (Nat,User))\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1322
#, no-wrap
msgid ""
"      -- check the size limit!\n"
"      putUsers : List (Nat,User) -> Prog ()\n"
msgstr ""
"      -- 項目数の上限を検査してください！\n"
"      putUsers : List (Nat,User) -> Prog ()\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1326
#, no-wrap
msgid ""
"      -- implement this in terms of `getUsers` and `putUsers`\n"
"      modifyDB : (List (Nat,User) -> List (Nat,User)) -> Prog ()\n"
"      ```\n"
msgstr ""
"      -- `getUsers`と`putUsers`を使って実装してください。\n"
"      modifyDB : (List (Nat,User) -> List (Nat,User)) -> Prog ()\n"
"      ```\n"

#. type: Bullet: '   4. '
#: ../src/Tutorial/Functor.md:1330
msgid ""
"Implement function `lookupUser`. This should fail with an appropriate error, "
"if a user with the given ID cannot be found."
msgstr ""
"関数`lookupUser`を実装してください。\n"
"この関数は与えられたIDに紐付く利用者が見付からなかったときは適切なエラーで失"
"敗します。"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1334
#, no-wrap
msgid ""
"      ```idris\n"
"      lookupUser : (id : Nat) -> Prog User\n"
"      ```\n"
msgstr ""
"      ```idris\n"
"      lookupUser : (id : Nat) -> Prog User\n"
"      ```\n"

#. type: Bullet: '   5. '
#: ../src/Tutorial/Functor.md:1339
msgid ""
"Implement function `deleteUser`. This should fail with an appropriate error, "
"if a user with the given ID cannot be found. Make use of `lookupUser` in "
"your implementation."
msgstr ""
"関数`deleteUser`を実装してください。\n"
"この関数は与えられたIDに紐付く利用者が見付からなかったときは適切なエラーで失"
"敗します。\n"
"実装では`lookupUser`を使ってください。"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1343
#, no-wrap
msgid ""
"      ```idris\n"
"      deleteUser : (id : Nat) -> Prog ()\n"
"      ```\n"
msgstr ""
"      ```idris\n"
"      deleteUser : (id : Nat) -> Prog ()\n"
"      ```\n"

#. type: Bullet: '   6. '
#: ../src/Tutorial/Functor.md:1349
msgid ""
"Implement function `addUser`. This should fail, if a user with the given "
"`Email` already exists, or if the data banks size limit of 1000 entries is "
"exceeded.  In addition, this should create and return a unique ID for the "
"new user entry."
msgstr ""
"関数`addUser`を実装してください。\n"
"与えられた`Email`に紐付く利用者が既に存在していたり、\n"
"データバンクの項目数上限である1000項目を超過したりした場合は、この関数は失敗"
"します。\n"
"加えてこの関数は新しい利用者の項目についての一意なIDを作って返します。"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1353
#, no-wrap
msgid ""
"      ```idris\n"
"      addUser : (new : User) -> Prog Nat\n"
"      ```\n"
msgstr ""
"      ```idris\n"
"      addUser : (new : User) -> Prog Nat\n"
"      ```\n"

#. type: Bullet: '   7. '
#: ../src/Tutorial/Functor.md:1358
msgid ""
"Implement function `updateUser`. This should fail, if the user in question "
"cannot be found or a user with the updated user's `Email` already exists.  "
"The returned value should be the updated user."
msgstr ""
"関数`updateUser`を実装してください。\n"
"問題の利用者が見付からなかったり更新された利用者の`Email`が既に存在している場"
"合は失敗します。\n"
"返値は更新された利用者です。"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1362
#, no-wrap
msgid ""
"      ```idris\n"
"      updateUser : (id : Nat) -> (mod : User -> User) -> Prog User\n"
"      ```\n"
msgstr ""
"      ```idris\n"
"      updateUser : (id : Nat) -> (mod : User -> User) -> Prog User\n"
"      ```\n"

#. type: Bullet: '   8. '
#: ../src/Tutorial/Functor.md:1366
msgid ""
"Data type `Prog` is actually too specific. We could just as well abstract "
"over the error type and the `DB` environment:"
msgstr ""
"実はデータ型`Prog`は限定的すぎます。\n"
"エラー型と`DB`環境を抽象化することができます。"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1372
#, fuzzy, no-wrap
#| msgid ""
#| "      ```idris\n"
#| "      record Prog' env err a where\n"
#| "        constructor MkProg\n"
#| "        runProg' : env -> IO (Either err a)\n"
#| "      ```\n"
msgid ""
"      ```idris\n"
"      record Prog' env err a where\n"
"        constructor MkProg'\n"
"        runProg' : env -> IO (Either err a)\n"
"      ```\n"
msgstr ""
"      ```idris\n"
"      record Prog' env err a where\n"
"        constructor MkProg\n"
"        runProg' : env -> IO (Either err a)\n"
"      ```\n"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1378
#, no-wrap
msgid ""
"      Verify, that all interface implementations you wrote\n"
"      for `Prog` can be used verbatim to implement the same\n"
"      interfaces for `Prog' env err`. The same goes for\n"
"      `throw` with only a slight adjustment in the function's\n"
"      type.\n"
msgstr ""
"      `Prog`に書いた全てのインターフェースの実装が、\n"
"      そのまま`Prog' env err`への同じインターフェースを実装するのに使えることを確認してください。\n"
"      関数の型に僅かに調整が必要ですが、それ以外は`throw`についても同じことが言えます。\n"

#. type: Title ##
#: ../src/Tutorial/Functor.md:1379
#, no-wrap
msgid "Background and further Reading"
msgstr "背景とさらなる文献"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1388
msgid ""
"Concepts like *functor* and *monad* have their origin in *category theory*, "
"a branch of mathematics. That is also where their laws come from.  Category "
"theory was found to have applications in programming language theory, "
"especially functional programming.  It is a highly abstract topic, but there "
"is a pretty accessible introduction for programmers, written by [Bartosz "
"Milewski](https://bartoszmilewski.com/2014/10/28/category-theory-for-"
"programmers-the-preface/)."
msgstr ""
"*関手*や*モナド*といった概念は数学の一分野である*圏論*に起源があります。\n"
"それぞれの法則が来ているのもそこからです。\n"
"圏論はプログラミング言語理論への応用が発見されていますが、特に関数型言語で顕"
"著です。\n"
"高度に抽象的な話題ですが、[Bartosz Milewski](https://bartoszmilewski."
"com/2014/10/28/category-theory-for-programmers-the-preface/)によって書かれた"
"プログラマにとってかなり手を出しやすい導入があります。"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1394
msgid ""
"The usefulness of applicative functors as a middle ground between functor "
"and monad was discovered several years after monads had already been in use "
"in Haskell. They where introduced in the article [*Applicative Programming "
"with Effects*](https://www.staff.city.ac.uk/~ross/papers/Applicative.html), "
"which is freely available online and a highly recommended read."
msgstr ""
"関手とモナドの中間地点としてのアプリカティブ関手の実用性は、\n"
"Haskellで既にモナドが使われるようになってから数年後に発見されました。\n"
"こちらは記事[*作用つきアプリカティブプログラミング* (Applicative Programming "
"with Effects)](https://www.staff.city.ac.uk/~ross/papers/Applicative.html)で"
"紹介されています。\n"
"オンラインで自由に見ることができ、読まれることを強くお勧めします。"

#. type: Bullet: '* '
#: ../src/Tutorial/Functor.md:1401
msgid ""
"Interfaces `Functor`, `Applicative`, and `Monad` abstract over programming "
"patterns that come up when working with type constructors of type `Type -> "
"Type`. Such data types are also referred to as *values in a context*, or "
"*effectful computations*."
msgstr ""
"インターフェース`Functor`、`Applicative`、そして`Monad`は、\n"
"型`Type -> Type`の型構築子を扱うときに引き合いに出されるプログラミング様式を"
"抽象化します。\n"
"そのようなデータ型は*文脈付きの値*や*作用付き計算*としても参照されます。"

#. type: Bullet: '* '
#: ../src/Tutorial/Functor.md:1404
msgid ""
"`Functor` allows us to *map* over values in a context without affecting the "
"context's underlying structure."
msgstr ""
"`Functor`があれば、文脈に土台の構造に影響することなく、文脈中の値を*写す*こと"
"ができます。"

#. type: Bullet: '* '
#: ../src/Tutorial/Functor.md:1407
msgid ""
"`Applicative` allows us to apply n-ary functions to n effectful computations "
"and to lift pure values into a context."
msgstr ""
"`Applicative`があれば、\n"
"n個の作用付き計算にn引数関数を適用したり、純粋な値を文脈に持ち上げたりするこ"
"とができます。"

#. type: Bullet: '* '
#: ../src/Tutorial/Functor.md:1411
msgid ""
"`Monad` allows us to chain effectful computations, where the intermediary "
"results can affect, which computation to run further down the chain."
msgstr ""
"`Monad`があれば作用付き計算を連鎖させることができます。\n"
"この連鎖では中間結果がその後どの計算を走らせるかに影響させられます。"

#. type: Bullet: '* '
#: ../src/Tutorial/Functor.md:1415
msgid ""
"Unlike `Monad`, `Functor` and `Applicative` compose: The product and "
"composition of two functors or applicatives are again functors or "
"applicatives, respectively."
msgstr ""
"`Monad`とは異なり、`Functor`と`Applicative`は組み合わさります。\n"
"2つの関手やアプリカティブの積や合成はこれまたそれぞれ関手やアプリカティブとな"
"ります。"

#. type: Bullet: '* '
#: ../src/Tutorial/Functor.md:1419
msgid ""
"Idris provides syntactic sugar for working with some of the interfaces "
"presented here: Idiom brackets for `Applicative`, *do blocks* and the bang "
"operator for `Monad`."
msgstr ""
"Idrisはここで提示したインターフェースのいくつかについて扱うための糖衣構文を提"
"供します。\n"
"`Applicative`の慣用括弧や*do記法*、そして`Monad`のびっくり演算子です。"

#. type: Title ###
#: ../src/Tutorial/Functor.md:1420 ../src/Tutorial/Intro.md:430
#, no-wrap
msgid "What's next?"
msgstr "お次は？"

#. type: Plain text
#: ../src/Tutorial/Functor.md:1425
msgid ""
"In the [next chapter](Folds.md) we get to learn more about recursion, "
"totality checking, and an interface for collapsing container types: "
"`Foldable`."
msgstr ""
"[次章](Folds.md)では再帰、全域性検査、\n"
"そして容器型を折り畳むインターフェースである`Foldable`について学び始めます。"

#. type: Title #
#: ../src/Tutorial/IO.md:1
#, no-wrap
msgid "IO: Programming with Side Effects"
msgstr "IO: 副作用のあるプログラミング"

#. type: Plain text
#: ../src/Tutorial/IO.md:7
msgid ""
"So far, all our examples and exercises dealt with pure, total functions.  We "
"didn't read or write content from or to files, nor did we write any messages "
"to the standard output. It is time to change that and learn, how we can "
"write effectful programs in Idris."
msgstr ""
"ここまでの全ての例や演習で、純粋で全域な関数を扱ってきました。\n"
"ファイルから内容を読んだり書き込んだり、\n"
"標準出力に文言を書き込んだりするようなことはしてきませんでした。\n"
"今こそ流れを変え、副作用のあるプログラムをIdrisで書く方法を学ぶときです。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/IO.md:8
#, no-wrap
msgid ""
"module Tutorial.IO\n"
"\n"
"import Data.List1\n"
"import Data.String\n"
"import Data.Vect\n"
"\n"
"import System.File\n"
"\n"
"%default total\n"
msgstr ""
"module Tutorial.IO\n"
"\n"
"import Data.List1\n"
"import Data.String\n"
"import Data.Vect\n"
"\n"
"import System.File\n"
"\n"
"%default total\n"

#. type: Title ##
#: ../src/Tutorial/IO.md:20
#, no-wrap
msgid "Pure Side Effects?"
msgstr "純粋な副作用？"

#. type: Plain text
#: ../src/Tutorial/IO.md:24
msgid ""
"If we once again look at the *hello world* example from the [introduction]"
"(Intro.md), it had the following type and implementation:"
msgstr ""
"[導入](Intro.md)の*hello world*の例をもう一度見ると、以下の型と実装がありまし"
"た。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/IO.md:25
#, no-wrap
msgid ""
"hello : IO ()\n"
"hello = putStrLn \"Hello World!\"\n"
msgstr ""
"hello : IO ()\n"
"hello = putStrLn \"Hello World!\"\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:32
msgid ""
"If you load this module in a REPL session and evaluate `hello`, you'll get "
"the following:"
msgstr ""
"このモジュールをREPLセッションに読み込んで`hello`を評価すると、以下が得られる"
"でしょう。"

#. type: Fenced code block (repl)
#: ../src/Tutorial/IO.md:33
#, no-wrap
msgid ""
"Tutorial.IO> hello\n"
"MkIO (prim__putStr \"Hello World!\")\n"
msgstr ""
"Tutorial.IO> hello\n"
"MkIO (prim__putStr \"Hello World!\")\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:41
msgid ""
"This might not be what you expected, given that we'd actually wanted the "
"program to just print \"Hello World!\". In order to explain what's going on "
"here, we need to quickly look at how evaluation at the REPL works."
msgstr ""
"実際にはプログラムに単に \"Hello World!\" を印字してほしかったとしたら、\n"
"この振舞いは期待したものではないでしょう。\n"
"ここで起こっていることを説明するためには、\n"
"REPLでどのように評価が行われるのかを軽く知っておかねばなりません。"

#. type: Plain text
#: ../src/Tutorial/IO.md:51
msgid ""
"When we evaluate some expression at the REPL, Idris tries to reduce it to a "
"value until it gets stuck somewhere. In the above case, Idris gets stuck at "
"function `prim__putStr`. This is a *foreign function* defined in the "
"*Prelude*, which has to be implemented by each backend in order to be "
"available there. At compile time (and at the REPL), Idris knows nothing "
"about the implementations of foreign functions and therefore can't reduce "
"foreign function calls, unless they are built into the compiler itself. But "
"even then, values of type `IO a` (`a` being a type parameter) are typically "
"not reduced."
msgstr ""
"REPLで何らかの式を評価するとき、Idrisは行き着くところまで値に簡略しようとしま"
"す。\n"
"上の場合、Idrisは関数`prim__putStr`で立ち止まります。\n"
"これは*Prelude*で定義された*異邦関数*であり、\n"
"それぞれのバックエンドで実装されることで使えるようになるものです。\n"
"コンパイル時（そしてREPL時）は、Idrisは異邦関数の実装について何も知らず、\n"
"したがってコンパイラ自身に組込まれていない限り異邦関数を簡略することはできま"
"せん。\n"
"なので型`IO a`（`a`は型変数）の値も同様に大抵は簡略できないのです。"

#. type: Plain text
#: ../src/Tutorial/IO.md:61
#, no-wrap
msgid ""
"It is important to understand that values of type `IO a` *describe*\n"
"a program, which, when being *executed*, will return a value of type `a`,\n"
"after performing arbitrary side effects along the way. For instance,\n"
"`putStrLn` has type `String -> IO ()`. Read this as: \"`putStrLn` is a function,\n"
"which, when given a `String` argument, will return a description of\n"
"an effectful program with an output type of `()`\".\n"
"(`()` is syntactic sugar for type `Unit`, the\n"
"empty tuple defined at the *Prelude*, which has only one value called `MkUnit`,\n"
"for which we can also use `()` in our code.)\n"
msgstr ""
"型`IO a`の値はプログラムを*記述*している、ということを理解することは大事です。\n"
"これは*実行*されると型`a`の値を返しますが、その道すがら任意の副作用を生じてからなのです。\n"
"例えば`putStrLn`は型`String -> IO ()`です。\n"
"読み下すとすればこうです。\n"
"「`putStrLn`は関数で、`String`引数を与えられると、\n"
"出力型が`()`の副作用付きのプログラムの記述を返す。」\n"
"（`()`は型`Unit`の糖衣構文で、*Prelude*で定義されている空タプルです。\n"
"`Unit`には唯一`MkUnit`という名前の値があり、コードでも`()`を使えるのです。）\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:72
#, no-wrap
msgid ""
"Since values of type `IO a` are mere descriptions of effectful computations,\n"
"functions returning such values or taking such values as\n"
"arguments are still *pure* and thus referentially transparent.\n"
"It is, however, not possible to extract a value of type `a` from\n"
"a value of type `IO a`, that is, there is no generic function `IO a -> a`,\n"
"as such a function would inadvertently execute the side\n"
"effects when extracting the result from its argument,\n"
"thus breaking referential transparency.\n"
"(Actually, there *is* such a function called `unsafePerformIO`.\n"
"Do not ever use it in your code unless you know what you are doing.)\n"
msgstr ""
"型`IO a`の値は作用付き計算の記述に過ぎないことから、\n"
"そのような値を返したり引数として値を取ったりする関数はそれでもなお*純粋*で、つまりは参照透過なのです。\n"
"しかしながら、型`a`の値を型`IO a`の値から抽出することは不可能です。\n"
"というのは、汎化関数`IO a -> a`は存在しないということですが、\n"
"これは関数が引数から結果を抽出するときにうっかり副作用を実行するであろうからで、\n"
"つまりは参照透過性を破っているのです。\n"
"（実は`unsafePerformIO`という名前の関数が*あります*。\n"
"何をするものかわかっていない限り、決してコードで使わないでください。）\n"

#. type: Title ###
#: ../src/Tutorial/IO.md:73
#, no-wrap
msgid "Do Blocks"
msgstr "doブロック"

#. type: Plain text
#: ../src/Tutorial/IO.md:83
#, no-wrap
msgid ""
"If you are new to pure functional programming, you might now - rightfully -\n"
"mumble something about how useless it is to\n"
"have descriptions of effectful programs without being able to run them.\n"
"So please, hear me out. While we are not able to run values of type\n"
"`IO a` when writing programs, that is, there is no function of\n"
"type `IO a -> a`, we are able to chain such computations and describe more\n"
"complex programs. Idris provides special syntax for this: *Do blocks*.\n"
"Here's an example:\n"
msgstr ""
"純粋関数型プログラミングを始めたてだったら、\n"
"今頃恐らく、というかきっと、実行できない作用付きプログラムのの記述の役立たなさを愚痴っているかもしれません。\n"
"まあ、聞いてください。\n"
"型`IO a`の値を実行することはできない、\n"
"つまり型`IO a -> a`の関数はどこにもありませんが、\n"
"こうした計算を連鎖させてより複雑なプログラムを記述できます。\n"
"Idrisはこのための特別な文法、*doブロック*を提供しています。\n"
"以下は例です。\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/IO.md:84
#, no-wrap
msgid ""
"readHello : IO ()\n"
"readHello = do\n"
"  name <- getLine\n"
"  putStrLn $ \"Hello \" ++ name ++ \"!\"\n"
msgstr ""
"readHello : IO ()\n"
"readHello = do\n"
"  name <- getLine\n"
"  putStrLn $ \"Hello \" ++ name ++ \"!\"\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:93
msgid ""
"Before we talk about what's going on here, let's give this a go at the REPL:"
msgstr "何が起こっているのかをお話しする前に、REPLでやってみましょう。"

#. type: Fenced code block (repl)
#: ../src/Tutorial/IO.md:94
#, no-wrap
msgid ""
"Tutorial.IO> :exec readHello\n"
"Stefan\n"
"Hello Stefan!\n"
msgstr ""
"Tutorial.IO> :exec readHello\n"
"Stefan\n"
"Hello Stefan!\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:104
msgid ""
"This is an interactive program, which will read a line from standard input "
"(`getLine`), assign the result to variable `name`, and then use `name` to "
"create a friendly greeting and write it to standard output."
msgstr ""
"これは対話的プログラムであり、標準入力から1行読んで (`getLine`)、\n"
"結果を変数`name`に代入し、\n"
"そうして`name`を使って気さくな挨拶文をつくって標準出力に書き込みます。"

#. type: Plain text
#: ../src/Tutorial/IO.md:114
#, no-wrap
msgid ""
"Note the `do` keyword at the beginning of the implementation of `readHello`:\n"
"It starts a *do block*, where we can chain `IO` computations and bind\n"
"intermediary results to variables using arrows pointing\n"
"to the left (`<-`), which can then be used in later\n"
"`IO` actions. This concept is powerful enough to let us encapsulate arbitrary\n"
"programs with side effects in a single value of type `IO`. Such a\n"
"description can then be returned by function `main`, the main entry point\n"
"to an Idris program, which is being executed when we run a compiled\n"
"Idris binary.\n"
msgstr ""
"`readHello`の実装の初めにある`do`キーワードに注目してください。\n"
"このキーワードから*doブロック*が始まり、\n"
"ここでは`IO`計算を連鎖できたり、\n"
"左向きの矢印 (`<-`) を使って中間結果を変数に束縛し、あとの`IO`行動で使えるようにできたりします。\n"
"型`IO`の値1つに副作用付きの任意のプログラムを内蔵化できるほどこの概念は強力です。\n"
"このような表現はそれから関数`main`から返されます。\n"
"`main`はIdrisプログラムへの主な入口で、コンパイルされたIdrisバイナリを走らせるときに実行されます。\n"

#. type: Title ###
#: ../src/Tutorial/IO.md:115
#, no-wrap
msgid "The Difference between Program Description and Execution"
msgstr "プログラム記述と実行の違い"

#. type: Plain text
#: ../src/Tutorial/IO.md:120
msgid ""
"In order to better understand the difference between *describing* an "
"effectful computation and *executing* or *running* it, here is a small "
"program:"
msgstr ""
"作用のある計算を*記述*することと、*実行し*たり*走らせ*たりすること、この違い"
"をよりよく理解するために、\n"
"以下の小さなプラグラムを見てみましょう。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/IO.md:121
#, no-wrap
msgid ""
"launchMissiles : IO ()\n"
"launchMissiles = putStrLn \"Boom! You're dead.\"\n"
"\n"
"friendlyReadHello : IO ()\n"
"friendlyReadHello = do\n"
"  _ <- putStrLn \"Please enter your name.\"\n"
"  readHello\n"
"\n"
"actions : Vect 3 (IO ())\n"
"actions = [launchMissiles, friendlyReadHello, friendlyReadHello]\n"
"\n"
"runActions : Vect (S n) (IO ()) -> IO ()\n"
"runActions (_ :: xs) = go xs\n"
"  where go : Vect k (IO ()) -> IO ()\n"
"        go []        = pure ()\n"
"        go (y :: ys) = do\n"
"          _ <- y\n"
"          go ys\n"
"\n"
"readHellos : IO ()\n"
"readHellos = runActions actions\n"
msgstr ""
"launchMissiles : IO ()\n"
"launchMissiles = putStrLn \"Boom! You're dead.\"\n"
"\n"
"friendlyReadHello : IO ()\n"
"friendlyReadHello = do\n"
"  _ <- putStrLn \"Please enter your name.\"\n"
"  readHello\n"
"\n"
"actions : Vect 3 (IO ())\n"
"actions = [launchMissiles, friendlyReadHello, friendlyReadHello]\n"
"\n"
"runActions : Vect (S n) (IO ()) -> IO ()\n"
"runActions (_ :: xs) = go xs\n"
"  where go : Vect k (IO ()) -> IO ()\n"
"        go []        = pure ()\n"
"        go (y :: ys) = do\n"
"          _ <- y\n"
"          go ys\n"
"\n"
"readHellos : IO ()\n"
"readHellos = runActions actions\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:153
#, no-wrap
msgid ""
"Before I explain what the code above does, please note function\n"
"`pure` used in the implementation of `runActions`. It is\n"
"a constrained function, about which we will learn in the next\n"
"chapter. Specialized to `IO`, it has generic type `a -> IO a`:\n"
"It allows us to wrap a value in an `IO` action. The resulting\n"
"`IO` program will just return the wrapped value without performing\n"
"any side effects. We can now look at the big picture of what's\n"
"going on in `readHellos`.\n"
msgstr ""
"上のコードが何をするのかを説明する前に、\n"
"`runActions`の実装で使われている関数`pure`を見てください。\n"
"これは制約付き関数ですが、これについては次の章で学びましょう。\n"
"`IO`に特化すれば汎化型`a -> IO a`です。\n"
"つまり値を`IO`行動に包むことができます。\n"
"`IO`プログラムの結果は副作用を生じることなく単に包まれた値を返します。\n"
"これで`readHellos`で何が起こっているのかを大局的に眺められます。\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:160
msgid ""
"First, we define a friendlier version of `readHello`: When executed, this "
"will ask about our name explicitly. Since we will not use the result of "
"`putStrLn` any further, we can use an underscore as a catch-all pattern "
"here. Afterwards, `readHello` is invoked. We also define `launchMissiles`, "
"which, when being executed, will lead to the destruction of planet earth."
msgstr ""
"まず、`readHello`のよりやさしい版を定義します。\n"
"実行されると名前をはっきりと尋ねます。\n"
"`putStrLn`の結果をこれ以上使うことがないので、全て堰き止めるパターンとしての"
"下線文字をここで使えます。\n"
"そのあとで`readHello`が呼び出されます。\n"
"`launchMissiles`も定義します。\n"
"これが実行されると惑星地球が破壊されてしまいます。"

#. type: Plain text
#: ../src/Tutorial/IO.md:169
msgid ""
"Now, `runActions` is the function we use to demonstrate that *describing* an "
"`IO` action is not the same as *running* it. It will drop the first action "
"from the non-empty vector it takes as its argument and return a new `IO` "
"action, which describes the execution of the remaining `IO` actions in "
"sequence. If this behaves as expected, the first `IO` action passed to "
"`runActions` should be silently dropped together with all its potential side "
"effects."
msgstr ""
"さて、`runActions`は`IO`行動を*記述する*ことが*走らせる*ことと同じではないこ"
"とを実演する関数です。\n"
"これは引数として取る非空ベクタから最初の行動を切り落として新しい`IO`行動を返"
"します。\n"
"返される行動は残りの`IO`行動を順番に実行する記述です。\n"
"もしこれが期待通りに振る舞うとしたら、\n"
"`runActions`に渡された最初の`IO`行動はあらゆる潜在的な副作用とともに黙殺され"
"ます。"

#. type: Plain text
#: ../src/Tutorial/IO.md:174
msgid ""
"When we execute `readHellos` at the REPL, we will be asked for our name "
"twice, although `actions` also contains `launchMissiles` at the beginning. "
"Luckily, although we described how to destroy the planet, the action was not "
"executed, and we are (probably) still here."
msgstr ""
"REPLで`readHellos`を実行すると、\n"
"`actions`は最初に`launchMissiles`も含んでいますが、名前を2回尋ねられます。\n"
"惑星を破壊する方法を記述したものの、\n"
"運よくその行動は実行されず、そして私達は（たぶん）まだここに立っています。"

#. type: Plain text
#: ../src/Tutorial/IO.md:176
msgid "From this example we learn several things:"
msgstr "この例からいくつかのことを学びました。"

#. type: Bullet: '* '
#: ../src/Tutorial/IO.md:180
msgid ""
"Values of type `IO a` are *pure descriptions* of programs, which, when being "
"*executed*, perform arbitrary side effects before returning a value of type "
"`a`."
msgstr ""
"型`IO a`の値はプログラムの*純粋記述*です。\n"
"この記述が*実行*されると型`a`の値を返す前にありとあらゆる副作用を生じます。"

#. type: Bullet: '* '
#: ../src/Tutorial/IO.md:184
msgid ""
"Values of type `IO a` can be safely returned from functions and passed "
"around as arguments or in data structures, without the risk of them being "
"executed."
msgstr ""
"型`IO a`の値は安全に関数から返したり引数やデータ構造に入れて受け渡したりでき"
"ます。\n"
"実行される惧れはありません。"

#. type: Bullet: '* '
#: ../src/Tutorial/IO.md:187
msgid ""
"Values of type `IO a` can be safely combined in *do blocks* to *describe* "
"new `IO` actions."
msgstr "型`IO a`の値は*doブロック*で安全に新しい`IO`行動に結合できます。"

#. type: Bullet: '* '
#: ../src/Tutorial/IO.md:191
msgid ""
"An `IO` action will only ever get executed when it's passed to `:exec` at "
"the REPL, or when it is the `main` function of a compiled Idris program that "
"is being executed."
msgstr ""
"`IO`行動は、REPLで`:exec`に渡されたり、\n"
"コンパイルされたIdrisプログラムの`main`関数から実行されるものであったりすると"
"きにのみ実行されます。"

#. type: Bullet: '* '
#: ../src/Tutorial/IO.md:196
msgid ""
"It is not possible to ever break out of the `IO` context: There is no "
"function of type `IO a -> a`, as such a function would need to execute its "
"argument in order to extract the final result, and this would break "
"referential transparency."
msgstr ""
"`IO`文脈の殻を破ることは絶対にできません。\n"
"つまり型`IO a -> a`の関数はありませんが、\n"
"それはそうした関数が最終的な結果を抽出するために引数を順番に実行する必要があ"
"り、\n"
"これが参照透過性を破るからです。"

#. type: Title ###
#: ../src/Tutorial/IO.md:197
#, no-wrap
msgid "Combining Pure Code with `IO` Actions"
msgstr "純粋なコードと`IO`行動をくっつける"

#. type: Plain text
#: ../src/Tutorial/IO.md:202
msgid ""
"The title of this subsection is somewhat misleading. `IO` actions *are* pure "
"values, but what is typically meant here, is that we combine non-`IO` "
"functions with effectful computations."
msgstr ""
"この小節の題はどこか誤読を誘うところがあります。\n"
"`IO`行動は純粋な値*です*が、\n"
"ここでの意味は`IO`ではない関数と作用のある計算をくっつけることです。"

#. type: Plain text
#: ../src/Tutorial/IO.md:208
msgid ""
"As a demonstration, in this section we are going to write a small program "
"for evaluating arithmetic expressions. We are going to keep things simple "
"and allow only expressions with a single operator and two arguments, both of "
"which must be integers, for instance `12 + 13`."
msgstr ""
"実演として本節では計算式を評価する小さなプログラムを書いていきます。\n"
"話を簡単にして演算子1つと2つの引数がある式のみ許すことにします。\n"
"引数はどちらも整数でなければならず、例えば`12 + 13`です。"

#. type: Plain text
#: ../src/Tutorial/IO.md:216
msgid ""
"We are going to use function `split` from `Data.String` in *base* to "
"tokenize arithmetic expressions. We are then trying to parse the two integer "
"values and the operator. These operations might fail, since user input can "
"be invalid, so we also need an error type. We could actually just use "
"`String`, but I consider it to be good practice to use custom sum types for "
"erroneous conditions."
msgstr ""
"*base*の`Data.String`由来の関数`split`を使って計算式を字句解析していきま"
"す。\n"
"それから2つの整数値と演算子のパースを試みます。\n"
"利用者の入力は不正かもしれず、これらの操作は失敗するかもしれません。\n"
"そのためエラー型も必要です。\n"
"実のところエラー型には単に`String`を使ってもいいのですが、\n"
"エラーの条件のための自前の直和型を使うことは良い作法だと考えます。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/IO.md:217
#, no-wrap
msgid ""
"data Error : Type where\n"
"  NotAnInteger    : (value : String) -> Error\n"
"  UnknownOperator : (value : String) -> Error\n"
"  ParseError      : (input : String) -> Error\n"
"\n"
"dispError : Error -> String\n"
"dispError (NotAnInteger v)    = \"Not an integer: \" ++ v ++ \".\"\n"
"dispError (UnknownOperator v) = \"Unknown operator: \" ++ v ++ \".\"\n"
"dispError (ParseError v)      = \"Invalid expression: \" ++ v ++ \".\"\n"
msgstr ""
"data Error : Type where\n"
"  NotAnInteger    : (value : String) -> Error\n"
"  UnknownOperator : (value : String) -> Error\n"
"  ParseError      : (input : String) -> Error\n"
"\n"
"dispError : Error -> String\n"
"dispError (NotAnInteger v)    = \"Not an integer: \" ++ v ++ \".\"\n"
"dispError (UnknownOperator v) = \"Unknown operator: \" ++ v ++ \".\"\n"
"dispError (ParseError v)      = \"Invalid expression: \" ++ v ++ \".\"\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:231
msgid ""
"In order to parse integer literals, we use function `parseInteger` from "
"`Data.String`:"
msgstr ""
"整数表記をパースするために`Data.String`の関数`parseInteger`を使います。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/IO.md:232
#, no-wrap
msgid ""
"readInteger : String -> Either Error Integer\n"
"readInteger s = maybe (Left $ NotAnInteger s) Right $ parseInteger s\n"
msgstr ""
"readInteger : String -> Either Error Integer\n"
"readInteger s = maybe (Left $ NotAnInteger s) Right $ parseInteger s\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:239
msgid ""
"Likewise, we declare and implement a function for parsing arithmetic "
"operators:"
msgstr "同様に計算演算子をパースする関数を宣言し実装します。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/IO.md:240
#, no-wrap
msgid ""
"readOperator : String -> Either Error (Integer -> Integer -> Integer)\n"
"readOperator \"+\" = Right (+)\n"
"readOperator \"*\" = Right (*)\n"
"readOperator s   = Left (UnknownOperator s)\n"
msgstr ""
"readOperator : String -> Either Error (Integer -> Integer -> Integer)\n"
"readOperator \"+\" = Right (+)\n"
"readOperator \"*\" = Right (*)\n"
"readOperator s   = Left (UnknownOperator s)\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:254
msgid ""
"We are now ready to parse and evaluate simple arithmetic expressions. This "
"consists of several steps (splitting the input string, parsing each "
"literal), each of which can fail.  Later, when we learn about monads, we "
"will see that do blocks can be used in such occasions just as well. However, "
"in this case we can use an alternative syntactic convenience: Pattern "
"matching in let bindings. Here is the code:"
msgstr ""
"これで簡単な計算式をパースし評価する準備ができました。\n"
"これはいくつかの段階（入力文字列を分割し、それぞれの表記をパースする）からな"
"り、\n"
"それぞれの段階は失敗しうるものです。\n"
"あとでモナドを学んだら、\n"
"doブロックがそうした場合にちょうど同じように使えることを見ていきます。\n"
"しかしこの場合代わりの文法的な便宜を図れます。\n"
"let束縛でパターンマッチするのです。\n"
"以下がコードです。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/IO.md:255
#, no-wrap
msgid ""
"eval : String -> Either Error Integer\n"
"eval s =\n"
"  let [x,y,z]  := forget $ split isSpace s | _ => Left (ParseError s)\n"
"      Right v1 := readInteger x  | Left e => Left e\n"
"      Right op := readOperator y | Left e => Left e\n"
"      Right v2 := readInteger z  | Left e => Left e\n"
"   in Right $ op v1 v2\n"
msgstr ""
"eval : String -> Either Error Integer\n"
"eval s =\n"
"  let [x,y,z]  := forget $ split isSpace s | _ => Left (ParseError s)\n"
"      Right v1 := readInteger x  | Left e => Left e\n"
"      Right op := readOperator y | Left e => Left e\n"
"      Right v2 := readInteger z  | Left e => Left e\n"
"   in Right $ op v1 v2\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:280
msgid ""
"Let's break this down a bit. On the first line, we split the input string at "
"all whitespace occurrences. Since `split` returns a `List1` (a type for non-"
"empty lists exported from `Data.List1` in *base*) but pattern matching on "
"`List` is more convenient, we convert the result using `Data.List1.forget`. "
"Note, how we use a pattern match on the left hand side of the assignment "
"operator `:=`.  This is a partial pattern match (*partial* meaning, that it "
"doesn't cover all possible cases), therefore we have to deal with the other "
"possibilities as well, which is done after the vertical line. This can be "
"read as follows: \"If the pattern match on the left hand side is successful, "
"and we get a list of exactly three tokens, continue with the `let` "
"expression, otherwise return a `ParseError` in a `Left` immediately\"."
msgstr ""
"これを少し解剖しましょう。\n"
"最初の行では入力文字列を全ての空白のある位置で分割します。\n"
"`split`は`List1`（*base*の`Data.List1`から高階されている非空のリスト型）を返"
"しますが、\n"
"`List`でパターン照合するほうがもっと便利なので、\n"
"`Data.List1.forget`を使って結果を変換します。\n"
"ここで代入演算子`:=`の左側でパターン照合を使っていますね。\n"
"これは部分パターン照合（*部分*というのは、全ての可能な場合を網羅していないか"
"らです）なので、\n"
"他の可能性も同様に対処しなければいけません。\n"
"その対処は垂直線のあとで行われます。\n"
"これは次のように読めます。\n"
"「もし左側のパターン照合が成功し、ちょうど3つの字句のリストが得られたら、\n"
"`let`式を続ける。\n"
"そうでなければ直ちに`ParseError`を`Left`に入れて返す。」"

#. type: Plain text
#: ../src/Tutorial/IO.md:286
msgid ""
"The other three lines behave exactly the same: Each has a partial pattern "
"match on the left hand side with instructions what to return in case of "
"invalid input after the vertical bar. We will later see, that this syntax is "
"also available in *do blocks*."
msgstr ""
"他の3行はちょうど同じように振舞います。\n"
"つまり、それぞれに左側に部分パターン照合がありつつ、\n"
"垂直棒のあとに不正な入力の場合に何を返すかという説明があります。\n"
"あとで見ていきますが、この構文は*doブロック*でも使えます。"

#. type: Plain text
#: ../src/Tutorial/IO.md:294
msgid ""
"Note, how all of the functionality implemented so far is *pure*, that is, it "
"does not describe computations with side effects. (One could argue that "
"already the possibility of failure is an observable *effect*, but even then, "
"the code above is still referentially transparent, can be easily tested at "
"the REPL, and evaluated at compile time, which is the important thing here.)"
msgstr ""
"ここで、これまで実装してきた機能の全ては*純粋*で、\n"
"副作用のある計算を記述していません。\n"
"（すでに失敗の可能性は観測できる*作用*だと言い張ることもできますが、\n"
"しかしそうだとしても上のコードはそれでも参照透過で、\n"
"REPLで簡単に試せたりコンパイル時に評価できます。\n"
"ここではこれが大事です。）"

#. type: Plain text
#: ../src/Tutorial/IO.md:298
msgid ""
"Finally, we can wrap this functionality in an `IO` action, which reads a "
"string from standard input and tries to evaluate the arithmetic expression:"
msgstr ""
"ついにこの機能を`IO`行動に包むことができます。\n"
"これは標準入力から文字列を読み取って計算式を評価しようとします。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/IO.md:299
#, no-wrap
msgid ""
"exprProg : IO ()\n"
"exprProg = do\n"
"  s <- getLine\n"
"  case eval s of\n"
"    Left err  => do\n"
"      putStrLn \"An error occured:\"\n"
"      putStrLn (dispError err)\n"
"    Right res => putStrLn (s ++ \" = \" ++ show res)\n"
msgstr ""
"exprProg : IO ()\n"
"exprProg = do\n"
"  s <- getLine\n"
"  case eval s of\n"
"    Left err  => do\n"
"      putStrLn \"An error occured:\"\n"
"      putStrLn (dispError err)\n"
"    Right res => putStrLn (s ++ \" = \" ++ show res)\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:316
msgid ""
"Note, how in `exprProg` we were forced to deal with the possibility of "
"failure and handle both constructors of `Either` differently in order to "
"print a result.  Note also, that *do blocks* are ordinary expressions, and "
"we can, for instance, start a new *do block* on the right hand side of a "
"case expression."
msgstr ""
"`exprProg`で失敗する可能性に対処することを強いられており、\n"
"結果を表示するために`Either`の両方の構築子をそれぞれ扱っていますよね。\n"
"あと、*doブロック*は普通の式なので、\n"
"例えばcase式の右側で新しい*doブロック*を始められますよ。"

#. type: Plain text
#: ../src/Tutorial/IO.md:329
msgid ""
"In these exercises, you are going to implement some small command-line "
"applications. Some of these will potentially run forever, as they will only "
"stop when the user enters a keyword for quitting the application. Such "
"programs are no longer provably total. If you added the `%default total` "
"pragma at the top of your source file, you'll need to annotate these "
"functions with `covering`, meaning that you covered all cases in all pattern "
"matches but your program might still loop due to unrestricted recursion."
msgstr ""
"この演習では小さなコマンドラインアプリケーションを実装していきます。\n"
"いくつかのものはアプリケーションを終了するためにキーワードを入力したときだけ"
"止まるものなので、\n"
"潜在的に永久に実行されます。\n"
"そうしたプログラムはもはや全域であることは証明されません。\n"
"ソースファイルの冒頭に`%default total`プラグマを加えていたら、\n"
"これらの関数を`covering`で註釈する必要があります。\n"
"これは全てのパターン照合の全ての場合を網羅できているものの、\n"
"制約のない再帰によりプログラムが堂々巡りになるかもしれないことを意味します。"

#. type: Bullet: '1. '
#: ../src/Tutorial/IO.md:333
msgid ""
"Implement function `rep`, which will read a line of input from the terminal, "
"evaluate it using the given function, and print the result to standard "
"output:"
msgstr ""
"関数`rep`を実装してください。\n"
"これは端末からの入力のうち1行を読み、与えられた関数を使って評価し、\n"
"そして標準出力に結果を印字します。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/IO.md:334
#, no-wrap
msgid "   rep : (String -> String) -> IO ()\n"
msgstr "   rep : (String -> String) -> IO ()\n"

#. type: Bullet: '2. '
#: ../src/Tutorial/IO.md:341
msgid ""
"Implement function `repl`, which behaves just like `rep` but will repeat "
"itself forever (or until being forcefully terminated):"
msgstr ""
"関数`repl`を実装してください。\n"
"これは`rep`のように振舞いますが、\n"
"（強制的に終了されるまで）永遠に関数自身を繰り返します。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/IO.md:342
#, no-wrap
msgid ""
"   covering\n"
"   repl : (String -> String) -> IO ()\n"
msgstr ""
"   covering\n"
"   repl : (String -> String) -> IO ()\n"

#. type: Bullet: '3. '
#: ../src/Tutorial/IO.md:351
msgid ""
"Implement function `replTill`, which behaves just like `repl` but will only "
"continue looping if the given function returns a `Right`. If it returns a "
"`Left`, `replTill` should print the final message wrapped in the `Left` and "
"then stop."
msgstr ""
"関数`replTill`を実装してください。\n"
"これはちょうど`repl`のように振舞いますが、\n"
"与えられた関数が`Right`を返したときだけ繰り返すのを続けます。\n"
"`Left`を返したら`replTill`は`Left`に包まれた最後の文言で印字し、それから停止"
"します。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/IO.md:352
#, no-wrap
msgid ""
"   covering\n"
"   replTill : (String -> Either String String) -> IO ()\n"
msgstr ""
"   covering\n"
"   replTill : (String -> Either String String) -> IO ()\n"

#. type: Bullet: '4. '
#: ../src/Tutorial/IO.md:364
msgid ""
"Write a program, which reads arithmetic expressions from standard input, "
"evaluates them using `eval`, and prints the result to standard output. The "
"program should loop until users stops it by entering \"done\", in which case "
"the program should terminate with a friendly greeting.  Use `replTill` in "
"your implementation."
msgstr ""
"計算式を標準入力から読み、`eval`を使って評価し、\n"
"標準出力に結果を印字するプログラムを書いてください。\n"
"プログラムは利用者が \"done\" と入力して停止させるまで繰り返します。\n"
"停止された場合はプログラムは気さくな挨拶とともに終了します。\n"
"実装では`replTill`を使ってください。"

#. type: Bullet: '5. '
#: ../src/Tutorial/IO.md:373
msgid ""
"Implement function `replWith`, which behaves just like `repl` but uses some "
"internal state to accumulate values.  At each iteration (including the very "
"first one!), the current state should be printed to standard output using "
"function `dispState`, and the next state should be computed using function "
"`next`.  The loop should terminate in case of a `Left` and print a final "
"message using `dispResult`:"
msgstr ""
"関数`replWith`を実装してください。\n"
"これはちょうど`repl`と同じように振舞いますが、\n"
"内部状態を使って値を積み重ねます。\n"
"それぞれの回（初回も含みます！）で関数`dispState`を使って現在の状態が標準出力"
"に印字され、\n"
"次の状態は関数`next`を使って計算されます。\n"
"繰り返しは`Left`の場合に終了し、`dispResult`を使って最後の文言を印字します。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/IO.md:374
#, no-wrap
msgid ""
"   covering\n"
"   replWith :  (state      : s)\n"
"            -> (next       : s -> String -> Either res s)\n"
"            -> (dispState  : s -> String)\n"
"            -> (dispResult : res -> s -> String)\n"
"            -> IO ()\n"
msgstr ""
"   covering\n"
"   replWith :  (state      : s)\n"
"            -> (next       : s -> String -> Either res s)\n"
"            -> (dispState  : s -> String)\n"
"            -> (dispResult : res -> s -> String)\n"
"            -> IO ()\n"

#. type: Bullet: '6. '
#: ../src/Tutorial/IO.md:388
msgid ""
"Use `replWith` from Exercise 5 to write a program for reading natural "
"numbers from standard input and printing the accumulated sum of these "
"numbers.  The program should terminate in case of invalid input and if a "
"user enters \"done\"."
msgstr ""
"問題5の`replWith`を使って、標準入力から自然数を読み、\n"
"積み重ねられたこれらの数値の合計を印字するプログラムを書いてください。\n"
"プログラムは不正な入力の場合と利用者が \"done\" が入力したときに終了します。"

#. type: Title ##
#: ../src/Tutorial/IO.md:389
#, no-wrap
msgid "Do Blocks, Desugared"
msgstr "doブロックとその脱糖"

#. type: Plain text
#: ../src/Tutorial/IO.md:402
msgid ""
"Here's an important piece of information: There is nothing special about *do "
"blocks*. They are just syntactic sugar, which is converted to a sequence of "
"operator applications.  With [syntactic sugar](https://en.wikipedia.org/wiki/"
"Syntactic_sugar), we mean syntax in a programming language that makes it "
"easier to express certain things in that language without making the "
"language itself any more powerful or expressive.  Here, it means you could "
"write all the `IO` programs without using `do` notation, but the code you'll "
"write will sometimes be harder to read, so *do blocks* provide nicer syntax "
"for these occasions."
msgstr ""
"ここで大事なお知らせがあります。\n"
"*doブロック*について特別なことは何もないということです。\n"
"これは単なる糖衣構文で、演算子の適用の羅列に変換されます。\n"
"[糖衣構文](https://en.wikipedia.org/wiki/Syntactic_sugar)があれば、\n"
"少しも言語自体を強力にしたり表現力豊かにすることなく、\n"
"その言語で特定のことを表現することをより簡単にできるようなプログラミング言語"
"での構文で書くことができます。\n"
"つまり全ての`IO`プログラムを`do`記法を使わずに書くことができるのですが、\n"
"書いたコードはしばしば読みにくくなるでしょう。\n"
"*doブロック*はそうした場合によりよい構文を提供するものです。"

#. type: Plain text
#: ../src/Tutorial/IO.md:404
msgid "Consider the following example program:"
msgstr "以下のプログラム例について考えます。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/IO.md:405
#, no-wrap
msgid ""
"sugared1 : IO ()\n"
"sugared1 = do\n"
"  str1 <- getLine\n"
"  str2 <- getLine\n"
"  str3 <- getLine\n"
"  putStrLn (str1 ++ str2 ++ str3)\n"
msgstr ""
"sugared1 : IO ()\n"
"sugared1 = do\n"
"  str1 <- getLine\n"
"  str2 <- getLine\n"
"  str3 <- getLine\n"
"  putStrLn (str1 ++ str2 ++ str3)\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:416
msgid ""
"The compiler will convert this to the following program *before "
"disambiguating function names and type checking*:"
msgstr ""
"コンパイラは*関数名の曖昧性を解決して型検査する前に*これを以下のプログラムに"
"変換します。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/IO.md:417
#, no-wrap
msgid ""
"desugared1 : IO ()\n"
"desugared1 =\n"
"  getLine >>= (\\str1 =>\n"
"    getLine >>= (\\str2 =>\n"
"      getLine >>= (\\str3 =>\n"
"        putStrLn (str1 ++ str2 ++ str3)\n"
"      )\n"
"    )\n"
"  )\n"
msgstr ""
"desugared1 : IO ()\n"
"desugared1 =\n"
"  getLine >>= (\\str1 =>\n"
"    getLine >>= (\\str2 =>\n"
"      getLine >>= (\\str3 =>\n"
"        putStrLn (str1 ++ str2 ++ str3)\n"
"      )\n"
"    )\n"
"  )\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:432
#, no-wrap
msgid ""
"There is a new operator (`(>>=)`) called *bind* in the\n"
"implementation of `desugared1`. If you look at its type\n"
"at the REPL, you'll see the following:\n"
msgstr ""
"*bind*と呼ばれる新しい演算子 (`>>=`) が`desugared1`の実装中にあります。\n"
"REPLで型を見ると以下のようになっています。\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/IO.md:433
#, no-wrap
msgid ""
"Main> :t (>>=)\n"
"Prelude.>>= : Monad m => m a -> (a -> m b) -> m b\n"
msgstr ""
"Main> :t (>>=)\n"
"Prelude.>>= : Monad m => m a -> (a -> m b) -> m b\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:441
msgid ""
"This is a constrained function requiring an interface called `Monad`.  We "
"will talk about `Monad` and some of its friends in the next chapter. "
"Specialized to `IO`, *bind* has the following type:"
msgstr ""
"これは制約付き関数で`Monad`と呼ばれるインターフェースを必要とします。\n"
"`Monad`とその仲間達については次章でお話しします。\n"
"`IO`に限っていうと*bind*は以下の型を持ちます。"

#. type: Fenced code block (repl)
#: ../src/Tutorial/IO.md:442
#, no-wrap
msgid ""
"Main> :t (>>=) {m = IO}\n"
">>= : IO a -> (a -> IO b) -> IO b\n"
msgstr ""
"Main> :t (>>=) {m = IO}\n"
">>= : IO a -> (a -> IO b) -> IO b\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:451
msgid ""
"This describes a sequencing of `IO` actions. Upon execution, the first `IO` "
"action is being run and its result is being passed as an argument to the "
"function generating the second `IO` action, which is then also being "
"executed."
msgstr ""
"これは`IO`行動の連接を表現しています。\n"
"実行にあたって最初の`IO`行動が走り、\n"
"その結果が2つ目の`IO`行動を生成する関数に引数として渡されます。\n"
"2つ目の`IO`行動もそれから実行されていきます。"

#. type: Plain text
#: ../src/Tutorial/IO.md:466
msgid ""
"You might remember, that you already implemented something similar in an "
"earlier exercise: In [Algebraic Data Types](DataTypes.md), you implemented "
"*bind* for `Maybe` and `Either e`. We will learn in the next chapter, that "
"`Maybe` and `Either e` too come with an implementation of `Monad`. For now, "
"suffice to say that `Monad` allows us to run computations with some kind of "
"effect in sequence by passing the *result* of the first computation to the "
"function returning the second computation. In `desugared1` you can see, how "
"we first perform an `IO` action and use its result to compute the next `IO` "
"action and so on. The code is somewhat hard to read, since we use several "
"layers of nested anonymous function, that's why in such cases, *do blocks* "
"are a nice alternative to express the same functionality."
msgstr ""
"お気付きかもしれませんが、以前の演習で似たようなものを既に実装していまし"
"た。\n"
"[代数的データ型](DataTypes.md)で`Maybe`と`Either e`に*bind*を実装しました"
"ね。\n"
"次の章で学ぶことになりますが、\n"
"`Maybe`と`Either e`もまた`Monad`の実装が付属しています。\n"
"さしあたって言うべきこととしては、\n"
"`Monad`があれば何らかの種類の作用付きの計算を、\n"
"最初の計算の*結果*を2つ目の計算が返す関数に渡すことで、\n"
"順繰りに走らせられるということです。\n"
"`desugared1`を見るとわかりますが、\n"
"最初に`IO`行動を実施し、その結果を次の`IO`行動の計算に使い、というようになっ"
"ています。\n"
"コードはどこか読み辛いものですが、\n"
"これは何層にも入れ子になった匿名関数があるからで、\n"
"だからこそそうした場合に*doブロック*が同じ機能を表現するよりよい代替となるの"
"です。"

#. type: Plain text
#: ../src/Tutorial/IO.md:471
msgid ""
"Since *do block* are always desugared to sequences of applied *bind* "
"operators, we can use them to chain any monadic computation. For instance, "
"we can rewrite function `eval` by using a *do block* like so:"
msgstr ""
"*doブロック*は常に*bind*演算子の適用の羅列に脱糖されるため、\n"
"これを使っていかなるモナド計算をも連鎖させられます。\n"
"例えば関数`eval`を*doブロック*を使って書き換えられます。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/IO.md:472
#, no-wrap
msgid ""
"evalDo : String -> Either Error Integer\n"
"evalDo s = case forget $ split isSpace s of\n"
"  [x,y,z] => do\n"
"    v1 <- readInteger x\n"
"    op <- readOperator y\n"
"    v2 <- readInteger z\n"
"    Right $ op v1 v2\n"
"  _       => Left (ParseError s)\n"
msgstr ""
"evalDo : String -> Either Error Integer\n"
"evalDo s = case forget $ split isSpace s of\n"
"  [x,y,z] => do\n"
"    v1 <- readInteger x\n"
"    op <- readOperator y\n"
"    v2 <- readInteger z\n"
"    Right $ op v1 v2\n"
"  _       => Left (ParseError s)\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:488
msgid ""
"Don't worry, if this doesn't make too much sense yet. We will see many more "
"examples, and you'll get the hang of this soon enough. The important thing "
"to remember is how *do blocks* are always converted to sequences of *bind* "
"operators as shown in `desugared1`."
msgstr ""
"まだよく飲み込めていなくても心配ないです。\n"
"より多くの例を見ていくことで、もうじきに会得できるでしょう。\n"
"覚えておくべき大事なことは*doブロック*が常に`desugared1`に示したような\n"
"*bind*演算子の羅列に変換されるということです。"

#. type: Title ###
#: ../src/Tutorial/IO.md:489
#, no-wrap
msgid "Binding Unit"
msgstr "Unitを束縛する"

#. type: Plain text
#: ../src/Tutorial/IO.md:492
msgid "Remember our implementation of `friendlyReadHello`? Here it is again:"
msgstr ""
"`friendlyReadHello`の実装を覚えていますか？\n"
"以下に再掲します。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/IO.md:493
#, no-wrap
msgid ""
"friendlyReadHello' : IO ()\n"
"friendlyReadHello' = do\n"
"  _ <- putStrLn \"Please enter your name.\"\n"
"  readHello\n"
msgstr ""
"friendlyReadHello' : IO ()\n"
"friendlyReadHello' = do\n"
"  _ <- putStrLn \"Please enter your name.\"\n"
"  readHello\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:505
msgid ""
"The underscore in there is a bit ugly and unnecessary. In fact, a common use "
"case is to just chain effectful computations with result type `Unit` (`()`), "
"merely for the side effects they perform. For instance, we could repeat "
"`friendlyReadHello` three times, like so:"
msgstr ""
"下線文字がちょっと見辛く不必要です。\n"
"実際、よくある使用例は結果の型が`Unit` (`()`) で作用のある計算を単に連鎖させ"
"るだけであり、\n"
"発生する副作用だけがほしいのです。\n"
"例えば`friendlyReadHello`を3回繰り返すことができます、こんな風に。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/IO.md:506
#, no-wrap
msgid ""
"friendly3 : IO ()\n"
"friendly3 = do\n"
"  _ <- friendlyReadHello\n"
"  _ <- friendlyReadHello\n"
"  friendlyReadHello\n"
msgstr ""
"friendly3 : IO ()\n"
"friendly3 = do\n"
"  _ <- friendlyReadHello\n"
"  _ <- friendlyReadHello\n"
"  friendlyReadHello\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:516
msgid ""
"This is such a common thing to do, that Idris allows us to drop the bound "
"underscores altogether:"
msgstr ""
"これはよくあることなので、Idrisでは下線文字への束縛を一気に削ぎ落とすことがで"
"きます。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/IO.md:517
#, no-wrap
msgid ""
"friendly4 : IO ()\n"
"friendly4 = do\n"
"  friendlyReadHello\n"
"  friendlyReadHello\n"
"  friendlyReadHello\n"
"  friendlyReadHello\n"
msgstr ""
"friendly4 : IO ()\n"
"friendly4 = do\n"
"  friendlyReadHello\n"
"  friendlyReadHello\n"
"  friendlyReadHello\n"
"  friendlyReadHello\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:527
msgid "Note, however, that the above gets desugared slightly differently:"
msgstr "ただしかし、上記は僅かに違う風に脱糖されます。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/IO.md:528
#, no-wrap
msgid ""
"friendly4Desugared : IO ()\n"
"friendly4Desugared =\n"
"  friendlyReadHello >>\n"
"  friendlyReadHello >>\n"
"  friendlyReadHello >>\n"
"  friendlyReadHello\n"
msgstr ""
"friendly4Desugared : IO ()\n"
"friendly4Desugared =\n"
"  friendlyReadHello >>\n"
"  friendlyReadHello >>\n"
"  friendlyReadHello >>\n"
"  friendlyReadHello\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:538
#, no-wrap
msgid "Operator `(>>)` has the following type:\n"
msgstr "演算子 `(>>)` は以下の型を持ちます。\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/IO.md:539
#, no-wrap
msgid ""
"Main> :t (>>)\n"
"Prelude.>> : Monad m => m () -> Lazy (m b) -> m b\n"
msgstr ""
"Main> :t (>>)\n"
"Prelude.>> : Monad m => m () -> Lazy (m b) -> m b\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:550
msgid ""
"Note the `Lazy` keyword in the type signature. This means, that the wrapped "
"argument will be *lazily evaluated*. This makes sense in many occasions. For "
"instance, if the `Monad` in question is `Maybe` the result will be `Nothing` "
"if the first argument is `Nothing`, in which case there is no need to even "
"evaluate the second argument."
msgstr ""
"型処方中に`Lazy`キーワードがありますね。\n"
"これが意味するのは、包まれた引数が*遅延評価*されるということです。\n"
"これは多くの場合理に適っています。\n"
"例えばもし問題の`Monad`が`Maybe`であれば、最初の引数が`Nothing`なら結果が"
"`Nothing`になるでしょう。\n"
"その場合2つ目の引数を評価する必要さえないのです。"

#. type: Title ###
#: ../src/Tutorial/IO.md:551
#, no-wrap
msgid "Do, Overloaded"
msgstr "doをオーバーロード"

#. type: Plain text
#: ../src/Tutorial/IO.md:562
#, no-wrap
msgid ""
"Because Idris supports function and operator overloading, we\n"
"can write custom *bind* operators, which allows us to\n"
"use *do notation* for types without an implementation\n"
"of `Monad`. For instance, here is a custom implementation of\n"
"`(>>=)` for sequencing computations returning vectors.\n"
"Every value in the first vector (of length `m`)\n"
"will be converted to a vector of length `n`, and\n"
"the results will be concatenated leading to\n"
"a vector of length `m * n`:\n"
msgstr ""
"Idrisでは関数と演算子のオーバーロードができるので、\n"
"自前の*束縛*演算子を書くことができ、\n"
"これによって`Monad`の実装を持たない型にも*do記法*が使えます。\n"
"例えば以下はベクタを返す連続計算のための`(>>=)`の自前実装です。\n"
"（長さ`m`の）1つ目のベクタ中の全ての値が長さ`n`のベクタに変換され、\n"
"連結された結果となるため長さ`m * n`のベクタになります。\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/IO.md:563
#, no-wrap
msgid ""
"flatten : Vect m (Vect n a) -> Vect (m * n) a\n"
"flatten []        = []\n"
"flatten (x :: xs) = x ++ flatten xs\n"
"\n"
"(>>=) : Vect m a -> (a -> Vect n b) -> Vect (m * n) b\n"
"as >>= f = flatten (map f as)\n"
msgstr ""
"flatten : Vect m (Vect n a) -> Vect (m * n) a\n"
"flatten []        = []\n"
"flatten (x :: xs) = x ++ flatten xs\n"
"\n"
"(>>=) : Vect m a -> (a -> Vect n b) -> Vect (m * n) b\n"
"as >>= f = flatten (map f as)\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:580
#, no-wrap
msgid ""
"It is not possible to write an implementation of `Monad`,\n"
"which encapsulates this behavior, as the types wouldn't\n"
"match: Monadic *bind* specialized to `Vect` has\n"
"type `Vect k a -> (a -> Vect k b) -> Vect k b`. As you\n"
"see, the sizes of all three occurrences of `Vect`\n"
"have to be the same, which is not what we expressed\n"
"in our custom version of *bind*. Here is an example to\n"
"see this in action:\n"
msgstr ""
"この振舞いを内蔵化するような`Monad`の実装を書くことはできません。\n"
"型が合わないからです。\n"
"というのは、`Vect`に特化したモナドな*束縛*は`Vect k a -> (a -> Vect k b) -> Vect k b`の型を持つからです。\n"
"見てわかるように出現する3箇所の`Vect`大きさはどれも同じであり、\n"
"これは自家製の*束縛*で表現しているものと異なります。\n"
"実際に動かしてみた例は以下です。\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/IO.md:581
#, no-wrap
msgid ""
"modString : String -> Vect 4 String\n"
"modString s = [s, reverse s, toUpper s, toLower s]\n"
"\n"
"testDo : Vect 24 String\n"
"testDo = IO.do\n"
"  s1 <- [\"Hello\", \"World\"]\n"
"  s2 <- [1, 2, 3]\n"
"  modString (s1 ++ show s2)\n"
msgstr ""
"modString : String -> Vect 4 String\n"
"modString s = [s, reverse s, toUpper s, toLower s]\n"
"\n"
"testDo : Vect 24 String\n"
"testDo = IO.do\n"
"  s1 <- [\"Hello\", \"World\"]\n"
"  s2 <- [1, 2, 3]\n"
"  modString (s1 ++ show s2)\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:601
msgid ""
"Try to figure out how `testDo` works by desugaring it manually and then "
"comparing its result with what you expected at the REPL. Note, how we helped "
"Idris disambiguate, which version of the *bind* operator to use by prefixing "
"the `do` keyword with part of the operator's namespace.  In this case, this "
"wasn't strictly necessary, although `Vect k` does have an implementation of "
"`Monad`, but it is still good to know that it is possible to help the "
"compiler with disambiguating do blocks."
msgstr ""
"手ずから脱糖してみて、`testDo`がどのように動いているのかを調べてみてくださ"
"い。\n"
"それからその結果とREPLで得られたものとを比較しましょう。\n"
"なお、ここではIdrisが曖昧さを解決できるように手助けしました。\n"
"演算子の名前空間の一部で`do`キーワードに前置することで、\n"
"どの版の*束縛*演算子を使うべきかを伝えています。\n"
"この場合、`Vect k`は`Monad`の実装を持ちますが、厳密には必要ではありません。\n"
"しかしそれでもコンパイラがdoブロックの曖昧さを解決することを手伝うことができ"
"ると知っておくことは良いことです。"

#. type: Plain text
#: ../src/Tutorial/IO.md:605
#, no-wrap
msgid ""
"Of course, we can (and should!) overload `(>>)` in the\n"
"same manner as `(>>=)`, if we want to overload the\n"
"behavior of *do blocks*.\n"
msgstr ""
"もちろん、`(>>=)`と同じ作法で`(>>)`をオーバーロードすることもできます（し、やるべきです！）。\n"
"もしdoブロックの振舞いをオーバーロードしたければね。\n"

#. type: Title ####
#: ../src/Tutorial/IO.md:606
#, no-wrap
msgid "Modules and Namespaces"
msgstr "モジュールと名前空間"

#. type: Plain text
#: ../src/Tutorial/IO.md:614
msgid ""
"Every data type, function, or operator can be unambiguously identified by "
"prefixing it with its *namespace*. A function's namespace typically is the "
"same as the module where it was defined.  For instance, the fully qualified "
"name of function `eval` would be `Tutorial.IO.eval`. Function and operator "
"names must be unique in their namespace."
msgstr ""
"あらゆるデータ型、関数、演算子は名前空間を前置することで曖昧さなく識別される"
"ようにできます。\n"
"関数の名前空間は大抵定義されているモジュールと同じです。\n"
"例えば関数`eval`の完全に限定された名前は`Tutorial.IO.eval`になります。\n"
"関数と演算子の名前は名前空間において唯一でなければいけません。"

#. type: Plain text
#: ../src/Tutorial/IO.md:620
msgid ""
"As we already learned, Idris can often disambiguate between functions with "
"the same name but defined in different namespaces based on the types "
"involved. If this is not possible, we can help the compiler by *prefixing* "
"the function or operator name with a *suffix* of the full namespace. Let's "
"demonstrate this at the REPL:"
msgstr ""
"既に見てきたように、Idrisはよく同名で異なる名前空間の関数を紐付く型で曖昧解決"
"します。\n"
"これができなければ、関数や演算子の名前に完全な名前空間の後ろ部分を前置するこ"
"とでコンパイラを手助けできます。\n"
"REPLで実演します。"

#. type: Fenced code block (repl)
#: ../src/Tutorial/IO.md:621
#, no-wrap
msgid ""
"Tutorial.IO> :t (>>=)\n"
"Prelude.>>= : Monad m => m a -> (a -> m b) -> m b\n"
"Tutorial.IO.>>= : Vect m a -> (a -> Vect n b) -> Vect (m * n) b\n"
msgstr ""
"Tutorial.IO> :t (>>=)\n"
"Prelude.>>= : Monad m => m a -> (a -> m b) -> m b\n"
"Tutorial.IO.>>= : Vect m a -> (a -> Vect n b) -> Vect (m * n) b\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:633
#, no-wrap
msgid ""
"As you can see, if we load this module in a REPL session and\n"
"inspect the type of `(>>=)`, we get two results as two\n"
"operators with this name are in scope. If we only want\n"
"the REPL to print the type of our custom *bind* operator,\n"
"is is sufficient to prefix it with `IO`, although we could\n"
"also prefix it with its full namespace:\n"
msgstr ""
"見てとれるように、本モジュールをREPLセッションで読み込んで`(>>=)`の型を調べると、\n"
"その名前の2つの演算子が結果に出てきます。\n"
"REPLに自前の束縛演算子のみを印字させたいときは、\n"
"`IO`を前置しておけば充分です。\n"
"完全な名前空間を前置することもできますけどね。\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/IO.md:634
#, no-wrap
msgid ""
"Tutorial.IO> :t IO.(>>=)\n"
"Tutorial.IO.>>= : Vect m a -> (a -> Vect n b) -> Vect (m * n) b\n"
"Tutorial.IO> :t Tutorial.IO.(>>=)\n"
"Tutorial.IO.>>= : Vect m a -> (a -> Vect n b) -> Vect (m * n) b\n"
msgstr ""
"Tutorial.IO> :t IO.(>>=)\n"
"Tutorial.IO.>>= : Vect m a -> (a -> Vect n b) -> Vect (m * n) b\n"
"Tutorial.IO> :t Tutorial.IO.(>>=)\n"
"Tutorial.IO.>>= : Vect m a -> (a -> Vect n b) -> Vect (m * n) b\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:649
msgid ""
"Since function names must be unique in their namespace and we still may want "
"to define two overloaded versions of a function in an Idris module, Idris "
"makes it possible to add additional namespaces to modules. For instance, in "
"order to define another function called `eval`, we need to add it to its own "
"namespace (note, that all definitions in a namespace must be indented by the "
"same amount of white space):"
msgstr ""
"関数名は名前空間で唯一でなければいけない一方で、\n"
"それでも1つのIdrisのモジュールで2つのオーバーロードされた版の関数を定義したい"
"ときがあるかもしれないので、\n"
"Idrisではモジュールに追加の名前空間を加えられます。\n"
"例えば`eval`という名前の別の関数を定義するためには、\n"
"それ自身の名前空間に加える必要があります。\n"
"（1つの名前空間中の全定義が同量の空白文字で前置されなければいけないことに注意"
"です。）"

#. type: Fenced code block (idris)
#: ../src/Tutorial/IO.md:650
#, no-wrap
msgid ""
"namespace Foo\n"
"  export\n"
"  eval : Nat -> Nat -> Nat\n"
"  eval = (*)\n"
"\n"
"-- prefixing `eval` with its namespace is not strictly necessary here\n"
"testFooEval : Nat\n"
"testFooEval = Foo.eval 12 100\n"
msgstr ""
"namespace Foo\n"
"  export\n"
"  eval : Nat -> Nat -> Nat\n"
"  eval = (*)\n"
"\n"
"-- `eval`を名前空間で前置していますが、ここでは厳密には不必要です\n"
"testFooEval : Nat\n"
"testFooEval = Foo.eval 12 100\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:665
msgid ""
"Now, here is an important thing: For functions and data types to be "
"accessible from outside their namespace or module, they need to be "
"*exported* by annotating them with the `export` or `public export` keywords."
msgstr ""
"さて、ここで大切な話があります。\n"
"外部の名前空間やモジュールから到達できる関数やデータ型というのは、\n"
"`export`や`public export`キーワードで印を付けることで*輸出*しなくてはいけませ"
"ん。"

#. type: Plain text
#: ../src/Tutorial/IO.md:674
msgid ""
"The difference between `export` and `public export` is the following: A "
"function annotated with `export` exports its type and can be called from "
"other namespaces. A data type annotated with `export` exports its type "
"constructor but not its data constructors.  A function annotated with "
"`public export` also exports its implementation. This is necessary to use "
"the function in compile-time computations. A data type annotated with "
"`public export` exports its data constructors as well."
msgstr ""
"`export`と`public export`の違いは次の通り。\n"
"`export`の印が付けられた関数は型を輸出しており他の名前空間から呼ぶことができ"
"ます。\n"
"`export`の印が付けられたデータ型は型構築子を輸出しますがデータ構築子は輸出し"
"ません。\n"
"`public export`の印が付けられた関数は実装も輸出します。\n"
"これはコンパイル時計算に使うために必要です。\n"
"`public export`の印が付けられたデータ型はデータ構築子も輸出します。"

#. type: Plain text
#: ../src/Tutorial/IO.md:680
msgid ""
"In general, consider annotating data types with `public export`, since "
"otherwise you will not be able to create values of these types or "
"deconstruct them in pattern matches. Likewise, unless you plan to use your "
"functions in compile-time computations, annotate them with `export`."
msgstr ""
"一般的にデータ型は`public export`の印を付けることを検討してください。\n"
"さもないとその型の値を作れなかったりパターン照合で解体できないからです。\n"
"また、関数をコンパイル時計算で使う予定がないときは`export`の印を付けましょ"
"う。"

#. type: Title ###
#: ../src/Tutorial/IO.md:681
#, no-wrap
msgid "Bind, with a Bang"
msgstr "束縛 〜びっくりマークを添えて〜"

#. type: Plain text
#: ../src/Tutorial/IO.md:688
msgid ""
"Sometimes, even *do blocks* are too noisy to express a combination of "
"effectful computations. In this case, we can prefix the effectful parts with "
"an exclamation mark (wrapping them in parentheses if they contain additional "
"white space), while leaving pure expressions unmodified:"
msgstr ""
"ときどき*doブロック*さえも作用付き計算の組み合わせを表現するのに目にうるさい"
"ことがあります。\n"
"この場合、純粋な式を変更しないままで、作用のある部分にびっくりマークを前置す"
"ることができます。\n"
"（作用のある部分に空白がある場合、括弧で囲みます。）"

#. type: Fenced code block (idris)
#: ../src/Tutorial/IO.md:689
#, no-wrap
msgid ""
"getHello : IO ()\n"
"getHello = putStrLn $ \"Hello \" ++ !getLine ++ \"!\"\n"
msgstr ""
"getHello : IO ()\n"
"getHello = putStrLn $ \"Hello \" ++ !getLine ++ \"!\"\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:695
msgid "The above gets desugared to the following *do block*:"
msgstr "上記は以下の*doブロック*に脱糖されます。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/IO.md:696
#, no-wrap
msgid ""
"getHello' : IO ()\n"
"getHello' = do\n"
"  s <- getLine\n"
"  putStrLn $ \"Hello \" ++ s ++ \"!\"\n"
msgstr ""
"getHello' : IO ()\n"
"getHello' = do\n"
"  s <- getLine\n"
"  putStrLn $ \"Hello \" ++ s ++ \"!\"\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:704
msgid "Here is another example:"
msgstr "以下は別の例です。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/IO.md:705
#, no-wrap
msgid ""
"bangExpr : String -> String -> String -> Maybe Integer\n"
"bangExpr s1 s2 s3 =\n"
"  Just $ !(parseInteger s1) + !(parseInteger s2) * !(parseInteger s3)\n"
msgstr ""
"bangExpr : String -> String -> String -> Maybe Integer\n"
"bangExpr s1 s2 s3 =\n"
"  Just $ !(parseInteger s1) + !(parseInteger s2) * !(parseInteger s3)\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:712
msgid "And here is the desugared *do block*:"
msgstr "そしてこれは以下の*doブロック*に脱糖されます。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/IO.md:713
#, no-wrap
msgid ""
"bangExpr' : String -> String -> String -> Maybe Integer\n"
"bangExpr' s1 s2 s3 = do\n"
"  x1 <- parseInteger s1\n"
"  x2 <- parseInteger s2\n"
"  x3 <- parseInteger s3\n"
"  Just $ x1 + x2 * x3\n"
msgstr ""
"bangExpr' : String -> String -> String -> Maybe Integer\n"
"bangExpr' s1 s2 s3 = do\n"
"  x1 <- parseInteger s1\n"
"  x2 <- parseInteger s2\n"
"  x3 <- parseInteger s3\n"
"  Just $ x1 + x2 * x3\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:727
msgid ""
"Please remember the following: Syntactic sugar has been introduced to make "
"code more readable or more convenient to write. If it is abused just to show "
"how clever you are, you make things harder for other people (including your "
"future self!)  reading and trying to understand your code."
msgstr ""
"次のことを心に留めておきましょう。\n"
"糖衣構文はコードをより読みやすくしたり書くのを便利にしたりするために導入され"
"ました。\n"
"自分がどれほど賢いかを誇示するためだけに乱用すると、\n"
"他のひと（と将来のあなたも！）がコードを読んで理解しようとすることが難しくな"
"ります。"

#. type: Bullet: '1. '
#: ../src/Tutorial/IO.md:733
msgid ""
"Reimplement the following *do blocks*, once by using *bang notation*, and "
"once by writing them in their desugared form with nested *bind*s:"
msgstr ""
"以下の*doブロック*を再実装してください。\n"
"1つはびっくりマーク記法を使って、\n"
"もう1つは入れ子の*束縛*の形式に脱糖した形で書いてください。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/IO.md:734
#, no-wrap
msgid ""
"   ex1a : IO String\n"
"   ex1a = do\n"
"     s1 <- getLine\n"
"     s2 <- getLine\n"
"     s3 <- getLine\n"
"     pure $ s1 ++ reverse s2 ++ s3\n"
"\n"
"   ex1b : Maybe Integer\n"
"   ex1b = do\n"
"     n1 <- parseInteger \"12\"\n"
"     n2 <- parseInteger \"300\"\n"
"     Just $ n1 + n2 * 100\n"
msgstr ""
"   ex1a : IO String\n"
"   ex1a = do\n"
"     s1 <- getLine\n"
"     s2 <- getLine\n"
"     s3 <- getLine\n"
"     pure $ s1 ++ reverse s2 ++ s3\n"
"\n"
"   ex1b : Maybe Integer\n"
"   ex1b = do\n"
"     n1 <- parseInteger \"12\"\n"
"     n2 <- parseInteger \"300\"\n"
"     Just $ n1 + n2 * 100\n"

#. type: Bullet: '2. '
#: ../src/Tutorial/IO.md:752
msgid ""
"Below is the definition of an indexed family of types, the index of which "
"keeps track of whether the value in question is possibly empty or provably "
"non-empty:"
msgstr ""
"以下は指標付けられた型族で、注目する値が空か証明的に空でないかのいずれかを取"
"る値を指標で追跡します。"

#. type: Plain text
#: ../src/Tutorial/IO.md:766
#, no-wrap
msgid ""
"   Please note, that the `Nil` case *must* have the `nonEmpty`\n"
"   tag set to `False`, while with the *cons* case, this is\n"
"   optional. So, a `List01 False a` can be empty or non-empty,\n"
"   and we'll only find out, which is the case, by pattern\n"
"   matching on it. A `List01 True a` on the other hand *must*\n"
"   be a *cons*, as for the `Nil` case the `nonEmpty` tag is\n"
"   always set to `False`.\n"
msgstr ""
"   注目していただきたいのは、`Nil`の場合では`nonEmpty`札が`False`に設定されて*いなければならず*、\n"
"   一方で*cons*の場合はどちらでもよいということです。\n"
"   なので、`List 01 False a`は空もしくは非空のどちらもありえて、\n"
"   どちらなのかはパターン照合することでのみ調べられます。\n"
"   他方で、`Nil`の場合は`nonEmpty`札が常に`False`なので、\n"
"   `List01 True a`は*cons*でなくてはいけません。\n"

#. type: Bullet: '   1. '
#: ../src/Tutorial/IO.md:768
msgid "Declare and implement function `head` for non-empty lists:"
msgstr "関数`head`を非空のリストに対して宣言し実装してください。"

#. type: Plain text
#: ../src/Tutorial/IO.md:772
#, no-wrap
msgid ""
"      ```idris\n"
"      head : List01 True a -> a\n"
"      ```\n"
msgstr ""
"      ```idris\n"
"      head : List01 True a -> a\n"
"      ```\n"

#. type: Bullet: '   2. '
#: ../src/Tutorial/IO.md:776
msgid ""
"Declare and implement function `weaken` for converting any `List01 ne a` to "
"a `List01 False a` of the same length and order of values."
msgstr ""
"あらゆる`List01 ne a`を同じ長さと値の順番の`List01 False a`に変換する関数"
"`weaken`を宣言し実装してください。"

#. type: Bullet: '   3. '
#: ../src/Tutorial/IO.md:779
msgid ""
"Declare and implement function `tail` for extracting the possibly empty tail "
"from a non-empty list."
msgstr ""
"非空のリストから空になりうる尾っぽを取り出す関数`tail`を宣言し実装してくださ"
"い。"

#. type: Bullet: '   4. '
#: ../src/Tutorial/IO.md:784
msgid ""
"Implement function `(++)` for concatenating two values of type `List01`. "
"Note, how we use a type-level computation to make sure the result is non-"
"empty if and only if at least one of the two arguments is non-empty:"
msgstr ""
"型`List 01`の値を連結する関数`(++)`を実装してください。\n"
"以下で、どのように型段階計算を使って、\n"
"2つのうち少なくとも1つが非空であるときに限って、\n"
"結果が非空であることを確かめているかに注目してください。"

#. type: Plain text
#: ../src/Tutorial/IO.md:788
#, no-wrap
msgid ""
"      ```idris\n"
"      (++) : List01 b1 a -> List01 b2 a -> List01 (b1 || b2) a\n"
"      ```\n"
msgstr ""
"      ```idris\n"
"      (++) : List01 b1 a -> List01 b2 a -> List01 (b1 || b2) a\n"
"      ```\n"

#. type: Bullet: '   5. '
#: ../src/Tutorial/IO.md:794
msgid ""
"Implement utility function `concat'` and use it in the implementation of "
"`concat`. Note, that in `concat` the two boolean tags are passed as "
"unrestricted implicits, since you will need to pattern match on these to "
"determine whether the result is provably non-empty or not:"
msgstr ""
"小間物関数`concat'`を実装して`concat`の実装で使ってください。\n"
"`concat`には2枚の真偽値の札が制約なし暗黙子として渡されていますね。\n"
"これは結果が証明的に非空かそうでないかを、この札でパターン照合することで決定"
"する必要があるからです。"

#. type: Plain text
#: ../src/Tutorial/IO.md:797
#, no-wrap
msgid ""
"      ```idris\n"
"      concat' : List01 ne1 (List01 ne2 a) -> List01 False a\n"
msgstr ""
"      ```idris\n"
"      concat' : List01 ne1 (List01 ne2 a) -> List01 False a\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:802
#, no-wrap
msgid ""
"      concat :  {ne1, ne2 : _}\n"
"             -> List01 ne1 (List01 ne2 a)\n"
"             -> List01 (ne1 && ne2) a\n"
"      ```\n"
msgstr ""
"      concat :  {ne1, ne2 : _}\n"
"             -> List01 ne1 (List01 ne2 a)\n"
"             -> List01 (ne1 && ne2) a\n"
"      ```\n"

#. type: Bullet: '   6. '
#: ../src/Tutorial/IO.md:804
msgid "Implement `map01`:"
msgstr "`map01`を実装してください。"

#. type: Plain text
#: ../src/Tutorial/IO.md:808
#, no-wrap
msgid ""
"      ```idris\n"
"      map01 : (a -> b) -> List01 ne a -> List01 ne b\n"
"      ```\n"
msgstr ""
"      ```idris\n"
"      map01 : (a -> b) -> List01 ne a -> List01 ne b\n"
"      ```\n"

#. type: Bullet: '   7. '
#: ../src/Tutorial/IO.md:811
msgid ""
"Implement a custom *bind* operator in namespace `List01` for sequencing "
"computations returning `List01`s."
msgstr ""
"`List01`を返す計算を並べるための、自前の*束縛*演算子を名前空間`List01`に実装"
"してください。"

#. type: Plain text
#: ../src/Tutorial/IO.md:814
#, no-wrap
msgid ""
"      Hint: Use `map01` and `concat` in your implementation and\n"
"      make sure to use unrestricted implicits where necessary.\n"
msgstr ""
"      解決の糸口：実装では`map01`と`concat`を、\n"
"      必要に応じて制約なし暗黙子を使ってくださいね。\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:817
#, no-wrap
msgid ""
"      You can use the following examples to test your\n"
"      custom *bind* operator:\n"
msgstr "      自前の*束縛*演算子が動くことを確かめるためには以下の例が使えます。\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:823
#, no-wrap
msgid ""
"      ```idris\n"
"      -- this and lf are necessary to make sure, which tag to use\n"
"      -- when using list literals\n"
"      lt : List01 True a -> List01 True a\n"
"      lt = id\n"
msgstr ""
"      ```idris\n"
"      -- これとlfはリスト表記を使うときにどちらの札を使うのかを確定させるために必要です。\n"
"      lt : List01 True a -> List01 True a\n"
"      lt = id\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:826
#, no-wrap
msgid ""
"      lf : List01 False a -> List01 False a\n"
"      lf = id\n"
msgstr ""
"      lf : List01 False a -> List01 False a\n"
"      lf = id\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:833
#, no-wrap
msgid ""
"      test : List01 True Integer\n"
"      test = List01.do\n"
"        x  <- lt [1,2,3]\n"
"        y  <- lt [4,5,6,7]\n"
"        op <- lt [(*), (+), (-)]\n"
"        [op x y]\n"
msgstr ""
"      test : List01 True Integer\n"
"      test = List01.do\n"
"        x  <- lt [1,2,3]\n"
"        y  <- lt [4,5,6,7]\n"
"        op <- lt [(*), (+), (-)]\n"
"        [op x y]\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:841
#, no-wrap
msgid ""
"      test2 : List01 False Integer\n"
"      test2 = List01.do\n"
"        x  <- lt [1,2,3]\n"
"        y  <- Nil {a = Integer}\n"
"        op <- lt [(*), (+), (-)]\n"
"        lt [op x y]\n"
"      ```\n"
msgstr ""
"      test2 : List01 False Integer\n"
"      test2 = List01.do\n"
"        x  <- lt [1,2,3]\n"
"        y  <- Nil {a = Integer}\n"
"        op <- lt [(*), (+), (-)]\n"
"        lt [op x y]\n"
"      ```\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:857
msgid ""
"Some notes on Exercise 2: Here, we combined the capabilities of `List` and "
"`Data.List1` in a single indexed type family.  This allowed us to treat list "
"concatenation correctly: If at least one of the arguments is provably non-"
"empty, the result is also non-empty. To tackle this correctly with `List` "
"and `List1`, a total of four concatenation functions would have to be "
"written. So, while it is often possible to define distinct data types "
"instead of indexed families, the latter allow us to perform type-level "
"computations to be more precise about the pre- and postconditions of the "
"functions we write, at the cost of more-complex type signatures.  In "
"addition, sometimes it's not possible to derive the values of the indices "
"from pattern matching on the data values alone, so they have to be passed as "
"unerased (possibly implicit) arguments."
msgstr ""
"演習2に数点補足します。\n"
"ここでは`List`と`Data.List1`の能力を単一の指標付けられた型族にまとめていま"
"す。\n"
"これによりリストの結合を正しく扱えます。\n"
"つまり、少なくとも一方の引数が証明的に非空であるなら、結果もまた非空なので"
"す。\n"
"このことを`List`と`List1`で取り組もうとすると、\n"
"合計4つの結合関数を書く必要があるでしょう。\n"
"なので、指標付けられた型族の代わりに個々のデータ型を定義できることはよくあり"
"ますが、\n"
"指標付けられた型族のほうが、より複雑な型処方と引き換えに、\n"
"書く関数のより精密な事前・事後条件のある型段階計算を行えます。\n"
"加えて、データ値へのパターン照合だけからでは指標値を導出できないことはしばし"
"ばあり、\n"
"そのため消去されない（暗黙にできる）引数として渡さなければなりません。"

#. type: Plain text
#: ../src/Tutorial/IO.md:864
msgid ""
"Please remember, that *do blocks* are first desugared, before type-checking, "
"disambiguating which *bind* operator to use, and filling in implicit "
"arguments. It is therefore perfectly fine to define *bind* operators with "
"arbitrary constraints or implicit arguments as was shown above. Idris will "
"handle all the details, *after* desugaring the *do blocks*."
msgstr ""
"覚えておいてほしいことは、*doブロック*が最初に脱糖されるもので、\n"
"それは型検査やどの*束縛*演算子かの曖昧解決をするかや暗黙引数を埋めていくより"
"前だということです。\n"
"したがって上記のような好きな制約や暗黙引数付きの*束縛*演算子を定義することは"
"全くもって大丈夫なのです。\n"
"Idrisは*doブロック*を脱糖した*後*に全ての詳細を取り扱います。"

#. type: Title ##
#: ../src/Tutorial/IO.md:865
#, no-wrap
msgid "Working with Files"
msgstr "ファイルを取り回す"

#. type: Plain text
#: ../src/Tutorial/IO.md:872
msgid ""
"Module `System.File` from the *base* library exports utilities necessary to "
"work with file handles and read and write from and to files. When you have a "
"file path (for instance \"/home/hock/idris/tutorial/tutorial.ipkg\"), the "
"first thing we will typically do is to try and create a file handle (of type "
"`System.File.File` by calling `fileOpen`)."
msgstr ""
"モジュール`System.File`は*base*ライブラリに由来し、\n"
"ファイル制御子を取り回したりファイルを読み書きしたりするのに必要な小間物を輸"
"出しています。\n"
"ファイルパス（例えば\"/home/hock/idris/tutorial/tutorial.ipkg\"）があると"
"き、\n"
"よく最初にすることはファイル制御子（型は`System.File.File`で`fileOpen`という"
"名前）を作ろうとすることです。"

#. type: Plain text
#: ../src/Tutorial/IO.md:874
msgid "Here is a program for counting all empty lines in a Unix/Linux-file:"
msgstr "以下はUnix/Linux上のファイル中の全空行を数えるプログラムです。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/IO.md:875
#, no-wrap
msgid ""
"covering\n"
"countEmpty : (path : String) -> IO (Either FileError Nat)\n"
"countEmpty path = openFile path Read >>= either (pure . Left) (go 0)\n"
"  where covering go : Nat -> File -> IO (Either FileError Nat)\n"
"        go k file = do\n"
"          False <- fEOF file | True => closeFile file $> Right k\n"
"          Right \"\\n\" <- fGetLine file\n"
"            | Right _  => go k file\n"
"            | Left err => closeFile file $> Left err\n"
"          go (k + 1) file\n"
msgstr ""
"covering\n"
"countEmpty : (path : String) -> IO (Either FileError Nat)\n"
"countEmpty path = openFile path Read >>= either (pure . Left) (go 0)\n"
"  where covering go : Nat -> File -> IO (Either FileError Nat)\n"
"        go k file = do\n"
"          False <- fEOF file | True => closeFile file $> Right k\n"
"          Right \"\\n\" <- fGetLine file\n"
"            | Right _  => go k file\n"
"            | Left err => closeFile file $> Left err\n"
"          go (k + 1) file\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:894
#, no-wrap
msgid ""
"In the example above, I invoked `(>>=)` without starting a *do block*.\n"
"Make sure you understand what's going on here. Reading concise functional\n"
"code is important in order to understand other people's code.\n"
"Have a look at function `either` at the REPL, try figuring out what\n"
"`(pure . Left)` does, and note how we use a curried version of `go`\n"
"as the second argument to `either`.\n"
msgstr ""
"上の例で*doブロック*なしに`(>>=)`を呼び出しました。\n"
"このときに起こることを確実に理解しましょう。\n"
"簡潔な関数型コードを読むことは他人のコードを理解するためには大切です。\n"
"REPLで関数`either`を見たり、\n"
"`(pure . Left)`がしていることを調べたり、\n"
"`go`のカリー化された版を`either`の2つ目の引数として使っていることに注目したりしてください。\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:905
msgid ""
"Function `go` calls for some additional explanations. First, note how we "
"used the same syntax for pattern matching intermediary results as we also "
"saw for `let` bindings. As you can see, we can use several vertical bars to "
"handle more than one additional pattern. In order to read a single line from "
"a file, we use function `fGetLine`. As with most operations working with the "
"file system, this function might fail with a `FileError`, which we have to "
"handle correctly. Note also, that `fGetLine` will return the line including "
"its trailing newline character `'\\n'`, so in order to check for empty "
"lines, we have to match against `\"\\n\"` instead of the empty string `\"\"`."
msgstr ""
"関数`go`については追加で説明せねばなりません。\n"
"まず、`let`束縛でも見たのと同じ構文で、結果にそのままパターン照合を使っている"
"ところに着目しましょう。\n"
"見てとれるようにいくつかの垂直棒を使って1つ以上の追加のパターンを制御できま"
"す。\n"
"ファイルから1行読むために関数`fGetLine`を使っています。\n"
"ファイルシステムでのほとんどの操作につきものですが、\n"
"この関数は`FileError`を返すかもしれません。\n"
"そのような場合に正しく対処する必要があります。\n"
"さらに言えば`fGetLine`は空行のとき末尾の改行文字`'\\n'`を含む行を返すので、\n"
"空行を確認するためには空文字列`\"\"`の代わりに`\"\\n\"`に照合する必要がありま"
"す。"

#. type: Plain text
#: ../src/Tutorial/IO.md:910
msgid ""
"Finally, `go` is not provably total and rightfully so.  Files like `/dev/"
"urandom` or `/dev/zero` provide infinite streams of data, so `countEmpty` "
"will never terminate when invoked with such a file path."
msgstr ""
"最後に`go`は証明的に全域ではなく、それはそうです。\n"
"`/dev/urandom`や`/dev/zero`のようなファイルはデータの無限ストリームを提供して"
"おり、\n"
"そのため`countEmpty`がそのようなファイルパスで呼び出されたときは終了すること"
"がないでしょう。"

#. type: Title ###
#: ../src/Tutorial/IO.md:911
#, no-wrap
msgid "Safe Resource Handling"
msgstr "安全な資源制御"

#. type: Plain text
#: ../src/Tutorial/IO.md:919
msgid ""
"Note, how we had to manually open and close the file handle in `countEmpty`. "
"This is error-prone and tedious. Resource handling is a big topic, and we "
"definitely won't be going into the details here, but there is a convenient "
"function exported from `System.File`: `withFile`, which handles the opening, "
"closing and handling of file errors for us."
msgstr ""
"`countEmpty`で手動でファイル制御子を開いたり閉じたりしなければなりませんでし"
"たね。\n"
"これはエラーの温床ですし億劫です。\n"
"資源制御は大きな話題であり、ここではその詳細に踏み込むことはありませんが、\n"
"`System.File`から輸出されている便利な関数があります。\n"
"それは`withFile`で、これはファイルを開いたり閉じたりファイルのエラーの制御の"
"面倒を見てくれたりします。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/IO.md:920
#, no-wrap
msgid ""
"covering\n"
"countEmpty' : (path : String) -> IO (Either FileError Nat)\n"
"countEmpty' path = withFile path Read pure (go 0)\n"
"  where covering go : Nat -> File -> IO (Either FileError Nat)\n"
"        go k file = do\n"
"          False <- fEOF file | True => pure (Right k)\n"
"          Right \"\\n\" <- fGetLine file\n"
"            | Right _  => go k file\n"
"            | Left err => pure (Left err)\n"
"          go (k + 1) file\n"
msgstr ""
"covering\n"
"countEmpty' : (path : String) -> IO (Either FileError Nat)\n"
"countEmpty' path = withFile path Read pure (go 0)\n"
"  where covering go : Nat -> File -> IO (Either FileError Nat)\n"
"        go k file = do\n"
"          False <- fEOF file | True => pure (Right k)\n"
"          Right \"\\n\" <- fGetLine file\n"
"            | Right _  => go k file\n"
"            | Left err => pure (Left err)\n"
"          go (k + 1) file\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:937
msgid ""
"Go ahead, and have a look at the type of `withFile`, then have a look how we "
"use it to simplify the implementation of `countEmpty'`. Reading and "
"understanding slightly more complex function types is important when "
"learning to program in Idris."
msgstr ""
"さあ、`withFile`の型を眺めてみて、\n"
"それからこれを使って`countEmpty'`の実装をどのように簡単にしているのか見てみま"
"しょう。\n"
"ちょっとだけより複雑な関数の型を読んで理解することはIdrisで書かれたプログラム"
"を学ぶ上で大事です。"

#. type: Title ####
#: ../src/Tutorial/IO.md:938
#, no-wrap
msgid "Interface `HasIO`"
msgstr "インターフェース`HasIO`"

#. type: Plain text
#: ../src/Tutorial/IO.md:948
msgid ""
"When you look at the `IO` functions we used so far, you'll notice that most "
"if not all of them actually don't work with `IO` itself but with a type "
"parameter `io` with a constraint of `HasIO`. This interface allows us to "
"*lift* a value of type `IO a` into another context. We will see use cases "
"for this in later chapters, especially when we talk about monad "
"transformers. For now, you can treat these `io` parameters as being "
"specialized to `IO`."
msgstr ""
"これまで使ってきた`IO`関数を見ると、\n"
"全てではないにしてもほとんどが実際には`IO`そのものを扱ってはおらず、\n"
"制約`HasIO`を持つ型変数`io`を使っていることに気付きます。\n"
"このインターフェースのおかげで型`IO a`の値を他の文脈に*持ち上げ*ることができ"
"ます。\n"
"この使用例については後の章、特にモナド変換子について話すときに見ていきましょ"
"う。\n"
"現段階ではこれらの`io`変数を`IO`に特化させたものとして扱ってよいです。"

#. type: Bullet: '1. '
#: ../src/Tutorial/IO.md:959
msgid ""
"As we have seen in the examples above, `IO` actions working with file "
"handles often come with the risk of failure. We can therefore simplify "
"things by writing some utility functions and a custom *bind* operator to "
"work with these nested effects. In a new namespace `IOErr`, implement the "
"following utility functions and use these to further cleanup the "
"implementation of `countEmpty'`:"
msgstr ""
"上の例で見てきたように、ファイル制御子を取り回す`IO`行動には失敗する危険性が"
"付き纏います。\n"
"したがってこういった入れ子の作用がを扱ういくらかの小間物関数と自前の*束縛*演"
"算子を書くことで、\n"
"話を簡単にすることができます。\n"
"新しい名前空間`IOErr`の中で以下の小間物関数を実装し、\n"
"これらを使ってさらに`countEmpty'`の実装を綺麗にしましょう。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/IO.md:960
#, no-wrap
msgid ""
"   pure : a -> IO (Either e a)\n"
"\n"
"   fail : e -> IO (Either e a)\n"
"\n"
"   lift : IO a -> IO (Either e a)\n"
"\n"
"   catch : IO (Either e1 a) -> (e1 -> IO (Either e2 a)) -> IO (Either e2 a)\n"
"\n"
"   (>>=) : IO (Either e a) -> (a -> IO (Either e b)) -> IO (Either e b)\n"
"\n"
"   (>>) : IO (Either e ()) -> Lazy (IO (Either e a)) -> IO (Either e a)\n"
msgstr ""
"   pure : a -> IO (Either e a)\n"
"\n"
"   fail : e -> IO (Either e a)\n"
"\n"
"   lift : IO a -> IO (Either e a)\n"
"\n"
"   catch : IO (Either e1 a) -> (e1 -> IO (Either e2 a)) -> IO (Either e2 a)\n"
"\n"
"   (>>=) : IO (Either e a) -> (a -> IO (Either e b)) -> IO (Either e b)\n"
"\n"
"   (>>) : IO (Either e ()) -> Lazy (IO (Either e a)) -> IO (Either e a)\n"

#. type: Bullet: '2. '
#: ../src/Tutorial/IO.md:977
msgid ""
"Write a function `countWords` for counting the words in a file.  Consider "
"using `Data.String.words` and the utilities from exercise 1 in your "
"implementation."
msgstr ""
"ファイル中の単語を数える関数`countWords`を書いてください。\n"
"実装では`Data.String.words`と演習1の小間物を使うことを検討してください。"

#. type: Bullet: '3. '
#: ../src/Tutorial/IO.md:983
msgid ""
"We can generalize the functionality used in `countEmpty` and `countWords`, "
"by implementing a helper function for iterating over the lines in a file and "
"accumulating some state along the way. Implement `withLines` and use it to "
"reimplement `countEmpty` and `countWords`:"
msgstr ""
"ファイル中の行を順次処理し道中の状態を累積するお助け関数を実装することで、\n"
"`countEmpty`と`countWords`で使う機能を一般化することができます。\n"
"`withLines`を実装し、それを使って`countEmpty`と`countWords`を実装してくださ"
"い。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/IO.md:984
#, no-wrap
msgid ""
"   covering\n"
"   withLines :  (path : String)\n"
"             -> (accum : s -> String -> s)\n"
"             -> (initialState : s)\n"
"             -> IO (Either FileError s)\n"
msgstr ""
"   covering\n"
"   withLines :  (path : String)\n"
"             -> (accum : s -> String -> s)\n"
"             -> (initialState : s)\n"
"             -> IO (Either FileError s)\n"

#. type: Bullet: '4. '
#: ../src/Tutorial/IO.md:996
msgid ""
"We often use a `Monoid` for accumulating values.  It is therefore convenient "
"to specialize `withLines` for this case. Use `withLines` to implement "
"`foldLines` according to the type given below:"
msgstr ""
"値を累積するのによく`Monoid`が使われます。\n"
"この場合は`withLines`に特化させると便利になるということですね。\n"
"`withLines`を使って`foldLines`を以下の型に沿って実装してください。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/IO.md:997
#, no-wrap
msgid ""
"   covering\n"
"   foldLines :  Monoid s\n"
"             => (path : String)\n"
"             -> (f    : String -> s)\n"
"             -> IO (Either FileError s)\n"
msgstr ""
"   covering\n"
"   foldLines :  Monoid s\n"
"             => (path : String)\n"
"             -> (f    : String -> s)\n"
"             -> IO (Either FileError s)\n"

#. type: Bullet: '5. '
#: ../src/Tutorial/IO.md:1012
msgid ""
"Implement function `wordCount` for counting the number of lines, words, and "
"characters in a text document. Define a custom record type together with an "
"implementation of `Monoid` for storing and accumulating these values and use "
"`foldLines` in your implementation of `wordCount`."
msgstr ""
"1つの文字文書中の行数、単語数、文字数を形状する関数`wordCount`を実装してくだ"
"さい。\n"
"これらの値を保管し累積できるように自前のレコード型を`Monoid`の実装とともに定"
"義し、\n"
"`foldLines`を`wordCount`の実装で使ってください。"

#. type: Title ##
#: ../src/Tutorial/IO.md:1013
#, no-wrap
msgid "How `IO` is Implemented"
msgstr "`IO`はどのように実装されているのか"

#. type: Plain text
#: ../src/Tutorial/IO.md:1019
msgid ""
"In this final section of an already lengthy chapter, we will risk a glance "
"at how `IO` is implemented in Idris. It is interesting to note, that `IO` is "
"not a built-in type but a regular data type with only one minor speciality. "
"Let's learn about it at the REPL:"
msgstr ""
"随分長くなってしまった章のこの最後の節では、\n"
"勇気を出してIdrisでどのように`IO`が実装されているのか覗いてみましょう。\n"
"面白いことに、`IO`は組み込み型ではないものの、1点些細な特異性がある以外は普通"
"のデータ型なのです。\n"
"そのことをREPLで学びましょう。"

#. type: Fenced code block (repl)
#: ../src/Tutorial/IO.md:1020
#, no-wrap
msgid ""
"Tutorial.IO> :doc IO\n"
"data PrimIO.IO : Type -> Type\n"
"  Totality: total\n"
"  Constructor: MkIO : (1 _ : PrimIO a) -> IO a\n"
"  Hints:\n"
"    Applicative IO\n"
"    Functor IO\n"
"    HasLinearIO IO\n"
"    Monad IO\n"
msgstr ""
"Tutorial.IO> :doc IO\n"
"data PrimIO.IO : Type -> Type\n"
"  Totality: total\n"
"  Constructor: MkIO : (1 _ : PrimIO a) -> IO a\n"
"  Hints:\n"
"    Applicative IO\n"
"    Functor IO\n"
"    HasLinearIO IO\n"
"    Monad IO\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:1037
msgid ""
"Here, we learn that `IO` has a single data constructor called `MkIO`, which "
"takes a single argument of type `PrimIO a` with quantity *1*. We are not "
"going to talk about the quantities here, as in fact they are not important "
"to understand how `IO` works."
msgstr ""
"ここで`IO`が`MkIO`という名前の単一データ構築子を持ち、\n"
"この構築子が型`PrimIO a`で数量子*1*の単一引数を取ることがわかります。\n"
"今は数量子についてお話ししませんが、それは実のところ`IO`の仕組みを理解するの"
"には重要ではないからです。"

#. type: Plain text
#: ../src/Tutorial/IO.md:1039
msgid "Now, `PrimIO a` is a type alias for the following function:"
msgstr "さて、`PrimIO`は以下の関数の型別称です。"

#. type: Fenced code block (repl)
#: ../src/Tutorial/IO.md:1040
#, no-wrap
msgid ""
"Tutorial.IO> :printdef PrimIO\n"
"PrimIO.PrimIO : Type -> Type\n"
"PrimIO a = (1 _ : %World) -> IORes a\n"
msgstr ""
"Tutorial.IO> :printdef PrimIO\n"
"PrimIO.PrimIO : Type -> Type\n"
"PrimIO a = (1 _ : %World) -> IORes a\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:1049
msgid ""
"Again, don't mind the quantities. There is only one piece of the puzzle "
"missing: `IORes a`, which is a publicly exported record type:"
msgstr ""
"繰り返しますが数量子は気にしないでください。\n"
"唯一の見つかっていないパズルピースは`IORes a`で、\n"
"これは公に輸出されているレコード型です。"

#. type: Fenced code block (repl)
#: ../src/Tutorial/IO.md:1050
#, no-wrap
msgid ""
"Solutions.IO> :doc IORes\n"
"data PrimIO.IORes : Type -> Type\n"
"  Totality: total\n"
"  Constructor: MkIORes : a -> (1 _ : %World) -> IORes a\n"
msgstr ""
"Solutions.IO> :doc IORes\n"
"data PrimIO.IORes : Type -> Type\n"
"  Totality: total\n"
"  Constructor: MkIORes : a -> (1 _ : %World) -> IORes a\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:1059
msgid ""
"So, to put this all together, `IO` is a wrapper around something similar to "
"the following function type:"
msgstr ""
"ですので、このことを全てまとめると、`IO`は以下の関数型に似た何かの梱包になり"
"ます。"

#. type: Fenced code block (repl)
#: ../src/Tutorial/IO.md:1060
#, no-wrap
msgid "%World -> (a, %World)\n"
msgstr "%World -> (a, %World)\n"

#. type: Plain text
#: ../src/Tutorial/IO.md:1072
msgid ""
"You can think of type `%World` as a placeholder for the state of the outside "
"world of a program (file system, memory, network connections, and so on). "
"Conceptually, to execute an `IO a` action, we pass it the current state of "
"the world, and in return get an updated world state plus a result of type "
"`a`. The world state being updated represents all the side effects "
"describable in a computer program."
msgstr ""
"型`%World`のことはプログラムの外側の世界の状態（ファイルシステム、記憶装置、"
"ネットワーク接続など）の\n"
"仮置場のように考えられます。\n"
"概念的には、`IO`行動を実行するには世界の現在の状態を渡し、\n"
"更新された世界状態に加えて型`a`の結果が返却される形です。\n"
"更新される世界状態はコンピュータプログラムで表現できる副作用の全てを表現しま"
"す。"

#. type: Plain text
#: ../src/Tutorial/IO.md:1088
msgid ""
"Now, it is important to understand that there is no such thing as the *state "
"of the world*. The `%World` type is just a placeholder, which is converted "
"to some kind of constant that's passed around and never inspected at "
"runtime. So, if we had a value of type `%World`, we could pass it to an `IO "
"a` action and execute it, and this is exactly what happens at runtime: A "
"single value of type `%World` (an uninteresting placeholder like `null`, "
"`0`, or - in case of the JavaScript backends - `undefined`)  is passed to "
"the `main` function, thus setting the whole program in motion. However, it "
"is impossible to programmatically create a value of type `%World` (it is an "
"abstract, primitive type), and therefore we cannot ever extract a value of "
"type `a` from an `IO a` action (modulo `unsafePerformIO`)."
msgstr ""
"ここで理解しておいてほしいことは、*世界の状態*なんてものはないということで"
"す。\n"
"`%World`型はただの仮置場であって、\n"
"受け渡されはするものの実行時に一度も中身が調べられないような類の定数に変換さ"
"れます。\n"
"なので型`%World`の値があったとして、\n"
"`IO a`行動に渡して実行することはできますが、\n"
"これは必ず実行時に起こることなのです。\n"
"つまり、型`%World`の単一の値\n"
"（特に意味のない仮置場で`null`や`0`や、JavaScriptバックエンドでは`undefined`"
"のような値）は\n"
"`main`関数に渡され、\n"
"それから全体のプログラムが動き始めます。\n"
"しかし、型`%World`の値をプログラムで生み出すことは不可能であり、\n"
"したがって型`a`の値を`IO a`行動から抽出することは決してできないのです"
"（`unsafePerformIO`を除く）。"

#. type: Plain text
#: ../src/Tutorial/IO.md:1094
msgid ""
"Once we will talk about monad transformers and the state monad, you will see "
"that `IO` is nothing else but a state monad in disguise but with an abstract "
"state type, which makes it impossible for us to run the stateful computation."
msgstr ""
"モナド変換子と状態モナドについてお話ししたあとでは、\n"
"`IO`が抽象的な状態型付きではあれど変装した状態モナドに過ぎないとわかるでしょ"
"う。\n"
"この抽象的な点により作用付き計算を走らせることができないようになっています。"

#. type: Bullet: '* '
#: ../src/Tutorial/IO.md:1099
msgid ""
"Values of type `IO a` describe programs with side effects, which will "
"eventually result in a value of type `a`."
msgstr ""
"型`IO a`の値は副作用付きのプログラムを記述しており、\n"
"最終的に型`a`の値になります。"

#. type: Bullet: '* '
#: ../src/Tutorial/IO.md:1104
msgid ""
"While we cannot safely extract a value of type `a` from an `IO a`, we can "
"use several combinators and syntactic constructs to combine `IO` actions and "
"build more-complex programs."
msgstr ""
"安全に`IO a`から型`a`の値を取り出すことはできませんが、\n"
"いくつかの結合子と構文的建材によって`IO`行動を組み合わせたりより複雑なプログ"
"ラムを構築できます。"

#. type: Bullet: '* '
#: ../src/Tutorial/IO.md:1107
msgid ""
"*Do blocks* offer a convenient way to run and combine `IO` actions "
"sequentially."
msgstr "*doブロック*があると`IO`行動を順番に組み合わせるのが便利になります。"

#. type: Bullet: '* '
#: ../src/Tutorial/IO.md:1110
msgid ""
"*Do blocks* are desugared to nested applications of *bind* operators "
"(`(>>=)`)."
msgstr "*doブロック*は*束縛*演算子 (`(>>=)`) の入れ子の適用に脱糖されます。"

#. type: Bullet: '* '
#: ../src/Tutorial/IO.md:1114
msgid ""
"*Bind* operators, and thus *do blocks*, can be overloaded to achieve custom "
"behavior instead of the default (monadic) *bind*."
msgstr ""
"*束縛*演算子、そして*doブロック*は、\n"
"既定の（モナドな）*束縛*の代わりとなる自前の振舞いを実現するためにオーバー"
"ロードできます。"

#. type: Bullet: '* '
#: ../src/Tutorial/IO.md:1117
msgid ""
"Under the hood, `IO` actions are stateful computations operating on a "
"symbolic `%World` state."
msgstr ""
"見えないところでは、`IO`行動は象徴としての`%World`状態を操作する状態付き計算"
"になっています。"

#. type: Plain text
#: ../src/Tutorial/IO.md:1123
msgid ""
"Now, that we had a glimpse at *monads* and the *bind* operator, it is time "
"to in the [next chapter](Functor.md) introduce `Monad` and some related "
"interfaces for real."
msgstr ""
"さて、*モナド*と*束縛*演算子をチラ見したところで、\n"
"[次章](Functor.md)でいよいよ`Monad`と関連する実際のインターフェースのいくつか"
"を紹介する時が来ました。"

#. type: Title #
#: ../src/Tutorial/Interfaces.md:1
#, no-wrap
msgid "Interfaces"
msgstr "インターフェース (Interface)"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:9
msgid ""
"Function overloading - the definition of functions with the same name but "
"different implementations - is a concept found in many programming "
"languages. Idris natively supports overloading of functions: Two functions "
"with the same name can be defined in different modules or namespaces, and "
"Idris will try to disambiguate between these based on the types involved. "
"Here is an example:"
msgstr ""
"関数オーバーロード - つまり同名異実装な関数定義 - は多くのプログラミング言語"
"で見られる概念です。\n"
"Idrisには関数のオーバーロードが備わっています。\n"
"つまり、同名の2つの関数は異なるモジュールや名前空間で定義できますし、\n"
"型をもとに曖昧さを解消しようとします。\n"
"例はこちら。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Interfaces.md:10
#, no-wrap
msgid ""
"module Tutorial.Interfaces\n"
"\n"
"%default total\n"
"\n"
"namespace Bool\n"
"  export\n"
"  size : Bool -> Integer\n"
"  size True  = 1\n"
"  size False = 0\n"
"\n"
"namespace Integer\n"
"  export\n"
"  size : Integer -> Integer\n"
"  size = id\n"
"\n"
"namespace List\n"
"  export\n"
"  size : List a -> Integer\n"
"  size = cast . length\n"
msgstr ""
"module Tutorial.Interfaces\n"
"\n"
"%default total\n"
"\n"
"namespace Bool\n"
"  export\n"
"  size : Bool -> Integer\n"
"  size True  = 1\n"
"  size False = 0\n"
"\n"
"namespace Integer\n"
"  export\n"
"  size : Integer -> Integer\n"
"  size = id\n"
"\n"
"namespace List\n"
"  export\n"
"  size : List a -> Integer\n"
"  size = cast . length\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:35
msgid ""
"Here, we defined three different functions called `size`, each in its own "
"namespace. We can disambiguate between these by prefixing them with their "
"namespace:"
msgstr ""
"ここでは`size`という名前の互いに異なる関数をそれぞれの名前空間で定義しまし"
"た。\n"
"これらの曖昧さを解消するにはそれぞれの名前空間を前置すればよいです。"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Interfaces.md:36
#, no-wrap
msgid ""
"Tutorial.Interfaces> :t Bool.size\n"
"Tutorial.Interfaces.Bool.size : Bool -> Integer\n"
msgstr ""
"Tutorial.Interfaces> :t Bool.size\n"
"Tutorial.Interfaces.Bool.size : Bool -> Integer\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:42
msgid "However, this is usually not necessary:"
msgstr "しかし、大抵は必要ありません。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Interfaces.md:43
#, no-wrap
msgid ""
"mean : List Integer -> Integer\n"
"mean xs = sum xs `div` size xs\n"
msgstr ""
"mean : List Integer -> Integer\n"
"mean xs = sum xs `div` size xs\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:51
msgid ""
"As you can see, Idris can disambiguate between the different `size` "
"functions, since `xs` is of type `List Integer`, which unifies only with "
"`List a`, the argument type of `List.size`."
msgstr ""
"見てみるとIdrisは互いに異なる`size`関数の曖昧さを解消できていることがわかりま"
"す。\n"
"`xs`は型`List Integer`であり、この型は`List a`にのみ統合できるので、\n"
"`List a`が引数の型である`List.size`が選ばれます。"

#. type: Title ##
#: ../src/Tutorial/Interfaces.md:52
#, no-wrap
msgid "Interface Basics"
msgstr "インターフェースの基本"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:57
msgid ""
"While function overloading as described above works well, there are use "
"cases, where this form of overloaded functions leads to a lot of code "
"duplication."
msgstr ""
"関数オーバーロードは上述したようにいい感じに動くものの、\n"
"こうした関数オーバーロードの形式だと沢山のコードの重複に繋がるような使用例が"
"あります。"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:61
msgid ""
"As an example, consider a function `cmp` (short for *compare*, which is "
"already exported by the *Prelude*), for describing an ordering for the "
"values of type `String`:"
msgstr ""
"例として、関数`cmp`を考えてみましょう。\n"
"（*compare*を縮めたもので、既に*Prelude*から公開されています。）\n"
"この関数は型`String`の値の序列を表現するものとします。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Interfaces.md:62
#, no-wrap
msgid "cmp : String -> String -> Ordering\n"
msgstr "cmp : String -> String -> Ordering\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:70
msgid ""
"We'd also like to have similar functions for many other data types.  "
"Function overloading allows us to do just that, but `cmp` is not an isolated "
"piece of functionality. From it, we can derive functions like "
"`greaterThan'`, `lessThan'`, `minimum'`, `maximum'`, and many others:"
msgstr ""
"似たような関数が沢山の他のデータ型についても欲しいです。\n"
"これだけだったら関数オーバーロードでいいですが、\n"
"`cmp`の機能性ははそれだけに留まりません。\n"
"この関数があれば`greaterThan`, `lessThan`, `minimum`, `maximum`やその他諸々の"
"関数を導出できます。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Interfaces.md:71
#, no-wrap
msgid ""
"lessThan' : String -> String -> Bool\n"
"lessThan' s1 s2 = LT == cmp s1 s2\n"
"\n"
"greaterThan' : String -> String -> Bool\n"
"greaterThan' s1 s2 = GT == cmp s1 s2\n"
"\n"
"minimum' : String -> String -> String\n"
"minimum' s1 s2 =\n"
"  case cmp s1 s2 of\n"
"    LT => s1\n"
"    _  => s2\n"
"\n"
"maximum' : String -> String -> String\n"
"maximum' s1 s2 =\n"
"  case cmp s1 s2 of\n"
"    GT => s1\n"
"    _  => s2\n"
msgstr ""
"lessThan' : String -> String -> Bool\n"
"lessThan' s1 s2 = LT == cmp s1 s2\n"
"\n"
"greaterThan' : String -> String -> Bool\n"
"greaterThan' s1 s2 = GT == cmp s1 s2\n"
"\n"
"minimum' : String -> String -> String\n"
"minimum' s1 s2 =\n"
"  case cmp s1 s2 of\n"
"    LT => s1\n"
"    _  => s2\n"
"\n"
"maximum' : String -> String -> String\n"
"maximum' s1 s2 =\n"
"  case cmp s1 s2 of\n"
"    GT => s1\n"
"    _  => s2\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:94
msgid ""
"We'd need to implement all of these again for the other types with a `cmp` "
"function, and most if not all of these implementations would be identical to "
"the ones written above. That's a lot of code repetition."
msgstr ""
"これら全てを`cmp`関数を使って他の型について再実装しなくてはならず、\n"
"それにこれらの実装は、全てではないにしても、上に書いたものと同じになりま"
"す。\n"
"そうなると沢山のコードの重複になります。"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:99
msgid ""
"One way to solve this is to use higher-order functions.  For instance, we "
"could define function `minimumBy`, which takes a comparison function as its "
"first argument and returns the smaller of the two remaining arguments:"
msgstr ""
"1つの方法として高階関数を使うという手があります。\n"
"例えば、関数`minimumBy`を定義するとしましょう。\n"
"この関数は最初の引数に比較関数を取り、残りの2つの引数のうちより小さいほうを返"
"します。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Interfaces.md:100
#, no-wrap
msgid ""
"minimumBy : (a -> a -> Ordering) -> a -> a -> a\n"
"minimumBy f a1 a2 =\n"
"  case f a1 a2 of\n"
"    LT => a1\n"
"    _  => a2\n"
msgstr ""
"minimumBy : (a -> a -> Ordering) -> a -> a -> a\n"
"minimumBy f a1 a2 =\n"
"  case f a1 a2 of\n"
"    LT => a1\n"
"    _  => a2\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:114
msgid ""
"This solution is another proof of how higher-order functions allow us to "
"reduce code duplication. However, the need to explicitly pass around the "
"comparison function all the time can get tedious as well.  It would be nice, "
"if we could teach Idris to come up with such a function on its own."
msgstr ""
"この解決策は高階関数があればコードの重複を減らせることの傍証になっていま"
"す。\n"
"しかしながら、いつも比較関数を持ち回らなければいけないのは億劫です。\n"
"Idrisにこの例での比較関数のようなものを自分で思い出せるようにさせられたらいい"
"ですね。"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:116
msgid "Interfaces solve exactly this issue. Here's an example:"
msgstr ""
"インターフェースはまさにこの問題を解消するものです。\n"
"こちらが例です。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Interfaces.md:117
#, no-wrap
msgid ""
"interface Comp a where\n"
"  comp : a -> a -> Ordering\n"
"\n"
"implementation Comp Bits8 where\n"
"  comp = compare\n"
"\n"
"implementation Comp Bits16 where\n"
"  comp = compare\n"
msgstr ""
"interface Comp a where\n"
"  comp : a -> a -> Ordering\n"
"\n"
"implementation Comp Bits8 where\n"
"  comp = compare\n"
"\n"
"implementation Comp Bits16 where\n"
"  comp = compare\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:133
msgid ""
"The code above defines *interface* `Comp` providing function `comp` for "
"calculating the ordering for two values of a type `a`, followed by two "
"*implementations* of this interface for types `Bits8` and `Bits16`. Note, "
"that the `implementation` keyword is optional."
msgstr ""
"上記のコードは*インターフェース*`Comp`を定義し、\n"
"型`a`の2つの値の序列を計算するための関数`comp`を提供しています。\n"
"これにさらにこのインターフェースについての型`Bits8`と`Bits16`のための2つの*実"
"装*が続きます。\n"
"ただし`implementation`キーワードはあってもなくてもよいです。"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:137
msgid ""
"The `comp` implementations for `Bits8` and `Bits16` both use function "
"`compare`, which is part of a similar interface from the *Prelude* called "
"`Ord`."
msgstr ""
"`Bits8`と`Bits16`のための`comp`の実装両方で使われている関数`compare`は、\n"
"*Prelude*の似たようなインターフェースである`Ord`の一部です。"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:139
msgid "The next step is to look at the type of `comp` at the REPL:"
msgstr "次に`comp`の型をREPLで見てみます。"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Interfaces.md:140
#, no-wrap
msgid ""
"Tutorial.Interfaces> :t comp\n"
"Tutorial.Interfaces.comp : Comp a => a -> a -> Ordering\n"
msgstr ""
"Tutorial.Interfaces> :t comp\n"
"Tutorial.Interfaces.comp : Comp a => a -> a -> Ordering\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:154
#, no-wrap
msgid ""
"The interesting part in the type signature of `comp` is\n"
"the initial `Comp a =>` argument. Here, `Comp` is a *constraint* on\n"
"type parameter `a`. This signature can be read as:\n"
"\"For any type `a`, given an implementation\n"
"of interface `Comp` for `a`, we can compare two values\n"
"of type `a` and return an `Ordering` for these.\"\n"
"Whenever we invoke `comp`, we expect Idris to come up with a\n"
"value of type `Comp a` on its own, hence the new `=>` arrow.\n"
"If Idris fails to do so, it will answer with a type error.\n"
msgstr ""
"`comp`の型シグネチャの面白い部分は最初の引数`Comp a =>`です。\n"
"ここで`Comp`は型変数`a`の*制約*です。\n"
"このシグネチャはこんな感じに読めます。\n"
"「あらゆる型`a`、ただしインターフェース`Comp`の実装があるもの、\n"
"については型`a`の2つの値を比較でき、それらの`Ordering`を返す。」\n"
"`comp`をどんなもので呼び出そうとも、\n"
"Idris自ら`Comp a`であるような型の値を思い付いてくれます。\n"
"そう、新しい矢印`=>`があればね。\n"
"もしIdrisがこれに失敗するなら、それは型エラーです。\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:158
msgid ""
"We can now use `comp` in the implementations of related functions.  All we "
"have to do is to also prefix these derived functions with a `Comp` "
"constraint:"
msgstr ""
"これにて`comp`を関係する関数の実装に使えます。\n"
"やらなければいけないことはこれらの導出される関数に`Comp`制約を前置することだ"
"けです。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Interfaces.md:159
#, no-wrap
msgid ""
"lessThan : Comp a => a -> a -> Bool\n"
"lessThan s1 s2 = LT == comp s1 s2\n"
"\n"
"greaterThan : Comp a => a -> a -> Bool\n"
"greaterThan s1 s2 = GT == comp s1 s2\n"
"\n"
"minimum : Comp a => a -> a -> a\n"
"minimum s1 s2 =\n"
"  case comp s1 s2 of\n"
"    LT => s1\n"
"    _  => s2\n"
"\n"
"maximum : Comp a => a -> a -> a\n"
"maximum s1 s2 =\n"
"  case comp s1 s2 of\n"
"    GT => s1\n"
"    _  => s2\n"
msgstr ""
"lessThan : Comp a => a -> a -> Bool\n"
"lessThan s1 s2 = LT == comp s1 s2\n"
"\n"
"greaterThan : Comp a => a -> a -> Bool\n"
"greaterThan s1 s2 = GT == comp s1 s2\n"
"\n"
"minimum : Comp a => a -> a -> a\n"
"minimum s1 s2 =\n"
"  case comp s1 s2 of\n"
"    LT => s1\n"
"    _  => s2\n"
"\n"
"maximum : Comp a => a -> a -> a\n"
"maximum s1 s2 =\n"
"  case comp s1 s2 of\n"
"    GT => s1\n"
"    _  => s2\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:185
msgid ""
"Note, how the definition of `minimum` is almost identical to `minimumBy`. "
"The only difference being that in case of `minimumBy` we had to pass the "
"comparison function as an explicit argument, while for `minimum` it is "
"provided as part of the `Comp` implementation, which is passed around by "
"Idris for us."
msgstr ""
"`minimum`の定義は`minimumBy`と瓜二つですね。\n"
"強いて違うところを挙げるとすれば、\n"
"`minimumBy`の場合は比較関数を明示的な引数として渡さねばならないところ、\n"
"`minimum`は`Comp`の実装の一部で提供されているのでIdrisが代わりに渡してくれる"
"ことです。"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:188
msgid ""
"Thus, we have defined all these utility functions once and for all for every "
"type with an implementation of interface `Comp`."
msgstr ""
"したがってこれら全ての小間物的関数を一度定義してしまえば、\n"
"インターフェース`Comp`の実装がある全ての型に適用できます。"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:195
#, no-wrap
msgid ""
"1. Implement function `anyLarger`, which should return `True`,\n"
"if and only if a list of values contains at least one element larger\n"
"than a given reference value. Use interface `Comp` in your\n"
"implementation.\n"
msgstr ""
"1. 関数`anyLarger`を実装してください。\n"
"この関数は、値のリストが与えられた参照値より大きい要素を少なくとも1つ含んでいるときに限り`True`を返します。\n"
"インターフェース`Comp`を実装で使ってください。\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:200
#, no-wrap
msgid ""
"2. Implement function `allLarger`, which should return `True`,\n"
"if and only if a list of values contains *only* elements larger\n"
"than a given reference value. Note, that this is trivially true\n"
"for the empty list. Use interface `Comp` in your implementation.\n"
msgstr ""
"2. 関数`allLarger`を実装してください。\n"
"この関数は、値のリストが与えられた参照値より大きい要素*のみ*を含んでいるときに限り`True`を返します。\n"
"ここで、自明な場合である空リストについては真になります。\n"
"インターフェース`Comp`を実装で使ってください。\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:206
#, no-wrap
msgid ""
"3. Implement function `maxElem`, which tries to extract the\n"
"largest element from a list of values with a `Comp` implementation.\n"
"Likewise for `minElem`, which tries to extract the smallest element.\n"
"Note, that the possibility of the list being empty must be considered\n"
"when deciding on the output type.\n"
msgstr ""
"3. 関数`maxElem`を実装してください。\n"
"この関数は`Comp`の実装を使って値のリストから最も大きい要素を抽出しようとします。\n"
"`minElem`も同様にしてください。\n"
"この関数は最も小さい要素を抽出しようとするものです。\n"
"出力の型を決めるときは、リストが空になる可能性があることを考慮しなくてはいけませんよ。\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:210
#, no-wrap
msgid ""
"4. Define an interface `Concat` for values like lists or\n"
"strings, which can be concatenated. Provide implementations\n"
"for lists and strings.\n"
msgstr ""
"4. リストや文字列のような連結できる値のためのインターフェース`Concat`を定義してください。\n"
"リストと文字列向けの実装を提供してください。\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:215
#, no-wrap
msgid ""
"5. Implement function `concatList` for concatenating the\n"
"values in a list holding values with a `Concat` implementation.\n"
"Make sure to reflect the possibility of the list being empty in your\n"
"output type.\n"
msgstr ""
"5. `Concat`の実装が備わる値を持つリスト中の値を連結する関数`concatList`を実装してください。\n"
"リストが空になる可能性があることを出力の型に反映してくださいね。\n"

#. type: Title ##
#: ../src/Tutorial/Interfaces.md:216
#, no-wrap
msgid "More about Interfaces"
msgstr "もっとインターフェース"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:224
msgid ""
"In the last section, we learned about the very basics of interfaces: Why "
"they are useful and how to define and implement them.  In this section, we "
"will learn about some slightly advanced concepts: Extending interfaces, "
"interfaces with constraints, and default implementations."
msgstr ""
"先の節ではごく基本的なインターフェースを学びました。\n"
"なぜ便利なのか、そしてどのように定義し実装するのかについてです。\n"
"この節では僅かに発展的な概念を学びます。\n"
"それはインターフェースを拡張すること、制約付きのインターフェース、そして既定"
"実装です。"

#. type: Title ###
#: ../src/Tutorial/Interfaces.md:225
#, no-wrap
msgid "Extending Interfaces"
msgstr "インターフェースを拡張する"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:233
msgid ""
"Some interfaces form a kind of hierarchy. For instance, for the `Concat` "
"interface used in exercise 4, there might be a child interface called "
"`Empty`, for those types, which have a neutral element with relation to "
"concatenation.  In such a case, we make an implementation of `Concat` a "
"prerequisite for implementing `Empty`:"
msgstr ""
"階層を形成するインターフェースがあります。\n"
"例えば演習4で使った`Concat`インターフェースについては、\n"
"`Empty`という名前の子インターフェースがあってもいいでしょう。\n"
"このインターフェースを満たすような型には、連結の際に何の効果も生じない値があ"
"ります。\n"
"そのような場合、`Concat`の実装が`Empty`の実装の必要条件にできます。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Interfaces.md:234
#, no-wrap
msgid ""
"interface Concat a where\n"
"  concat : a -> a -> a\n"
"\n"
"implementation Concat String where\n"
"  concat = (++)\n"
"\n"
"interface Concat a => Empty a where\n"
"  empty : a\n"
"\n"
"implementation Empty String where\n"
"  empty = \"\"\n"
msgstr ""
"interface Concat a where\n"
"  concat : a -> a -> a\n"
"\n"
"implementation Concat String where\n"
"  concat = (++)\n"
"\n"
"interface Concat a => Empty a where\n"
"  empty : a\n"
"\n"
"implementation Empty String where\n"
"  empty = \"\"\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:254
#, no-wrap
msgid ""
"`Concat a => Empty a` should be read as: \"An implementation\n"
"of `Concat` for type `a` is a *prerequisite* for there being\n"
"an implementation of `Empty` for `a`.\"\n"
"But this also means that, whenever we have an implementation\n"
"of interface `Empty`, we *must* also have an implementation of `Concat`\n"
"and can invoke the corresponding functions:\n"
msgstr ""
"`Concat a => Empty a`はこのように読めます。\n"
"「`Concat`の型`a`のための実装は、`a`に対して`Empty`の実装をするための必要条件である。」\n"
"しかしこれは、インターフェース`Empty`の実装があるならば、常に`Concat`の実装が*なくてはならず*、\n"
"いつでも`Concat`にある関数を呼び出すことができる、という意味でもあるのです。\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Interfaces.md:255
#, no-wrap
msgid ""
"concatListE : Empty a => List a -> a\n"
"concatListE []        = empty\n"
"concatListE (x :: xs) = concat x (concatListE xs)\n"
msgstr ""
"concatListE : Empty a => List a -> a\n"
"concatListE []        = empty\n"
"concatListE (x :: xs) = concat x (concatListE xs)\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:264
msgid ""
"Note, how in the type of `concatListE` we only used an `Empty` constraint, "
"and how in the implementation we were still able to invoke both `empty` and "
"`concat`."
msgstr ""
"`concatListE`の型で`Empty`制約のみ使っているにも関わらず、\n"
"実装で`empty`と`concat`の両方を呼び出せていますね。"

#. type: Title ###
#: ../src/Tutorial/Interfaces.md:265
#, no-wrap
msgid "Constrained Implementations"
msgstr "制約付きの実装"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:273
msgid ""
"Sometimes, it is only possible to implement an interface for a generic type, "
"if its type parameters implement this interface as well. For instance, "
"implementing interface `Comp` for `Maybe a` makes sense only if type `a` "
"itself implements `Comp`. We can constrain interface implementations with "
"the same syntax we use for constrained functions:"
msgstr ""
"ときに、ある汎化型のインターフェースを実装できるのが、\n"
"その型変数がこのインターフェースを実装しているときだけ、ということがありま"
"す。\n"
"たとえば、インターフェース`Comp`を`Maybe a`に実装するのが可能なのは、\n"
"型`a`自体が`Comp`を実装しているときだけです。\n"
"インターフェースの実装に制約を課すのは、制約付きの関数で使ったのと同じ文法で"
"できます。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Interfaces.md:274
#, no-wrap
msgid ""
"implementation Comp a => Comp (Maybe a) where\n"
"  comp Nothing  Nothing  = EQ\n"
"  comp (Just _) Nothing  = GT\n"
"  comp Nothing  (Just _) = LT\n"
"  comp (Just x) (Just y) = comp x y\n"
msgstr ""
"implementation Comp a => Comp (Maybe a) where\n"
"  comp Nothing  Nothing  = EQ\n"
"  comp (Just _) Nothing  = GT\n"
"  comp Nothing  (Just _) = LT\n"
"  comp (Just x) (Just y) = comp x y\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:292
msgid ""
"This is not the same as extending an interface, although the syntax looks "
"very similar. Here, the constraint lies on a *type parameter* instead of the "
"full type.  The last line in the implementation of `Comp (Maybe a)` compares "
"the values stored in the two `Just`s. This is only possible, if there is a "
"`Comp` implementation for these values as well. Go ahead, and remove the "
"`Comp a` constraint from the above implementation. Learning to read and "
"understand Idris' type errors is important for fixing them."
msgstr ""
"これはインターフェースを拡張することとは同じではありません。\n"
"文法がよく似てはいますが。\n"
"制約は*型変数*に課されていて、全体の型ではないですね。\n"
"`Comp (Maybe a)`の実装の最後の行では2つの`Just`に格納された値を比較します。\n"
"これが可能となるのは、これらの値にも`Comp`の実装があるときだけです。\n"
"さあ、上記の実装から`Comp a`制約を消去してみましょう。\n"
"Idrisの型エラーを読み解くことは、修正を行う上で大事です。"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:295
msgid "The good thing is, that Idris will solve all these constraints for us:"
msgstr "幸いにもIdrisはこれら全ての制約を代わりに解いてくれます。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Interfaces.md:296
#, no-wrap
msgid ""
"maxTest : Maybe Bits8 -> Ordering\n"
"maxTest = comp (Just 12)\n"
msgstr ""
"maxTest : Maybe Bits8 -> Ordering\n"
"maxTest = comp (Just 12)\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:305
msgid ""
"Here, Idris tries to find an implementation for `Comp (Maybe Bits8)`.  In "
"order to do so, it needs an implementation for `Comp Bits8`.  Go ahead, and "
"replace `Bits8` in the type of `maxTest` with `Bits64`, and have a look at "
"the error message Idris produces."
msgstr ""
"ここでIdrisは`Comp (Maybe Bits8)`の実装を見つけ出そうとします。\n"
"そのためには`Comp Bits8`のための実装が必要です。\n"
"さあさあ`maxInt`の型にある`Bits8`を`Bits64`に変えてみましょう。\n"
"どんなエラー文言をIdrisが出すでしょうか。"

#. type: Title ###
#: ../src/Tutorial/Interfaces.md:306
#, no-wrap
msgid "Default Implementations"
msgstr "既定実装"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:320
msgid ""
"Sometimes, we'd like to pack several related functions in an interface to "
"allow programmers to implement each in the most efficient way, although they "
"*could* be implemented in terms of each other. For instance, consider an "
"interface `Equals` for comparing two values for equality, with functions "
"`eq` returning `True` if two values are equal and `neq` returning `True` if "
"they are not. Surely, we can implement `neq` in terms of `eq`, so most of "
"the time when implementing `Equals`, we will only implement the latter.  In "
"this case, we can give an implementation for `neq` already in the definition "
"of `Equals`:"
msgstr ""
"ときどき、いくつかの関係する関数を1つのインターフェースに収めて、\n"
"そのインターフェースにある関数を使うことが*できながらも*、\n"
"プログラマがそれぞれの関数をもっとも効率的に動くように実装できるようにしたい"
"ことがあります。\n"
"たとえば、2つの値の等値性で比較するインターフェース`Equals`を考えましょう。\n"
"このインターフェースには2つの値が等しいとき`True`を返す関数`eq`と、\n"
"等しくないときに`True`を返す`neq`があります。\n"
"もちろん`neq`は`eq`を使って実装できますし、\n"
"ほとんどの場合で`Equals`を実装するときは`eq`のみを実装すればよいでしょう。\n"
"この場合、`neq`の実装を`Equals`の定義中に含めてしまうことができます。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Interfaces.md:321
#, no-wrap
msgid ""
"interface Equals a where\n"
"  eq : a -> a -> Bool\n"
"\n"
"  neq : a -> a -> Bool\n"
"  neq a1 a2 = not (eq a1 a2)\n"
msgstr ""
"interface Equals a where\n"
"  eq : a -> a -> Bool\n"
"\n"
"  neq : a -> a -> Bool\n"
"  neq a1 a2 = not (eq a1 a2)\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:332
msgid ""
"If in an implementation of `Equals` we only implement `eq`, Idris will use "
"the default implementation for `neq` as shown above:"
msgstr ""
"`Equals`の実装で`eq`のみ実装した場合は、\n"
"Idrisは上記の`neq`の既定実装を使うことになります。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Interfaces.md:333
#, no-wrap
msgid ""
"Equals String where\n"
"  eq = (==)\n"
msgstr ""
"Equals String where\n"
"  eq = (==)\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:340
msgid ""
"If on the other hand we'd like to provide explicit implementations for both "
"functions, we can do so as well:"
msgstr "他方で両方の関数に陽に実装を提供したい場合も同様に可能です。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Interfaces.md:341
#, no-wrap
msgid ""
"Equals Bool where\n"
"  eq True True   = True\n"
"  eq False False = True\n"
"  eq _ _         = False\n"
"\n"
"  neq True  False = True\n"
"  neq False True  = True\n"
"  neq _ _         = False\n"
msgstr ""
"Equals Bool where\n"
"  eq True True   = True\n"
"  eq False False = True\n"
"  eq _ _         = False\n"
"\n"
"  neq True  False = True\n"
"  neq False True  = True\n"
"  neq _ _         = False\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:358
#, no-wrap
msgid ""
"1. Implement interfaces `Equals`, `Comp`, `Concat`, and\n"
"  `Empty` for pairs, constraining your implementations as necessary.\n"
"  (Note, that multiple constraints can be given sequentially like\n"
"  other function arguments: `Comp a => Comp b => Comp (a,b)`.)\n"
msgstr ""
"1. インターフェース`Equals`, `Comp`, `Concat`, `Empty`を対（2つ組タプル）に実装してください。\n"
"  実装では必要に応じて制約を課して構いません。\n"
"  （他の関数の引数と同様に、複数の制約を連続して課すことができます。\n"
"  例えば`Comp a => Comp b => Comp (a,b)`です。）\n"

#. type: Bullet: '2. '
#: ../src/Tutorial/Interfaces.md:361
msgid ""
"Below is an implementation of a binary tree. Implement interfaces `Equals` "
"and `Concat` for this type."
msgstr ""
"以下は2分木の実装です。\n"
"インターフェース`Equals`と`Concat`をこの型に実装してください。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Interfaces.md:362
#, no-wrap
msgid ""
"   data Tree : Type -> Type where\n"
"     Leaf : a -> Tree a\n"
"     Node : Tree a -> Tree a -> Tree a\n"
msgstr ""
"   data Tree : Type -> Type where\n"
"     Leaf : a -> Tree a\n"
"     Node : Tree a -> Tree a -> Tree a\n"

#. type: Title ##
#: ../src/Tutorial/Interfaces.md:368
#, no-wrap
msgid "Interfaces in the *Prelude*"
msgstr "*Prelude*にあるインターフェース"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:374
msgid ""
"The Idris *Prelude* provides several interfaces plus implementations that "
"are useful in almost every non-trivial program. I'll introduce the basic "
"ones here. The more advanced ones will be discussed in later chapters."
msgstr ""
"Idrisの*Prelude*はいくつかのインターフェースと実装を提供します。\n"
"これらはほぼ全てのある程度以上のプログラムで便利です。\n"
"基本的なものをここで紹介します。\n"
"より発展的なものは後の章でお話ししましょう。"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:378
msgid ""
"Most of these interfaces come with associated mathematical laws, and "
"implementations are assumed to adhere to these laws. These laws will be "
"given here as well."
msgstr ""
"これらのインターフェースのほとんどは数学的な法則に関連します。\n"
"そして、実装はこれらの実装に従うことになっています。\n"
"法則についてもここで触れます。"

#. type: Title ###
#: ../src/Tutorial/Interfaces.md:379
#, no-wrap
msgid "`Eq`"
msgstr "`Eq`"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:389
msgid ""
"Probably the most often used interface, `Eq` corresponds to interface "
"`Equals` we used above as an example. Instead of `eq` and `neq`, `Eq` "
"provides two operators `(==)` and `(/=)` for comparing two values of the "
"same type for being equal or not. Most of the data types defined in the "
"*Prelude* come with an implementation of `Eq`, and whenever programmers "
"define their own data types, `Eq` is typically one of the first interfaces "
"they implement."
msgstr ""
"おそらく最も使われているインターフェースは`Eq`でしょう。\n"
"これは前述の例で使ったインターフェース`Equal`に対応します。\n"
"`eq`と`neq`の代わりに、`Eq`は2つの演算子`(==)`と`(/=)`を提供し、\n"
"2つの同じ型の値について等しいか異なるかを比べられます。\n"
"*Prelude*で定義されているほとんどのデータ型は`Eq`の実装付きですし、\n"
"プログラマが自前のデータ型を作るときも最初に実装するインターフェースでしょ"
"う。"

#. type: Title ####
#: ../src/Tutorial/Interfaces.md:390
#, no-wrap
msgid "`Eq` Laws"
msgstr "`Eq`の法則"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:393
msgid "We expect the following laws to hold for all implementations of `Eq`:"
msgstr "`Eq`の全ての実装について以下の法則を満たすようにしてください。"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:396
#, no-wrap
msgid ""
"* `(==)` is *reflexive*: `x == x = True` for all `x`. This means, that\n"
"every value is equal to itself.\n"
msgstr ""
"* `(==)`は*反射的*です。\n"
"`x == x = True`が全ての`x`について成り立ちます。\n"
"つまり、全ての値はそれ自身と等しいです。\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:399
#, no-wrap
msgid ""
"* `(==)` is *symmetric*: `x == y = y == x` for all `x` and `y`.\n"
"This means, that the order of arguments passed to `(==)` does not matter.\n"
msgstr ""
"* `(==)`は*対称的*です。\n"
"`x == y = y == x`が全ての`x`と`y`について成り立ちます。\n"
"つまり、`(==)`の引数の順序は重要ではありません。\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:402
#, no-wrap
msgid ""
"* `(==)` is *transitive*: From `x == y = True` and `y == z = True` follows\n"
"`x == z = True`.\n"
msgstr ""
"* `(==)`は*推移的*です。\n"
"`x == y = True`と`y == z = True`から`x == z = True`が導かれます。\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:405
#, no-wrap
msgid ""
"* `(/=)` is the negation of `(==)`: `x == y = not (x /= y)`\n"
"for all `x` and `y`.\n"
msgstr "* `(/=)`は`(==)`の否定です。`x == y = not (x /= y)`が全ての`x`と`y`について成り立ちます。\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:410
msgid ""
"In theory, Idris has the power to verify these laws at compile time for many "
"non-primitive types. However, out of pragmatism this is not required when "
"implementing `Eq`, since writing such proofs can be quite involved."
msgstr ""
"理論上、Idrisにはこれらの法則を非原始型に対してコンパイル時に検証する能力があ"
"ります。\n"
"しかしながら、実用上`Eq`の実装には必要ではありません。\n"
"そのような証明を書くというのはちょっとしたハマりどころだからです。"

#. type: Title ###
#: ../src/Tutorial/Interfaces.md:411
#, no-wrap
msgid "`Ord`"
msgstr "`Ord`"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:419
#, no-wrap
msgid ""
"The pendant to `Comp` in the *Prelude* is interface `Ord`. In addition\n"
"to `compare`, which is identical to our own `comp` it provides comparison\n"
"operators `(>=)`, `(>)`, `(<=)`, and `(<)`, as well as utility functions\n"
"`max` and `min`. Unlike `Comp`, `Ord` extends `Eq`,\n"
"so whenever there is an `Ord` constraint, we also have access to operators\n"
"`(==)` and `(/=)` and related functions.\n"
msgstr ""
"*Prelude*版`Comp`として`Ord`があります。\n"
"自前の`comp`と等価な`compare`に加えて、\n"
"比較演算子`(>=)`, `(>)`, `(<=)`, `(<)`や小間物関数`max`と`min`を提供します。\n"
"`Comp`とは異なり、`Ord`は`Eq`を拡張します。\n"
"なので`Ord`制約がある場合は、常に演算子`(==)`および`(/=)`と関連する関数が使えます。\n"

#. type: Title ####
#: ../src/Tutorial/Interfaces.md:420
#, no-wrap
msgid "`Ord` Laws"
msgstr "`Ord`の法則"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:423
msgid "We expect the following laws to hold for all implementations of `Ord`:"
msgstr "`Ord`の全ての実装について以下の法則を満たすようにしてください。"

#. type: Bullet: '* '
#: ../src/Tutorial/Interfaces.md:433
msgid "`(<=)` is *reflexive* and *transitive*."
msgstr "`(<=)`は*反射的*で*推移的*です。"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:433
#, no-wrap
msgid ""
"* `(<=)` is *antisymmetric*: From `x <= y = True` and `y <= x = True`\n"
"follows `x == y = True`.\n"
"* `x <= y = y >= x`.\n"
"* `x < y = not (y <= x)`\n"
"* `x > y = not (y >= x)`\n"
"* `compare x y = EQ` => `x == y = True`\n"
"* `compare x y == GT = x > y`\n"
"* `compare x y == LT = x < y`\n"
msgstr ""
"* `(<=)`は*非対称的*です。\n"
"`x <= y = True`と`y <= x = True`から`x == y = True`が導かれます。\n"
"* `x <= y = y >= x`\n"
"* `x < y = not (y <= x)`\n"
"* `x > y = not (y >= x)`\n"
"* `compare x y = EQ` => `x == y = True`\n"
"* `compare x y == GT = x > y`\n"
"* `compare x y == LT = x < y`\n"

#. type: Title ###
#: ../src/Tutorial/Interfaces.md:434
#, no-wrap
msgid "`Semigroup` and `Monoid`"
msgstr "`Semigroup`と`Monoid`"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:439
#, no-wrap
msgid ""
"`Semigroup` is the pendant to our example interface `Concat`,\n"
"with operator `(<+>)` (also called *append*) corresponding\n"
"to function `concat`.\n"
msgstr ""
"`Semigroup`は例に出てきたインターフェース`Concat`のようなもので、\n"
"関数`concat`に対応する演算子`(<+>)`（*append*とも）を持ちます。\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:442
msgid ""
"Likewise, `Monoid` corresponds to `Empty`, with `neutral` corresponding to "
"`empty`."
msgstr ""
"同様に`Monoid`は`Empty`に対応するもので、`empty`に対応する`neutral`がありま"
"す。"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:449
msgid ""
"These are incredibly important interfaces, which can be used to combine two "
"or more values of a data type into a single value of the same type. Examples "
"include but are not limited to addition or multiplication of numeric types, "
"concatenation of sequences of data, or sequencing of computations."
msgstr ""
"これらは極めて重要なインターフェースで、\n"
"2つ以上のデータ型の値を単一の同じ型の値に結合するのに使えます。\n"
"前述の例にもありましたが数値型の和や積に留まらず、\n"
"連続するデータや連続する計算処理の結合にも使えます。"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:455
msgid ""
"As an example, consider a data type for representing distances in a "
"geometric application. We could just use `Double` for this, but that's not "
"very type safe. It would be better to use a single field record wrapping "
"values type `Double`, to give such values clear semantics:"
msgstr ""
"例として地理を扱うアプリケーションでの距離を表すデータ型を考えます。\n"
"単に`Double`を使うこともできますが、あまり型安全ではありません。\n"
"単一のフィールドを持つレコード型で`Double`型の値をくるむとよいでしょう。\n"
"値に明確な意味論が備わるためです。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Interfaces.md:456
#, no-wrap
msgid ""
"record Distance where\n"
"  constructor MkDistance\n"
"  meters : Double\n"
msgstr ""
"record Distance where\n"
"  constructor MkDistance\n"
"  meters : Double\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:465
msgid ""
"There is a natural way for combining two distances: We sum up the values "
"they hold. This immediately leads to an implementation of `Semigroup`:"
msgstr ""
"2つの距離を結合するには自然な方法があります。\n"
"それらが持つ値を加算すればよいのです。\n"
"そこで直ちに`Semigroup`の実装が導かれます。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Interfaces.md:466
#, no-wrap
msgid ""
"Semigroup Distance where\n"
"  x <+> y = MkDistance $ x.meters + y.meters\n"
msgstr ""
"Semigroup Distance where\n"
"  x <+> y = MkDistance $ x.meters + y.meters\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:474
msgid ""
"It is also immediately clear, that zero is the neutral element of this "
"operation: Adding zero to any value does not affect the value at all.  This "
"allows us to implement `Monoid` as well:"
msgstr ""
"これも直ちに明らかなことですが、\n"
"ゼロはこの操作での中立的な要素です。\n"
"ゼロを加算しても値には何ら影響がありません。\n"
"これにより`Monoid`も同様に実装できます。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Interfaces.md:475
#, no-wrap
msgid ""
"Monoid Distance where\n"
"  neutral = MkDistance 0\n"
msgstr ""
"Monoid Distance where\n"
"  neutral = MkDistance 0\n"

#. type: Title ####
#: ../src/Tutorial/Interfaces.md:480
#, no-wrap
msgid "`Semigroup` and `Monoid` Laws"
msgstr "`Semigroup`と`Monoid`の法則"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:484
msgid ""
"We expect the following laws to hold for all implementations of `Semigroup` "
"and `Monoid`:"
msgstr ""
"`Semigroup`と`Monoid`の全ての実装について以下の法則を満たすようにしてくださ"
"い。"

#. type: Bullet: '* '
#: ../src/Tutorial/Interfaces.md:489
msgid ""
"`(<+>)` is *associative*: `x <+> (y <+> z) = (x <+> y) <+> z`, for all "
"values `x`, `y`, and `z`."
msgstr ""
"`(<+>)`は結合的です。\n"
"`x <+> (y <+> z) = (x <+> y) <+> z`は全ての`x`, `y`, `z`の値について成り立ち"
"ます。"

#. type: Bullet: '* '
#: ../src/Tutorial/Interfaces.md:489
msgid ""
"`neutral` is the *neutral element* with relation to `(<+>)`: `neutral <+> x "
"= x <+> neutral = x`, for all `x`."
msgstr ""
"`neural`は`(<+>)`に関して*中立な要素*です。\n"
"`neural <+> x = x <+> neural = x`が全ての`x`について成り立ちます。"

#. type: Title ###
#: ../src/Tutorial/Interfaces.md:490
#, no-wrap
msgid "`Show`"
msgstr "`Show`"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:497
msgid ""
"The `Show` interface is mainly used for debugging purposes, and is supposed "
"to display values of a given type as a string, typically closely resembling "
"the Idris code used to create the value. This includes the proper wrapping "
"of arguments in parentheses where necessary. For instance, experiment with "
"the output of the following function at the REPL:"
msgstr ""
"`Show`インターフェースは主にデバッグ用途で使われ、\n"
"与えられた型の値を文字列として表示するためのものです。\n"
"典型的にはその値を作るIdrisのコードに近付けることが多いです。\n"
"その場合は必要に応じて括弧内に引数を適切にくるむことがあります。\n"
"例えば以下の関数の出力がどうなるかREPLでやってみてください。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Interfaces.md:498
#, no-wrap
msgid ""
"showExample : Maybe (Either String (List (Maybe Integer))) -> String\n"
"showExample = show\n"
msgstr ""
"showExample : Maybe (Either String (List (Maybe Integer))) -> String\n"
"showExample = show\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Interfaces.md:505
#, no-wrap
msgid ""
"Tutorial.Interfaces> showExample (Just (Right [Just 12, Nothing]))\n"
"\"Just (Right [Just 12, Nothing])\"\n"
msgstr ""
"Tutorial.Interfaces> showExample (Just (Right [Just 12, Nothing]))\n"
"\"Just (Right [Just 12, Nothing])\"\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:511
msgid "We will learn how to implement instances of `Show` in an exercise."
msgstr "`Show`のインスタンスを実装する方法は演習で学びましょう。"

#. type: Title ###
#: ../src/Tutorial/Interfaces.md:512
#, no-wrap
msgid "Overloaded Literals"
msgstr "オーバーロードされたリテラル"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:524
msgid ""
"Literal values in Idris, such as integer literals (`12001`), string literals "
"(`\"foo bar\"`), floating point literals (`12.112`), and character literals "
"(`'$'`) can be overloaded. This means, that we can create values of types "
"other than `String` from just a string literal. The exact workings of this "
"has to wait for another section, but for many common cases, it is sufficient "
"for a value to implement interfaces `FromString` (for using string "
"literals), `FromChar` (for using character literals), or `FromDouble` (for "
"using floating point literals).  The case of integer literals is special, "
"and will be discussed in the next section."
msgstr ""
"Idrisのリテラル値、例えば整数リテラル (`12001`)、\n"
"文字列リテラル (`\"foo bar\"`)、\n"
"浮動小数点数リテラル (`12.112`) 、そして文字リテラル (`'$'`) はオーバーロード"
"できます。\n"
"つまり、`String`ではない型の値を単なる文字列リテラルから作れるということで"
"す。\n"
"ちゃんとした仕組みは他の節まで待たなければいけませんが、\n"
"大体はインターフェース`FromString`（文字列リテラル用）や\n"
"`FromChar` （文字リテラル用）や`FromDouble`（浮動小数点リテラル用）を実装すれ"
"ば充分でしょう。\n"
"整数リテラルについては特殊なので次の節で詳述します。"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:531
msgid ""
"Here is an example of using `FromString`. Assume, we write an application "
"where users can identify themselves with a username and password. Both "
"consist of strings of characters, so it is pretty easy to confuse and mix up "
"the two things, although they clearly have very different semantics.  In "
"these cases, it is advisable to come up with new types for the two, "
"especially since getting these things wrong is a security concern."
msgstr ""
"`FromString`の使用例はこちらです。\n"
"アプリケーションを書いており、利用者が利用者名とパスワードで自身であることを"
"同定できるものだとします。\n"
"いずれも文字からなる文字列なので、\n"
"2つを混同してしまいがちです。\n"
"はっきりと異なる意味論を持つものではあるのですが。\n"
"この場合、これら2つのために新しい型を用意することが望ましいです。\n"
"特にこれらを取り違えたりなんかするとセキュリティ上の問題になりますから。"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:533
msgid "Here are three example record types to do this:"
msgstr "例としてレコード型を3つ用意しました。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Interfaces.md:534
#, no-wrap
msgid ""
"record UserName where\n"
"  constructor MkUserName\n"
"  name : String\n"
"\n"
"record Password where\n"
"  constructor MkPassword\n"
"  value : String\n"
"\n"
"record User where\n"
"  constructor MkUser\n"
"  name     : UserName\n"
"  password : Password\n"
msgstr ""
"record UserName where\n"
"  constructor MkUserName\n"
"  name : String\n"
"\n"
"record Password where\n"
"  constructor MkPassword\n"
"  value : String\n"
"\n"
"record User where\n"
"  constructor MkUser\n"
"  name     : UserName\n"
"  password : Password\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:551
msgid ""
"In order to create a value of type `User`, even for testing, we'd have to "
"wrap all strings using the given constructors:"
msgstr ""
"型`User`の値を作るには、試したいときであっても、\n"
"逐一文字列を構築子でくるむ必要があります。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Interfaces.md:552
#, no-wrap
msgid ""
"hock : User\n"
"hock = MkUser (MkUserName \"hock\") (MkPassword \"not telling\")\n"
msgstr ""
"hock : User\n"
"hock = MkUser (MkUserName \"hock\") (MkPassword \"not telling\")\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:560
msgid ""
"This is rather cumbersome, and some people might think this to be too high a "
"price to pay just for an increase in type safety (I'd tend to disagree).  "
"Luckily, we can get the convenience of string literals back very easily:"
msgstr ""
"これはわりとまどろっこしく、型安全性を増すには割に合わなさすぎると考える人も"
"いるでしょう。\n"
"（私はどちらかというと違いますが。）\n"
"幸運にも文字列リテラルの便利さをとても簡単に取り戻せます。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Interfaces.md:561
#, no-wrap
msgid ""
"FromString UserName where\n"
"  fromString = MkUserName\n"
"\n"
"FromString Password where\n"
"  fromString = MkPassword\n"
"\n"
"hock2 : User\n"
"hock2 = MkUser \"hock\" \"not telling\"\n"
msgstr ""
"FromString UserName where\n"
"  fromString = MkUserName\n"
"\n"
"FromString Password where\n"
"  fromString = MkPassword\n"
"\n"
"hock2 : User\n"
"hock2 = MkUser \"hock\" \"not telling\"\n"

#. type: Title ###
#: ../src/Tutorial/Interfaces.md:572
#, no-wrap
msgid "Numeric Interfaces"
msgstr "数的インターフェース"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:577
msgid ""
"The *Prelude* also exports several interfaces providing the usual arithmetic "
"operations. Below is a comprehensive list of the interfaces and the "
"functions each provides:"
msgstr ""
"*Prelude*はよくある代数操作を提供するインターフェースもいくつか公開していま"
"す。\n"
"以下はインターフェースと提供されている関数の網羅的な一覧です。"

#. type: Bullet: '* '
#: ../src/Tutorial/Interfaces.md:582
msgid "`Num`"
msgstr "`Num`"

#. type: Bullet: '  * '
#: ../src/Tutorial/Interfaces.md:582
msgid "`(+)` : Addition"
msgstr "`(+)`: 加算"

#. type: Bullet: '  * '
#: ../src/Tutorial/Interfaces.md:582
msgid "`(*)` : Multiplication"
msgstr "`(*)`: 乗算"

#. type: Bullet: '  * '
#: ../src/Tutorial/Interfaces.md:582
msgid "`fromInteger` : Overloaded integer literals"
msgstr "`fromInteger`: オーバーロードされた整数リテラル"

#. type: Bullet: '* '
#: ../src/Tutorial/Interfaces.md:586
msgid "`Neg`"
msgstr "`Neg`"

#. type: Bullet: '  * '
#: ../src/Tutorial/Interfaces.md:586
msgid "`negate` : Negation"
msgstr "`negate` : 正負反転"

#. type: Bullet: '  * '
#: ../src/Tutorial/Interfaces.md:586
msgid "`(-)` : Subtraction"
msgstr "`(-)`: 減算"

#. type: Bullet: '* '
#: ../src/Tutorial/Interfaces.md:590
msgid "`Integral`"
msgstr "整数"

#. type: Bullet: '  * '
#: ../src/Tutorial/Interfaces.md:590
msgid "`div` : Integer division"
msgstr "`div`: 整数の除算"

#. type: Bullet: '  * '
#: ../src/Tutorial/Interfaces.md:590
msgid "`mod` : Modulo operation"
msgstr "`mod` : 剰余演算"

#. type: Bullet: '* '
#: ../src/Tutorial/Interfaces.md:594
msgid "`Fractional`"
msgstr "`Fractional`"

#. type: Bullet: '  * '
#: ../src/Tutorial/Interfaces.md:594
msgid "`(/)` : Division"
msgstr "`(/)`: 除算"

#. type: Bullet: '  * '
#: ../src/Tutorial/Interfaces.md:594
msgid "`recip` : Calculates the reciprocal of a value"
msgstr "`recip` : 値の逆数を計算する"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:599
msgid ""
"As you can see: We need to implement interface `Num` to use integer literals "
"for a given type. In order to use negative integer literals like `-12`, we "
"also have to implement interface `Neg`."
msgstr ""
"ここで次のことがわかります。\n"
"所与の型に整数リテラルを使うのにはインターフェース`Num`を実装する必要がありま"
"す。\n"
"`-12`のような負数の整数リテラルを使うためにはインターフェース`Neg`も実装する"
"必要があります。"

#. type: Title ###
#: ../src/Tutorial/Interfaces.md:600
#, no-wrap
msgid "`Cast`"
msgstr "`Cast`"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:607
msgid ""
"The last interface we will quickly discuss in this section is `Cast`. It is "
"used to convert values of one type to values of another via function `cast`. "
"`Cast` is special, since it is parameterized over *two* type parameters "
"unlike the other interfaces we looked at so far, with only one type "
"parameter."
msgstr ""
"最後にこの節で手早く説明するインターフェースは`Cast`です。\n"
"ある型の値を他の型の値に関数`cast`で変換するというものです。\n"
"`Cast`は特別です。\n"
"なぜならこのインターフェースは*2つ*の型変数を引数に取りますが、\n"
"これまで見てきた他のインターフェースは型変数が1つしかないからです。"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:614
msgid ""
"So far, `Cast` is mainly used for interconversion between primitive types in "
"the standard libraries, especially numeric types. When you look at the "
"implementations exported from the *Prelude* (for instance, by invoking `:doc "
"Cast` at the REPL), you'll see that there are dozens of implementations for "
"most pairings of primitive types."
msgstr ""
"これまで`Cast`を主に標準ライブラリにある原始型の相互変換に使ってきました。\n"
"特に数値型です。\n"
"*Prelude*から公開されている実装を見てみると（例えば`:doc Cast`とREPLで呼び出"
"します）、\n"
"原始型のほとんどの対に関して沢山の実装があることがわかるでしょう。"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:623
msgid ""
"Although `Cast` would also be useful for other conversions (for going from "
"`Maybe` to `List` or for going from `Either e` to `Maybe`, for instance), "
"the *Prelude* and *base* seem not to introduce these consistently. For "
"instance, there are `Cast` implementations from going from `SnocList` to "
"`List` and vice versa, but not for going from `Vect n` to `List`, or for "
"going from `List1` to `List`, although these would be just as feasible."
msgstr ""
"`Cast`は他の変換にも便利ですが（`Maybe`から`List`であったり、\n"
"`Either e`から`Maybe`であったり）、\n"
"*Prelude*と*base*はそうした変換を一環して提供してはいないようです。\n"
"例として`Cast`の実装として`SnocList`から`List`とその逆のものがありますが、\n"
"`Vect n`から`List`へ、あるいは`Vect n`から`List`への実装はありません。\n"
"そうした実装も可能ではあるのですが。"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:629
msgid ""
"These exercises are meant to make you comfortable with implementing "
"interfaces for your own data types, as you will have to do so regularly when "
"writing Idris code."
msgstr ""
"ここにある演習は流暢に自前のデータ型のためのインターフェースが実装できるよう"
"になることを意図しています。\n"
"Idrisのコードを書くときはしばしば必要になることですから。"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:635
msgid ""
"While it is immediately clear why interfaces like `Eq`, `Ord`, or `Num` are "
"useful, the usability of `Semigroup` and `Monoid` may be harder to "
"appreciate at first.  Therefore, there are several exercises where you'll "
"implement different instances for these."
msgstr ""
"`Eq`, `Ord`, `Num`のようなインターフェースが便利な理由は直ちに明らかです"
"が、\n"
"一方で`Semigroup`と`Monoid`の便利さは最初は実感しにくいかもしれません。\n"
"したがって演習の中にはいくつかの異なるインスタンスについて実装するものがあり"
"ます。"

#. type: Bullet: '1. '
#: ../src/Tutorial/Interfaces.md:639
msgid ""
"Define a record type `Complex` for complex numbers, by pairing two values of "
"type `Double`.  Implement interfaces `Eq`, `Num`, `Neg`, and `Fractional` "
"for `Complex`."
msgstr ""
"レコード型`Complex`を複素数について定義してください。\n"
"型`Double`の値2つを対にします。\n"
"`Eq`, `Num`, `Neg`、そして`Fractional`を`Complex`に実装してください。"

#. type: Bullet: '2. '
#: ../src/Tutorial/Interfaces.md:643
msgid ""
"Implement interface `Show` for `Complex`. Have a look at data type `Prec` "
"and function `showPrec` and how these are used in the *Prelude* to implement "
"instances for `Either` and `Maybe`."
msgstr ""
"`Show`を`Complex`に実装してください。\n"
"データ型`Prec`と関数`showPrec`を調べて、\n"
"*Prelude*で`Either`や`Maybe`のインスタンスを実装するためにどのようにこれらが"
"使われているのか見てみましょう。"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:647
#, no-wrap
msgid ""
"   Verify the correct behavior of your implementation by wrapping\n"
"   a value of type `Complex` in a `Just` and `show` the result at\n"
"   the REPL.\n"
msgstr ""
"   書いた実装が正しい振舞いになっていることを確かめるために、\n"
"   REPLで型`Complex`の値を`Just`でくるんで`show`してみましょう。\n"

#. type: Bullet: '3. '
#: ../src/Tutorial/Interfaces.md:649
msgid "Consider the following wrapper for optional values:"
msgstr "あってもなくてもよい値の、以下の梱包について考えてみましょう。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Interfaces.md:650
#, no-wrap
msgid ""
"   record First a where\n"
"     constructor MkFirst\n"
"     value : Maybe a\n"
msgstr ""
"   record First a where\n"
"     constructor MkFirst\n"
"     value : Maybe a\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:660
#, no-wrap
msgid ""
"   Implement interfaces `Eq`, `Ord`, `Show`, `FromString`, `FromChar`, `FromDouble`,\n"
"   `Num`, `Neg`, `Integral`, and `Fractional` for `First a`. All of these will require\n"
"   corresponding constraints on type parameter `a`. Consider implementing and\n"
"   using the following utility functions where they make sense:\n"
msgstr ""
"   インターフェース`Eq`, `Ord`, `Show`, `FromString`, `FromChar`, `FromDouble`,\n"
"   `Num`, `Neg`, `Integral`, `Fractional`を`First a`に実装してください。\n"
"   これらは全て型変数`a`に対応する制約が必要になるでしょう。\n"
"   必要に応じて、以下の小間物関数を実装したのち使ってください。\n"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Interfaces.md:661
#, no-wrap
msgid ""
"   pureFirst : a -> First a\n"
"\n"
"   mapFirst : (a -> b) -> First a -> First b\n"
"\n"
"   mapFirst2 : (a -> b -> c) -> First a -> First b -> First c\n"
msgstr ""
"   pureFirst : a -> First a\n"
"\n"
"   mapFirst : (a -> b) -> First a -> First b\n"
"\n"
"   mapFirst2 : (a -> b -> c) -> First a -> First b -> First c\n"

#. type: Bullet: '4. '
#: ../src/Tutorial/Interfaces.md:673
msgid ""
"Implement interfaces `Semigroup` and `Monoid` for `First a` in such a way, "
"that `(<+>)` will return the first non-nothing argument and `neutral` is the "
"corresponding neutral element. There must be no constraints on type "
"parameter `a` in these implementations."
msgstr ""
"同様にインターフェース`Semigroup`と`Monoid`を`First a`に実装してください。\n"
"`(<+>)`は最初の非空な引数を返します。\n"
"また、`neutral`は対応する中立要素です。\n"
"これらの実装では型変数`a`に制約があってはいけません。"

#. type: Bullet: '5. '
#: ../src/Tutorial/Interfaces.md:676
msgid ""
"Repeat exercises 3 and 4 for record `Last`. The `Semigroup` implementation "
"should return the last non-nothing value."
msgstr ""
"問題3と4をレコード`Last`に改めて行ってください。\n"
"`Semigroup`の実装は最後の非空な値を返します。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Interfaces.md:677
#, no-wrap
msgid ""
"   record Last a where\n"
"     constructor MkLast\n"
"     value : Maybe a\n"
msgstr ""
"   record Last a where\n"
"     constructor MkLast\n"
"     value : Maybe a\n"

#. type: Bullet: '6. '
#: ../src/Tutorial/Interfaces.md:687
msgid ""
"Function `foldMap` allows us to map a function returning a `Monoid` over a "
"list of values and accumulate the result using `(<+>)` at the same time.  "
"This is a very powerful way to accumulate the values stored in a list.  Use "
"`foldMap` and `Last` to extract the last element (if any) from a list."
msgstr ""
"関数`foldMap`は関数を順番に写して`Monoid`を返します。\n"
"値のリストを巡回しつつ`(<+>)`で結果を積み重ねます。\n"
"これはリストに格納された値を集積するとても強力な方法です。\n"
"`foldMap`と`Last`でリストから最後の要素を（もしあれば）取り出してください。"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:692
#, no-wrap
msgid ""
"   Note, that the type of `foldMap` is more general and not specialized\n"
"   to lists only. It works also for `Maybe`, `Either` and other container\n"
"   types we haven't looked at so far. We will learn about\n"
"   interface `Foldable` in a later section.\n"
msgstr ""
"   ここで`foldMap`の型はより一般的でリストのみが専門ではありません。\n"
"   `Maybe`や`Either`やその他のまだ見ぬ荷車型に対しても動きます。\n"
"   後の節でインターフェース`Foldable`を学びましょう。\n"

#. type: Bullet: '7. '
#: ../src/Tutorial/Interfaces.md:694
msgid "Consider record wrappers `Any` and `All` for boolean values:"
msgstr "真偽値の値のレコード梱包`Any`と`All`を考えます。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Interfaces.md:695
#, no-wrap
msgid ""
"   record Any where\n"
"     constructor MkAny\n"
"     any : Bool\n"
"\n"
"   record All where\n"
"     constructor MkAll\n"
"     all : Bool\n"
msgstr ""
"   record Any where\n"
"     constructor MkAny\n"
"     any : Bool\n"
"\n"
"   record All where\n"
"     constructor MkAll\n"
"     all : Bool\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:708
#, no-wrap
msgid ""
"   Implement `Semigroup` and `Monoid` for `Any`, so that the result of\n"
"   `(<+>)` is `True`, if and only if at least one of the arguments is `True`.\n"
"   Make sure that `neutral` is indeed the neutral element for this operation.\n"
msgstr ""
"   `Semigroup`と`Monoid`を`Any`に実装してください。\n"
"   ただし`(<+>)`の結果は、少なくとも1つの引数が`True`であるときにのみ`True`です。\n"
"   `neural`はもちろんこの操作において中立な要素になるようにしてくださいね。\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:712
#, no-wrap
msgid ""
"   Likewise, implement `Semigroup` and `Monoid` for `All`, so that the result of\n"
"   `(<+>)` is `True`, if and only if both of the arguments are `True`.\n"
"   Make sure that `neutral` is indeed the neutral element for this operation.\n"
msgstr ""
"   同様に`Semigroup`と`Monoid`を`All`に実装してください。\n"
"   `(<+>)`の結果は、両方の引数が`True`のときにのみ`True`であるようにしてください。\n"
"   `neural`はもちろんこの操作において中立な要素になるようにしてくださいね。\n"

#. type: Bullet: '8. '
#: ../src/Tutorial/Interfaces.md:715
msgid ""
"Implement functions `anyElem` and `allElems` using `foldMap` and `Any` or "
"`All`, respectively:"
msgstr ""
"関数`anyElem`と`allElems`を、`foldMap`と`Any`ないし`All`を使って実装してくだ"
"さい。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Interfaces.md:716
#, no-wrap
msgid ""
"   -- True, if the predicate holds for at least one element\n"
"   anyElem : (a -> Bool) -> List a -> Bool\n"
"\n"
"   -- True, if the predicate holds for all elements\n"
"   allElems : (a -> Bool) -> List a -> Bool\n"
msgstr ""
"   -- 命題が少なくとも1つの要素について満たされているとき真\n"
"   anyElem : (a -> Bool) -> List a -> Bool\n"
"\n"
"   -- 命題が全ての要素について満たされているとき真\n"
"   allElems : (a -> Bool) -> List a -> Bool\n"

#. type: Bullet: '9. '
#: ../src/Tutorial/Interfaces.md:726
msgid ""
"Record wrappers `Sum` and `Product` are mainly used to hold numeric types."
msgstr "レコード梱包`Sum`と`Product`は主に数値型を保持するのに使われます。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Interfaces.md:727
#, no-wrap
msgid ""
"   record Sum a where\n"
"     constructor MkSum\n"
"     value : a\n"
"\n"
"   record Product a where\n"
"     constructor MkProduct\n"
"     value : a\n"
msgstr ""
"   record Sum a where\n"
"     constructor MkSum\n"
"     value : a\n"
"\n"
"   record Product a where\n"
"     constructor MkProduct\n"
"     value : a\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:739
#, no-wrap
msgid ""
"   Given an implementation of `Num a`, implement `Semigroup (Sum a)`\n"
"   and `Monoid (Sum a)`, so that `(<+>)` corresponds to addition.\n"
msgstr ""
"   `Num a`の実装があったとして、`Semigroup (Sum a)`と`Monoid (Sum a)`を実装してください。\n"
"   ただし`(<+>)`は加算に対応します。\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:742
#, no-wrap
msgid ""
"   Likewise, implement `Semigroup (Product a)` and `Monoid (Product a)`,\n"
"   so that `(<+>)` corresponds to multiplication.\n"
msgstr ""
"   同様に`Semigroup (Product a)`と`Monoid (Product a)`を実装してください。\n"
"   ただし`(<+>)`は乗算に対応します。\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:745
#, no-wrap
msgid ""
"   When implementing `neutral`, remember that you can use integer\n"
"   literals when working with numeric types.\n"
msgstr "   `neutral`を実装する際は、数値型を扱うときは整数リテラルが使えることを思い出してください。\n"

#. type: Bullet: '10. '
#: ../src/Tutorial/Interfaces.md:748
msgid ""
"Implement `sumList` and `productList` by using `foldMap` together with the "
"wrappers from Exercise 9:"
msgstr ""
"`sumList`と`productList`を実装してください。\n"
"`foldMap`とともに演習9の梱包を使ってください。"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:751
#, no-wrap
msgid ""
"    ```idris\n"
"    sumList : Num a => List a -> a\n"
msgstr ""
"    ```idris\n"
"    sumList : Num a => List a -> a\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:754
#, no-wrap
msgid ""
"    productList : Num a => List a -> a\n"
"    ```\n"
msgstr ""
"    productList : Num a => List a -> a\n"
"    ```\n"

#. type: Bullet: '11. '
#: ../src/Tutorial/Interfaces.md:760
msgid ""
"To appreciate the power and versatility of `foldMap`, after solving "
"exercises 6 to 10 (or by loading `Solutions.Inderfaces` in a REPL session), "
"run the following at the REPL, which will - in a single list traversal! - "
"calculate the first and last element of the list as well as the sum and "
"product of all values."
msgstr ""
"`foldMap`の強力さと多芸さを享受するために、\n"
"演習6から10までを解いたあとに（もしくはREPLで`Solutions.Interfaces`をロードし"
"てもよいです）、\n"
"以下をREPLで実行してください。\n"
"これは、たった1回の巡回で！、リストの最初と最後の要素と全ての値の和と積を計算"
"しています。"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:765
#, no-wrap
msgid ""
"    ```repl\n"
"    > foldMap (\\x => (pureFirst x, pureLast x, MkSum x, MkProduct x)) [3,7,4,12]\n"
"    (MkFirst (Just 3), (MkLast (Just 12), (MkSum 26, MkProduct 1008)))\n"
"    ```\n"
msgstr ""
"    ```repl\n"
"    > foldMap (\\x => (pureFirst x, pureLast x, MkSum x, MkProduct x)) [3,7,4,12]\n"
"    (MkFirst (Just 3), (MkLast (Just 12), (MkSum 26, MkProduct 1008)))\n"
"    ```\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:772
#, no-wrap
msgid ""
"    Note, that there are also `Semigroup` implementations for\n"
"    types with an `Ord` implementation, which will return\n"
"    the smaller or larger of two values. In case of types\n"
"    with an absolute minimum or maximum (for instance, 0 for\n"
"    natural numbers, or 0 and 255 for `Bits8`), these can even\n"
"    be extended to `Monoid`.\n"
msgstr ""
"   `Ord`の実装付きの型のための`Semigroup`の実装もあります。\n"
"   この実装は2つの値のうちより小さいかより大きいほうを返します。\n"
"   決まった最小値や最大値がある型の場合（例えば自然数の0や、`Bits8`の0と255）、\n"
"   これらについてもまた`Monoid`に拡張できます。\n"

#. type: Bullet: '12. '
#: ../src/Tutorial/Interfaces.md:778
msgid ""
"In an earlier exercise, you implemented a data type representing chemical "
"elements and wrote a function for calculating their atomic masses. Define a "
"new single field record type for representing atomic masses, and implement "
"interfaces `Eq`, `Ord`, `Show`, `FromDouble`, `Semigroup`, and `Monoid` for "
"this."
msgstr ""
"以前の演習で化学の元素を表現するデータ型を実装し、\n"
"化学の体積を計算する関数を書きました。\n"
"新しく原子の体積を表現する単一フィールドレコード型を定義して、\n"
"インターフェース`Eq`, `Ord`, `Show`, `FromDouble`, `Semigroup`, `Monoid`をこ"
"の型に実装してください。"

#. type: Bullet: '13. '
#: ../src/Tutorial/Interfaces.md:782
msgid ""
"Use the new data type from exercise 12 to calculate the atomic mass of an "
"element and compute the molecular mass of a molecule given by its formula."
msgstr ""
"演習12の新しいデータ型を使って原子の原子質量を算出し、\n"
"分子式で与えられる分子の分子質量を計算してください。"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:785
#, no-wrap
msgid ""
"    Hint: With a suitable utility function, you can use `foldMap`\n"
"    once again for this.\n"
msgstr "   解決の糸口：相応しい小間物関数があれば、ここでも`foldMap`が使えます。\n"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:791
msgid ""
"Final notes: If you are new to functional programming, make sure to give "
"your implementations of exercises 6 to 10 a try at the REPL.  Note, how we "
"can implement all of these functions with a minimal amount of code and how, "
"as shown in exercise 11, these behaviors can be combined in a single list "
"traversal."
msgstr ""
"最後の註釈：もし関数型プログラミングが初めてであれば、\n"
"演習6から10の実装をREPLで確かめてみてください。\n"
"これら全ての関数を最小限の量のコードでどのように実装できたか、\n"
"そして演習11で見たように1回のリストの巡回においてこれらの振舞いをどのように組"
"み合わせられたか、\n"
"を思い返しましょう。"

#. type: Bullet: '* '
#: ../src/Tutorial/Interfaces.md:807
msgid ""
"Interfaces allow us to implement the same function with different behavior "
"for different types."
msgstr ""
"インターフェースのおかげで、異なる型で異なる振舞いをする同じ関数を実装できま"
"す。"

#. type: Bullet: '* '
#: ../src/Tutorial/Interfaces.md:807
msgid ""
"Functions taking one or more interface implementations as arguments are "
"called *constrained functions*."
msgstr ""
"1つ以上のインターフェースの実装を引数に取る関数は*制約付き関数*と呼ばれます。"

#. type: Bullet: '* '
#: ../src/Tutorial/Interfaces.md:807
msgid ""
"Interfaces can be organized hierarchically by *extending* other interfaces."
msgstr ""
"インターフェースは他のインターフェースを*拡張*することで階層的に組織付けられ"
"ます。"

#. type: Bullet: '* '
#: ../src/Tutorial/Interfaces.md:807
msgid ""
"Interfaces implementations can themselves be *constrained* requiring other "
"implementations to be available."
msgstr ""
"インターフェースの実装は、それ自体が他の実装を必要とする*制約*が課されること"
"があります。"

#. type: Bullet: '* '
#: ../src/Tutorial/Interfaces.md:807
msgid ""
"Interface functions can be given a *default implementation*, which can be "
"overridden by implementers, for instance for reasons of efficiency."
msgstr ""
"インターフェースの関数には*既定実装*を与えられます。\n"
"この実装は実装者によって上書きできます。\n"
"例えば効率性の理由などからです。"

#. type: Bullet: '* '
#: ../src/Tutorial/Interfaces.md:807
msgid ""
"Certain interfaces allow us to use literal values such as string or integer "
"literals for our own data types."
msgstr ""
"いくつかのインターフェースがあれば、\n"
"文字列や整数といったリテラルのリテラル値を自前のデータ型に使えます。"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:812
msgid ""
"Note, that I did not yet tell the whole story about literal values in this "
"section. More details for using literals with types that accept only a "
"restricted set of values can be found in the chapter about [primitives](Prim."
"md)."
msgstr ""
"ただ、この節ではリテラル値の一部始終はまだお話ししていません。\n"
"限られた値の集合のみを受け付ける型にリテラルを使うことに関するもっと詳しい話"
"は、\n"
"[原始型](Prim.md)についての章にあります。"

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:819
msgid ""
"In the [next chapter](Functions2.md), we have a closer look at functions and "
"their types. We will learn about named arguments, implicit arguments, and "
"erased arguments as well as some constructors for implementing more complex "
"functions."
msgstr ""
"[次の章](Functions2.md)では関数とその型にさらに迫ります。\n"
"名前付き引数、暗黙の引数、引数消去に加え、\n"
"より複雑な関数を実装するためのいくつかの構築子について学びます。"

#. type: Title #
#: ../src/Tutorial/Intro.md:1
#, no-wrap
msgid "Introduction"
msgstr "導入"

#. type: Plain text
#: ../src/Tutorial/Intro.md:15
msgid ""
"Welcome to my Idris 2 tutorial. I'll try and treat as many aspects of the "
"Idris 2 programming language as possible here.  All `.md` files in here a "
"literate Idris files: They consist of Markdown (hence the `.md` ending), "
"which is being pretty printed by GitHub together with Idris code blocks, "
"which can be type checked and built by the Idris compiler (more on this "
"later).  Note, however, that regular Idris source files use an `.idr` "
"ending, and that you go with that file type unless you end up writing much "
"more prose than code as I do at the moment. Later in this tutorial, you'll "
"have to solve some exercises, the solutions of which can be found in the "
"`src/Solutions` subfolder. There, I use regular `.idr` files."
msgstr ""
"Idris 2 入門へようこそ。\n"
"ここではプログラミング言語 Idris 2 のできるだけ多くの側面を扱ってみることにし"
"ます。\n"
"ここにある全ての `.md` ファイルは文芸的 Idris ファイルです。\n"
"つまり、Markdownで書かれていて（だから `.md` で終わります）、\n"
"Idris のコードブロックを混じえつつ GitHub で綺麗に表示され、\n"
"そして Idris のコンパイラで型検査とビルドができます（これについては後述）。\n"
"ただし、通常の Idris のソースファイルは `.idr` で終わりますし、\n"
"ここで私がやっているようにコードよりも地の文をかなり多く書かない限り、\n"
"そのファイルの種類を使うものです。\n"
"この入門のあとに、\n"
"いくつかの演習問題を解くことになりますが、\n"
"解答は `src/Solutions` サブフォルダにあります。\n"
"そこでは通常の `.idr` ファイルにしています。"

#. type: Plain text
#: ../src/Tutorial/Intro.md:19
msgid ""
"Every Idris source file should typically start with a module name plus some "
"necessary imports, and this document is no exception:"
msgstr ""
"あらゆる Idris のソースファイルにおいて、\n"
"モジュール名といくらかの必要となるインポートから始まるのが典型で、\n"
"この文書も例外ではありません。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Intro.md:20
#, no-wrap
msgid "module Tutorial.Intro\n"
msgstr "module Tutorial.Intro\n"

#. type: Plain text
#: ../src/Tutorial/Intro.md:27
msgid ""
"A module name consists of a list of identifiers separated by dots and must "
"reflect the folder structure plus the module file's name."
msgstr ""
"モジュール名はドットで区切られた識別子の連なりからなっており、\n"
"フォルダの構造とモジュールファイル名を反映したものでなくてはいけません。"

#. type: Title ##
#: ../src/Tutorial/Intro.md:28
#, no-wrap
msgid "About the Idris Programming Language"
msgstr "プログラミング言語Idrisについて"

#. type: Plain text
#: ../src/Tutorial/Intro.md:33
msgid ""
"Idris is a *pure*, *dependently typed*, *total* *functional* programming "
"language. I'll quickly explain each of these adjectives in this section."
msgstr ""
"Idrisは *純粋* で *依存型* で *全域* な *関数型* プログラミング言語です。\n"
"この節でこれらの形容詞について簡単に説明します。"

#. type: Title ###
#: ../src/Tutorial/Intro.md:34
#, no-wrap
msgid "Functional Programming"
msgstr "関数型プログラミング"

#. type: Plain text
#: ../src/Tutorial/Intro.md:42
msgid ""
"In functional programming languages, functions are first-class constructs, "
"meaning that they can be assigned to variables, passed as arguments to other "
"functions, and returned as results from functions. Unlike for instance in "
"object-oriented programming languages, in functional programming, functions "
"are the main form of abstraction."
msgstr ""
"関数型プログラミング言語では、\n"
"関数は第一級の構築子です。\n"
"というのは、関数は変数に代入することができますし、\n"
"他の関数の引数に渡すことができますし、\n"
"そして関数の結果として返すこともできます。\n"
"オブジェクト指向プログラミング言語などとは異なり、\n"
"関数型プログラミングでは、抽象化が主に関数の形式で行われます。"

#. type: Plain text
#: ../src/Tutorial/Intro.md:46
msgid ""
"Functional programming languages are concerned with the evaluation of "
"functions, unlike classical imperative languages, which are concerned with "
"the execution of statements."
msgstr ""
"関数型プログラミング言語では関数の演算に着目しますが、\n"
"これは古典的な手続き型言語とは違います。\n"
"手続き型言語では文の実行に着目していました。"

#. type: Title ###
#: ../src/Tutorial/Intro.md:47
#, no-wrap
msgid "Pure Functional Programming"
msgstr "純粋関数型プログラミング"

#. type: Plain text
#: ../src/Tutorial/Intro.md:57
msgid ""
"Pure functional programming languages come with an additional important "
"guarantee: Functions don't have side effects like writing to a file or "
"mutating global state. They can only compute a result from their arguments "
"possibly by invoking other pure functions, *and nothing else*. As a "
"consequence, given the same input, they will *always* generate the same "
"output.  This property is known as [referential transparency](https://en."
"wikipedia.org/wiki/Referential_transparency)."
msgstr ""
"純粋関数型プログラミング言語は、\n"
"関数型プログラミング言語に重要な保証がついたものです。\n"
"その保証とは、関数が副作用を持たないことで、\n"
"例えばファイルへの書き込みや大域状態の変更を行いません。\n"
"関数は引数から結果を計算するもので、\n"
"他の純粋な関数を呼び出すかもしれませんが、\n"
"*その他には何も呼び出しません*。\n"
"その結果として、\n"
"同じ入力があったとすると、\n"
"*常に* 同じ出力を生成することになります。\n"
"この性質は[参照透過性](https://en.wikipedia.org/wiki/"
"Referential_transparency)として知られています。"

#. type: Plain text
#: ../src/Tutorial/Intro.md:59
msgid "Pure functions have several advantages:"
msgstr "純粋な関数にはいくつかの利点があります。"

#. type: Bullet: '* '
#: ../src/Tutorial/Intro.md:62
msgid ""
"They can easily be tested by specifying (possibly randomly generated)  sets "
"of input arguments together with the expected results."
msgstr ""
"関数をテストするのが簡単です。\n"
"いくつかの入力（乱択による生成でも可）と期待値を指定します。"

#. type: Bullet: '* '
#: ../src/Tutorial/Intro.md:66
msgid ""
"They are thread-safe, since the don't mutate global state, and as such can "
"be freely used in several computations running in parallel."
msgstr ""
"関数はスレッドセーフです。\n"
"なぜなら大域状態を変更しないからです。\n"
"そして、並列実行される計算でも自由に使えます。"

#. type: Plain text
#: ../src/Tutorial/Intro.md:68
msgid "There are, of course, also some disadvantages:"
msgstr "純粋な関数にももちろん欠点があります。"

#. type: Bullet: '* '
#: ../src/Tutorial/Intro.md:71
msgid ""
"Some algorithms are hard to implement efficiently using only pure functions."
msgstr "純粋関数だけでは、効率良く実装することが困難なアルゴリズムがあります。"

#. type: Bullet: '* '
#: ../src/Tutorial/Intro.md:75
msgid ""
"Writing programs that actually *do* something (have some observable effect) "
"is a bit trickier but certainly possible."
msgstr ""
"実際に何かを *する* プログラム（何らかの観測可能な効果を伴う）を書くのにひと"
"工夫いることです。\n"
"でも、確実にできます。"

#. type: Plain text
#: ../src/Tutorial/Intro.md:83
msgid ""
"Idris is a strongly, statically typed programming language. This means, that "
"ever Idris expression is given a *type* (for instance: integer, list of "
"strings, boolean, function from integer to boolean, etc.)  and types are "
"verified at compile time to rule out certain common programming errors."
msgstr ""
"Idrisは強力に静的型付けされたプログラミング言語です。\n"
"つまり、あらゆるIdrisの式には *型*\n"
"（例えば整数、文字列のリスト、真偽値、整数から真偽値への関数など）があり、\n"
"型はコンパイル時に検証されます。\n"
"この時点でプログラミングにおいてよくあるエラーを排除できます。"

#. type: Plain text
#: ../src/Tutorial/Intro.md:89
msgid ""
"For instance, if a function expects an argument of type `String` (a sequence "
"of unicode characters, such as `\"Hello123\"`), it is a *type error* to "
"invoke this function with an argument of type `Integer`, and the Idris "
"compiler will refuse to generate an executable from such an ill-typed "
"program."
msgstr ""
"例えば、もしある関数が `String` 型（unicode文字の連なりで、 `\"Hello123\"` な"
"ど）\n"
"の引数を期待しているとすれば、\n"
"この関数を `Integer` 型で呼び出すと *型エラー* になります。\n"
"そして、Idrisのコンパイラはそのような型付けできていないプログラムから\n"
"実行可能プログラムを生成しません。"

#. type: Plain text
#: ../src/Tutorial/Intro.md:97
msgid ""
"Even more, Idris is *dependently typed*, which is one of its most "
"characteristic properties in the landscape of programming languages. In "
"Idris, types are *first class*: Types can be passed as arguments to "
"functions, and functions can return types as their results. Even more, types "
"can *depend* on other *values*.  What this means, and why this is incredibly "
"useful, we'll explore in due time."
msgstr ""
"さらに言えば、Idrisは *依存型* です。\n"
"この依存型というものは、プログラミング言語界隈では最も特徴的な性質の1つで"
"す。\n"
"Idrisでは型は第一級です。\n"
"つまり、型は関数の引数に渡せますし、関数は計算結果として型を返すことができま"
"す。\n"
"さらにさらに、型は他の *値* に *依存* することもできます。\n"
"このことが何を意味するのか、そしてなぜこれが滅茶苦茶役に立つのかということ"
"を、\n"
"その時が来たときに探索することにしましょう。"

#. type: Title ###
#: ../src/Tutorial/Intro.md:98
#, no-wrap
msgid "Total Functions"
msgstr "全域関数"

#. type: Plain text
#: ../src/Tutorial/Intro.md:104
msgid ""
"A *total* function is a pure function, that is guaranteed to return a value "
"of the expected return type for every possible input in a finite amount of "
"time. A total function will never fail with an exception or loop infinitely."
msgstr ""
"*全域* な関数は純粋な関数である必要があります。\n"
"そして、ありうる全ての入力に対して、\n"
"有限時間内に期待される型の値を返すことが保証されています。"

#. type: Plain text
#: ../src/Tutorial/Intro.md:113
msgid ""
"Idris comes with a totality checker built in, which enables us to verify the "
"functions we write to be provably total. Totality in Idris is opt-in, as in "
"general, checking the totality of an arbitrary computer program is "
"undecidable (see also the [halting problem](https://en.wikipedia.org/wiki/"
"Halting_problem)).  However, if we annotate a function with the `total` "
"keyword, Idris will fail with a type error, if its totality checker cannot "
"verify that the function in question is indeed total."
msgstr ""
"Idrisには全域性検査器が組込まれています。\n"
"この検査器により、書いた関数が証明によって全域であることを検証することができ"
"ます。\n"
"Idrisにおける全域性はオプションで有効にするものです。\n"
"一般に、任意のコンピュータプログラムの全域性を確認できるかは、\n"
"決定できません（[停止性問題](https://en.wikipedia.org/wiki/Halting_problem)も"
"参照のこと）。\n"
"しかし、関数に `total` キーワードの註釈を付けたときに、\n"
"全域性検査器がその関数をたしかに全域かどうか検証できなければ、\n"
"Idrisは型エラーとして失敗させます。"

#. type: Title ##
#: ../src/Tutorial/Intro.md:114
#, no-wrap
msgid "Using the REPL"
msgstr "REPLを使う"

#. type: Plain text
#: ../src/Tutorial/Intro.md:121
msgid ""
"Idris comes with a useful REPL (an acronym for *Read Evaluate Print Loop*), "
"which we will use for tinkering with small ideas, and for quickly "
"experimenting with the code we just wrote.  In order to start a REPL "
"session, run the following command in a terminal."
msgstr ""
"Idrisには便利なREPL（*Read Evaluate Print Loop*の頭字語）があります。\n"
"REPLではちょっとしたアイディアをもとにいじってみたり、\n"
"書いたばかりのコードで素早く実験したりできます。\n"
"REPLセッションを始めるためには、\n"
"以下のコマンドを端末で実行します。"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Intro.md:122
#, no-wrap
msgid "rlwrap idris2\n"
msgstr "rlwrap idris2\n"

#. type: Plain text
#: ../src/Tutorial/Intro.md:131
msgid ""
"(Using command-line utility `rlwrap` is optional. It leads to a somewhat "
"nicer user experience, as it allows us to use the up and down arrow keys to "
"scroll through a history of commands and expressions we entered. It should "
"be available for most Linux distributions.)"
msgstr ""
"（コマンドラインユーティリティである `rlwrap` はあってもなくてもよいです。\n"
"`rlwrap` があれば、過去に入力したコマンドや式を上下の矢印キーで遡れるので、"
"もっといい感じに使えます。\n"
"ほとんどのLinuxディストリビューションで利用できるはずです。）"

#. type: Plain text
#: ../src/Tutorial/Intro.md:133
msgid "Idris should now be ready to accept you commands:"
msgstr "そうしたら、Idrisがコマンドを受け付けるようになります。"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Intro.md:134
#, no-wrap
msgid ""
"     ____    __     _         ___\n"
"    /  _/___/ /____(_)____   |__ \\\n"
"    / // __  / ___/ / ___/   __/ /     Version 0.5.1-3c532ea35\n"
"  _/ // /_/ / /  / (__  )   / __/      https://www.idris-lang.org\n"
" /___/\\__,_/_/  /_/____/   /____/      Type :? for help\n"
"\n"
"Welcome to Idris 2.  Enjoy yourself!\n"
"Main>\n"
msgstr ""
"     ____    __     _         ___\n"
"    /  _/___/ /____(_)____   |__ \\\n"
"    / // __  / ___/ / ___/   __/ /     Version 0.5.1-3c532ea35\n"
"  _/ // /_/ / /  / (__  )   / __/      https://www.idris-lang.org\n"
" /___/\\__,_/_/  /_/____/   /____/      Type :? for help\n"
"\n"
"Welcome to Idris 2.  Enjoy yourself!\n"
"Main>\n"

#. type: Plain text
#: ../src/Tutorial/Intro.md:147
msgid ""
"We can go ahead and enter some simple arithmetic expressions. Idris will "
"*evaluate* these and print the result:"
msgstr ""
"簡単な計算式を入力してみましょう。\n"
"Idrisは式を *評価* して結果を表示します。"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Intro.md:148
#, no-wrap
msgid ""
"Main> 2 * 4\n"
"8\n"
"Main> 3 * (7 + 100)\n"
"321\n"
msgstr ""
"Main> 2 * 4\n"
"8\n"
"Main> 3 * (7 + 100)\n"
"321\n"

#. type: Plain text
#: ../src/Tutorial/Intro.md:157
msgid ""
"Since every expression in Idris has an associated *type*, we might want to "
"inspect these as well:"
msgstr ""
"Idrisでの全ての式には *型* があるので、\n"
"型を調べたいですね。"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Intro.md:158
#, no-wrap
msgid ""
"Main> :t 2\n"
"2 : Integer\n"
msgstr ""
"Main> :t 2\n"
"2 : Integer\n"

#. type: Plain text
#: ../src/Tutorial/Intro.md:166
msgid ""
"Here `:t` is a command of the Idris REPL (it is not part of the Idris "
"programming language), and it is used to inspect the type of an expression."
msgstr ""
"ここで `:t` はIdris REPLのコマンド（プログラミング言語Idrisには含まれません）"
"です。\n"
"このコマンドは式の型を調べるのに使えます。"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Intro.md:167
#, no-wrap
msgid ""
"Main> :t 2 * 4\n"
"2 * 4 : Integer\n"
msgstr ""
"Main> :t 2 * 4\n"
"2 * 4 : Integer\n"

#. type: Plain text
#: ../src/Tutorial/Intro.md:182
msgid ""
"Whenever we perform calculations with integer literals without being "
"explicit about the types we want to use, Idris will use `Integer` as a "
"default. `Integer` is an arbitrary precision signed integer type. It is one "
"of the *primitive types* built into the language. Other primitives include "
"fixed precision signed and unsigned integral types (`Bits8`, `Bits16`, "
"`Bits32` `Bits64`, `Int8`, `Int16`, `Int32`, and `Int64`), double precision "
"(64 bit) floating point numbers (`Double`), unicode characters (`Char`) and "
"strings of unicode characters (`String`).  We will use many of these in due "
"time."
msgstr ""
"使いたい型を明示せずに整数リテラルの計算をすると、\n"
"Idrisはデフォルトで常に `Integer` を使います。\n"
"`Integer` は任意精度の符号付き整数型です。\n"
"`Integer` は言語に組込まれている *原始型* の1つです。\n"
"他の原始型には、\n"
"固定精度で符号付きないし符号なしの整数型 (`Bits8`, `Bits16`, `Bits32`, "
"`Bits64`, `Int8`, `Int16`, `Int32`, `Int64`)、\n"
"倍精度 (64 bit) 浮動小数点小数 (`Double`)、\n"
"Unicode文字 (`Char`)、\n"
"そしてUnicode文字の連なり (`String`) があります。\n"
"その時が来たら、これらの型の多くを使っていきます。"

#. type: Title ##
#: ../src/Tutorial/Intro.md:183
#, no-wrap
msgid "A First Idris Program"
msgstr "最初のIdrisプログラム"

#. type: Plain text
#: ../src/Tutorial/Intro.md:190
msgid ""
"We will often start up a REPL for tinkering with small parts of the Idris "
"language, for reading some documentation, or for inspecting the content of "
"an Idris module, but now we will write a minimal Idris program to get "
"started with the language. Here comes the mandatory *Hello World*:"
msgstr ""
"この入門ではIdris言語の一部分を触ってみるのにREPLを立ち上げることが多いで"
"す。\n"
"REPLでは文書を読んだり、Idrisのモジュールの中身を調べたりできます。\n"
"しかしまずは言語を学び始める上で最小のIdrisのプログラムを書いてみましょう。\n"
"なにはともあれ *Hello World* から。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Intro.md:191
#, no-wrap
msgid ""
"main : IO ()\n"
"main = putStrLn \"Hello World!\"\n"
msgstr ""
"main : IO ()\n"
"main = putStrLn \"Hello World!\"\n"

#. type: Plain text
#: ../src/Tutorial/Intro.md:199
msgid ""
"We will inspect the code above in some detail in a moment, but first we'd "
"like to compile and run it. From this project's root directory, run the "
"following:"
msgstr ""
"少ししたら上のコードをもうちょっと詳しく調べます。\n"
"でもまずはコンパイルして実行してみたいですね。\n"
"このプロジェクトのルートディレクトリで以下を実行してください。"

#. type: Fenced code block (sh)
#: ../src/Tutorial/Intro.md:199
#, no-wrap
msgid "idris2 --find-ipkg -o hello src/Tutorial/Intro.md\n"
msgstr "idris2 --find-ipkg -o hello src/Tutorial/Intro.md\n"

#. type: Plain text
#: ../src/Tutorial/Intro.md:207
msgid ""
"This will create executable `hello` in directory `build/exec`, which can be "
"invoked from the command-line like so (without the dollar prefix; this is "
"used here to distinguish the terminal command from its output):"
msgstr ""
"こうすることで実行可能ファイル `hello` がディレクトリ `build/exec` に作られま"
"す。\n"
"これはコマンドラインで次のようにして実行できます。\n"
"（行頭のドル記号の有無で端末のコマンドとその出力を区別します。）"

#. type: Fenced code block (sh)
#: ../src/Tutorial/Intro.md:208
#, no-wrap
msgid ""
"$ build/exec/hello\n"
"Hello World!\n"
msgstr ""
"$ build/exec/hello\n"
"Hello World!\n"

#. type: Plain text
#: ../src/Tutorial/Intro.md:219
msgid ""
"The `--find-ipkg` option will look for an `.ipkg` file in the current "
"directory or one of its parent directories, from which it will get other "
"settings like the source directory to use (`src` in our case). The `-o` "
"option gives the name of the executable to be generated. Type `idris2 --"
"help` for a list of available command-line options and environment variables."
msgstr ""
"`--find-ipkg` オプションは現在のディレクトリかそれより上位ディレクトリのいず"
"れかにある `.ipkg` ファイルを探します。\n"
"そこからIdrisは使用するソースディレクトリ（ここでは `src` です）のような他の"
"設定を取得します。\n"
"`-o` オプションは生成される実行可能ファイルに名前を付けます。\n"
"`idris2 --help` とすると使えるコマンドラインオプションと環境変数が一覧になり"
"ます。"

#. type: Plain text
#: ../src/Tutorial/Intro.md:222
msgid ""
"As an alternative, you can also load this source file in a REPL session and "
"invoke function `main` from there:"
msgstr ""
"他の方法としては、ソースファイルをREPLセッションで読み込んで、\n"
"`main` 関数を呼び出すというのもあります。"

#. type: Fenced code block (sh)
#: ../src/Tutorial/Intro.md:223
#, no-wrap
msgid "rlwrap idris2 --find-ipkg src/Tutorial/Intro.md\n"
msgstr "rlwrap idris2 --find-ipkg src/Tutorial/Intro.md\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Intro.md:227
#, no-wrap
msgid ""
"Tutorial.Intro> :exec main\n"
"Hello World!\n"
msgstr ""
"Tutorial.Intro> :exec main\n"
"Hello World!\n"

#. type: Plain text
#: ../src/Tutorial/Intro.md:234
msgid ""
"Go ahead and try both ways of building and running function `main` on your "
"system!"
msgstr "両方のやり方を試してみて、システム上で `main` 関数を実行しましょう！"

#. type: Plain text
#: ../src/Tutorial/Intro.md:239
msgid ""
"Note: It might be instructive to omit the `--find-ipkg` option.  You will "
"get an error message about the module name `Tutorial.Intro` not matching the "
"file path `src/Tutorial/Intro.md`. You can also use option `--source-dir "
"src` to silence this error."
msgstr ""
"附記： `--find-ipkg` オプションを省いてみるとためになるかもしれません。\n"
"モジュール名 `Tutorial.Intro` がファイルパス `src/Tutorial/Intro.md` と\n"
"一致しないというエラーメッセージが出るでしょう。\n"
"この場合、 `--source-dir src` オプションを使えばこのエラーを解消できます。"

#. type: Title ##
#: ../src/Tutorial/Intro.md:240
#, no-wrap
msgid "The Shape of an Idris Definition"
msgstr "Idrisの定義の形"

#. type: Plain text
#: ../src/Tutorial/Intro.md:244
msgid ""
"Now that we executed our first Idris program, we will talk a bit more about "
"the code we had to write to define it."
msgstr ""
"最初のIdrisプログラムを実行したところで、\n"
"定義する部分のコードについて話しましょう。"

#. type: Plain text
#: ../src/Tutorial/Intro.md:251
msgid ""
"A typical top level function in Idris consists of three things: The "
"function's name (`main` in our case), its type (`IO ()`)  plus its "
"implementation (`putStrLn \"Hello World\"`). It is easier to explain these "
"things with a couple of simple examples. Below, we define a top level "
"constant for the largest unsigned eight bit integer:"
msgstr ""
"Idrisでのよくある最上位で定義された関数は3つの部分から成り立ちます。\n"
"関数名（ここでは `main` です）、\n"
"関数の型 (`IO ()`)、\n"
"そして関数の実装 (`putStrLn \"Hello World\"`) です。\n"
"いくつかの簡単な例を出すとわかりやすいです。\n"
"以下では最上位の定数に最大の符号なし8ビット整数を定義しています。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Intro.md:252
#, no-wrap
msgid ""
"maxBits8 : Bits8\n"
"maxBits8 = 255\n"
msgstr ""
"maxBits8 : Bits8\n"
"maxBits8 = 255\n"

#. type: Plain text
#: ../src/Tutorial/Intro.md:266
msgid ""
"The first line can be read as: \"We'd like to declare (nullary)  function "
"`maxBits8`. It is of type `Bits8`\". This is called the *function "
"declaration*: We declare, that there shall be a function of the given name "
"and type. The second line reads: \"The result of invoking `maxBits8` should "
"be `255`.\" (As you can see, we can use integer literals for other integral "
"types than just `Integer`.) This is called the *function definition*: "
"Function `maxBits8` should behave as described here when being evaluated."
msgstr ""
"最初の行はこんな感じに読めます。\n"
"「（引数のない）関数 `maxBits8` を定義します。\n"
"型は `Bits8` です。」\n"
"これは *関数宣言* と呼ばれます。\n"
"与えられた名前と型を持つ関数があることを宣言するのです。\n"
"2行目はこんな感じに読めます。\n"
"「`maxBits8` を呼び出した結果は `255` です。」\n"
"（整数リテラルは `Integer` 以外の他の数値の型でも使えることが見てとれま"
"す。）\n"
"これは *関数定義* と呼ばれます。\n"
"`maxBits8` 関数は評価されるときにここに記述されたように振舞います。"

#. type: Plain text
#: ../src/Tutorial/Intro.md:269
msgid ""
"We can inspect this at the REPL. Load this source file into an Idris REPL "
"(as described above), and run the following tests."
msgstr ""
"この関数をREPLで調べることができます。\n"
"このソースファイルを（前述したように）Idris REPLに読み込んで、\n"
"以下を試しましょう。"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Intro.md:270
#, no-wrap
msgid ""
"Tutorial.Intro> maxBits8\n"
"255\n"
"Tutorial.Intro> :t maxBits8\n"
"Tutorial.Intro.maxBits8 : Bits8\n"
msgstr ""
"Tutorial.Intro> maxBits8\n"
"255\n"
"Tutorial.Intro> :t maxBits8\n"
"Tutorial.Intro.maxBits8 : Bits8\n"

#. type: Plain text
#: ../src/Tutorial/Intro.md:278
msgid "We can also use `maxBits8` as part of another expression:"
msgstr "`maxBits8` を他の式の一部として使うこともできます。"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Intro.md:279
#, no-wrap
msgid ""
"Tutorial.Intro> maxBits8 - 100\n"
"155\n"
msgstr ""
"Tutorial.Intro> maxBits8 - 100\n"
"155\n"

#. type: Plain text
#: ../src/Tutorial/Intro.md:286
msgid ""
"I called `maxBits8` a *nullary function*, which is just a fancy word for "
"*constant*. Let's write and test our first *real* function:"
msgstr ""
"私は `maxBits8` を *無引数関数* と呼びました。\n"
"無引数関数は *定数* のちょっと変わった呼び方です。\n"
"*真の* 関数を書いて試してみましょう。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Intro.md:287
#, no-wrap
msgid ""
"distanceToMax : Bits8 -> Bits8\n"
"distanceToMax n = maxBits8 - n\n"
msgstr ""
"distanceToMax : Bits8 -> Bits8\n"
"distanceToMax n = maxBits8 - n\n"

#. type: Plain text
#: ../src/Tutorial/Intro.md:299
#, no-wrap
msgid ""
"This introduces some new syntax and a new kind of type: Function\n"
"types. `distanceToMax : Bits8 -> Bits8` can be read as follows:\n"
"\"`distanceToMax` is a function of one argument of type `Bits8`, which\n"
"returns a result of type `Bits8`\". In the implementation, the argument\n"
"is given a local identifier `n`, which is then used in the\n"
"calculation on the right hand side. Again, go ahead and try this\n"
"function at the REPL:\n"
msgstr ""
"この例ではいくつかの新しい文法と新しい種類の型が紹介されています。\n"
"それは関数型です。\n"
"`distanceToMax : Bits8 -> Bits8` は次のように読み替えることができます。\n"
"「`distanceToMax` は関数で、型が `Bits8` な引数を1つ取って、\n"
"型が `Bits8` な結果を返します。」\n"
"実装では、引数がローカル変数 `n` として与えられています。\n"
"この変数は右側の計算に使われます。\n"
"再びREPLに戻ってこの関数を試しましょう。\n"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Intro.md:300
#, no-wrap
msgid ""
"Tutorial.Intro> distanceToMax 12\n"
"243\n"
"Tutorial.Intro> :t distanceToMax\n"
"Tutorial.Intro.distanceToMax : Bits8 -> Bits8\n"
"Tutorial.Intro> :t distanceToMax 12\n"
"distanceToMax 12 : Bits8\n"
msgstr ""
"Tutorial.Intro> distanceToMax 12\n"
"243\n"
"Tutorial.Intro> :t distanceToMax\n"
"Tutorial.Intro.distanceToMax : Bits8 -> Bits8\n"
"Tutorial.Intro> :t distanceToMax 12\n"
"distanceToMax 12 : Bits8\n"

#. type: Plain text
#: ../src/Tutorial/Intro.md:311
msgid ""
"As a final example, let's implement a function to calculate the square of an "
"integer:"
msgstr "最後の例として、整数の2乗を計算する関数を実装しましょう。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Intro.md:312
#, no-wrap
msgid ""
"square : Integer -> Integer\n"
"square n = n * n\n"
msgstr ""
"square : Integer -> Integer\n"
"square n = n * n\n"

#. type: Plain text
#: ../src/Tutorial/Intro.md:325
msgid ""
"We now learn a very important aspect of programming in Idris: Idris is a "
"*statically typed* programming language. We are not allowed to freely mix "
"types as we please. Doing so will result in an error message from the type "
"checker (which is part of the compilation process of Idris).  For instance, "
"if we try the following at the REPL, we will get a type error:"
msgstr ""
"ここでIdrisにおけるプログラミングのとても大切な側面を学びましょう。\n"
"Idrisは *静的型付け* プログラミング言語です。\n"
"好き勝手に型をごちゃ混ぜにすることはできません。\n"
"それをすると型検査器がエラーメッセージが出ます（型検査器はIdrisのコンパイル過"
"程の一部です）。\n"
"例えば、以下をREPLに打ち込むと、\n"
"型エラーが出ます。"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Intro.md:326
#, no-wrap
msgid ""
"Tutorial.Intro> square maxBits8\n"
"Error: ...\n"
msgstr ""
"Tutorial.Intro> square maxBits8\n"
"Error: ...\n"

#. type: Plain text
#: ../src/Tutorial/Intro.md:336
msgid ""
"The reason: `square` expects an argument of type `Integer`, but `maxBits8` "
"is of type `Bits8`. Many primitive types are interconvertible (sometimes "
"with the risk of loss of precision) using function `cast` (more on the "
"details later):"
msgstr ""
"その理由は、 `square` が `Integer` 型の引数を期待しているのに、\n"
"`maxBits8` は型が `Bits8` だからです。\n"
"多くの原始型は `cast` 関数（詳細は後述）を使って相互に変換できます（精度が落"
"ちる組み合わせもあります）。"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Intro.md:337
#, no-wrap
msgid ""
"Tutorial.Intro> square (cast maxBits8)\n"
"65025\n"
msgstr ""
"Tutorial.Intro> square (cast maxBits8)\n"
"65025\n"

#. type: Plain text
#: ../src/Tutorial/Intro.md:348
msgid ""
"Note, that in the example above the result is much larger that `maxBits8`. "
"The reason is, that `maxBits8` is first converted to an `Integer` of the "
"same value, which is then squared. If on the other hand we squared "
"`maxBits8` directly, the result would be truncated to still fit the valid "
"range of `Bits8`:"
msgstr ""
"上の例で、結果が `maxBits8` の型での上限よりかなり大きいですね。\n"
"なぜかというと、 `maxBits8` はまず同じ値の `Integer` に変換されて、\n"
"それから2乗されるからです。\n"
"一方でもし `maxBits8` を直接2乗したら、\n"
"結果は `Bits8` の正しい範囲に収まるように切り詰められます。"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Intro.md:349
#, no-wrap
msgid ""
"Tutorial.Intro> maxBits8 * maxBits8\n"
"1\n"
msgstr ""
"Tutorial.Intro> maxBits8 * maxBits8\n"
"1\n"

#. type: Title ##
#: ../src/Tutorial/Intro.md:354
#, no-wrap
msgid "Where to get Help"
msgstr "困ったときは"

#. type: Plain text
#: ../src/Tutorial/Intro.md:359
msgid ""
"There are several resources available online and in print, where you can "
"find help and documentation about the Idris programming language. Here is a "
"non-comprehensive list of them:"
msgstr ""
"オンラインや刊行物の形でいくつかの資料があります。\n"
"それらのプログラミング言語Idrisのドキュメントは役に立つでしょう。\n"
"全ては紹介しきれませんが、次のようなものがあります。"

#. type: Bullet: '* '
#: ../src/Tutorial/Intro.md:361
msgid ""
"[Type-Driven Development with Idris](https://www.manning.com/books/type-"
"driven-development-with-idris)"
msgstr ""
"[Type-Driven Development with Idris](https://www.manning.com/books/type-"
"driven-development-with-idris)"

#. type: Plain text
#: ../src/Tutorial/Intro.md:368
#, no-wrap
msgid ""
"  *The* Idris book! This describes in great detail\n"
"  the core concepts for using Idris and dependent types\n"
"  to write robust and concise code. It uses Idris 1 in\n"
"  its examples, so parts of it have to be slightly adjusted\n"
"  when using Idris 2. There is also a\n"
"  [list of required updates](https://idris2.readthedocs.io/en/latest/typedd/typedd.html).\n"
msgstr ""
"*唯一の* Idrisの書籍です！\n"
"堅牢で簡潔なコードを書くために、Idrisと依存型を使う上での核となる概念がとても詳しく書かれています。\n"
"例ではIdris 1が使われているので、\n"
"Idris 2で使うためには一部分を少しだけ調整する必要があります。\n"
"[更新が必要な箇所の一覧](https://idris2.readthedocs.io/en/latest/typedd/typedd.html)もあります。\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Intro.md:370
msgid ""
"[A Crash Course in Idris 2](https://idris2.readthedocs.io/en/latest/tutorial/"
"index.html)"
msgstr ""
"[A Crash Course in Idris 2](https://idris2.readthedocs.io/en/latest/tutorial/"
"index.html)"

#. type: Plain text
#: ../src/Tutorial/Intro.md:375
#, no-wrap
msgid ""
"  The official Idris 2 tutorial. A comprehensive but dense explanation of\n"
"  all features of Idris 2. I find this to be useful as a reference, and as such\n"
"  it is highly accessible. However, it is not an introduction to functional\n"
"  programming or type-driven development in general.\n"
msgstr ""
"公式のIdris 2入門です。\n"
"網羅的で密度の濃いIdris 2の特徴の説明があります。\n"
"広くアクセスできるため、筆者にとってはリファレンスとして重宝しています。\n"
"しかし、一般には関数型プログラミングや型駆動開発の導入ではありません。\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Intro.md:377
msgid "[The Idris 2 GitHub Repository](https://github.com/idris-lang/Idris2)"
msgstr "[Idris 2のGitHubリポジトリ](https://github.com/idris-lang/Idris2)"

#. type: Plain text
#: ../src/Tutorial/Intro.md:384
#, no-wrap
msgid ""
"  Look here for detailed installation instructions and some\n"
"  introductory material. There is also a [wiki](https://github.com/idris-lang/Idris2/wiki),\n"
"  where you can find a [list of editor plugins](https://github.com/idris-lang/Idris2/wiki/The-Idris-editor-experience),\n"
"  a [list of community libraries](https://github.com/idris-lang/Idris2/wiki/Libraries),\n"
"  a [list of external backends](https://github.com/idris-lang/Idris2/wiki/External-backends),\n"
"  and other useful information.\n"
msgstr ""
"ここにはインストール方法や導入資料があります。\n"
"[Wiki](https://github.com/idris-lang/Idris2/wiki)もあって、\n"
"[エディタのプラグインの一覧](https://github.com/idris-lang/Idris2/wiki/The-Idris-editor-experience)、\n"
"[コミュニティによるライブラリの一覧](https://github.com/idris-lang/Idris2/wiki/Libraries)、\n"
"[バックエンドの一覧](https://github.com/idris-lang/Idris2/wiki/External-backends)、\n"
"などの役に立つ情報が載っています。\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Intro.md:386
msgid "[The Idris 2 Discord Channel](https://discord.gg/UX68fDs2jc)"
msgstr "[Idris 2のDiscordチャンネル](https://discord.gg/UX68fDs2jc)"

#. type: Plain text
#: ../src/Tutorial/Intro.md:392
#, no-wrap
msgid ""
"  If you get stuck with a piece of code, want to ask about some\n"
"  obscure language feature, want to promote your new library,\n"
"  or want to just hang out with other Idris programmers, this\n"
"  is the place to go. The discord channel is pretty active and\n"
"  *very* friendly towards newcomers.\n"
msgstr ""
"コードの一部で詰まったり、\n"
"よくわからない言語の特徴について質問したいとき、\n"
"自分の新しいライブラリを喧伝したいとき、\n"
"あるいは他のIdrisプログラマと駄弁りたいときとかには、\n"
"こちらにお越しください。\n"
"Discordチャンネルはかなり活発で、\n"
"新参者に *とっても* 優しいです。\n"

#. type: Bullet: '* '
#: ../src/Tutorial/Intro.md:394
msgid "The Idris REPL"
msgstr "IdrisのREPL"

#. type: Plain text
#: ../src/Tutorial/Intro.md:400
#, no-wrap
msgid ""
"  Finally, a lot of useful information can be provided by\n"
"  Idris itself. I tend to have at least one REPL session open all the\n"
"  time when programming in Idris. My editor (neovim) is set up\n"
"  to use the [language server for Idris 2](https://github.com/idris-community/idris2-lsp),\n"
"  which is incredibly useful. In the REPL,\n"
msgstr ""
"最後に、沢山の役に立つ情報はIdris自身から提供されます。\n"
"筆者はIdrisでプログラミングするときはずっと、最低でも1つのREPLセッションを立ち上げたままにしがちです。\n"
"私が使っているエディタ (neovim) には\n"
"[Idris2のlanguage server](https://github.com/idris-community/idris2-lsp)が設定されています。\n"
"idris2-lspは大変便利です。\n"
"REPLでは、\n"

#. type: Bullet: '  * '
#: ../src/Tutorial/Intro.md:417
msgid ""
"use `:t` to inspect the type of an expression or meta variable (hole): `:t "
"foldl`,"
msgstr ""
"`:t` で式やメタ変数（穴）の型を調べられます。\n"
"例えば `:t foldl` とします。"

#. type: Bullet: '  * '
#: ../src/Tutorial/Intro.md:417
msgid ""
"use `:ti` to inspect the type of a function including implicit arguments: `:"
"ti foldl`,"
msgstr ""
"`:ti` で暗黙の引数を含む関数の型を調べられます。\n"
"例えば `:ti foldl` とします。"

#. type: Bullet: '  * '
#: ../src/Tutorial/Intro.md:417
msgid "use `:m` to list all meta variables (holes) in scope,"
msgstr "`:m` でスコープ内の全てのメタ変数（穴）の一覧が出てきます。"

#. type: Bullet: '  * '
#: ../src/Tutorial/Intro.md:417
msgid ""
"use `:doc` to access the documentation of a top level function (`:doc the`), "
"a data type plus all its constructors and available hints (`:doc Bool`), a "
"language feature (`:doc case`, `:doc let`, `:doc interface`, `:doc record`, "
"or even `:doc ?`), or an interface (`:doc Uninhabited`),"
msgstr ""
"`:doc` でドキュメントにアクセスできます。\n"
"トップレベルの関数（`:doc the`）、\n"
"データ型とその型の構築子と使えるヒント（`:doc Bool`）、\n"
"言語の特徴（`:doc case`, `:doc let`, `:doc interface`, `:doc record`, `:doc ?"
"` まで）、\n"
"それからインターフェース（`:doc Uninhabited`）が対象です。"

#. type: Bullet: '  * '
#: ../src/Tutorial/Intro.md:417
msgid ""
"use `:module` to import a module from one of the available packages: `:"
"module Data.Vect`,"
msgstr ""
"`:module` で使えるパッケージの中からモジュールをインポートします。\n"
"例えば `:module Data.Vect` とします。"

#. type: Bullet: '  * '
#: ../src/Tutorial/Intro.md:417
msgid ""
"use `:browse` to list the names and types of all functions exported by a "
"loaded module: `:browse Data.Vect`,"
msgstr ""
"`:browse` で読み込むモジュールが提供している全ての関数の名前と型の一覧が出て"
"きます。\n"
"例えば `:browse Data.Vect` とします。"

#. type: Bullet: '  * '
#: ../src/Tutorial/Intro.md:417
msgid ""
"use `:help` to get a list of other commands plus a short description for "
"each."
msgstr "`:help` で他のコマンドとそれぞれの短い説明が一覧で表示されます。"

#. type: Title ##
#: ../src/Tutorial/Intro.md:418
#, no-wrap
msgid "Summary"
msgstr "まとめ"

#. type: Plain text
#: ../src/Tutorial/Intro.md:425
msgid ""
"In this introduction we learned about the most basic features of the Idris "
"programming language. We used the REPL to tinker with our ideas and inspect "
"the types of things in our code, and we used the Idris compiler to compile "
"an Idris source file to an executable."
msgstr ""
"この導入ではプログラミング言語Idrisの一番基本的なことを学びました。\n"
"REPLで考えていることを試したり、\n"
"コード中の型を調べたり、\n"
"IdrisのソースファイルをIdrisのコンパイラで実行可能ファイルにしたりしました。"

#. type: Plain text
#: ../src/Tutorial/Intro.md:429
msgid ""
"We also learned about the basic shape of a top level definition in Idris, "
"which always consists of an identifier (its name), a type, and an "
"implementation."
msgstr ""
"Idrisでの最上位での定義の仕方の基本的な形を学びました。\n"
"定義には、識別子（名前）、型、そして実装があるのでした。"

#. type: Plain text
#: ../src/Tutorial/Intro.md:436
msgid ""
"In the [next chapter](Functions1.md), we start programming in Idris for "
"real. We learn how to write our own pure functions, how functions compose, "
"and how we can treat functions just like other values and pass them around "
"as arguments to other functions."
msgstr ""
"[次の章](Functions1.md)では、\n"
"実際のIdrisでのプログラミングを始めます。\n"
"自分で純粋な関数を書くやりかたや、\n"
"関数を組み合わせる方法、\n"
"そして関数を他の値と同じように扱ったり他の関数の引数として渡したりする方法を"
"学びます。"

#. type: Title #
#: ../src/Tutorial/Predicates.md:1
#, no-wrap
msgid "Predicates and Proof Search"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:12
msgid ""
"In the [last chapter](Eq.md) we learned about propositional equality, which "
"allowed us to proof that two values are equal. Equality is a relation "
"between values, and we used an indexed data type to encode this relation by "
"limiting the degrees of freedom of the indices in the sole data constructor. "
"There are other relations and contracts we can encode this way. This will "
"allow us to restrict the values we accept as a function's arguments or the "
"values returned by functions."
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:13
#, no-wrap
msgid ""
"module Tutorial.Predicates\n"
"\n"
"import Data.Either\n"
"import Data.List1\n"
"import Data.String\n"
"import Data.Vect\n"
"import Data.HList\n"
"import Decidable.Equality\n"
"\n"
"import Text.CSV\n"
"import System.File\n"
"\n"
"%default total\n"
msgstr ""

#. type: Title ##
#: ../src/Tutorial/Predicates.md:29
#, no-wrap
msgid "Preconditions"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:38
msgid ""
"Often, when we implement functions operating on values of a given type, not "
"all values are considered to be valid arguments for the function in "
"question. For instance, we typically do not allow division by zero, as the "
"result is undefined in the general case. This concept of putting a "
"*precondition* on a function argument comes up pretty often, and there are "
"several ways to go about this."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:45
msgid ""
"A very common operation when working with lists or other container types is "
"to extract the first value in the sequence.  This function, however, cannot "
"work in the general case, because in order to extract a value from a list, "
"the list must not be empty. Here are a couple of ways to encode and "
"implement this, each with its own advantages and disadvantages:"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Predicates.md:57
msgid ""
"Wrap the result in a failure type, such as a `Maybe` or `Either e` with some "
"custom error type `e`. This makes it immediately clear that the function "
"might not be able to return a result. It is a natural way to deal with "
"unvalidated input from unknown sources. The drawback of this approach is "
"that results will carry the `Maybe` stain, even in situations when we *know* "
"that the *nil* case is impossible, for instance because we know the value of "
"the list argument at compile-time, or because we already *refined* the input "
"value in such a way that we can be sure it is not empty (due to an earlier "
"pattern match, for instance)."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Predicates.md:67
msgid ""
"Define a new data type for non-empty lists and use this as the function's "
"argument. This is the approach taken in module `Data.List1`. It allows us to "
"return a pure value (meaning \"not wrapped in a failure type\" here), "
"because the function cannot possibly fail, but it comes with the burden of "
"reimplementing many of the utility functions and interfaces we already "
"implemented for `List`. For a very common data structure this can be a valid "
"option, but for rare use cases it is often too cumbersome."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Predicates.md:81
msgid ""
"Use an index to keep track of the property we are interested in. This was "
"the approach we took with type family `List01`, which we saw in several "
"examples and exercises in this guide so far. This is also the approach taken "
"with vectors, where we use the exact length as our index, which is even more "
"expressive. While this allows us to implement many functions only once and "
"with greater precision at the type level, it also comes with the burden of "
"keeping track of changes in the types, making for more complex function "
"types and forcing us to at times return existentially quantified wrappers "
"(for instance, dependent pairs), because the outcome of a computation is not "
"known until runtime."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Predicates.md:87
msgid ""
"Fail with a runtime exception. This is a popular solution in many "
"programming languages (even Haskell), but in Idris we try to avoid this, "
"because it breaks totality in a way, which also affects client code. "
"Luckily, we can make use of our powerful type system to avoid this situation "
"in general."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Predicates.md:94
msgid ""
"Take an additional (possibly erased) argument of a type we can use as a "
"witness that the input value is of the correct kind or shape. This is the "
"solution we will discuss in this chapter in great detail. It is an "
"incredibly powerful way to talk about restrictions on values without having "
"to replicate a lot of already existing functionality."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:100
msgid ""
"There is a time and place for most if not all of the solutions listed above "
"in Idris, but we will often turn to the last one and refine function "
"arguments with predicates (so called *preconditions*), because it makes our "
"functions nice to use at runtime *and* compile time."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Predicates.md:101
#, no-wrap
msgid "Example: Non-empty Lists"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:107
msgid ""
"Remember how we implemented an indexed data type for propositional equality: "
"We restricted the valid values of the indices in the constructors. We can do "
"the same thing for a predicate for non-empty lists:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:108
#, no-wrap
msgid ""
"data NotNil : (as : List a) -> Type where\n"
"  IsNotNil : NotNil (h :: t)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:117
msgid ""
"This is a single-value data type, so we can always use it as an erased "
"function argument and still pattern match on it. We can now use this to "
"implement a safe and pure `head` function:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:118
#, no-wrap
msgid ""
"head1 : (as : List a) -> (0 _ : NotNil as) -> a\n"
"head1 (h :: _) _ = h\n"
"head1 [] IsNotNil impossible\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:129
msgid ""
"Note, how value `IsNotNil` is a *witness* that its index, which corresponds "
"to our list argument, is indeed non-empty, because this is what we specified "
"in its type.  The impossible case in the implementation of `head1` is not "
"strictly necessary here. It was given above for completeness."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:134
msgid ""
"We call `NotNil` a *predicate* on lists, as it restricts the values allowed "
"in the index. We can express a function's preconditions by adding additional "
"(possibly erased) predicates to the function's list of arguments."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:138
msgid ""
"The first really cool thing is how we can safely use `head1`, if we can at "
"compile-time show that our list argument is indeed non-empty:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:139
#, no-wrap
msgid ""
"headEx1 : Nat\n"
"headEx1 = head1 [1,2,3] IsNotNil\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:152
msgid ""
"It is a bit cumbersome that we have to pass the `IsNotNil` proof manually. "
"Before we scratch that itch, we will first discuss what to do with lists, "
"the values of which are not known until runtime. For these cases, we have to "
"try and produce a value of the predicate programmatically by inspecting the "
"runtime list value. In the most simple case, we can wrap the proof in a "
"`Maybe`, but if we can show that our predicate is *decidable*, we can get "
"even stronger guarantees by returning a `Dec`:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:153
#, no-wrap
msgid ""
"Uninhabited (NotNil []) where\n"
"  uninhabited IsNotNil impossible\n"
"\n"
"nonEmpty : (as : List a) -> Dec (NotNil as)\n"
"nonEmpty (x :: xs) = Yes IsNotNil\n"
"nonEmpty []        = No uninhabited\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:164
msgid ""
"With this, we can implement function `headMaybe`, which is to be used with "
"lists of unknown origin:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:165
#, no-wrap
msgid ""
"headMaybe1 : List a -> Maybe a\n"
"headMaybe1 as = case nonEmpty as of\n"
"  Yes prf => Just $ head1 as prf\n"
"  No  _   => Nothing\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:176
msgid ""
"Of course, for trivial functions like `headMaybe` it makes more sense to "
"implement them directly by pattern matching on the list argument, but we "
"will soon see examples of predicates the values of which are more cumbersome "
"to create."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Predicates.md:177
#, no-wrap
msgid "Auto Implicits"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:187
msgid ""
"Having to manually pass a proof of being non-empty to `head1` makes this "
"function unnecessarily verbose to use at compile time. Idris allows us to "
"define implicit function arguments, the values of which it tries to assemble "
"on its own by means of a technique called *proof search*. This is not to be "
"confused with type inference, which means inferring values or types from the "
"surrounding context. It's best to look at some examples to explain the "
"difference."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:190
msgid ""
"Let us first have a look at the following implementation of `replicate` for "
"vectors:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:191
#, no-wrap
msgid ""
"replicate' : {n : _} -> a -> Vect n a\n"
"replicate' {n = 0}   _ = []\n"
"replicate' {n = S _} v = v :: replicate' v\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:202
msgid ""
"Function `replicate'` takes an unerased implicit argument.  The *value* of "
"this argument must be derivable from the surrounding context. For instance, "
"in the following example it is immediately clear that `n` equals three, "
"because that is the length of the vector we want:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:203
#, no-wrap
msgid ""
"replicateEx1 : Vect 3 Nat\n"
"replicateEx1 = replicate' 12\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:211
msgid ""
"In the next example, the value of `n` is not known at compile time, but it "
"is available as an unerased implicit, so this can again be passed as is to "
"`replicate'`:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:212
#, no-wrap
msgid ""
"replicateEx2 : {n : _} -> Vect n Nat\n"
"replicateEx2 = replicate' 12\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:223
msgid ""
"However, in the following example, the value of `n` can't be inferred, as "
"the intermediary vector is immediately converted to a list of unknown "
"length. Although Idris could try and insert any value for `n` here, it won't "
"do so, because it can't be sure that this is the length we want. We "
"therefore have to pass the length explicitly:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:224
#, no-wrap
msgid ""
"replicateEx3 : List Nat\n"
"replicateEx3 = toList $ replicate' {n = 17} 12\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:234
msgid ""
"Note, how the *value* of `n` had to be inferable in these examples, which "
"means it had to make an appearance in the surrounding context. With auto "
"implicit arguments, this works differently. Here is the `head` example, this "
"time with an auto implicit:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:235
#, no-wrap
msgid ""
"head : (as : List a) -> {auto 0 prf : NotNil as} -> a\n"
"head (x :: _) = x\n"
"head [] impossible\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:249
msgid ""
"Note the `auto` keyword before the quantity of implicit argument `prf`. This "
"means, we want Idris to construct this value on its own, without it being "
"visible in the surrounding context.  In order to do so, Idris will have to "
"at compile time know the structure of the list argument `as`. It will then "
"try and build such a value from the data type's constructors. If it "
"succeeds, this value will then be automatically filled in as the desired "
"argument, otherwise, Idris will fail with a type error."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:251
msgid "Let's see this in action:"
msgstr "ちょっとREPLで動かしてみましょう。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:252
#, no-wrap
msgid ""
"headEx3 : Nat\n"
"headEx3 = Predicates.head [1,2,3]\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:258
msgid "The following example fails with an error:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:259
#, no-wrap
msgid ""
"failing \"Can't find an implementation\\nfor NotNil [].\"\n"
"  errHead : Nat\n"
"  errHead = Predicates.head []\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:276
#, no-wrap
msgid ""
"Wait! \"Can't find an implementation for...\"? Is this not the\n"
"error message we get for missing interface implementations?\n"
"That's correct, and I'll show you that interface resolution\n"
"is just proof search at the end of this chapter. What I can\n"
"show you already, is that writing the lengthy `{auto prf : t} ->`\n"
"all the times can be cumbersome. Idris therefore allows us\n"
"to use the same syntax as for constrained functions instead:\n"
"`(prf : t) =>`, or even `t =>`, if we don't need to name the\n"
"constraint. As usual, we can then access a constraint in the\n"
"function body by its name (if any). Here is another implementation\n"
"of `head`:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:277
#, no-wrap
msgid ""
"head' : (as : List a) -> (0 _ : NotNil as) => a\n"
"head' (x :: _) = x\n"
"head' [] impossible\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:287
msgid ""
"During proof search, Idris will also look for values of the required type in "
"the current function context. This allows us to implement `headMaybe` "
"without having to pass on the `NotNil` proof manually:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:288
#, no-wrap
msgid ""
"headMaybe : List a -> Maybe a\n"
"headMaybe as = case nonEmpty as of\n"
"  -- `prf` is available during proof seach\n"
"  Yes prf => Just $ Predicates.head as\n"
"  No  _   => Nothing\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:304
msgid ""
"To conclude: Predicates allow us to restrict the values a function accepts "
"as arguments. At runtime, we need to build such *witnesses* by pattern "
"matching on the function arguments. These operations can typically fail. At "
"compile time, we can let Idris try and build these values for us using a "
"technique called *proof search*. This allows us to make functions safe and "
"convenient to use at the same time."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:312
msgid ""
"In these exercises, you'll have to implement several functions making use of "
"auto implicits, to constrain the values accepted as function arguments. The "
"results should be *pure*, that is, not wrapped in a failure type like "
"`Maybe`."
msgstr ""

#. type: Bullet: '1. '
#: ../src/Tutorial/Predicates.md:314
msgid "Implement `tail` for lists."
msgstr ""

#. type: Bullet: '2. '
#: ../src/Tutorial/Predicates.md:318
msgid ""
"Implement `concat1` and `foldMap1` for lists. These should work like "
"`concat` and `foldMap`, but taking only a `Semigroup` constraint on the "
"element type."
msgstr ""

#. type: Bullet: '3. '
#: ../src/Tutorial/Predicates.md:321
msgid ""
"Implement functions for returning the largest and smallest element in a list."
msgstr ""

#. type: Bullet: '4. '
#: ../src/Tutorial/Predicates.md:325
msgid ""
"Define a predicate for strictly positive natural numbers and use it to "
"implement a safe and provably total division function on natural numbers."
msgstr ""

#. type: Bullet: '5. '
#: ../src/Tutorial/Predicates.md:330
msgid ""
"Define a predicate for a non-empty `Maybe` and use it to safely extract the "
"value stored in a `Just`. Show that this predicate is decidable by "
"implementing a corresponding conversion function."
msgstr ""

#. type: Bullet: '6. '
#: ../src/Tutorial/Predicates.md:334
msgid ""
"Define and implement functions for safely extracting values from a `Left` "
"and a `Right` by using suitable predicates.  Show again that these "
"predicates are decidable."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:339
msgid ""
"The predicates you implemented in these exercises are already available in "
"the *base* library: `Data.List.NonEmpty`, `Data.Maybe.IsJust`, `Data.Either."
"IsLeft`, `Data.Either.IsRight`, and `Data.Nat.IsSucc`."
msgstr ""

#. type: Title ##
#: ../src/Tutorial/Predicates.md:340
#, no-wrap
msgid "Contracts between Values"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:346
msgid ""
"The predicates we saw so far restricted the values of a single type, but it "
"is also possible to define predicates describing contracts between several "
"values of possibly distinct types."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Predicates.md:347
#, no-wrap
msgid "The `Elem` Predicate"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:351
msgid ""
"Assume we'd like to extract a value of a given type from a heterogeneous "
"list:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:352
#, no-wrap
msgid "get' : (0 t : Type) -> HList ts -> t\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:358
msgid ""
"This can't work in general: If we could implement this we would immediately "
"have a proof of void:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:359
#, no-wrap
msgid ""
"voidAgain : Void\n"
"voidAgain = get' Void []\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:367
msgid ""
"The problem is obvious: The type of which we'd like to extract a value must "
"be an element of the index of the heterogeneous list.  Here is a predicate, "
"with which we can express this:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:368
#, no-wrap
msgid ""
"data Elem : (elem : a) -> (as : List a) -> Type where\n"
"  Here  : Elem x (x :: xs)\n"
"  There : Elem x xs -> Elem x (y :: xs)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:386
msgid ""
"This is a predicate describing a contract between two values: A value of "
"type `a` and a list of `a`s. Values of this predicate are witnesses that the "
"value is an element of the list.  Note, how this is defined recursively: The "
"case where the value we look for is at the head of the list is handled by "
"the `Here` constructor, where the same variable (`x`) is used for the "
"element and the head of the list. The case where the value is deeper within "
"the list is handled by the `There` constructor. This can be read as follows: "
"If `x` is and element of `xs`, then `x` is also an element of `y :: xs` for "
"any value `y`. Let's write down some examples to get a feel for these:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:387
#, no-wrap
msgid ""
"MyList : List Nat\n"
"MyList = [1,3,7,8,4,12]\n"
"\n"
"oneElemMyList : Elem 1 MyList\n"
"oneElemMyList = Here\n"
"\n"
"sevenElemMyList : Elem 7 MyList\n"
"sevenElemMyList = There $ There Here\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:402
msgid ""
"Now, `Elem` is just another way of indexing into a list of values. Instead "
"of using a `Fin` index, which is limited by the list's length, we use a "
"proof that a value can be found at a certain position."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:405
msgid ""
"We can use the `Elem` predicate to extract a value from the desired type of "
"a heterogeneous list:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:406
#, no-wrap
msgid "get : (0 t : Type) -> HList ts -> (prf : Elem t ts) => t\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:415
msgid ""
"It is important to note that the auto implicit must not be erased in this "
"case. This is no longer a single value data type, and we must be able to "
"pattern match on this value in order to figure out, how far within the "
"heterogeneous list our value is stored:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:416
#, no-wrap
msgid ""
"get t (v :: vs) {prf = Here}    = v\n"
"get t (v :: vs) {prf = There p} = get t vs\n"
"get _ [] impossible\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:425
msgid ""
"It can be instructive to implement `get` yourself, using holes on the right "
"hand side to see the context and types of values Idris infers based on the "
"value of the `Elem` predicate."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:427
msgid "Let's give this a spin at the REPL:"
msgstr "ちょっとREPLで動かしてみましょう。"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Predicates.md:428
#, no-wrap
msgid ""
"Tutorial.Predicates> get Nat [\"foo\", Just \"bar\", S Z]\n"
"1\n"
"Tutorial.Predicates> get Nat [\"foo\", Just \"bar\"]\n"
"Error: Can't find an implementation for Elem Nat [String, Maybe String].\n"
"\n"
"(Interactive):1:1--1:28\n"
" 1 | get Nat [\"foo\", Just \"bar\"]\n"
"     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:446
msgid ""
"With this example we start to appreciate what *proof search* actually means: "
"Given a value `v` and a list of values `vs`, Idris tries to find a proof "
"that `v` is an element of `vs`.  Now, before we continue, please note that "
"proof search is not a silver bullet. The search algorithm has a reasonably "
"limited *search depth*, and will fail with the search if this limit is "
"exceeded. For instance:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:447
#, no-wrap
msgid ""
"Tps : List Type\n"
"Tps = List.replicate 50 Nat ++ [Maybe String]\n"
"\n"
"hlist : HList Tps\n"
"hlist = [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n"
"        , 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n"
"        , 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n"
"        , 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n"
"        , 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n"
"        , Nothing ]\n"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Predicates.md:462
#, no-wrap
msgid ""
"Tutorial.Predicates> get (Maybe String) hlist\n"
"Error: Can't find an implementation for Elem (Maybe String) [Nat,...\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:474
msgid ""
"As you can see, Idris fails to find a proof that `Maybe String` is an "
"element of `Tps`. The search depth can be increased with the `"
"%auto_implicit_depth` directive, which will hold for the rest of the source "
"file or until set to a different value.  The default value is set at 25. In "
"general, it is not advisable to set this to a too large value as this can "
"drastically increase compile times."
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:475
#, no-wrap
msgid ""
"%auto_implicit_depth 100\n"
"aMaybe : Maybe String\n"
"aMaybe = get _ hlist\n"
"\n"
"%auto_implicit_depth 25\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Predicates.md:483
#, no-wrap
msgid "Use Case: A nicer Schema"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:492
msgid ""
"In the chapter about [sigma types](DPair.md), we introduced a schema for CSV "
"files. This was not very nice to use, because we had to use natural numbers "
"to access a certain column. Even worse, users of our small library had to do "
"the same. There was no way to define a name for each column and access "
"columns by name. We are going to change this. Here is an encoding for this "
"use case:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:493
#, no-wrap
msgid ""
"data ColType = I64 | Str | Boolean | Float\n"
"\n"
"IdrisType : ColType -> Type\n"
"IdrisType I64     = Int64\n"
"IdrisType Str     = String\n"
"IdrisType Boolean = Bool\n"
"IdrisType Float   = Double\n"
"\n"
"record Column where\n"
"  constructor MkColumn\n"
"  name : String\n"
"  type : ColType\n"
"\n"
"infixr 8 :>\n"
"\n"
"(:>) : String -> ColType -> Column\n"
"(:>) = MkColumn\n"
"\n"
"Schema : Type\n"
"Schema = List Column\n"
"\n"
"Show ColType where\n"
"  show I64     = \"I64\"\n"
"  show Str     = \"Str\"\n"
"  show Boolean = \"Boolean\"\n"
"  show Float   = \"Float\"\n"
"\n"
"Show Column where\n"
"  show (MkColumn n ct) = \"\\{n}:\\{show ct}\"\n"
"\n"
"showSchema : Schema -> String\n"
"showSchema = concat . intersperse \",\" . map show\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:531
msgid ""
"As you can see, in a schema we now pair a column's type with its name. Here "
"is an example schema for a CSV file holding information about employees in a "
"company:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:532
#, no-wrap
msgid ""
"EmployeeSchema : Schema\n"
"EmployeeSchema = [ \"firstName\"  :> Str\n"
"                 , \"lastName\"   :> Str\n"
"                 , \"email\"      :> Str\n"
"                 , \"age\"        :> I64\n"
"                 , \"salary\"     :> Float\n"
"                 , \"management\" :> Boolean\n"
"                 ]\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:549
msgid ""
"Such a schema could of course again be read from user input, but we will "
"wait with implementing a parser until later in this chapter.  Using this new "
"schema with an `HList` directly led to issues with type inference, therefore "
"I quickly wrote a custom row type: A heterogeneous list indexed over a "
"schema."
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:550
#, no-wrap
msgid ""
"data Row : Schema -> Type where\n"
"  Nil  : Row []\n"
"\n"
"  (::) :  {0 name : String}\n"
"       -> {0 type : ColType}\n"
"       -> (v : IdrisType type)\n"
"       -> Row ss\n"
"       -> Row (name :> type :: ss)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:565
msgid ""
"In the signature of *cons*, I list the erased implicit arguments explicitly. "
"This is good practice, as otherwise Idris will often issue shadowing "
"warnings when using such data constructors in client code."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:567
msgid "We can now define a type alias for CSV rows representing employees:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:568
#, no-wrap
msgid ""
"0 Employee : Type\n"
"Employee = Row EmployeeSchema\n"
"\n"
"hock : Employee\n"
"hock = [ \"Stefan\", \"Höck\", \"hock@foo.com\", 46, 5443.2, False ]\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:584
msgid ""
"Note, how I gave `Employee` a zero quantity. This means, we are only ever "
"allowed to use this function at compile time but never at runtime. This is a "
"safe way to make sure our type-level functions and aliases do not leak into "
"the executable when we build our application. We are allowed to use zero-"
"quantity functions and values in type signatures and when computing other "
"erased values, but not for runtime-relevant computations."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:602
msgid ""
"We would now like to access a value in a row based on the name given. For "
"this, we write a custom predicate, which serves as a witness that a column "
"with the given name is part of the schema. Now, here is an important thing "
"to note: In this predicate we include an index for the *type* of the column "
"with the given name. We need this, because when we access a column by name, "
"we need a way to figure out the return type. But during proof search, this "
"type will have to be derived by Idris based on the column name and schema in "
"question (otherwise, the proof search will fail unless the return type is "
"known in advance).  We therefore *must* tell Idris, that it can't include "
"this type in the list of search criteria, otherwise it will try and infer "
"the column type from the context (using type inference) before running the "
"proof search. This can be done by listing the indices to be used in the "
"search like so: `[search name schema]`."
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:603
#, no-wrap
msgid ""
"data InSchema :  (name    : String)\n"
"              -> (schema  : Schema)\n"
"              -> (colType : ColType)\n"
"              -> Type where\n"
"  [search name schema]\n"
"  IsHere  : InSchema n (n :> t :: ss) t\n"
"  IsThere : InSchema n ss t -> InSchema n (fld :: ss) t\n"
"\n"
"Uninhabited (InSchema n [] c) where\n"
"  uninhabited IsHere impossible\n"
"  uninhabited (IsThere _) impossible\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:619
msgid ""
"With this, we are now ready to access the value at a given column based on "
"the column's name:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:620
#, no-wrap
msgid ""
"getAt :  {0 ss : Schema}\n"
"      -> (name : String)\n"
"      -> (row  : Row ss)\n"
"      -> (prf  : InSchema name ss c)\n"
"      => IdrisType c\n"
"getAt name (v :: vs) {prf = IsHere}    = v\n"
"getAt name (_ :: vs) {prf = IsThere p} = getAt name vs\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:638
msgid ""
"Below is an example how to use this at compile time. Note the amount of work "
"Idris performs for us: It first comes up with proofs that `firstName`, "
"`lastName`, and `age` are indeed valid names in the `Employee` schema. From "
"these proofs it automatically figures out the return types of the calls to "
"`getAt` and extracts the corresponding values from the row. All of this "
"happens in a provably total and type safe way."
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:639
#, no-wrap
msgid ""
"shoeck : String\n"
"shoeck =  getAt \"firstName\" hock\n"
"       ++ \" \"\n"
"       ++ getAt \"lastName\" hock\n"
"       ++ \": \"\n"
"       ++ show (getAt \"age\" hock)\n"
"       ++ \" years old.\"\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:657
msgid ""
"In order to at runtime specify a column name, we need a way for computing "
"values of type `InSchema` by comparing the column names with the schema in "
"question. Since we have to compare two string values for being "
"propositionally equal, we use the `DecEq` implementation for `String` here "
"(Idris provides `DecEq` implementations for all primitives). We extract the "
"column type at the same time and pair this (as a dependent pair) with the "
"`InSchema` proof:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:658
#, no-wrap
msgid ""
"inSchema : (ss : Schema) -> (n : String) -> Maybe (c ** InSchema n ss c)\n"
"inSchema []                    _ = Nothing\n"
"inSchema (MkColumn cn t :: xs) n = case decEq cn n of\n"
"  Yes Refl   => Just (t ** IsHere)\n"
"  No  contra => case inSchema xs n of\n"
"    Just (t ** prf) => Just $ (t ** IsThere prf)\n"
"    Nothing         => Nothing\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:671
msgid ""
"At the end of this chapter we will use `InSchema` in our CSV command-line "
"application to list all values in a column."
msgstr ""

#. type: Bullet: '1. '
#: ../src/Tutorial/Predicates.md:676
msgid ""
"Show that `InSchema` is decidable by changing the output type of `inSchema` "
"to `Dec (c ** InSchema n ss c)`."
msgstr ""

#. type: Bullet: '2. '
#: ../src/Tutorial/Predicates.md:679
msgid ""
"Declare and implement a function for modifying a field in a row based on the "
"column name given."
msgstr ""

#. type: Bullet: '3. '
#: ../src/Tutorial/Predicates.md:684
msgid ""
"Define a predicate to be used as a witness that one list contains only "
"elements in the second list in the same order and use this predicate to "
"extract several columns from a row at once."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:688
#, no-wrap
msgid ""
"   For instance, `[2,4,5]` contains elements from\n"
"   `[1,2,3,4,5,6]` in the correct order, but `[4,2,5]`\n"
"   does not.\n"
msgstr ""

#. type: Bullet: '4. '
#: ../src/Tutorial/Predicates.md:694
msgid ""
"Improve the functionality from exercise 3 by defining a new predicate, "
"witnessing that all strings in a list correspond to column names in a schema "
"(in arbitrary order).  Use this to extract several columns from a row at "
"once in arbitrary order."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:698
#, no-wrap
msgid ""
"   Hint: Make sure to include the resulting schema as an index,\n"
"   but search only based on the list of names and the input\n"
"   schema.\n"
msgstr ""

#. type: Title ##
#: ../src/Tutorial/Predicates.md:699
#, no-wrap
msgid "Use Case: Flexible Error Handling"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:718
msgid ""
"A recurring pattern when writing larger applications is the combination of "
"different parts of a program each with their own failure types in a larger "
"effectful computation.  We saw this, for instance, when implementing a "
"command-line tool for handling CSV files. There, we read and wrote data from "
"and to files, we parsed column types and schemata, we parsed row and column "
"indices and command-line commands.  All these operations came with the "
"potential of failure and might be implemented in different parts of our "
"application.  In order to unify these different failure types, we wrote a "
"custom sum type encapsulating each of them, and wrote a single handler for "
"this sum type. This approach was alright then, but it does not scale well "
"and is lacking in terms of flexibility. We are therefore trying a different "
"approach here. Before we continue, we quickly implement a couple of "
"functions with the potential of failure plus some custom error types:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:719
#, no-wrap
msgid ""
"record NoNat where\n"
"  constructor MkNoNat\n"
"  str : String\n"
"\n"
"readNat' : String -> Either NoNat Nat\n"
"readNat' s = maybeToEither (MkNoNat s) $ parsePositive s\n"
"\n"
"record NoColType where\n"
"  constructor MkNoColType\n"
"  str : String\n"
"\n"
"readColType' : String -> Either NoColType ColType\n"
"readColType' \"I64\"     = Right I64\n"
"readColType' \"Str\"     = Right Str\n"
"readColType' \"Boolean\" = Right Boolean\n"
"readColType' \"Float\"   = Right Float\n"
"readColType' s         = Left $ MkNoColType s\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:746
msgid ""
"However, if we wanted to parse a `Fin n`, there'd be already two ways how "
"this could fail: The string in question could not represent a natural number "
"(leading to a `NoNat` error), or it could be out of bounds (leading to an "
"`OutOfBounds` error).  We have to somehow encode these two possibilities in "
"the return type, for instance, by using an `Either` as the error type:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:747
#, no-wrap
msgid ""
"record OutOfBounds where\n"
"  constructor MkOutOfBounds\n"
"  size  : Nat\n"
"  index : Nat\n"
"\n"
"readFin' : {n : _} -> String -> Either (Either NoNat OutOfBounds) (Fin n)\n"
"readFin' s = do\n"
"  ix <- mapFst Left (readNat' s)\n"
"  maybeToEither (Right $ MkOutOfBounds n ix) $ natToFin ix n\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:767
msgid ""
"This is incredibly ugly. A custom sum type might have been slightly better, "
"but we still would have to use `mapFst` when invoking `readNat'`, and "
"writing custom sum types for every possible combination of errors will get "
"cumbersome very quickly as well.  What we are looking for, is a generalized "
"sum type: A type indexed by a list of types (the possible choices) holding a "
"single value of exactly one of the types in question.  Here is a first naive "
"try:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:768
#, no-wrap
msgid ""
"data Sum : List Type -> Type where\n"
"  MkSum : (val : t) -> Sum ts\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:783
msgid ""
"However, there is a crucial piece of information missing: We have not "
"verified that `t` is an element of `ts`, nor *which* type it actually is. In "
"fact, this is another case of an erased existential, and we will have no way "
"to at runtime learn something about `t`. What we need to do is to pair the "
"value with a proof, that its type `t` is an element of `ts`.  We could use "
"`Elem` again for this, but for some use cases we will require access to the "
"number of types in the list.  We will therefore use a vector instead of a "
"list as our index.  Here is a predicate similar to `Elem` but for vectors:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:784
#, no-wrap
msgid ""
"data Has :  (v : a) -> (vs  : Vect n a) -> Type where\n"
"  Z : Has v (v :: vs)\n"
"  S : Has v vs -> Has v (w :: vs)\n"
"\n"
"Uninhabited (Has v []) where\n"
"  uninhabited Z impossible\n"
"  uninhabited (S _) impossible\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:797
msgid ""
"A value of type `Has v vs` is a witness that `v` is an element of `vs`. With "
"this, we can now implement an indexed sum type (also called an *open union*):"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:798
#, no-wrap
msgid ""
"data Union : Vect n Type -> Type where\n"
"  U : (ix : Has t ts) -> (val : t) -> Union ts\n"
"\n"
"Uninhabited (Union []) where\n"
"  uninhabited (U ix _) = absurd ix\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:811
msgid ""
"Note the difference between `HList` and `Union`. `HList` is a *generalized "
"product type*: It holds a value for each type in its index. `Union` is a "
"*generalized sum type*: It holds only a single value, which must be of a "
"type listed in the index.  With this we can now define a much more flexible "
"error type:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:812
#, no-wrap
msgid ""
"0 Err : Vect n Type -> Type -> Type\n"
"Err ts t = Either (Union ts) t\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:820
msgid ""
"A function returning an `Err ts a` describes a computation, which can fail "
"with one of the errors listed in `ts`.  We first need some utility functions."
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:821
#, no-wrap
msgid ""
"inject : (prf : Has t ts) => (v : t) -> Union ts\n"
"inject v = U prf v\n"
"\n"
"fail : Has t ts => (err : t) -> Err ts a\n"
"fail err = Left $ inject err\n"
"\n"
"failMaybe : Has t ts => (err : Lazy t) -> Maybe a -> Err ts a\n"
"failMaybe err = maybeToEither (inject err)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:834
msgid ""
"Next, we can write more flexible versions of the parsers we wrote above:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:835
#, no-wrap
msgid ""
"readNat : Has NoNat ts => String -> Err ts Nat\n"
"readNat s = failMaybe (MkNoNat s) $ parsePositive s\n"
"\n"
"readColType : Has NoColType ts => String -> Err ts ColType\n"
"readColType \"I64\"     = Right I64\n"
"readColType \"Str\"     = Right Str\n"
"readColType \"Boolean\" = Right Boolean\n"
"readColType \"Float\"   = Right Float\n"
"readColType s         = fail $ MkNoColType s\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:849
msgid ""
"Before we implement `readFin`, we introduce a short cut for specifying that "
"several error types must be present:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:850
#, no-wrap
msgid ""
"0 Errs : List Type -> Vect n Type -> Type\n"
"Errs []        _  = ()\n"
"Errs (x :: xs) ts = (Has x ts, Errs xs ts)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:860
msgid ""
"Function `Errs` returns a tuple of constraints. This can be used as a "
"witness that all listed types are present in the vector of types: Idris will "
"automatically extract the proofs from the tuple as needed."
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:862
#, no-wrap
msgid ""
"readFin : {n : _} -> Errs [NoNat, OutOfBounds] ts => String -> Err ts (Fin n)\n"
"readFin s = do\n"
"  S ix <- readNat s | Z => fail (MkOutOfBounds n Z)\n"
"  failMaybe (MkOutOfBounds n (S ix)) $ natToFin ix n\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:871
msgid "As a last example, here are parsers for schemata and CSV rows:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:872
#, no-wrap
msgid ""
"fromCSV : String -> List String\n"
"fromCSV = forget . split (',' ==)\n"
"\n"
"record InvalidColumn where\n"
"  constructor MkInvalidColumn\n"
"  str : String\n"
"\n"
"readColumn : Errs [InvalidColumn, NoColType] ts => String -> Err ts Column\n"
"readColumn s = case forget $ split (':' ==) s of\n"
"  [n,ct] => MkColumn n <$> readColType ct\n"
"  _      => fail $ MkInvalidColumn s\n"
"\n"
"readSchema : Errs [InvalidColumn, NoColType] ts => String -> Err ts Schema\n"
"readSchema = traverse readColumn . fromCSV\n"
"\n"
"data RowError : Type where\n"
"  InvalidField  : (row, col : Nat) -> (ct : ColType) -> String -> RowError\n"
"  UnexpectedEOI : (row, col : Nat) -> RowError\n"
"  ExpectedEOI   : (row, col : Nat) -> RowError\n"
"\n"
"decodeField :  Has RowError ts\n"
"            => (row,col : Nat)\n"
"            -> (c : ColType)\n"
"            -> String\n"
"            -> Err ts (IdrisType c)\n"
"decodeField row col c s =\n"
"  let err = InvalidField row col c s\n"
"   in case c of\n"
"        I64     => failMaybe err $ read s\n"
"        Str     => failMaybe err $ read s\n"
"        Boolean => failMaybe err $ read s\n"
"        Float   => failMaybe err $ read s\n"
"\n"
"decodeRow :  Has RowError ts\n"
"          => {s : _}\n"
"          -> (row : Nat)\n"
"          -> (str : String)\n"
"          -> Err ts (Row s)\n"
"decodeRow row = go 1 s . fromCSV\n"
"  where go : Nat -> (cs : Schema) -> List String -> Err ts (Row cs)\n"
"        go k []       []                    = Right []\n"
"        go k []       (_ :: _)              = fail $ ExpectedEOI row k\n"
"        go k (_ :: _) []                    = fail $ UnexpectedEOI row k\n"
"        go k (MkColumn n c :: cs) (s :: ss) =\n"
"          [| decodeField row k c s :: go (S k) cs ss |]\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:925
msgid ""
"Here is an example REPL session, where I test `readSchema`. I defined "
"variable `ts` using the `:let` command to make this more convenient.  Note, "
"how the order of error types is of no importance, as long as types "
"`InvalidColumn` and `NoColType` are present in the list of errors:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Predicates.md:926
#, no-wrap
msgid ""
"Tutorial.Predicates> :let ts = the (Vect 3 _) [NoColType,NoNat,InvalidColumn]\n"
"Tutorial.Predicates> readSchema {ts} \"foo:bar\"\n"
"Left (U Z (MkNoColType \"bar\"))\n"
"Tutorial.Predicates> readSchema {ts} \"foo:Float\"\n"
"Right [MkColumn \"foo\" Float]\n"
"Tutorial.Predicates> readSchema {ts} \"foo Float\"\n"
"Left (U (S (S Z)) (MkInvalidColumn \"foo Float\"))\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Predicates.md:936
#, no-wrap
msgid "Error Handling"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:943
msgid ""
"There are several techniques for handling errors, all of which are useful at "
"times. For instance, we might want to handle some errors early on and "
"individually, while dealing with others much later in our application. Or we "
"might want to handle them all in one fell swoop. We look at both approaches "
"here."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:950
msgid ""
"First, in order to handle a single error individually, we need to *split* a "
"union into one of two possibilities: A value of the error type in question "
"or a new union, holding one of the other error types. We need a new "
"predicate for this, which not only encodes the presence of a value in a "
"vector but also the result of removing that value:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:951
#, no-wrap
msgid ""
"data Rem : (v : a) -> (vs : Vect (S n) a) -> (rem : Vect n a) -> Type where\n"
"  [search v vs]\n"
"  RZ : Rem v (v :: rem) rem\n"
"  RS : Rem v vs rem -> Rem v (w :: vs) (w :: rem)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:962
msgid ""
"Once again, we want to use one of the indices (`rem`) in our functions' "
"return types, so we only use the other indices during proof search. Here is "
"a function for splitting off a value from an open union:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:963
#, no-wrap
msgid ""
"split : (prf : Rem t ts rem) => Union ts -> Either t (Union rem)\n"
"split {prf = RZ}   (U Z     val) = Left val\n"
"split {prf = RZ}   (U (S x) val) = Right (U x val)\n"
"split {prf = RS p} (U Z     val) = Right (U Z val)\n"
"split {prf = RS p} (U (S x) val) = case split {prf = p} (U x val) of\n"
"  Left vt        => Left vt\n"
"  Right (U ix y) => Right $ U (S ix) y\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:977
msgid ""
"This tries to extract a value of type `t` from a union. If it works, the "
"result is wrapped in a `Left`, otherwise a new union is returned in a "
"`Right`, but this one has `t` removed from its list of possible types."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:982
msgid ""
"With this, we can implement a handler for single errors.  Error handling "
"often happens in an effectful context (we might want to print a message to "
"the console or write the error to a log file), so we use an applicative "
"effect type to handle errors in."
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:983
#, no-wrap
msgid ""
"handle :  Applicative f\n"
"       => Rem t ts rem\n"
"       => (h : t -> f a)\n"
"       -> Err ts a\n"
"       -> f (Err rem a)\n"
"handle h (Left x)  = case split x of\n"
"  Left v    => Right <$> h v\n"
"  Right err => pure $ Left err\n"
"handle _ (Right x) = pure $ Right x\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:998
msgid ""
"For handling all errors at once, we can use a handler type indexed by the "
"vector of errors, and parameterized by the output type:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:999
#, no-wrap
msgid ""
"namespace Handler\n"
"  public export\n"
"  data Handler : (ts : Vect n Type) -> (a : Type) -> Type where\n"
"    Nil  : Handler [] a\n"
"    (::) : (t -> a) -> Handler ts a -> Handler (t :: ts) a\n"
"\n"
"extract : Handler ts a -> Has t ts -> t -> a\n"
"extract (f :: _)  Z     val = f val\n"
"extract (_ :: fs) (S y) val = extract fs y val\n"
"extract []        ix    _   = absurd ix\n"
"\n"
"handleAll : Applicative f => Handler ts (f a) -> Err ts a -> f a\n"
"handleAll _ (Right v)       = pure v\n"
"handleAll h (Left $ U ix v) = extract h ix v\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:1019
msgid ""
"Below, we will see an additional way of handling all errors at once by "
"defining a custom interface for error handling."
msgstr ""

#. type: Bullet: '1. '
#: ../src/Tutorial/Predicates.md:1023
msgid "Implement the following utility functions for `Union`:"
msgstr "`List`についての以下の汎化関数を実装してください。"

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:1024
#, no-wrap
msgid ""
"   project : (0 t : Type) -> (prf : Has t ts) => Union ts -> Maybe t\n"
"\n"
"   project1 : Union [t] -> t\n"
"\n"
"   safe : Err [] a -> a\n"
msgstr ""

#. type: Bullet: '2. '
#: ../src/Tutorial/Predicates.md:1034
msgid ""
"Implement the following two functions for embedding an open union in a "
"larger set of possibilities.  Note the unerased implicit in `extend`!"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:1035
#, no-wrap
msgid ""
"   weaken : Union ts -> Union (ts ++ ss)\n"
"\n"
"   extend : {m : _} -> {0 pre : Vect m _} -> Union ts -> Union (pre ++ ts)\n"
msgstr ""

#. type: Bullet: '3. '
#: ../src/Tutorial/Predicates.md:1043
msgid ""
"Find a general way to embed a `Union ts` in a `Union ss`, so that the "
"following is possible:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:1044
#, no-wrap
msgid ""
"   embedTest :  Err [NoNat,NoColType] a\n"
"             -> Err [FileError, NoColType, OutOfBounds, NoNat] a\n"
"   embedTest = mapFst embed\n"
msgstr ""

#. type: Bullet: '4. '
#: ../src/Tutorial/Predicates.md:1052
msgid ""
"Make `handle` more powerful, by letting the handler convert the error in "
"question to an `f (Err rem a)`."
msgstr ""

#. type: Title ##
#: ../src/Tutorial/Predicates.md:1053
#, no-wrap
msgid "The Truth about Interfaces"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:1065
msgid ""
"Well, here it finally is: The truth about interfaces. Internally, an "
"interface is just a record data type, with its fields corresponding to the "
"members of the interface. An interface implementation is a *value* of such a "
"record, annotated with a `%hint` pragma (see below) to make the value "
"available during proof search. Finally, a constrained function is just a "
"function with one or more auto implicit arguments. For instance, here is the "
"same function for looking up an element in a list, once with the known "
"syntax for constrained functions, and once with an auto implicit argument. "
"The code produced by Idris is the same in both cases:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:1066
#, no-wrap
msgid ""
"isElem1 : Eq a => a -> List a -> Bool\n"
"isElem1 v []        = False\n"
"isElem1 v (x :: xs) = x == v || isElem1 v xs\n"
"\n"
"isElem2 : {auto _ : Eq a} -> a -> List a -> Bool\n"
"isElem2 v []        = False\n"
"isElem2 v (x :: xs) = x == v || isElem2 v xs\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:1079
msgid ""
"Being mere records, we can also take interfaces as regular function "
"arguments and dissect them with a pattern match:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:1080
#, no-wrap
msgid ""
"eq : Eq a -> a -> a -> Bool\n"
"eq (MkEq feq fneq) = feq\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Predicates.md:1085
#, no-wrap
msgid "A manual Interface Definition"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:1093
msgid ""
"I'll now demonstrate how we can achieve the same behavior with proof search "
"as with a regular interface definition plus implementations. Since I want to "
"finish the CSV example with our new error handling tools, we are going to "
"implement some error handlers.  First, an interface is just a record:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:1094
#, no-wrap
msgid ""
"record Print a where\n"
"  constructor MkPrint\n"
"  print' : a -> String\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:1104
msgid ""
"In order to access the record in a constrained function, we use the `"
"%search` keyword, which will try to conjure a value of the desired type "
"(`Print a` in this case) by means of a proof search:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:1105
#, no-wrap
msgid ""
"print : Print a => a -> String\n"
"print = print' %search\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:1112
msgid ""
"As an alternative, we could use a named constraint, and access it directly "
"via its name:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:1113
#, no-wrap
msgid ""
"print2 : (impl : Print a) => a -> String\n"
"print2 = print' impl\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:1120
msgid ""
"As yet another alternative, we could use the syntax for auto implicit "
"arguments:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:1121
#, no-wrap
msgid ""
"print3 : {auto impl : Print a} -> a -> String\n"
"print3 = print' impl\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:1129
#, no-wrap
msgid ""
"All three versions of `print` behave exactly the same at runtime.\n"
"So, whenever we write `{auto x : Foo} ->` we can just as well\n"
"write `(x : Foo) =>` and vice versa.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:1133
msgid ""
"Interface implementations are just values of the given record type, but in "
"order to be available during proof search, these need to be annotated with a "
"`%hint` pragma:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:1134
#, no-wrap
msgid ""
"%hint\n"
"noNatPrint : Print NoNat\n"
"noNatPrint = MkPrint $ \\e => \"Not a natural number: \\{e.str}\"\n"
"\n"
"%hint\n"
"noColTypePrint : Print NoColType\n"
"noColTypePrint = MkPrint $ \\e => \"Not a column type: \\{e.str}\"\n"
"\n"
"%hint\n"
"outOfBoundsPrint : Print OutOfBounds\n"
"outOfBoundsPrint = MkPrint $ \\e => \"Index is out of bounds: \\{show e.index}\"\n"
"\n"
"%hint\n"
"rowErrorPrint : Print RowError\n"
"rowErrorPrint = MkPrint $\n"
"  \\case InvalidField r c ct s =>\n"
"          \"Not a \\{show ct} in row \\{show r}, column \\{show c}. \\{s}\"\n"
"        UnexpectedEOI r c =>\n"
"          \"Unexpected end of input in row \\{show r}, column \\{show c}.\"\n"
"        ExpectedEOI r c =>\n"
"          \"Expected end of input in row \\{show r}, column \\{show c}.\"\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:1162
msgid ""
"We can also write an implementation of `Print` for a union or errors. For "
"this, we first come up with a proof that all types in the union's index come "
"with an implementation of `Print`:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:1163
#, no-wrap
msgid ""
"0 All : (f : a -> Type) -> Vect n a -> Type\n"
"All f []        = ()\n"
"All f (x :: xs) = (f x, All f xs)\n"
"\n"
"unionPrintImpl : All Print ts => Union ts -> String\n"
"unionPrintImpl (U Z val)     = print val\n"
"unionPrintImpl (U (S x) val) = unionPrintImpl $ U x val\n"
"\n"
"%hint\n"
"unionPrint : All Print ts => Print (Union ts)\n"
"unionPrint = MkPrint unionPrintImpl\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:1184
msgid ""
"Defining interfaces this way can be an advantage, as there is much less "
"magic going on, and we have more fine grained control over the types and "
"values of our fields. Note also, that all of the magic comes from the search "
"hints, with which our \"interface implementations\" were annotated.  These "
"made the corresponding values and functions available during proof search."
msgstr ""

#. type: Title ####
#: ../src/Tutorial/Predicates.md:1185
#, no-wrap
msgid "Parsing CSV Commands"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:1195
msgid ""
"To conclude this chapter, we reimplement our CSV command parser, using the "
"flexible error handling approach from the last section. While not "
"necessarily less verbose than the original parser, this approach decouples "
"the handling of errors and printing of error messages from the rest of the "
"application: Functions with a possibility of failure are reusable in "
"different contexts, as are the pretty printers we use for the error messages."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:1198
msgid ""
"First, we repeat some stuff from earlier chapters. I sneaked in a new "
"command for printing all values in a column:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:1199
#, no-wrap
msgid ""
"record Table where\n"
"  constructor MkTable\n"
"  schema : Schema\n"
"  size   : Nat\n"
"  rows   : Vect size (Row schema)\n"
"\n"
"data Command : (t : Table) -> Type where\n"
"  PrintSchema :  Command t\n"
"  PrintSize   :  Command t\n"
"  New         :  (newSchema : Schema) -> Command t\n"
"  Prepend     :  Row (schema t) -> Command t\n"
"  Get         :  Fin (size t) -> Command t\n"
"  Delete      :  Fin (size t) -> Command t\n"
"  Col         :  (name : String)\n"
"              -> (tpe  : ColType)\n"
"              -> (prf  : InSchema name t.schema tpe)\n"
"              -> Command t\n"
"  Quit        : Command t\n"
"\n"
"applyCommand : (t : Table) -> Command t -> Table\n"
"applyCommand t                 PrintSchema = t\n"
"applyCommand t                 PrintSize   = t\n"
"applyCommand _                 (New ts)    = MkTable ts _ []\n"
"applyCommand (MkTable ts n rs) (Prepend r) = MkTable ts _ $ r :: rs\n"
"applyCommand t                 (Get x)     = t\n"
"applyCommand t                 Quit        = t\n"
"applyCommand t                 (Col _ _ _) = t\n"
"applyCommand (MkTable ts n rs) (Delete x)  = case n of\n"
"  S k => MkTable ts k (deleteAt x rs)\n"
"  Z   => absurd x\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:1235
msgid ""
"Next, below is the command parser reimplemented. In total, it can fail in "
"seven different was, at least some of which might also be possible in other "
"parts of a larger application."
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:1236
#, no-wrap
msgid ""
"record UnknownCommand where\n"
"  constructor MkUnknownCommand\n"
"  str : String\n"
"\n"
"%hint\n"
"unknownCommandPrint : Print UnknownCommand\n"
"unknownCommandPrint = MkPrint $ \\v => \"Unknown command: \\{v.str}\"\n"
"\n"
"record NoColName where\n"
"  constructor MkNoColName\n"
"  str : String\n"
"\n"
"%hint\n"
"noColNamePrint : Print NoColName\n"
"noColNamePrint = MkPrint $ \\v => \"Unknown column: \\{v.str}\"\n"
"\n"
"0 CmdErrs : Vect 7 Type\n"
"CmdErrs = [ InvalidColumn\n"
"          , NoColName\n"
"          , NoColType\n"
"          , NoNat\n"
"          , OutOfBounds\n"
"          , RowError\n"
"          , UnknownCommand ]\n"
"\n"
"readCommand : (t : Table) -> String -> Err CmdErrs (Command t)\n"
"readCommand _                \"schema\"  = Right PrintSchema\n"
"readCommand _                \"size\"    = Right PrintSize\n"
"readCommand _                \"quit\"    = Right Quit\n"
"readCommand (MkTable ts n _) s         = case words s of\n"
"  [\"new\",    str] => New     <$> readSchema str\n"
"  \"add\" ::   ss   => Prepend <$> decodeRow 1 (unwords ss)\n"
"  [\"get\",    str] => Get     <$> readFin str\n"
"  [\"delete\", str] => Delete  <$> readFin str\n"
"  [\"column\", str] => case inSchema ts str of\n"
"    Just (ct ** prf) => Right $ Col str ct prf\n"
"    Nothing          => fail $ MkNoColName str\n"
"  _               => fail $ MkUnknownCommand s\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:1280
msgid ""
"Note, how we could invoke functions like `readFin` or `readSchema` directly, "
"because the necessary error types are part of our list of possible errors."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:1286
msgid ""
"To conclude this sections, here is the functionality for printing the result "
"of a command plus the application's main loop. Most of this is repeated from "
"earlier chapters, but note how we can handle all errors at once with a "
"single call to `print`:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:1287
#, no-wrap
msgid ""
"encodeField : (t : ColType) -> IdrisType t -> String\n"
"encodeField I64     x     = show x\n"
"encodeField Str     x     = show x\n"
"encodeField Boolean True  = \"t\"\n"
"encodeField Boolean False = \"f\"\n"
"encodeField Float   x     = show x\n"
"\n"
"encodeRow : (s : Schema) -> Row s -> String\n"
"encodeRow s = concat . intersperse \",\" . go s\n"
"  where go : (s' : Schema) -> Row s' -> Vect (length s') String\n"
"        go []        []        = []\n"
"        go (MkColumn _ c :: cs) (v :: vs) = encodeField c v :: go cs vs\n"
"\n"
"encodeCol :  (name : String)\n"
"          -> (c    : ColType)\n"
"          -> InSchema name s c\n"
"          => Vect n (Row s)\n"
"          -> String\n"
"encodeCol name c = unlines . toList . map (\\r => encodeField c $ getAt name r)\n"
"\n"
"result :  (t : Table) -> Command t -> String\n"
"result t PrintSchema   = \"Current schema: \\{showSchema t.schema}\"\n"
"result t PrintSize     = \"Current size: \\{show t.size}\"\n"
"result _ (New ts)      = \"Created table. Schema: \\{showSchema ts}\"\n"
"result t (Prepend r)   = \"Row prepended: \\{encodeRow t.schema r}\"\n"
"result _ (Delete x)    = \"Deleted row: \\{show $ FS x}.\"\n"
"result _ Quit          = \"Goodbye.\"\n"
"result t (Col n c prf) = \"Column \\{n}:\\n\\{encodeCol n c t.rows}\"\n"
"result t (Get x)       =\n"
"  \"Row \\{show $ FS x}: \\{encodeRow t.schema (index x t.rows)}\"\n"
"\n"
"covering\n"
"runProg : Table -> IO ()\n"
"runProg t = do\n"
"  putStr \"Enter a command: \"\n"
"  str <- getLine\n"
"  case readCommand t str of\n"
"    Left err   => putStrLn (print err) >> runProg t\n"
"    Right Quit => putStrLn (result t Quit)\n"
"    Right cmd  => putStrLn (result t cmd) >>\n"
"                  runProg (applyCommand t cmd)\n"
"\n"
"covering\n"
"main : IO ()\n"
"main = runProg $ MkTable [] _ []\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:1336
msgid "Here is an example REPL session:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Predicates.md:1337
#, no-wrap
msgid ""
"Tutorial.Predicates> :exec main\n"
"Enter a command: new name:Str,age:Int64,salary:Float\n"
"Not a column type: Int64\n"
"Enter a command: new name:Str,age:I64,salary:Float\n"
"Created table. Schema: name:Str,age:I64,salary:Float\n"
"Enter a command: add John Doe,44,3500\n"
"Row prepended: \"John Doe\",44,3500.0\n"
"Enter a command: add Jane Doe,50,4000\n"
"Row prepended: \"Jane Doe\",50,4000.0\n"
"Enter a command: get 1\n"
"Row 1: \"Jane Doe\",50,4000.0\n"
"Enter a command: column salary\n"
"Column salary:\n"
"4000.0\n"
"3500.0\n"
"\n"
"Enter a command: quit\n"
"Goodbye.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:1367
msgid ""
"Predicates allow us to describe contracts between types and to refine the "
"values we accept as valid function arguments.  They allow us to make a "
"function safe and convenient to use at runtime *and* compile time by using "
"them as auto implicit arguments, which Idris should try to construct on its "
"own if it has enough information about the structure of a function's "
"arguments."
msgstr ""

#. type: Title #
#: ../src/Tutorial/Prim.md:1
#, no-wrap
msgid "Primitives"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:7
msgid ""
"In the topics we covered so far, we hardly ever talked about primitive types "
"in Idris. They where around and we used them in some computations, but I "
"never really explained how they work and where they come from, nor did I "
"show in detail what we can and can't do with them."
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:8
#, no-wrap
msgid ""
"module Tutorial.Prim\n"
"\n"
"import Data.Bits\n"
"import Data.String\n"
"\n"
"%default total\n"
msgstr ""
"module Tutorial.Prim\n"
"\n"
"import Data.Bits\n"
"import Data.String\n"
"\n"
"%default total\n"

#. type: Title ##
#: ../src/Tutorial/Prim.md:17
#, no-wrap
msgid "How Primitives are Implemented"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Prim.md:19
#, no-wrap
msgid "A Short Note on Backends"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:30
msgid ""
"According to [Wikipedia](https://en.wikipedia.org/wiki/Compiler), a compiler "
"is \"a computer program that translates computer code written in one "
"programming language (the source language) into another language (the target "
"language)\". The Idris compiler is exactly that: A program translating "
"programs written in Idris into programs written in Chez Scheme. This scheme "
"code is then parsed and interpreted by a Chez Scheme interpreter, which must "
"be installed on the computers we use to run compiled Idris programs."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:37
msgid ""
"But that's only part of the story. Idris 2 was from the beginning designed "
"to support different code generators (so called *backends*), which allows us "
"to write Idris code to target different platforms, and your Idris "
"installation comes with several additional backends available. You can "
"specify the backend to use with the `--cg` command line argument (`cg` "
"stands for *code generator*). For instance:"
msgstr ""

#. type: Fenced code block (sh)
#: ../src/Tutorial/Prim.md:38
#, no-wrap
msgid "idris2 --cg racket\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:45
msgid ""
"Here is a non-comprehensive list of the backends available with a standard "
"Idris installation (the name to be used in the command line argument is "
"given in parentheses):"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:54
msgid ""
"Racket Scheme (`racket`): This is a different flavour of the scheme "
"programming language, which can be useful to use when Chez Scheme is not "
"available on your operating system."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:54
msgid "Node.js (`node`): This converts an Idris program to JavaScript."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:54
msgid ""
"Browser (`javascript`): Another JavaScript backend which allows you to write "
"web applications which run in the browser in Idris."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:54
msgid ""
"RefC (`refc`): A backend compiling Idris to C code, which is then further "
"compiled by a C compiler."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:57
msgid ""
"I plan to at least cover the JavaScript backends in some more detail in "
"another part of this Idris guide, as I use them pretty often myself."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:62
msgid ""
"There are also several external backends not officially supported by the "
"Idris project, amongst which are backends for compiling Idris code to Java "
"and Python. You can find a list of external backends on the [Idris Wiki]"
"(https://github.com/idris-lang/Idris2/wiki/1-%5BLanguage%5D-External-"
"backends)."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Prim.md:63
#, no-wrap
msgid "The Idris Primitives"
msgstr "Idrisの原始型"

#. type: Plain text
#: ../src/Tutorial/Prim.md:69
msgid ""
"A *primitive data type* is a type that is built into the Idris compiler "
"together with a set of *primitive functions*, which are used to perform "
"calculations on the primitives. You will therefore not find a definition of "
"a primitive type or function in the source code of the *Prelude*."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:71
msgid "Here is again the list of primitive types in Idris:"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:98
msgid "Signed, fixed precision integers:"
msgstr ""

#. type: Bullet: '  * '
#: ../src/Tutorial/Prim.md:98
msgid "`Int8`: Integer in the range [-128,127]"
msgstr ""

#. type: Bullet: '  * '
#: ../src/Tutorial/Prim.md:98
msgid "`Int16`: Integer in the range [-32768,32767]"
msgstr ""

#. type: Bullet: '  * '
#: ../src/Tutorial/Prim.md:98
msgid "`Int32`: Integer in the range [-2147483648,2147483647]"
msgstr ""

#. type: Bullet: '  * '
#: ../src/Tutorial/Prim.md:98
msgid ""
"`Int64`: Integer in the range [-9223372036854775808,9223372036854775807]"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:98
msgid "Unsigned, fixed precision integers:"
msgstr ""

#. type: Bullet: '  * '
#: ../src/Tutorial/Prim.md:98
msgid "`Bits8`: Integer in the range [0,255]"
msgstr ""

#. type: Bullet: '  * '
#: ../src/Tutorial/Prim.md:98
msgid "`Bits16`: Integer in the range [0,65535]"
msgstr ""

#. type: Bullet: '  * '
#: ../src/Tutorial/Prim.md:98
msgid "`Bits32`: Integer in the range [0,4294967295]"
msgstr ""

#. type: Bullet: '  * '
#: ../src/Tutorial/Prim.md:98
msgid "`Bits64`: Integer in the range [0,18446744073709551615]"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:98
msgid "`Integer`: A signed, arbitrary precision integer."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:98
msgid "`Double`: A double precision (64 bit) floating point number."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:98
msgid "`Char`: A unicode character."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:98
msgid "`String`: A sequence of unicode characters."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:98
msgid ""
"`%World`: A symbolic representation of the current world state.  We learned "
"about this when I showed you how `IO` is implemented.  Most of the time, you "
"will not handle values of this type in your own code."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:98
#, no-wrap
msgid ""
"* `Int`: This one is special. It is a fixed precision, signed integer,\n"
"   but the bit size is somewhat dependent on the backend and\n"
"   (maybe) platform we use.\n"
"   For instance, if you use the default Chez Scheme backend, `Int` is\n"
"   a 64 bit signed integer, while on the JavaScript backends it is a\n"
"   32 bit signed integer for performance reasons. Therefore, `Int` comes\n"
"   with very few guarantees, and you should use one of the well\n"
"   specified integer types listed above whenever possible.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:104
msgid ""
"It can be instructive to learn, where in the compiler's source code the "
"primitive types and functions are defined. This source code can be found in "
"folder `src` of the [Idris project](https://github.com/idris-lang/Idris2)  "
"and the primitive types are the constant constructors of data type `Core.TT."
"Constant`."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Prim.md:105
#, no-wrap
msgid "Primitive Functions"
msgstr "原始関数"

#. type: Plain text
#: ../src/Tutorial/Prim.md:112
msgid ""
"All calculations operating on primitives are based on two kinds of primitive "
"functions: The ones built into the compiler (see below) and the ones defined "
"by programmers via the foreign function interface (FFI), about which I'll "
"talk in another chapter."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:119
msgid ""
"Built-in primitive functions are functions known to the compiler the "
"definition of which can not be found in the *Prelude*. They define the core "
"functionality available for the primitive types. Typically, you do not "
"invoke these directly (although it is perfectly fine to do so in most cases) "
"but via functions and interfaces exported by the *Prelude* or the *base* "
"library."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:123
msgid ""
"For instance, the primitive function for adding two eight bit unsigned "
"integers is `prim__add_Bits8`. You can inspect its type and behavior at the "
"REPL:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Prim.md:124
#, no-wrap
msgid ""
"Tutorial.Prim> :t prim__add_Bits8\n"
"prim__add_Bits8 : Bits8 -> Bits8 -> Bits8\n"
"Tutorial.Prim> prim__add_Bits8 12 100\n"
"112\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:148
msgid ""
"If you look at the source code implementing interface `Num` for `Bits8`, you "
"will see that the plus operator just invokes `prim__add_Bits8` internally. "
"The same goes for most of the other functions in primitive interface "
"implementations.  For instance, every primitive type with the exception of `"
"%World` comes with primitive comparison functions.  For `Bits8`, these are: "
"`prim__eq_Bits8`, `prim__gt_Bits8`, `prim__lt_Bits8`, `prim__gte_Bits8`, and "
"`prim__lte_Bits8`.  Note, that these functions do not return a `Bool` (which "
"is *not* a primitive type in Idris), but an `Int`. They are therefore not as "
"safe or convenient to use as the corresponding operator implementations form "
"interfaces `Eq` and `Comp`.  On the other hand, they do not go via a "
"conversion to `Bool` and might therefore perform slightly better in "
"performance critical code (which you can only identify after some serious "
"profiling)."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:152
msgid ""
"As with primitive types, the primitive functions are listed as constructors "
"in a data type (`Core.TT.PrimFn`) in the compiler sources. We will look at "
"most of these in the following sections."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Prim.md:153
#, no-wrap
msgid "Consequences of being Primitive"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:163
msgid ""
"Primitive functions and types are opaque to the compiler in most regards: "
"They have to be defined and implemented by each backend individually, "
"therefore, the compiler knows nothing about the inner structure of a "
"primitive value nor about the inner workings of primitive functions. For "
"instance, in the following recursive function, *we* know that the argument "
"in the recursive call must be converging towards the base case (unless there "
"is a bug in the backend we use), but the compiler does not:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:164
#, no-wrap
msgid ""
"covering\n"
"replicateBits8' : Bits8 -> a -> List a\n"
"replicateBits8' 0 _ = []\n"
"replicateBits8' n v = v :: replicateBits8' (n - 1) v\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:174
msgid ""
"In these cases, we either must be content with just a *covering* function, "
"or we use `assert_smaller` to convince the totality checker (the preferred "
"way):"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:175
#, no-wrap
msgid ""
"replicateBits8 : Bits8 -> a -> List a\n"
"replicateBits8 0 _ = []\n"
"replicateBits8 n v = v :: replicateBits8 (assert_smaller n $ n - 1) v\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:184
msgid ""
"I have shown you the risks of using `assert_smaller` before, so we must be "
"extra careful in making sure that the new function argument is indeed "
"smaller with relation to the base case."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:189
msgid ""
"While Idris knows nothing about the internal workings of primitives and "
"related functions, most of these functions still reduce during evaluation "
"when fed with values known at compile time. For instance, we can trivially "
"proof that for `Bits8` the following equation holds:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:190
#, no-wrap
msgid ""
"zeroBits8 : the Bits8 0 = 255 + 1\n"
"zeroBits8 = Refl\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:200
msgid ""
"Having no clue about the internal structure of a primitive nor about the "
"implementations of primitive functions, Idris can't help us proofing any "
"*general* properties of such functions and values. Here is an example to "
"demonstrate this. Assume we'd like to wrap a list in a data type indexed by "
"the list's length:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:201
#, no-wrap
msgid ""
"data LenList : (n : Nat) -> Type -> Type where\n"
"  MkLenList : (as : List a) -> LenList (length as) a\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:209
msgid ""
"When we concatenate two `LenList`s, the length indices should be added. "
"That's how list concatenation affects the length of lists. We can safely "
"teach Idris that this is true:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:210
#, no-wrap
msgid ""
"0 concatLen : (xs,ys : List a) -> length xs + length ys = length (xs ++ ys)\n"
"concatLen []        ys = Refl\n"
"concatLen (x :: xs) ys = cong S $ concatLen xs ys\n"
msgstr ""
"0 concatLen : (xs,ys : List a) -> length xs + length ys = length (xs ++ ys)\n"
"concatLen []        ys = Refl\n"
"concatLen (x :: xs) ys = cong S $ concatLen xs ys\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:217
msgid "With the above lemma, we can implement concatenation of `LenList`:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:218
#, no-wrap
msgid ""
"(++) : LenList m a -> LenList n a -> LenList (m + n) a\n"
"MkLenList xs ++ MkLenList ys =\n"
"  rewrite concatLen xs ys in MkLenList (xs ++ ys)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:231
msgid ""
"The same is not possible for strings. There are applications where pairing a "
"string with its length would be useful (for instance, if we wanted to make "
"sure that strings are getting strictly shorter during parsing and will "
"therefore eventually be wholly consumed), but Idris cannot help us getting "
"these things right.  There is no way to implement and thus proof the "
"following lemma in a safe way:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:232
#, no-wrap
msgid "0 concatLenStr : (a,b : String) -> length a + length b = length (a ++ b)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:237
#, no-wrap
msgid "<!-- markdownlint-disable MD026 -->\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Prim.md:237
#, no-wrap
msgid "Believe Me!"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:239
#, no-wrap
msgid "<!-- markdownlint-enable MD026 -->\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:245
msgid ""
"In order to implement `concatLenStr`, we have to abandon all safety and use "
"the ten ton wrecking ball of type coercion: `believe_me`. This primitive "
"function allows us to freely coerce a value of any type into a value of any "
"other type.  Needless to say, this is only safe if we *really* know what we "
"are doing:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:246
#, no-wrap
msgid "concatLenStr a b = believe_me $ Refl {x = length a + length b}\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:257
msgid ""
"The explicit assignment of variable `x` in `{x = length a + length b}` is "
"necessary, because otherwise Idris will complain about an *unsolved hole*: "
"It can't infer the type of parameter `x` in the `Refl` constructor. We could "
"assign any type to `x` here, because we are passing the result to "
"`believe_me` anyway, but I consider it to be good practice to assign one of "
"the two sides of the equality to make our intention clear."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:262
msgid ""
"The higher the complexity of a primitive type, the riskier it is to assume "
"even the most basic properties for it to hold.  For instance, we might act "
"under the delusion that floating point addition is associative:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:263
#, no-wrap
msgid ""
"0 doubleAddAssoc : (x,y,z : Double) -> x + (y + z) = (x + y) + z\n"
"doubleAddAssoc x y z = believe_me $ Refl {x = x + (y + z)}\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:270
msgid ""
"Well, guess what: That's a lie. And lies lead us straight into the `Void`:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:271
#, no-wrap
msgid ""
"Tiny : Double\n"
"Tiny = 0.0000000000000001\n"
"\n"
"One : Double\n"
"One = 1.0\n"
"\n"
"wrong : (0 _ : 1.0000000000000002 = 1.0) -> Void\n"
"wrong Refl impossible\n"
"\n"
"boom : Void\n"
"boom = wrong (doubleAddAssoc One Tiny Tiny)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:291
msgid ""
"Here's what happens in the code above: The call to `doubleAddAssoc` returns "
"a proof that `One + (Tiny + Tiny)` is equal to `(One + Tiny) + Tiny`. But "
"`One + (Tiny + Tiny)` equals `1.0000000000000002`, while `(One + Tiny) + "
"Tiny` equals `1.0`.  We can therefore pass our (wrong) proof to `wrong`, "
"because it is of the correct type, and from this follows a proof of `Void`."
msgstr ""

#. type: Title ##
#: ../src/Tutorial/Prim.md:292
#, no-wrap
msgid "Working with Strings"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:297
msgid ""
"Module `Data.String` in *base* offers a rich set of functions for working "
"with strings. All these are based on the following primitive operations "
"built into the compiler:"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:305
msgid "`prim__strLength`: Returns the length of a string."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:305
msgid "`prim__strHead`: Extracts the first character from a string."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:305
msgid "`prim__strTail`: Removes the first character from a string."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:305
msgid "`prim__strCons`: Prepends a character to a string."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:305
msgid "`prim__strAppend`: Appends two strings."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:305
msgid ""
"`prim__strIndex`: Extracts a character at the given position from a string."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:305
msgid "`prim__strSubstr`: Extracts the substring between the given positions."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:311
msgid ""
"Needless to say, not all of these functions are total. Therefore, Idris must "
"make sure that invalid calls do not reduce during compile time, as otherwise "
"the compiler would crash. If, however we force the evaluation of a partial "
"primitive function by compiling and running the corresponding program, this "
"program will crash with an error:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Prim.md:312
#, no-wrap
msgid ""
"Tutorial.Prim> prim__strTail \"\"\n"
"prim__strTail \"\"\n"
"Tutorial.Prim> :exec putStrLn (prim__strTail \"\")\n"
"Exception in substring: 1 and 0 are not valid start/end indices for \"\"\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:323
msgid ""
"Note, how `prim__strTail \"\"` is not reduced at the REPL and how the same "
"expression leads to a runtime exception if we compile and execute the "
"program. Valid calls to `prim__strTail` are reduced just fine, however:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:324
#, no-wrap
msgid ""
"tailExample : prim__strTail \"foo\" = \"oo\"\n"
"tailExample = Refl\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Prim.md:329
#, no-wrap
msgid "Pack and Unpack"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:339
msgid ""
"Two of the most important functions for working with strings are `unpack` "
"and `pack`, which convert a string to a list of characters and vice versa. "
"This allows us to conveniently implement many string operations by iterating "
"or folding over the list of characters instead. This might not always be the "
"most efficient thing to do, but unless you plan to handle very large amounts "
"of text, they work and perform reasonably well."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Prim.md:340
#, no-wrap
msgid "String Interpolation"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:345
msgid ""
"Idris allows us to include arbitrary string expressions in a string literal "
"by wrapping them in curly braces, the first of which has to be escaped with "
"a backslash. For instance:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:346
#, no-wrap
msgid ""
"interpEx1 : Bits64 -> Bits64 -> String\n"
"interpEx1 x y = \"\\{show x} + \\{show y} = \\{show $ x + y}\"\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:356
msgid ""
"This is a very convenient way to assemble complex strings from values of "
"different types.  In addition, there is interface `Interpolation`, which "
"allows us to use values in interpolated strings without having to convert "
"them to strings first:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:357
#, no-wrap
msgid ""
"data Element = H | He | C | N | O | F | Ne\n"
"\n"
"Formula : Type\n"
"Formula = List (Element,Nat)\n"
"\n"
"Interpolation Element where\n"
"  interpolate H  = \"H\"\n"
"  interpolate He = \"He\"\n"
"  interpolate C  = \"C\"\n"
"  interpolate N  = \"N\"\n"
"  interpolate O  = \"O\"\n"
"  interpolate F  = \"F\"\n"
"  interpolate Ne = \"Ne\"\n"
"\n"
"Interpolation (Element,Nat) where\n"
"  interpolate (_, 0) = \"\"\n"
"  interpolate (x, 1) = \"\\{x}\"\n"
"  interpolate (x, k) = \"\\{x}\\{show k}\"\n"
"\n"
"Interpolation Formula where\n"
"  interpolate = foldMap interpolate\n"
"\n"
"ethanol : String\n"
"ethanol = \"The formulat of ethanol is: \\{[(C,2),(H,6),(O, the Nat 1)]}\"\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Prim.md:384
#, no-wrap
msgid "Raw and Multiline String Literals"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:388
msgid ""
"In string literals, we have to escape certain characters like quotes, "
"backslashes or new line characters. For instance:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:389
#, no-wrap
msgid ""
"escapeExample : String\n"
"escapeExample = \"A quote: \\\". \\nThis is on a new line.\\nA backslash: \\\\\"\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:398
msgid ""
"Idris allows us to enter raw string literals, where there is no need to "
"escape quotes and backslashes, by pre- and postfixing the wrapping quote "
"characters with the same number of hash characters. For instance:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:399
#, no-wrap
msgid ""
"rawExample : String\n"
"rawExample = #\"A quote: \". A blackslash: \\\"#\n"
"\n"
"rawExample2 : String\n"
"rawExample2 = ##\"A quote: \". A blackslash: \\\"##\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:411
msgid ""
"With raw string literals, it is still possible to use string interpolation, "
"but the opening curly brace has to be prefixed with a backslash and the same "
"number of hashes as are being used for opening and closing the string "
"literal:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:412
#, no-wrap
msgid ""
"rawInterpolExample : String\n"
"rawInterpolExample = ##\"An interpolated \"string\": \\##{rawExample}\"##\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:424
msgid ""
"Finally, Idris also allows us to conveniently write multiline strings. These "
"can be pre- and postfixed with hashes if we want raw multiline string "
"literals, and they also can be combined with string interpolation. Multiline "
"literals are opened and closed with triple quote characters. Indenting the "
"closing triple quotes allows us to indent the whole multiline literal. "
"Whitespace used for indentation will not appear in the resulting string. For "
"instance:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:425
#, no-wrap
msgid ""
"multiline1 : String\n"
"multiline1 = \"\"\"\n"
"  And I raise my head and stare\n"
"  Into the eyes of a stranger\n"
"  I've always known that the mirror never lies\n"
"  People always turn away\n"
"  From the eyes of a stranger\n"
"  Afraid to see what hides behind the stare\n"
"  \"\"\"\n"
"\n"
"multiline2 : String\n"
"multiline2 = #\"\"\"\n"
"  An example for a simple expression:\n"
"  \"foo\" ++ \"bar\".\n"
"  This is reduced to \"\\#{\"foo\" ++ \"bar\"}\".\n"
"  \"\"\"#\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:447
msgid ""
"Make sure to look at the example strings at the REPL to see the effect of "
"interpolation and raw string literals and compare it with the syntax we used."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:454
msgid ""
"In these exercises, you are supposed to implement a bunch of utility "
"functions for consuming and converting strings.  I don't give the expected "
"types here, because you are supposed to come up with those yourself."
msgstr ""

#. type: Bullet: '1. '
#: ../src/Tutorial/Prim.md:458
msgid ""
"Implement functions similar to `map`, `filter`, and `mapMaybe` for strings. "
"The output type of these should always be a string."
msgstr ""

#. type: Bullet: '2. '
#: ../src/Tutorial/Prim.md:461
msgid "Implement functions similar to `foldl` and `foldMap` for strings."
msgstr ""

#. type: Bullet: '3. '
#: ../src/Tutorial/Prim.md:464
msgid ""
"Implement a function similar to `traverse` for strings. The output type "
"should be a wrapped string."
msgstr ""

#. type: Bullet: '4. '
#: ../src/Tutorial/Prim.md:467
msgid ""
"Implement the bind operator for strings. The output type should again be a "
"string."
msgstr ""

#. type: Title ##
#: ../src/Tutorial/Prim.md:468
#, no-wrap
msgid "Integers"
msgstr "整数"

#. type: Plain text
#: ../src/Tutorial/Prim.md:475
msgid ""
"As listed at the beginning of this chapter, Idris provides different fixed-"
"precision signed and unsigned integer types as well as `Integer`, an "
"arbitrary precision signed integer type.  All of them come with the "
"following primitive functions (given here for `Bits8` as an example):"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:486
msgid "`prim__add_Bits8`: Integer addition."
msgstr "`prim__add_Bits8`: 整数の加算。"

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:486
msgid "`prim__sub_Bits8`: Integer subtraction."
msgstr "`prim__add_Bits8`: 整数の加算。"

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:486
msgid "`prim__mul_Bits8`: Integer multiplication."
msgstr "`prim__add_Bits8`: 整数の加算。"

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:486
msgid "`prim__div_Bits8`: Integer division."
msgstr "`prim__div_Bits8`: 整数の除算。"

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:486
msgid "`prim__mod_Bits8`: Modulo function."
msgstr "`prim__mod_Bits8`: 剰余関数。"

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:486
msgid "`prim__shl_Bits8`: Bitwise left shift."
msgstr "`prim__add_Bits8`: 整数の加算。"

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:486
msgid "`prim__shr_Bits8`: Bitwise right shift."
msgstr "`prim__add_Bits8`: 整数の加算。"

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:486
msgid "`prim__and_Bits8`: Bitwise *and*."
msgstr "`prim__add_Bits8`: 整数の加算。"

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:486
msgid "`prim__or_Bits8`: Bitwise *or*."
msgstr "`prim__mod_Bits8`: 剰余関数。"

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:486
msgid "`prim__xor_Bits8`: Bitwise *xor*."
msgstr "`prim__mod_Bits8`: 剰余関数。"

#. type: Plain text
#: ../src/Tutorial/Prim.md:493
msgid ""
"Typically, you use the functions for addition and multiplication through the "
"operators from interface `Num`, the function for subtraction through "
"interface `Neg`, and the functions for division (`div` and `mod`) through "
"interface `Integral`.  The bitwise operations are available through "
"interfaces `Data.Bits.Bits` and `Data.Bits.FiniteBits`."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:497
msgid ""
"For all integral types, the following laws are assumed to hold for numeric "
"operations (`x`, `y`, and `z` are arbitrary value of the same primitive "
"integral type):"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:507
msgid "`x + y = y + x`: Addition is commutative."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:507
msgid "`x + (y + z) = (x + y) + z`: Addition is associative."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:507
msgid "`x + 0 = x`: Zero is the neutral element of addition."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:507
msgid "`x - x = x + (-x) = 0`: `-x` is the additive inverse of `x`."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:507
msgid "`x * y = y * x`: Multiplication is commutative."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:507
msgid "`x * (y * z) = (x * y) * z`: Multiplication is associative."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:507
msgid "`x * 1 = x`: One is the neutral element of multiplication."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:507
msgid "`x * (y + z) = x * y + x * z`: The distributive law holds."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:507
msgid "``y * (x `div` y) + (x `mod` y) = x`` (for `y /= 0`)."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:515
msgid ""
"Please note, that the officially supported backends use *Euclidian modulus* "
"for calculating `mod`: For `y /= 0`, ``x `mod` y`` is always a non-negative "
"value strictly smaller than `abs y`, so that the law given above does hold. "
"If `x` or `y` are negative numbers, this is different to what many other "
"languages do but for good reasons as explained in the following [article]"
"(https://www.microsoft.com/en-us/research/publication/division-and-modulus-"
"for-computer-scientists/)."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Prim.md:516
#, no-wrap
msgid "Unsigned Integers"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:526
msgid ""
"The unsigned fixed precision integer types (`Bits8`, `Bits16`, `Bits32`, and "
"`Bits64`) come with implementations of all integral interfaces (`Num`, "
"`Neg`, and `Integral`) and the two interfaces for bitwise operations (`Bits` "
"and `FiniteBits`).  All functions with the exception of `div` and `mod` are "
"total. Overflows are handled by calculating the remainder modulo "
"`2^bitsize`. For instance, for `Bits8`, all operations calculate their "
"results modulo 256:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Prim.md:527
#, no-wrap
msgid ""
"Main> the Bits8 255 + 1\n"
"0\n"
"Main> the Bits8 255 + 255\n"
"254\n"
"Main> the Bits8 128 * 2 + 7\n"
"7\n"
"Main> the Bits8 12 - 13\n"
"255\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Prim.md:538
#, no-wrap
msgid "Signed Integers"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:549
msgid ""
"Like the unsigned integer types, the signed fixed precision integer types "
"(`Int8`, `Int16`, `Int32`, and `Int64`) come with implementations of all "
"integral interfaces and the two interfaces for bitwise operations (`Bits` "
"and `FiniteBits`).  Overflows are handled by calculating the remainder "
"modulo `2^bitsize` and adding the lower bound (a negative number)  if the "
"result is still out of range. For instance, for `Int8`, all operations "
"calculate their results modulo 256, subtracting 128 if the result is still "
"out of bounds:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Prim.md:550
#, no-wrap
msgid ""
"Main> the Int8 2 * 127\n"
"-2\n"
"Main> the Int8 3 * 127\n"
"125\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Prim.md:557
#, no-wrap
msgid "Bitwise Operations"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:568
msgid ""
"Module `Data.Bits` exports interfaces for performing bitwise operations on "
"integral types. I'm going to show a couple of examples on unsigned 8-bit "
"numbers (`Bits8`) to explain the concept to readers new to bitwise "
"arithmetics. Note, that this is much easier to grasp for unsigned integer "
"types than for the signed versions.  Those have to include information about "
"the *sign* of numbers in their bit pattern, and it is assumed that signed "
"integers in Idris use a [two's complement representation](https://en."
"wikipedia.org/wiki/Two%27s_complement), about which I will not go into the "
"details here."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:573
msgid ""
"An unsigned 8-bit binary number is represented internally as a sequence of "
"eight bits (with values 0 or 1), each of which corresponds to a power of 2. "
"For instance, the number 23 (= 16 + 4 + 2 + 1) is represented as `0001 0111`:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Prim.md:574
#, no-wrap
msgid ""
"23 in binary:    0  0  0  1    0  1  1  1\n"
"\n"
"Bit number:      7  6  5  4    3  2  1  0\n"
"Decimal value: 128 64 32 16    8  4  2  1\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:583
msgid ""
"We can use function `testBit` to check if the bit at the given position is "
"set or not:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Prim.md:584
#, no-wrap
msgid ""
"Tutorial.Prim> testBit (the Bits8 23) 0\n"
"True\n"
"Tutorial.Prim> testBit (the Bits8 23) 1\n"
"True\n"
"Tutorial.Prim> testBit (the Bits8 23) 3\n"
"False\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:595
msgid ""
"Likewise, we can use functions `setBit` and `clearBit` to set or unset a bit "
"at a certain position:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Prim.md:596
#, no-wrap
msgid ""
"Tutorial.Prim> setBit (the Bits8 23) 3\n"
"31\n"
"Tutorial.Prim> clearBit (the Bits8 23) 2\n"
"19\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:610
msgid ""
"There are also operators `(.&.)` (bitwise *and*) and `(.|.)` (bitwise *or*) "
"as well as function `xor` (bitwise *exclusive or*)  for performing boolean "
"operations on integral values.  For instance `x .&. y` has exactly those "
"bits set, which both `x` and `y` have set, while `x .|. y` has all bits set "
"that are either set in `x` or `y` (or both), and ``x `xor` y`` has those "
"bits set that are set in exactly one of the two values:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Prim.md:611
#, no-wrap
msgid ""
"23 in binary:          0  0  0  1    0  1  1  1\n"
"11 in binary:          0  0  0  0    1  0  1  1\n"
"\n"
"23 .&. 11 in binary:   0  0  0  0    0  0  1  1\n"
"23 .|. 11 in binary:   0  0  0  1    1  1  1  1\n"
"23 `xor` 11 in binary: 0  0  0  1    1  1  0  0\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:621
msgid "And here are the examples at the REPL:"
msgstr "以下はREPLでの例です。"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Prim.md:622
#, no-wrap
msgid ""
"Tutorial.Prim> the Bits8 23 .&. 11\n"
"3\n"
"Tutorial.Prim> the Bits8 23 .|. 11\n"
"31\n"
"Tutorial.Prim> the Bits8 23 `xor` 11\n"
"28\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:637
msgid ""
"Finally, it is possible to shift all bits to the right or left by a certain "
"number of steps by using functions `shiftR` and `shiftL`, respectively "
"(overflowing bits will just be dropped).  A left shift can therefore be "
"viewed as a multiplication by a power of two, while a right shift can be "
"seen as a division by a power of two:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Prim.md:638
#, no-wrap
msgid ""
"22 in binary:            0  0  0  1    0  1  1  0\n"
"\n"
"22 `shiftL` 2 in binary: 0  1  0  1    1  0  0  0\n"
"22 `shiftR` 1 in binary: 0  0  0  0    1  0  1  1\n"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Prim.md:647
#, no-wrap
msgid ""
"Tutorial.Prim> the Bits8 22 `shiftL` 2\n"
"88\n"
"Tutorial.Prim> the Bits8 22 `shiftR` 1\n"
"11\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:657
msgid ""
"Bitwise operations are often used in specialized code or certain high-"
"performance applications. As programmers, we have to know they exist and how "
"they work."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Prim.md:658
#, no-wrap
msgid "Integer Literals"
msgstr "整数表記"

#. type: Plain text
#: ../src/Tutorial/Prim.md:666
msgid ""
"So far, we always required an implementation of `Num` in order to be able to "
"use integer literals for a given type. However, it is actually only "
"necessary to implement a function `fromInteger` converting an `Integer` to "
"the type in question. As we will see in the last section, such a function "
"can even restrict the values allowed as valid literals."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:671
msgid ""
"For instance, assume we'd like to define a data type for representing the "
"charge of a chemical molecule. Such a value can be positive or negative and "
"(theoretically) of almost arbitrary magnitude:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:672
#, no-wrap
msgid ""
"record Charge where\n"
"  constructor MkCharge\n"
"  value : Integer\n"
msgstr ""
"record Charge where\n"
"  constructor MkCharge\n"
"  value : Integer\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:683
msgid ""
"It makes sense to be able to sum up charges, but not to multiply them. They "
"should therefore have an implementation of `Monoid` but not of `Num`. Still, "
"we'd like to have the convenience of integer literals when using constant "
"charges at compile time. Here's how to do this:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:684
#, no-wrap
msgid ""
"fromInteger : Integer -> Charge\n"
"fromInteger = MkCharge\n"
"\n"
"Semigroup Charge where\n"
"  x <+> y = MkCharge $ x.value + y.value\n"
"\n"
"Monoid Charge where\n"
"  neutral = 0\n"
msgstr ""

#. type: Title ####
#: ../src/Tutorial/Prim.md:695
#, no-wrap
msgid "Alternative Bases"
msgstr "別の基数"

#. type: Plain text
#: ../src/Tutorial/Prim.md:702
msgid ""
"In addition to the well known decimal literals, it is also possible to use "
"integer literals in binary, octal, or hexadecimal representation. These have "
"to be prefixed with a zero following by a `b`, `o`, or `x` for binary, "
"octal, and hexadecimal, respectively:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Prim.md:703
#, no-wrap
msgid ""
"Tutorial.Prim> 0b1101\n"
"13\n"
"Tutorial.Prim> 0o773\n"
"507\n"
"Tutorial.Prim> 0xffa2\n"
"65442\n"
msgstr ""

#. type: Bullet: '1. '
#: ../src/Tutorial/Prim.md:716
msgid ""
"Define a wrapper record for integral values and implement `Monoid` so that "
"`(<+>)` corresponds to `(.&.)`."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:719
#, no-wrap
msgid ""
"   Hint: Have a look at the functions available from interface\n"
"   `Bits` to find a value suitable as the neutral element.\n"
msgstr ""

#. type: Bullet: '2. '
#: ../src/Tutorial/Prim.md:722
msgid ""
"Define a wrapper record for integral values and implement `Monoid` so that "
"`(<+>)` corresponds to `(.|.)`."
msgstr ""

#. type: Bullet: '3. '
#: ../src/Tutorial/Prim.md:725
msgid ""
"Use bitwise operations to implement a function, which tests if a given value "
"of type `Bits64` is even or not."
msgstr ""

#. type: Bullet: '4. '
#: ../src/Tutorial/Prim.md:727
msgid "Convert a value of type `Bits64` to a string in binary representation."
msgstr ""

#. type: Bullet: '5. '
#: ../src/Tutorial/Prim.md:729
msgid ""
"Convert a value of type `Bits64` to a string in hexadecimal representation."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:732
#, no-wrap
msgid ""
"   Hint: Use `shiftR` and `(.&. 15)` to access subsequent packages of\n"
"   four bits.\n"
msgstr ""

#. type: Title ##
#: ../src/Tutorial/Prim.md:733
#, no-wrap
msgid "Refined Primitives"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:741
msgid ""
"We often do not want to allow all values of a type in a certain context. For "
"instance, `String` as an arbitrary sequence of UTF-8 characters (several of "
"which are not even printable), is too general most of the time. Therefore, "
"it is usually advisable to rule out invalid values early on, by pairing a "
"value with an erased proof of validity."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:749
msgid ""
"We have learned how we can write elegant predicates, with which we can proof "
"our functions to be total, and from which we can - in the ideal case - "
"derive other, related predicates. However, when we define predicates on "
"primitives they are to a certain degree doomed to live in isolation, unless "
"we come up with a set of primitive axioms (implemented most likely using "
"`believe_me`), with which we can manipulate our predicates."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Prim.md:750
#, no-wrap
msgid "Use Case: ASCII Strings"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:756
msgid ""
"String encodings is a difficult topic, so in many low level routines it "
"makes sense to rule out most characters from the beginning. Assume "
"therefore, we'd like to make sure the strings we accept in our application "
"only consist of ASCII characters:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:757
#, no-wrap
msgid ""
"isAsciiChar : Char -> Bool\n"
"isAsciiChar c = ord c <= 127\n"
"\n"
"isAsciiString : String -> Bool\n"
"isAsciiString = all isAsciiChar . unpack\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:767
msgid ""
"We can now *refine* a string value by pairing it with an erased proof of "
"validity:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:768
#, no-wrap
msgid ""
"record Ascii where\n"
"  constructor MkAscii\n"
"  value : String\n"
"  0 prf : isAsciiString value === True\n"
msgstr ""
"record Ascii where\n"
"  constructor MkAscii\n"
"  value : String\n"
"  0 prf : isAsciiString value === True\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:779
msgid ""
"It is now *impossible* to at runtime or compile time create a value of type "
"`Ascii` without first validating the wrapped string. With this, it is "
"already pretty easy to safely wrap strings at compile time in a value of "
"type `Ascii`:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:780
#, no-wrap
msgid ""
"hello : Ascii\n"
"hello = MkAscii \"Hello World!\" Refl\n"
msgstr ""
"hello : Ascii\n"
"hello = MkAscii \"Hello World!\" Refl\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:800
msgid ""
"And yet, it would be much more convenient to still use string literals for "
"this, without having to sacrifice the comfort of safety. To do so, we can't "
"use interface `FromString`, as its function `fromString` would force us to "
"convert *any* string, even an invalid one. However, we actually don't need "
"an implementation of `FromString` to support string literals, just like we "
"didn't require an implementation of `Num` to support integer literals.  What "
"we really need is a function named `fromString`. Now, when string literals "
"are desugared, they are converted to invocations of `fromString` with the "
"given string value as its argument.  For instance, literal `\"Hello\"` gets "
"desugared to `fromString \"Hello\"`.  This happens before type checking and "
"filling in of (auto) implicit values. It is therefore perfectly fine, to "
"define a custom `fromString` function with an erased auto implicit argument "
"as a proof of validity:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:801
#, no-wrap
msgid ""
"fromString : (s : String) -> {auto 0 prf : isAsciiString s === True} -> Ascii\n"
"fromString s = MkAscii s prf\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:808
msgid ""
"With this, we can us (valid) string literals for coming up with values of "
"type `Ascii` directly:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:809
#, no-wrap
msgid ""
"hello2 : Ascii\n"
"hello2 = \"Hello World!\"\n"
msgstr ""
"hello2 : Ascii\n"
"hello2 = \"Hello World!\"\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:817
msgid ""
"In order to at runtime create values of type `Ascii` from strings of an "
"unknown source, we can use a refinement function returning some kind of "
"failure type:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:818
#, no-wrap
msgid ""
"test : (b : Bool) -> Dec (b === True)\n"
"test True  = Yes Refl\n"
"test False = No absurd\n"
"\n"
"ascii : String -> Maybe Ascii\n"
"ascii x = case test (isAsciiString x) of\n"
"  Yes prf   => Just $ MkAscii x prf\n"
"  No contra => Nothing\n"
msgstr ""

#. type: Title ####
#: ../src/Tutorial/Prim.md:829
#, no-wrap
msgid "Disadvantages of Boolean Proofs"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:834
msgid ""
"For many use cases, what we described above for ASCII strings can take us "
"very far. However, one drawback of this approach is that we can't safely "
"perform any computations with the proofs at hand."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:839
msgid ""
"For instance, we know it will be perfectly fine to concatenate two ASCII "
"strings, but in order to convince Idris of this, we will have to use "
"`believe_me`, because we will not be able to proof the following lemma "
"otherwise:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:840
#, no-wrap
msgid ""
"0 allAppend :  (f : Char -> Bool)\n"
"            -> (s1,s2 : String)\n"
"            -> (p1 : all f (unpack s1) === True)\n"
"            -> (p2 : all f (unpack s2) === True)\n"
"            -> all f (unpack (s1 ++ s2)) === True\n"
"allAppend f s1 s2 p1 p2 = believe_me $ Refl {x = True}\n"
"\n"
"namespace Ascii\n"
"  export\n"
"  (++) : Ascii -> Ascii -> Ascii\n"
"  MkAscii s1 p1 ++ MkAscii s2 p2 =\n"
"    MkAscii (s1 ++ s2) (allAppend isAsciiChar s1 s2 p1 p2)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:861
msgid ""
"The same goes for all operations extracting a substring from a given string: "
"We will have to implement according rules using `believe_me`. Finding a "
"reasonable set of axioms to conveniently deal with refined primitives can "
"therefore be challenging at times, and whether such axioms are even required "
"very much depends on the use case at hand."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Prim.md:862
#, no-wrap
msgid "Use Case: Sanitized HTML"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:869
msgid ""
"Assume you write a simple web application for scientific discourse between "
"registered users. To keep things simple, we only consider unformatted text "
"input here. Users can write arbitrary text in a text field and upon hitting "
"Enter, the message is displayed to all other registered users."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:871
msgid "Assume now a user decides to enter the following text:"
msgstr "ここで利用者が以下の文言を入力することにしたとしましょう。"

#. type: Fenced code block (html)
#: ../src/Tutorial/Prim.md:872
#, no-wrap
msgid "<script>alert(\"Hello World!\")</script>\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:884
msgid ""
"Well, it could have been (much) worse. Still, unless we take measures to "
"prevent this from happening, this might embed a JavaScript program in our "
"web page we never intended to have there! What I described here, is a well "
"known security vulnerability called [cross-site scripting](https://en."
"wikipedia.org/wiki/Cross-site_scripting).  It allows users of web pages to "
"enter malicious JavaScript code in text fields, which will then be included "
"in the page's HTML structure and executed when it is being displayed to "
"other users."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:891
#, no-wrap
msgid ""
"We want to make sure, that this cannot happen on our own web page.\n"
"In order to protect us from this attack, we could for instance disallow\n"
"certain characters like `'<'` or `'>'` completely (although this might not\n"
"be enough!), but if our chat service is targeted at programmers,\n"
"this will be overly restrictive. An alternative\n"
"is to escape certain characters before rendering them on the page.\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:892
#, no-wrap
msgid ""
"escape : String -> String\n"
"escape = concat . map esc . unpack\n"
"  where esc : Char -> String\n"
"        esc '<'  = \"&lt;\"\n"
"        esc '>'  = \"&gt;\"\n"
"        esc '\"'  = \"&quot;\"\n"
"        esc '&'  = \"&amp;\"\n"
"        esc '\\'' = \"&apos;\"\n"
"        esc c    = singleton c\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:910
msgid ""
"What we now want to do is to store a string together with a proof that is "
"was properly escaped. This is another form of existential quantification: "
"\"Here is a string, and there once existed another string, which we passed "
"to `escape` and arrived at the string we have now\". Here's how to encode "
"this:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:911
#, no-wrap
msgid ""
"record Escaped where\n"
"  constructor MkEscaped\n"
"  value    : String\n"
"  0 origin : String\n"
"  0 prf    : escape origin === value\n"
msgstr ""
"record Escaped where\n"
"  constructor MkEscaped\n"
"  value    : String\n"
"  0 origin : String\n"
"  0 prf    : escape origin === value\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:925
msgid ""
"Whenever we now embed a string of unknown origin in our web page, we can "
"request a value of type `Escaped` and have the very strong guarantee that we "
"are no longer vulnerable to cross-site scripting attacks. Even better, it is "
"also possible to safely embed string literals known at compile time without "
"the need to escape them first:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:926
#, no-wrap
msgid ""
"namespace Escaped\n"
"  export\n"
"  fromString : (s : String) -> {auto 0 prf : escape s === s} -> Escaped\n"
"  fromString s = MkEscaped s s prf\n"
"\n"
"escaped : Escaped\n"
"escaped = \"Hello World!\"\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:941
msgid ""
"In this massive set of exercises, you are going to build a small library for "
"working with predicates on primitives.  We want to keep the following goals "
"in mind:"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:955
msgid ""
"We want to use the usual operations of propositional logic to combine "
"predicates: Negation, conjuction (logical *and*), and disjunction (logical "
"*or*)."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:955
msgid ""
"All predicates should be erased at runtime. If we proof something about a "
"primitive number, we want to make sure not to carry around a huge proof of "
"validity."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:955
msgid ""
"Calculations on predicates should make no appearance at runtime (with the "
"exception of `decide`; see below)."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:955
msgid ""
"Recursive calculations on predicates should be tail recursive if they are "
"used in implementations of `decide`. This might be tough to achieve. If you "
"can't find a tail recursive solution for a given problem, use what feels "
"most natural instead."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:980
msgid ""
"A note on efficiency: In order to be able to run computations on our "
"predicates, we try to convert primitive values to algebraic data types as "
"often and as soon as possible: Unsigned integers will be converted to `Nat` "
"using `cast`, and strings will be converted to `List Char` using `unpack`.  "
"This allows us to work with proofs on `Nat` and `List` most of the time, and "
"such proofs can be implemented without resorting to `believe_me` or other "
"cheats. However, the one advantage of primitive types over algebraic data "
"types is that they often perform much better. This is especially critical "
"when comparing integral types with `Nat`: Operations on natural numbers "
"often run with `O(n)` time complexity, where `n` is the size of one of the "
"natural numbers involved, while with `Bits64`, for instance, many operations "
"run in fast constant time (`O(1)`). Luckily, the Idris compiler optimizes "
"many functions on natural number to use the corresponding `Integer` "
"operations at runtime. This has the advantage that we can still use proper "
"induction to proof stuff about natural numbers at compile time, while "
"getting the benefit of fast integer operations at runtime. However, "
"operations on `Nat` do run with `O(n)` time complexity and *compile time*. "
"Proofs working on large natural number will therefore drastically slow down "
"the compiler. A way out of this is discussed at the end of this section of "
"exercises."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:983
msgid ""
"Enough talk, let's begin! To start with, you are given the following "
"utilities:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:984
#, no-wrap
msgid ""
"-- Like `Dec` but with erased proofs. Constructors `Yes0`\n"
"-- and `No0` will be converted to constants `0` and `1` by\n"
"-- the compiler!\n"
"data Dec0 : (prop : Type) -> Type where\n"
"  Yes0 : (0 prf : prop) -> Dec0 prop\n"
"  No0  : (0 contra : prop -> Void) -> Dec0 prop\n"
"\n"
"-- For interfaces with more than one parameter (`a` and `p`\n"
"-- in this example) sometimes one parameter can be determined\n"
"-- by knowing the other. For instance, if we know what `p` is,\n"
"-- we will most certainly also know what `a` is. We therefore\n"
"-- specify that proof search on `Decidable` should only be\n"
"-- based on `p` by listing `p` after a vertical bar: `| p`.\n"
"-- This is like specifing the search parameter(s) of\n"
"-- a data type with `[search p]` as was shown in the chapter\n"
"-- about predicates.\n"
"-- Specifying a single search parameter as shown here can\n"
"-- drastically help with type inference.\n"
"interface Decidable (0 a : Type) (0 p : a -> Type) | p where\n"
"  decide : (v : a) -> Dec0 (p v)\n"
"\n"
"-- We often have to pass `p` explicitly in order to help Idris with\n"
"-- type inference. In such cases, it is more convenient to use\n"
"-- `decideOn pred` instead of `decide {p = pred}`.\n"
"decideOn : (0 p : a -> Type) -> Decidable a p => (v : a) -> Dec0 (p v)\n"
"decideOn _ = decide\n"
"\n"
"-- Some primitive predicates can only be reasonably implemented\n"
"-- using boolean functions. This utility helps with decidability\n"
"-- on such proofs.\n"
"test0 : (b : Bool) -> Dec0 (b === True)\n"
"test0 True  = Yes0 Refl\n"
"test0 False = No0 absurd\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1025
msgid ""
"We also want to run decidable computations at compile time. This is often "
"much more efficient than running a direct proof search on an inductive type. "
"We therefore come up with a predicate witnessing that a `Dec0` value is "
"actually a `Yes0` together with two utility functions:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:1026
#, no-wrap
msgid ""
"data IsYes0 : (d : Dec0 prop) -> Type where\n"
"  ItIsYes0 : IsYes0 (Yes0 prf)\n"
"\n"
"0 fromYes0 : (d : Dec0 prop) -> (0 prf : IsYes0 d) => prop\n"
"fromYes0 (Yes0 x) = x\n"
"fromYes0 (No0 contra) impossible\n"
"\n"
"0 safeDecideOn :  (0 p : a -> Type)\n"
"               -> Decidable a p\n"
"               => (v : a)\n"
"               -> (0 prf : IsYes0 (decideOn p v))\n"
"               => p v\n"
"safeDecideOn p v = fromYes0 $ decideOn p v\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1045
msgid ""
"Finally, as we are planning to refine mostly primitives, we will at times "
"require some sledge hammer to convince Idris that we know what we are doing:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:1046
#, no-wrap
msgid ""
"-- only use this if you are sure that `decideOn p v`\n"
"-- will return a `Yes0`!\n"
"0 unsafeDecideOn : (0 p : a -> Type) -> Decidable a p => (v : a) -> p v\n"
"unsafeDecideOn p v = case decideOn p v of\n"
"  Yes0 prf => prf\n"
"  No0  _   =>\n"
"    assert_total $ idris_crash \"Unexpected refinement failure in `unsafeRefineOn`\"\n"
msgstr ""

#. type: Bullet: '1. '
#: ../src/Tutorial/Prim.md:1058
msgid "We start with equality proofs. Implement `Decidable` for `Equal v`."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1061
#, no-wrap
msgid ""
"   Hint: Use `DecEq` from module `Decidable.Equality` as a constraint\n"
"         and make sure that `v` is available at runtime.\n"
msgstr ""

#. type: Bullet: '2. '
#: ../src/Tutorial/Prim.md:1063
msgid "We want to be able to negate a predicate:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:1064
#, no-wrap
msgid ""
"   data Neg : (p : a -> Type) -> a -> Type where\n"
"     IsNot : {0 p : a -> Type} -> (contra : p v -> Void) -> Neg p v\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1070
#, no-wrap
msgid "   Implement `Decidable` for `Neg p` using a suitable constraint.\n"
msgstr ""

#. type: Bullet: '3. '
#: ../src/Tutorial/Prim.md:1072
msgid "We want to describe the conjunction of two predicates:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:1073
#, no-wrap
msgid ""
"   data (&&) : (p,q : a -> Type) -> a -> Type where\n"
"     Both : {0 p,q : a -> Type} -> (prf1 : p v) -> (prf2 : q v) -> (&&) p q v\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1079
#, no-wrap
msgid "   Implement `Decidable` for `(p && q)` using suitable constraints.\n"
msgstr ""

#. type: Bullet: '4. '
#: ../src/Tutorial/Prim.md:1083
msgid ""
"Come up with a data type called `(||)` for the disjunction (logical *or*) of "
"two predicates and implement `Decidable` using suitable constraints."
msgstr ""

#. type: Bullet: '5. '
#: ../src/Tutorial/Prim.md:1086
msgid ""
"Proof [De Morgan's laws](https://en.wikipedia.org/wiki/De_Morgan%27s_laws)  "
"by implementing the following propositions:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:1087
#, no-wrap
msgid ""
"   negOr : Neg (p || q) v -> (Neg p && Neg q) v\n"
"\n"
"   andNeg : (Neg p && Neg q) v -> Neg (p || q) v\n"
"\n"
"   orNeg : (Neg p || Neg q) v -> Neg (p && q) v\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1100
#, no-wrap
msgid ""
"   The last of De Morgan's implications is harder to type and proof\n"
"   as we need a way to come up with values of type `p v` and `q v`\n"
"   and show that not both can exist. Here is a way to encode this\n"
"   (annotated with quantity 0 as we will need to access an erased\n"
"   contraposition):\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:1101
#, no-wrap
msgid ""
"   0 negAnd :  Decidable a p\n"
"            => Decidable a q\n"
"            => Neg (p && q) v\n"
"            -> (Neg p || Neg q) v\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1111
#, no-wrap
msgid ""
"   When you implement `negAnd`, remember that you can freely access\n"
"   erased (implicit) arguments, because `negAnd` itself can only be\n"
"   used in an erased context.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1117
msgid ""
"So far, we implemented the tools to algebraically describe and combine "
"several predicate. It is now time to come up with some examples. As a first "
"use case, we will focus on limiting the valid range of natural numbers. For "
"this, we use the following data type:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:1118
#, no-wrap
msgid ""
"-- Proof that m <= n\n"
"data (<=) : (m,n : Nat) -> Type where\n"
"  ZLTE : 0 <= n\n"
"  SLTE : m <= n -> S m <= S n\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1128
msgid ""
"This is similar to `Data.Nat.LTE` but I find operator notation often to be "
"clearer.  We also can define and use the following aliases:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Prim.md:1129
#, no-wrap
msgid ""
"(>=) : (m,n : Nat) -> Type\n"
"m >= n = n <= m\n"
"\n"
"(<) : (m,n : Nat) -> Type\n"
"m < n = S m <= n\n"
"\n"
"(>) : (m,n : Nat) -> Type\n"
"m > n = n < m\n"
"\n"
"LessThan : (m,n : Nat) -> Type\n"
"LessThan m = (< m)\n"
"\n"
"To : (m,n : Nat) -> Type\n"
"To m = (<= m)\n"
"\n"
"GreaterThan : (m,n : Nat) -> Type\n"
"GreaterThan m = (> m)\n"
"\n"
"From : (m,n : Nat) -> Type\n"
"From m = (>= m)\n"
"\n"
"FromTo : (lower,upper : Nat) -> Nat -> Type\n"
"FromTo l u = From l && To u\n"
"\n"
"Between : (lower,upper : Nat) -> Nat -> Type\n"
"Between l u = GreaterThan l && LessThan u\n"
msgstr ""

#. type: Bullet: '6. '
#: ../src/Tutorial/Prim.md:1171
msgid ""
"Coming up with a value of type `m <= n` by pattern matching on `m` and `n` "
"is highly inefficient for large values of `m`, as it will require `m` "
"iterations to do so. However, while in an erased context, we don't need to "
"hold a value of type `m <= n`. We only need to show, that such a value "
"follows from a more efficient computation. Such a computation is `compare` "
"for natural numbers: Although this is implemented in the *Prelude* with a "
"pattern match on its arguments, it is optimized by the compiler to a "
"comparison of integers which runs in constant time even for very large "
"numbers.  Since `Prelude.(<=)` for natural numbers is implemented in terms "
"of `compare`, it runs just as efficiently."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1175
#, no-wrap
msgid ""
"   We therefore need to proof the following two lemmas (make\n"
"   sure to not confuse `Prelude.(<=)` with `Prim.(<=)` in\n"
"   these declarations):\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:1176
#, no-wrap
msgid ""
"   0 fromLTE : (n1,n2 : Nat) -> (n1 <= n2) === True -> n1 <= n2\n"
"\n"
"   0 toLTE : (n1,n2 : Nat) -> n1 <= n2 -> (n1 <= n2) === True\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1185
#, no-wrap
msgid ""
"   They come with a quantity of 0, because they are just as inefficient\n"
"   as the other computations we discussed above. We therefore want\n"
"   to make absolutely sure that they will never be used at runtime!\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1190
#, no-wrap
msgid ""
"   Now, implement `Decidable Nat (<= n)`, making use of `test0`,\n"
"   `fromLTE`, and `toLTE`.\n"
"   Likewise, implement `Decidable Nat (m <=)`, because we require\n"
"   both kinds of predicates.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1193
#, no-wrap
msgid ""
"   Note: You should by know figure out yourself that `n` must be\n"
"   available at runtime and how to make sure that this is the case.\n"
msgstr ""

#. type: Bullet: '7. '
#: ../src/Tutorial/Prim.md:1198
msgid ""
"Proof that `(<=)` is reflexive and transitive by declaring and implementing "
"corresponding propositions. As we might require the proof of transitivity to "
"chain several values of type `(<=)`, it makes sense to also define a short "
"operator alias for this."
msgstr ""

#. type: Bullet: '8. '
#: ../src/Tutorial/Prim.md:1200
msgid "Proof that from `n > 0` follows `IsSucc n` and vise versa."
msgstr ""

#. type: Bullet: '9. '
#: ../src/Tutorial/Prim.md:1207
msgid ""
"Declare and implement safe division and modulo functions for `Bits64`, by "
"requesting an erased proof that the denominator is strictly positive when "
"cast to a natural number. In case of the modulo function, return a refined "
"value carrying an erased proof that the result is strictly smaller than the "
"modulus:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:1208
#, no-wrap
msgid ""
"   safeMod :  (x,y : Bits64)\n"
"           -> (0 prf : cast y > 0)\n"
"           => Subset Bits64 (\\v => cast v < cast y)\n"
msgstr ""

#. type: Bullet: '10. '
#: ../src/Tutorial/Prim.md:1218
msgid ""
"We will use the predicates and utilities we defined so far to convert a "
"value of type `Bits64` to a string of digits in base `b` with `2 <= b && b "
"<= 16`.  To do so, implement the following skeleton definitions:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1223
#, no-wrap
msgid ""
"    ```idris\n"
"    -- this will require some help from `assert_total`\n"
"    -- and `idris_crash`.\n"
"    digit : (v : Bits64) -> (0 prf : cast v < 16) => Char\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1228
#, no-wrap
msgid ""
"    record Base where\n"
"      constructor MkBase\n"
"      value : Bits64\n"
"      0 prf : FromTo 2 16 (cast value)\n"
msgstr ""
"    record Base where\n"
"      constructor MkBase\n"
"      value : Bits64\n"
"      0 prf : FromTo 2 16 (cast value)\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1230
#, no-wrap
msgid "    base : Bits64 -> Maybe Base\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1235
#, no-wrap
msgid ""
"    namespace Base\n"
"      public export\n"
"      fromInteger : (v : Integer) -> {auto 0 _ : IsJust (base $ cast v)} -> Base\n"
"    ```\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1241
#, no-wrap
msgid ""
"    Finally, implement `digits`, using `safeDiv` and `safeMod`\n"
"    in your implementation. This might be challenging, as you will\n"
"    have to manually transform some proofs to satisfy the type\n"
"    checker. You might also require `assert_smaller` in the\n"
"    recursive step.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1245
#, no-wrap
msgid ""
"    ```idris\n"
"    digits : Bits64 -> Base -> String\n"
"    ```\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1255
msgid ""
"We will now turn our focus on strings. Two of the most obvious ways in which "
"we can restrict the strings we accept are by limiting the set of characters "
"and limiting their lengths. More advanced refinements might require strings "
"to match a certain pattern or regular expression. In such cases, we might "
"either go for a boolean check or use a custom data type representing the "
"different parts of the pattern, but we will not cover these topics here."
msgstr ""

#. type: Bullet: '11. '
#: ../src/Tutorial/Prim.md:1258
msgid "Implement the following aliases for useful predicates on characters."
msgstr "以下の関数名で、文字における有用な述語を実装してください。"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1262
#, no-wrap
msgid ""
"    Hint: Use `cast` to convert characters to natural numbers,\n"
"    use `(<=)` and `InRange` to specify regions of characters,\n"
"    and use `(||)` to combine regions of characters.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1266
#, no-wrap
msgid ""
"    ```idris\n"
"    -- Characters <= 127\n"
"    IsAscii : Char -> Type\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1269
#, no-wrap
msgid ""
"    -- Characters <= 255\n"
"    IsLatin : Char -> Type\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1272
#, no-wrap
msgid ""
"    -- Characters in the interval ['A','Z']\n"
"    IsUpper : Char -> Type\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1275
#, no-wrap
msgid ""
"    -- Characters in the interval ['a','z']\n"
"    IsLower : Char -> Type\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1278
#, no-wrap
msgid ""
"    -- Lower or upper case characters\n"
"    IsAlpha : Char -> Type\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1281
#, no-wrap
msgid ""
"    -- Characters in the range ['0','9']\n"
"    IsDigit : Char -> Type\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1284
#, no-wrap
msgid ""
"    -- Digits or characters from the alphabet\n"
"    IsAlphaNum : Char -> Type\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1287
#, no-wrap
msgid ""
"    -- Characters in the ranges [0,31] or [127,159]\n"
"    IsControl : Char -> Type\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1290
#, no-wrap
msgid ""
"    -- An ASCII character that is not a control character\n"
"    IsPlainAscii : Char -> Type\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1294
#, no-wrap
msgid ""
"    -- A latin character that is not a control character\n"
"    IsPlainLatin : Char -> Type\n"
"    ```\n"
msgstr ""

#. type: Bullet: '12. '
#: ../src/Tutorial/Prim.md:1301
msgid ""
"The advantage of this more modular approach to predicates on primitives is "
"that we can safely run calculations on our predicates and get the strong "
"guarantees from the existing proofs on inductive types like `Nat` and "
"`List`. Here are some examples of such calculations and conversions, all of "
"which can be implemented without cheating:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1304
#, no-wrap
msgid ""
"    ```idris\n"
"    0 plainToAscii : IsPlainAscii c -> IsAscii c\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1306
#, no-wrap
msgid "    0 digitToAlphaNum : IsDigit c -> IsAlphaNum c\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1308
#, no-wrap
msgid "    0 alphaToAlphaNum : IsAlpha c -> IsAlphaNum c\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1310
#, no-wrap
msgid "    0 lowerToAlpha : IsLower c -> IsAlpha c\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1312
#, no-wrap
msgid "    0 upperToAlpha : IsUpper c -> IsAlpha c\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1314
#, no-wrap
msgid "    0 lowerToAlphaNum : IsLower c -> IsAlphaNum c\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1317
#, no-wrap
msgid ""
"    0 upperToAlphaNum : IsUpper c -> IsAlphaNum c\n"
"    ```\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1324
#, no-wrap
msgid ""
"    The following (`asciiToLatin`) is trickier. Remember that\n"
"    `(<=)` is transitive. However, in your invocation of the proof\n"
"    of transitivity, you will not be able to apply direct proof search using\n"
"    `%search` because the search depth is too small. You could\n"
"    increase the search depth, but it is much more efficient\n"
"    to use `safeDecideOn` instead.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1327
#, no-wrap
msgid ""
"    ```idris\n"
"    0 asciiToLatin : IsAscii c -> IsLatin c\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1330
#, no-wrap
msgid ""
"    0 plainAsciiToPlainLatin : IsPlainAscii c -> IsPlainLatin c\n"
"    ```\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1334
msgid ""
"Before we turn our full attention to predicates on strings, we have to cover "
"lists first, because we will often treat strings as lists of characters."
msgstr ""

#. type: Bullet: '13. '
#: ../src/Tutorial/Prim.md:1336
msgid "Implement `Decidable` for `Head`:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1341
#, no-wrap
msgid ""
"    ```idris\n"
"    data Head : (p : a -> Type) -> List a -> Type where\n"
"      AtHead : {0 p : a -> Type} -> (0 prf : p v) -> Head p (v :: vs)\n"
"    ```\n"
msgstr ""

#. type: Bullet: '14. '
#: ../src/Tutorial/Prim.md:1343
msgid "Implement `Decidable` for `Length`:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1350
#, no-wrap
msgid ""
"    ```idris\n"
"    data Length : (p : Nat -> Type) -> List a -> Type where\n"
"      HasLength :  {0 p : Nat -> Type}\n"
"                -> (0 prf : p (List.length vs))\n"
"                -> Length p vs\n"
"    ```\n"
msgstr ""

#. type: Bullet: '15. '
#: ../src/Tutorial/Prim.md:1354
msgid ""
"The following predicate is a proof that all values in a list of values "
"fulfill the given predicate. We will use this to limit the valid set of "
"characters in a string."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1363
#, no-wrap
msgid ""
"    ```idris\n"
"    data All : (p : a -> Type) -> (as : List a) -> Type where\n"
"      Nil  : All p []\n"
"      (::) :  {0 p : a -> Type}\n"
"           -> (0 h : p v)\n"
"           -> (0 t : All p vs)\n"
"           -> All p (v :: vs)\n"
"    ```\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1365
#, no-wrap
msgid "    Implement `Decidable` for `All`.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1373
#, no-wrap
msgid ""
"    For a real challenge, try to make your implementation of\n"
"    `decide` tail recursive. This will be important for real world\n"
"    applications on the JavaScript backends, where we might want to\n"
"    refine strings of thousands of characters without overflowing the\n"
"    stack at runtime. In order to come up with a tail recursive implementation,\n"
"    you will need an additional data type `AllSnoc` witnessing that a predicate\n"
"    holds for all elements in a `SnocList`.\n"
msgstr ""

#. type: Bullet: '16. '
#: ../src/Tutorial/Prim.md:1379
msgid ""
"It's time to come to an end here. An identifier in Idris is a sequence of "
"alphanumeric characters, possibly separated by underscore characters (`_`). "
"In addition, all identifiers must start with a letter.  Given this "
"specification, implement predicate `IdentChar`, from which we can define a "
"new wrapper type for identifiers:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1382
#, no-wrap
msgid ""
"    ```idris\n"
"    0 IdentChars : List Char -> Type\n"
msgstr ""
"    ```idris\n"
"    0 IdentChars : List Char -> Type\n"

#. type: Plain text
#: ../src/Tutorial/Prim.md:1388
#, no-wrap
msgid ""
"    record Identifier where\n"
"      constructor MkIdentifier\n"
"      value : String\n"
"      0 prf : IdentChars (unpack value)\n"
"    ```\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1391
#, no-wrap
msgid ""
"    Implement a factory method `identifier` for converting strings\n"
"    of unknown source at runtime:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1395
#, no-wrap
msgid ""
"    ```idris\n"
"    identifier : String -> Maybe Identifier\n"
"    ```\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1398
#, no-wrap
msgid ""
"    In addition, implement `fromString` for `Identifier` and verify,\n"
"    that the following is a valid identifier:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1403
#, no-wrap
msgid ""
"    ```idris\n"
"    testIdent : Identifier\n"
"    testIdent = \"fooBar_123\"\n"
"    ```\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1409
msgid ""
"Final remarks: Proofing stuff about the primitives can be challenging, both "
"when deciding on what axioms to use and when trying to make things perform "
"well at runtime and compile time. I'm experimenting with a library, which "
"deals with these issues. It is not yet finished, but you can have a look at "
"it [here](https://github.com/stefan-hoeck/idris2-prim)."
msgstr ""

#. type: Title #
#: ../src/Tutorial/Traverse.md:1
#, no-wrap
msgid "Effectful Traversals"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:11
msgid ""
"In this chapter, we are going to bring our treatment of the higher-kinded "
"interfaces in the *Prelude* to an end. In order to do so, we will continue "
"developing the CSV reader we started implementing in chapter [Functor and "
"Friends](Functor.md). I moved some of the data types and interfaces from "
"that chapter to their own modules, so we can import them here without the "
"need to start from scratch."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:16
msgid ""
"Note that unlike in our original CSV reader, we will use `Validated` instead "
"of `Either` for handling exceptions, since this will allow us to accumulate "
"all errors when reading a CSV file."
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:17
#, no-wrap
msgid ""
"module Tutorial.Traverse\n"
"\n"
"import Data.HList\n"
"import Data.IORef\n"
"import Data.List1\n"
"import Data.String\n"
"import Data.Validated\n"
"import Data.Vect\n"
"import Text.CSV\n"
"\n"
"%default total\n"
msgstr ""

#. type: Title ##
#: ../src/Tutorial/Traverse.md:31
#, no-wrap
msgid "Reading CSV Tables"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:37
msgid ""
"We stopped developing our CSV reader with function `hdecode`, which allows "
"us to read a single line in a CSV file and decode it to a heterogeneous "
"list.  As a reminder, here is how to use `hdecode` at the REPL:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Traverse.md:38
#, no-wrap
msgid ""
"Tutorial.Traverse> hdecode [Bool,String,Bits8] 1 \"f,foo,12\"\n"
"Valid [False, \"foo\", 12]\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:51
msgid ""
"The next step will be to parse a whole CSV table, represented as a list of "
"strings, where each string corresponds to one of the table's rows.  We will "
"go about this stepwise as there are several aspects about doing this "
"properly. What we are looking for - eventually - is a function of the "
"following type (we are going to implement several versions of this function, "
"hence the numbering):"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:52
#, no-wrap
msgid ""
"hreadTable1 :  (0 ts : List Type)\n"
"            -> CSVLine (HList ts)\n"
"            => List String\n"
"            -> Validated CSVError (List $ HList ts)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:61
msgid ""
"In our first implementation, we are not going to care about line numbers:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:62
#, no-wrap
msgid ""
"hreadTable1 _  []        = pure []\n"
"hreadTable1 ts (s :: ss) = [| hdecode ts 0 s :: hreadTable1 ts ss |]\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:72
msgid ""
"Note, how we can just use applicative syntax in the implementation of "
"`hreadTable1`. To make this clearer, I used `pure []` on the first line "
"instead of the more specific `Valid []`. In fact, if we used `Either` or "
"`Maybe` instead of `Validated` for error handling, the implementation of "
"`hreadTable1` would look exactly the same."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:81
#, no-wrap
msgid ""
"The question is: Can we extract a pattern to abstract over\n"
"from this observation? What we do in `hreadTable1` is running\n"
"an effectful computation of type `String -> Validated CSVError (HList ts)`\n"
"over a list of strings, so that the result is a list of `HList ts`\n"
"wrapped in a `Validated CSVError`. The first step of abstraction\n"
"should be to use type parameters for the input and output:\n"
"Run a computation of type `a -> Validated CSVError b` over a\n"
"list `List a`:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:82
#, no-wrap
msgid ""
"traverseValidatedList :  (a -> Validated CSVError b)\n"
"                      -> List a\n"
"                      -> Validated CSVError (List b)\n"
"traverseValidatedList _ []        = pure []\n"
"traverseValidatedList f (x :: xs) = [| f x :: traverseValidatedList f xs |]\n"
"\n"
"hreadTable2 :  (0 ts : List Type)\n"
"            -> CSVLine (HList ts)\n"
"            => List String\n"
"            -> Validated CSVError (List $ HList ts)\n"
"hreadTable2 ts = traverseValidatedList (hdecode ts 0)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:104
msgid ""
"But our observation was, that the implementation of `hreadTable1` would be "
"exactly the same if we used `Either CSVError` or `Maybe` as our effect types "
"instead of `Validated CSVError`.  So, the next step should be to abstract "
"over the *effect type*.  We note, that we used applicative syntax (idiom "
"brackets and `pure`) in our implementation, so we will need to write a "
"function with an `Applicative` constraint on the effect type:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:105
#, no-wrap
msgid ""
"traverseList :  Applicative f => (a -> f b) -> List a -> f (List b)\n"
"traverseList _ []        = pure []\n"
"traverseList f (x :: xs) = [| f x :: traverseList f xs |]\n"
"\n"
"hreadTable3 :  (0 ts : List Type)\n"
"            -> CSVLine (HList ts)\n"
"            => List String\n"
"            -> Validated CSVError (List $ HList ts)\n"
"hreadTable3 ts = traverseList (hdecode ts 0)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:120
msgid ""
"Note, how the implementation of `traverseList` is exactly the same as the "
"one of `traverseValidatedList`, but the types are more general and "
"therefore, `traverseList` is much more powerful."
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Traverse.md:123
#, no-wrap
msgid ""
"Tutorial.Traverse> hreadTable3 [Bool,Bits8] [\"f,12\",\"t,0\"]\n"
"Valid [[False, 12], [True, 0]]\n"
"Tutorial.Traverse> hreadTable3 [Bool,Bits8] [\"f,12\",\"t,1000\"]\n"
"Invalid (FieldError 0 2 \"1000\")\n"
"Tutorial.Traverse> hreadTable3 [Bool,Bits8] [\"1,12\",\"t,1000\"]\n"
"Invalid (Append (FieldError 0 1 \"1\") (FieldError 0 2 \"1000\"))\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:139
msgid ""
"This works very well already, but note how our error messages do not yet "
"print the correct line numbers. That's not surprising, as we are using a "
"dummy constant in our call to `hdecode`.  We will look at how we can come up "
"with the line numbers on the fly when we talk about stateful computations "
"later in this chapter.  For now, we could just manually annotate the lines "
"with their numbers and pass a list of pairs to `hreadTable`:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:140
#, no-wrap
msgid ""
"hreadTable4 :  (0 ts : List Type)\n"
"            -> CSVLine (HList ts)\n"
"            => List (Nat, String)\n"
"            -> Validated CSVError (List $ HList ts)\n"
"hreadTable4 ts = traverseList (uncurry $ hdecode ts)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:154
msgid ""
"If this is the first time you came across function `uncurry`, make sure you "
"have a look at its type and try to figure out why it is used here. There are "
"several utility functions like this in the *Prelude*, such as `curry`, "
"`uncurry`, `flip`, or even `id`, all of which can be very useful when "
"working with higher-order functions."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:157
msgid ""
"While not perfect, this version at least allows us to verify at the REPL "
"that the line numbers are passed to the error messages correctly:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Traverse.md:158
#, no-wrap
msgid ""
"Tutorial.Traverse> hreadTable4 [Bool,Bits8] [(1,\"t,1000\"),(2,\"1,100\")]\n"
"Invalid (Append (FieldError 1 2 \"1000\") (FieldError 2 1 \"1\"))\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Traverse.md:163
#, no-wrap
msgid "Interface Traversable"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:172
msgid ""
"Now, here is an interesting observation: We can implement a function like "
"`traverseList` for other container types as well. You might think that's "
"obvious, given that we can convert container types to lists via function "
"`toList` from interface `Foldable`. However, while going via `List` might be "
"feasible in some occasions, it is undesirable in general, as we loose typing "
"information. For instance, here is such a function for `Vect`:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:173
#, no-wrap
msgid ""
"traverseVect' : Applicative f => (a -> f b) -> Vect n a -> f (List b)\n"
"traverseVect' fun = traverseList fun . toList\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:182
msgid ""
"Note how we lost all information about the structure of the original "
"container type. What we are looking for is a function like `traverseVect'`, "
"which keeps this type level information: The result should be a vector of "
"the same length as the input."
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:183
#, no-wrap
msgid ""
"traverseVect : Applicative f => (a -> f b) -> Vect n a -> f (Vect n b)\n"
"traverseVect _   []        = pure []\n"
"traverseVect fun (x :: xs) = [| fun x :: traverseVect fun xs |]\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:193
msgid ""
"That's much better! And as I wrote above, we can easily get the same for "
"other container types like `List1`, `SnocList`, `Maybe`, and so on.  As "
"usual, some derived functions will follow immediately from `traverseXY`.  "
"For instance:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:194
#, no-wrap
msgid ""
"sequenceList : Applicative f => List (f a) -> f (List a)\n"
"sequenceList = traverseList id\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:202
msgid ""
"All of this calls for a new interface, which is called `Traversable` and is "
"exported from the *Prelude*. Here is its definition (with primes for "
"disambiguation):"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:203
#, no-wrap
msgid ""
"interface Functor t => Foldable t => Traversable' t where\n"
"  traverse' : Applicative f => (a -> f b) -> t a -> f (t b)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:214
msgid ""
"Function `traverse` is one of the most abstract and versatile functions "
"available from the *Prelude*. Just how powerful it is will only become clear "
"once you start using it over and over again in your code. However, it will "
"be the goal of the remainder of this chapter to show you several diverse and "
"interesting use cases."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:229
msgid ""
"For now, we will quickly focus on the degree of abstraction.  Function "
"`traverse` is parameterized over no less than four parameters: The container "
"type `t` (`List`, `Vect n`, `Maybe`, to just name a few), the effect type "
"(`Validated e`, `IO`, `Maybe`, and so on), the input element type `a`, and "
"the output element type `b`. Considering that the libraries bundled with the "
"Idris project export more than 30 data types with an implementation of "
"`Applicative` and more than ten traversable container types, there are "
"literally hundreds of combinations for traversing a container with an "
"effectful computation. This number gets even larger once we realize that "
"traversable containers - like applicative functors - are closed under "
"composition (see the exercises and the final section in this chapter)."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Traverse.md:230
#, no-wrap
msgid "Traversable Laws"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:233
msgid "There are two laws function `traverse` must obey:"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Traverse.md:241
msgid ""
"`traverse (Id . f) = Id . map f`: Traversing over the `Identity` monad is "
"just functor `map`."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Traverse.md:241
msgid ""
"`traverse (MkComp . map f . g) = MkComp . map (traverse f) . traverse g`: "
"Traversing with a composition of effects must be the same when being done in "
"a single traversal (left hand side) or a sequence of two traversals (right "
"hand side)."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:246
msgid ""
"Since `map id = id` (functor's identity law), we can derive from the first "
"law that `traverse Id = Id`. This means, that `traverse` must not change the "
"size or shape of the container type, nor is it allowed to change the order "
"of elements."
msgstr ""

#. type: Bullet: '1. '
#: ../src/Tutorial/Traverse.md:253
msgid ""
"It is interesting that `Traversable` has a `Functor` constraint. Proof that "
"every `Traversable` is automatically a `Functor` by implementing `map` in "
"terms of `traverse`."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:255
#, no-wrap
msgid "   Hint: Remember `Control.Monad.Identity`.\n"
msgstr ""

#. type: Bullet: '2. '
#: ../src/Tutorial/Traverse.md:259
msgid ""
"Likewise, proof that every `Traversable` is a `Foldable` by implementing "
"`foldMap` in terms of `Traverse`."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:261
#, no-wrap
msgid "   Hint: Remember `Control.Applicative.Const`.\n"
msgstr ""

#. type: Bullet: '3. '
#: ../src/Tutorial/Traverse.md:264
msgid ""
"To gain some routine, implement `Traversable'` for `List1`, `Either e`, and "
"`Maybe`."
msgstr ""

#. type: Bullet: '4. '
#: ../src/Tutorial/Traverse.md:266
msgid "Implement `Traversable` for `List01 ne`:"
msgstr ""

#. type: Bullet: '5. '
#: ../src/Tutorial/Traverse.md:275
msgid ""
"Implement `Traversable` for rose trees. Try to satisfy the totality checker "
"without cheating."
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:276
#, no-wrap
msgid ""
"   record Tree a where\n"
"     constructor Node\n"
"     value  : a\n"
"     forest : List (Tree a)\n"
msgstr ""

#. type: Bullet: '6. '
#: ../src/Tutorial/Traverse.md:284
msgid "Implement `Traversable` for `Crud i`:"
msgstr ""

#. type: Bullet: '7. '
#: ../src/Tutorial/Traverse.md:294
msgid "Implement `Traversable` for `Response e i`:"
msgstr ""

#. type: Bullet: '8. '
#: ../src/Tutorial/Traverse.md:307
msgid ""
"Like `Functor`, `Applicative` and `Foldable`, `Traversable` is closed under "
"composition. Proof this by implementing `Traversable` for `Comp` and "
"`Product`:"
msgstr ""

#. type: Title ##
#: ../src/Tutorial/Traverse.md:319
#, no-wrap
msgid "Programming with State"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:324
msgid ""
"Let's go back to our CSV reader. In order to get reasonable error messages, "
"we'd like to tag each line with its index:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:325
#, no-wrap
msgid "zipWithIndex : List a -> List (Nat, a)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:331
msgid ""
"It is, of course, very easy to come up with an ad hoc implementation for "
"this:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:332
#, no-wrap
msgid ""
"zipWithIndex = go 1\n"
"  where go : Nat -> List a -> List (Nat,a)\n"
"        go _ []        = []\n"
"        go n (x :: xs) = (n,x) :: go (S n) xs\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:344
msgid ""
"While this is perfectly fine, we should still note that we might want to do "
"the same thing with the elements of trees, vectors, non-empty lists and so "
"on.  And again, we are interested in whether there is some form of "
"abstraction we can use to describe such computations."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Traverse.md:345
#, no-wrap
msgid "Mutable References in Idris"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:352
msgid ""
"Let us for a moment think about how we'd do such a thing in an imperative "
"language. There, we'd probably define a local (mutable) variable to keep "
"track of the current index, which would then be increased while iterating "
"over the list in a `for`- or `while`-loop."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:363
msgid ""
"In Idris, there is no such thing as mutable state.  Or is there? Remember, "
"how we used a mutable reference to simulate a data base connection in an "
"earlier exercise. There, we actually used some truly mutable state. However, "
"since accessing or modifying a mutable variable is not a referential "
"transparent operation, such actions have to be performed within `IO`.  Other "
"than that, nothing keeps us from using mutable variables in our code. The "
"necessary functionality is available from module `Data.IORef` from the "
"*base* library."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:367
msgid ""
"As a quick exercise, try to implement a function, which - given an `IORef "
"Nat` - pairs a value with the current index and increases the index "
"afterwards."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:369
msgid "Here's how I would do this:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:370
#, no-wrap
msgid ""
"pairWithIndexIO : IORef Nat -> a -> IO (Nat,a)\n"
"pairWithIndexIO ref va = do\n"
"  ix <- readIORef ref\n"
"  writeIORef ref (S ix)\n"
"  pure (ix,va)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:387
#, no-wrap
msgid ""
"Note, that every time we *run* `pairWithIndexIO ref`, the\n"
"natural number stored in `ref` is incremented by one.\n"
"Also, look at the type of `pairWithIndexIO ref`: `a -> IO (Nat,a)`.\n"
"We want to apply this effectful computation to each element\n"
"in a list, which should lead to a new list wrapped in `IO`,\n"
"since all of this describes a single computation with side\n"
"effects. But this is *exactly* what function `traverse` does: Our\n"
"input type is `a`, our output type is `(Nat,a)`, our\n"
"container type is `List`, and the effect type is `IO`!\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:388
#, no-wrap
msgid ""
"zipListWithIndexIO : IORef Nat -> List a -> IO (List (Nat,a))\n"
"zipListWithIndexIO ref = traverse (pairWithIndexIO ref)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:397
msgid ""
"Now *this* is really powerful: We could apply the same function to *any* "
"traversable data structure. It therefore makes absolutely no sense to "
"specialize `zipListWithIndexIO` to lists only:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:398
#, no-wrap
msgid ""
"zipWithIndexIO : Traversable t => IORef Nat -> t a -> IO (t (Nat,a))\n"
"zipWithIndexIO ref = traverse (pairWithIndexIO ref)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:405
msgid ""
"To please our intellectual minds even more, here is the same function in "
"point-free style:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:406
#, no-wrap
msgid ""
"zipWithIndexIO' : Traversable t => IORef Nat -> t a -> IO (t (Nat,a))\n"
"zipWithIndexIO' = traverse . pairWithIndexIO\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:413
msgid ""
"All that's left to do now is to initialize a new mutable variable before "
"passing it to `zipWithIndexIO`:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:414
#, no-wrap
msgid ""
"zipFromZeroIO : Traversable t => t a -> IO (t (Nat,a))\n"
"zipFromZeroIO ta = newIORef 0 >>= (`zipWithIndexIO` ta)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:420
msgid "Quickly, let's give this a go at the REPL:"
msgstr "ちょっとREPLで動かしてみましょう。"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Traverse.md:421
#, no-wrap
msgid ""
"> :exec zipFromZeroIO {t = List} [\"hello\", \"world\"] >>= printLn\n"
"[(0, \"hello\"), (1, \"world\")]\n"
"> :exec zipFromZeroIO (Just 12) >>= printLn\n"
"Just (0, 12)\n"
"> :exec zipFromZeroIO {t = Vect 2} [\"hello\", \"world\"] >>= printLn\n"
"[(0, \"hello\"), (1, \"world\")]\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:432
msgid ""
"Thus, we solved the problem of tagging each element with its index once and "
"for all for all traversable container types."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Traverse.md:433
#, no-wrap
msgid "The State Monad"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:441
msgid ""
"Alas, while the solution presented above is elegant and performs very well, "
"it still carries its `IO` stain, which is fine if we are already in `IO` "
"land, but unacceptable otherwise. We do not want to make our otherwise pure "
"functions much harder to test and reason about just for a simple case of "
"stateful element tagging."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:450
msgid ""
"Luckily, there is an alternative to using a mutable reference, which allows "
"us to keep our computations pure and untainted. However, it is not easy to "
"come upon this alternative on one's own, and it can be hard to figure out "
"what's going on here, so I'll try to introduce this slowly.  We first need "
"to ask ourselves what the essence of a \"stateful\" but otherwise pure "
"computation is. There are two essential ingredients:"
msgstr ""

#. type: Bullet: '1. '
#: ../src/Tutorial/Traverse.md:458
msgid ""
"Access to the *current* state. In case of a pure function, this means that "
"the function should take the current state as one of its arguments."
msgstr ""

#. type: Bullet: '2. '
#: ../src/Tutorial/Traverse.md:458
msgid ""
"Ability to communicate the updated state to later stateful computations. In "
"case of a pure function this means, that the function will return a pair of "
"values: The computation's result plus the updated state."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:462
msgid ""
"These two prerequisites lead to the following generic type for a pure, "
"stateful computation operating on state type `st` and producing values of "
"type `a`:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:463
#, no-wrap
msgid ""
"Stateful : (st : Type) -> (a : Type) -> Type\n"
"Stateful st a = st -> (st, a)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:470
msgid ""
"Our use case is pairing elements with indices, which can be implemented as a "
"pure, stateful computation like so:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:471
#, no-wrap
msgid ""
"pairWithIndex' : a -> Stateful Nat (Nat,a)\n"
"pairWithIndex' v index = (S index, (index,v))\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:479
msgid ""
"Note, how we at the same time increment the index, returning the incremented "
"value as the new state, while pairing the first argument with the original "
"index."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:488
msgid ""
"Now, here is an important thing to note: While `Stateful` is a useful type "
"alias, Idris in general does *not* resolve interface implementations for "
"function types. If we want to write a small library of utility functions "
"around such a type, it is therefore best to wrap it in a single-constructor "
"data type and use this as our building block for writing more complex "
"computations. We therefore introduce record `State` as a wrapper for pure, "
"stateful computations:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:489
#, no-wrap
msgid ""
"record State st a where\n"
"  constructor ST\n"
"  runST : st -> (st,a)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:496
msgid "We can now implement `pairWithIndex` in terms of `State` like so:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:497
#, no-wrap
msgid ""
"pairWithIndex : a -> State Nat (Nat,a)\n"
"pairWithIndex v = ST $ \\index => (S index, (index, v))\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:505
msgid ""
"In addition, we can define some more utility functions. Here's one for "
"getting the current state without modifying it (this corresponds to "
"`readIORef`):"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:506
#, no-wrap
msgid ""
"get : State st st\n"
"get = ST $ \\s => (s,s)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:513
msgid ""
"Here are two others, for overwriting the current state. These corresponds to "
"`writeIORef` and `modifyIORef`:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:514
#, no-wrap
msgid ""
"put : st -> State st ()\n"
"put v = ST $ \\_ => (v,())\n"
"\n"
"modify : (st -> st) -> State st ()\n"
"modify f = ST $ \\v => (f v,())\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:524
msgid ""
"Finally, we can define three functions in addition to `runST` for running "
"stateful computations"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:525
#, no-wrap
msgid ""
"runState : st -> State st a -> (st, a)\n"
"runState = flip runST\n"
"\n"
"evalState : st -> State st a -> a\n"
"evalState s = snd . runState s\n"
"\n"
"execState : st -> State st a -> st\n"
"execState s = fst . runState s\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:542
msgid ""
"All of these are useful on their own, but the real power of `State s` comes "
"from the observation that it is a monad.  Before you go on, please spend "
"some time and try implementing `Functor`, `Applicative`, and `Monad` for "
"`State s` yourself.  Even if you don't succeed, you will have an easier time "
"understanding how the implementations below work."
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:543
#, no-wrap
msgid ""
"Functor (State st) where\n"
"  map f (ST run) = ST $ \\s => let (s2,va) = run s in (s2, f va)\n"
"\n"
"Applicative (State st) where\n"
"  pure v = ST $ \\s => (s,v)\n"
"\n"
"  ST fun <*> ST val = ST $ \\s =>\n"
"    let (s2, f)  = fun s\n"
"        (s3, va) = val s2\n"
"     in (s3, f va)\n"
"\n"
"Monad (State st) where\n"
"  ST val >>= f = ST $ \\s =>\n"
"    let (s2, va) = val s\n"
"     in runST (f va) s2\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:573
msgid ""
"This may take some time to digest, so we come back to it in a slightly "
"advanced exercise. The most important thing to note is, that we use every "
"state value only ever once. We *must* make sure that the updated state is "
"passed to later computations, otherwise the information about state updates "
"is being lost. This can best be seen in the implementation of `Applicative`: "
"The initial state, `s`, is used in the computation of the function value, "
"which will also return an updated state, `s2`, which is then used in the "
"computation of the function argument. This will again return an updated "
"state, `s3`, which is passed on to later stateful computations together with "
"the result of applying `f` to `va`."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:583
msgid ""
"This sections consists of two extended exercise, the aim of which is to "
"increase your understanding of the state monad.  In the first exercise, we "
"will look at random value generation, a classical application of stateful "
"computations.  In the second exercise, we will look at an indexed version of "
"a state monad, which allows us to not only change the state's value but also "
"its *type* during computations."
msgstr ""

#. type: Bullet: '1. '
#: ../src/Tutorial/Traverse.md:590
msgid ""
"Below is the implementation of a simple pseudo-random number generator. We "
"call this a *pseudo-random* number generator, because the numbers look "
"pretty random but are generated predictably. If we initialize a series of "
"such computations with a truly random seed, most users of our library will "
"not be able to predict the outcome of our computations."
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:591
#, no-wrap
msgid ""
"   rnd : Bits64 -> Bits64\n"
"   rnd seed = fromInteger\n"
"            $ (437799614237992725 * cast seed) `mod` 2305843009213693951\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:604
#, no-wrap
msgid ""
"   The idea here is that the next pseudo-random number gets\n"
"   calculated from the previous one. But once we think about\n"
"   how we can use these numbers as seeds for computing\n"
"   random values of other types, we realize that these are\n"
"   just stateful computations. We can therefore write\n"
"   down an alias for random value generators as stateful\n"
"   computations:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:605
#, no-wrap
msgid ""
"   Gen : Type -> Type\n"
"   Gen = State Bits64\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:617
#, no-wrap
msgid ""
"   Before we begin, please note that `rnd` is not a very strong\n"
"   pseudo-random number generator. It will not generate values in\n"
"   the full 64bit range, nor is it safe to use in cryptographic\n"
"   applications. It is sufficient for our purposes in this chapter,\n"
"   however. Note also, that we could replace `rnd` with a stronger\n"
"   generator without any changes to the functions you will implement\n"
"   as part of this exercise.\n"
msgstr ""

#. type: Bullet: '   1. '
#: ../src/Tutorial/Traverse.md:622
msgid ""
"Implement `bits64` in terms of `rnd`. This should return the current state, "
"updating it afterwards by invoking function `rnd`. Make sure the state is "
"properly updated, otherwise this won't behave as expected."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:626
#, no-wrap
msgid ""
"      ```idris\n"
"      bits64 : Gen Bits64\n"
"      ```\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:631
#, no-wrap
msgid ""
"      This will be our *only* primitive generator, from which\n"
"      we will derived all the others. Therefore,\n"
"      before you continue, quickly test your implementation of\n"
"      `bits64` at the REPL:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:636
#, no-wrap
msgid ""
"      ```repl\n"
"      Solutions.Traverse> runState 100 bits64\n"
"      (2274787257952781382, 100)\n"
"      ```\n"
msgstr ""

#. type: Bullet: '   2. '
#: ../src/Tutorial/Traverse.md:642
msgid ""
"Implement `range64` for generating random values in the range `[0,upper]`. "
"Hint: Use `bits64` and `mod` in your implementation but make sure to deal "
"with the fact that `mod x upper` produces values in the range `[0,upper)`."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:646
#, no-wrap
msgid ""
"      ```idris\n"
"      range64 : (upper : Bits64) -> Gen Bits64\n"
"      ```\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:649
#, no-wrap
msgid ""
"      Likewise, implement `interval64` for generating values\n"
"      in the range `[min a b, max a b]`:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:653
#, no-wrap
msgid ""
"      ```idris\n"
"      interval64 : (a,b : Bits64) -> Gen Bits64\n"
"      ```\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:655
#, no-wrap
msgid "      Finally, implement `interval` for arbitrary integral types.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:659
#, no-wrap
msgid ""
"      ```idris\n"
"      interval : Num n => Cast n Bits64 => (a,b : n) -> Gen n\n"
"      ```\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:663
#, no-wrap
msgid ""
"      Note, that `interval` will not generate all possible values in\n"
"      the given interval but only such values with a `Bits64`\n"
"      representation in the the range `[0,2305843009213693950]`.\n"
msgstr ""

#. type: Bullet: '   3. '
#: ../src/Tutorial/Traverse.md:665
msgid "Implement a generator for random boolean values."
msgstr ""

#. type: Bullet: '   4. '
#: ../src/Tutorial/Traverse.md:670
msgid ""
"Implement a generator for `Fin n`. You'll have to think carefully about "
"getting this one to typecheck and be accepted by the totality checker "
"without cheating.  Note: Have a look at function `Data.Fin.natToFin`."
msgstr ""

#. type: Bullet: '   5. '
#: ../src/Tutorial/Traverse.md:674
msgid ""
"Implement a generator for selecting a random element from a vector of "
"values. Use the generator from exercise 4 in your implementation."
msgstr ""

#. type: Bullet: '   6. '
#: ../src/Tutorial/Traverse.md:678
msgid ""
"Implement `vect` and `list`. In case of `list`, the first argument should be "
"used to randomly determine the length of the list."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:681
#, no-wrap
msgid ""
"      ```idris\n"
"      vect : {n : _} -> Gen a -> Gen (Vect n a)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:684
#, no-wrap
msgid ""
"      list : Gen Nat -> Gen a -> Gen (List a)\n"
"      ```\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:687
#, no-wrap
msgid ""
"      Use `vect` to implement utility function `testGen` for\n"
"      testing your generators at the REPL:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:691
#, no-wrap
msgid ""
"      ```idris\n"
"      testGen : Bits64 -> Gen a -> Vect 10 a\n"
"      ```\n"
msgstr ""

#. type: Bullet: '   7. '
#: ../src/Tutorial/Traverse.md:693
msgid "Implement `choice`."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:697
#, no-wrap
msgid ""
"      ```idris\n"
"      choice : {n : _} -> Vect (S n) (Gen a) -> Gen a\n"
"      ```\n"
msgstr ""

#. type: Bullet: '   8. '
#: ../src/Tutorial/Traverse.md:699
msgid "Implement `either`."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:703
#, no-wrap
msgid ""
"      ```idris\n"
"      either : Gen a -> Gen b -> Gen (Either a b)\n"
"      ```\n"
msgstr ""

#. type: Bullet: '   9. '
#: ../src/Tutorial/Traverse.md:708
msgid ""
"Implement a generator for printable ASCII characters.  These are characters "
"with ASCII codes in the interval `[32,126]`. Hint: Function `chr` from the "
"*Prelude* will be useful here."
msgstr ""

#. type: Bullet: '   10. '
#: ../src/Tutorial/Traverse.md:711
msgid ""
"Implement a generator for strings. Hint: Function `pack` from the *Prelude* "
"might be useful for this."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:715
#, no-wrap
msgid ""
"       ```idris\n"
"       string : Gen Nat -> Gen Char -> Gen String\n"
"       ```\n"
msgstr ""

#. type: Bullet: '   11. '
#: ../src/Tutorial/Traverse.md:722
msgid ""
"We shouldn't forget about our ability to encode interesting things in the "
"types in Idris, so, for a challenge and without further ado, implement "
"`hlist` (note the distinction between `HListF` and `HList`). If you are "
"rather new to dependent types, this might take a moment to digest, so don't "
"forget to use holes."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:727
#, no-wrap
msgid ""
"       ```idris\n"
"       data HListF : (f : Type -> Type) -> (ts : List Type) -> Type where\n"
"         Nil  : HListF f []\n"
"         (::) : (x : f t) -> (xs : HLift f ts) -> HListF f (t :: ts)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:730
#, no-wrap
msgid ""
"       hlist : HListF Gen ts -> Gen (HList ts)\n"
"       ```\n"
msgstr ""

#. type: Bullet: '   12. '
#: ../src/Tutorial/Traverse.md:732
msgid ""
"Generalize `hlist` to work with any applicative functor, not just `Gen`."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:736
#, no-wrap
msgid ""
"   If you arrived here, please realize how we can now generate pseudo-random\n"
"   values for most primitives, as well as regular sum- and product types.\n"
"   Here is an example REPL session:\n"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Traverse.md:737
#, no-wrap
msgid ""
"   > testGen 100 $ hlist [bool, printableAscii, interval 0 127]\n"
"   [[True, ';', 5],\n"
"    [True, '^', 39],\n"
"    [False, 'o', 106],\n"
"    [True, 'k', 127],\n"
"    [False, ' ', 11],\n"
"    [False, '~', 76],\n"
"    [True, 'M', 11],\n"
"    [False, 'P', 107],\n"
"    [True, '5', 67],\n"
"    [False, '8', 9]]\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:764
#, no-wrap
msgid ""
"   Final remarks: Pseudo-random value generators play an important role\n"
"   in property based testing libraries like [QuickCheck](https://hackage.haskell.org/package/QuickCheck)\n"
"   or [Hedgehog](https://github.com/stefan-hoeck/idris2-hedgehog).\n"
"   The idea of property based testing is to test predefined *properties* of\n"
"   pure functions against a large number of randomly generated arguments,\n"
"   to get strong guarantees about these properties to hold for *all*\n"
"   possible arguments. One example would be a test for verifying\n"
"   that the result of reversing a list twice equals the original list.\n"
"   While it is possible to proof many of the simpler properties in Idris\n"
"   directly without the need for tests, this is no longer possible\n"
"   as soon as functions are involved, which don't reduce during unification\n"
"   such as foreign function calls or functions not publicly exported from\n"
"   other modules.\n"
msgstr ""

#. type: Bullet: '2. '
#: ../src/Tutorial/Traverse.md:770
msgid ""
"While `State s a` gives us a convenient way to talk about stateful "
"computations, it only allows us to mutate the state's *value* but not its "
"*type*. For instance, the following function cannot be encapsulated in "
"`State` because the type of the state changes:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:771
#, no-wrap
msgid ""
"   uncons : Vect (S n) a -> (Vect n a, a)\n"
"   uncons (x :: xs) = (xs, x)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:784
#, no-wrap
msgid ""
"   Your task is to come up with a new state type allowing for\n"
"   such changes (sometimes referred to as an *indexed* state data type).\n"
"   The goal of this exercise is to also sharpen your skills in\n"
"   expressing things at the type level including derived function\n"
"   types and interfaces. Therefore, I will give only little\n"
"   guidance on how to go about this. If you get stuck, feel free to\n"
"   peek at the solutions but make sure to only look at the types\n"
"   at first.\n"
msgstr ""

#. type: Bullet: '   1. '
#: ../src/Tutorial/Traverse.md:790
msgid ""
"Come up with a parameterized data type for encapsulating stateful "
"computations where the input and output state type can differ. It must be "
"possible to wrap `uncons` in a value of this type."
msgstr ""

#. type: Bullet: '   2. '
#: ../src/Tutorial/Traverse.md:792
msgid "Implement `Functor` for your indexed state type."
msgstr ""

#. type: Bullet: '   3. '
#: ../src/Tutorial/Traverse.md:797
msgid ""
"It is not possible to implement `Applicative` for this *indexed* state type "
"(but see also exercise 2.vii).  Still, implement the necessary functions to "
"use it with idom brackets."
msgstr ""

#. type: Bullet: '   4. '
#: ../src/Tutorial/Traverse.md:801
msgid ""
"It is not possible to implement `Monad` for this indexed state type. Still, "
"implement the necessary functions to use it in do blocks."
msgstr ""

#. type: Bullet: '   5. '
#: ../src/Tutorial/Traverse.md:805
msgid ""
"Generalize the functions from exercises 3 and 4 with two new interfaces "
"`IxApplicative` and `IxMonad` and provide implementations of these for your "
"indexed state data type."
msgstr ""

#. type: Bullet: '   6. '
#: ../src/Tutorial/Traverse.md:809
msgid ""
"Implement functions `get`, `put`, `modify`, `runState`, `evalState`, and "
"`execState` for the indexed state data type. Make sure to adjust the type "
"parameters where necessary."
msgstr ""

#. type: Bullet: '   7. '
#: ../src/Tutorial/Traverse.md:812
msgid ""
"Show that your indexed state type is strictly more powerful than `State` by "
"implementing `Applicative` and `Monad` for it."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:816
#, no-wrap
msgid ""
"      Hint: Keep the input and output state identical. Note also,\n"
"      that you might need to implement `join` manually if Idris\n"
"      has trouble inferring the types correctly.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:821
#, no-wrap
msgid ""
"   Indexed state types can be useful when we want to make sure that\n"
"   stateful computations are combined in the correct sequence, or\n"
"   that scarce resources get cleaned up properly. We might get back\n"
"   to such use cases in later examples.\n"
msgstr ""

#. type: Title ##
#: ../src/Tutorial/Traverse.md:822
#, no-wrap
msgid "The Power of Composition"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:830
msgid ""
"After our excursion into the realms of stateful computations, we will go "
"back and combine mutable state with error accumulation to tag and read CSV "
"lines in a single traversal. We already defined `pairWithIndex` for tagging "
"lines with their indices.  We also have `uncurry $ hdecode ts` for decoding "
"single tagged lines.  We can now combine the two effects in a single "
"computation:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:831
#, no-wrap
msgid ""
"tagAndDecode :  (0 ts : List Type)\n"
"             -> CSVLine (HList ts)\n"
"             => String\n"
"             -> State Nat (Validated CSVError (HList ts))\n"
"tagAndDecode ts s = uncurry (hdecode ts) <$> pairWithIndex s\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:851
msgid ""
"Now, as we learned before, applicative functors are closed under "
"composition, and the result of `tagAndDecode` is a nesting of two "
"applicatives: `State Nat` and `Validated CSVError`.  The *Prelude* exports a "
"corresponding named interface implementation (`Prelude.Applicative."
"Compose`), which we can use for traversing a list of strings with "
"`tagAndDecode`.  Remember, that we have to provide named implementations "
"explicitly.  Since `traverse` has the applicative functor as its second "
"constraint, we also need to provide the first constraint (`Traversable`) "
"explicitly. But this is going to be the unnamed default implementation! To "
"get our hands on such a value, we can use the `%search` pragma:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:852
#, no-wrap
msgid ""
"readTable :  (0 ts : List Type)\n"
"          -> CSVLine (HList ts)\n"
"          => List String\n"
"          -> Validated CSVError (List $ HList ts)\n"
"readTable ts = evalState 1 . traverse @{%search} @{Compose} (tagAndDecode ts)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:866
msgid ""
"This tells Idris to use the default implementation for the `Traversable` "
"constraint, and `Prelude.Applicatie.Compose` for the `Applicative` "
"constraint.  While this syntax is not very nice, it doesn't come up too "
"often, and if it does, we can improve things by providing custom functions "
"for better readability:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:867
#, no-wrap
msgid ""
"traverseComp : Traversable t\n"
"             => Applicative f\n"
"             => Applicative g\n"
"             => (a -> f (g b))\n"
"             -> t a\n"
"             -> f (g (t b))\n"
"traverseComp = traverse @{%search} @{Compose}\n"
"\n"
"readTable' :  (0 ts : List Type)\n"
"           -> CSVLine (HList ts)\n"
"           => List String\n"
"           -> Validated CSVError (List $ HList ts)\n"
"readTable' ts = evalState 1 . traverseComp (tagAndDecode ts)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:885
msgid ""
"Note, how this allows us to combine two computational effects (mutable state "
"and error accumulation) in a single list traversal."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:898
msgid ""
"But I am not yet done demonstrating the power of composition. As you showed "
"in one of the exercises, `Traversable` is also closed under composition, so "
"a nesting of traversables is again a traversable. Consider the following use "
"case: When reading a CSV file, we'd like to allow lines to be annotated with "
"additional information. Such annotations could be mere comments but also "
"some formatting instructions or other custom data tags might be feasible.  "
"Annotations are supposed to be separated from the rest of the content by a "
"single hash character (`#`).  We want to keep track of these optional "
"annotations so we come up with a custom data type encapsulating this "
"distinction:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:899
#, no-wrap
msgid ""
"data Line : Type -> Type where\n"
"  Annotated : String -> a -> Line a\n"
"  Clean     : a -> Line a\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:908
msgid ""
"This is just another container type and we can easily implement "
"`Traversable` for `Line` (do this yourself as a quick exercise):"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:909
#, no-wrap
msgid ""
"Functor Line where\n"
"  map f (Annotated s x) = Annotated s $ f x\n"
"  map f (Clean x)       = Clean $ f x\n"
"\n"
"Foldable Line where\n"
"  foldr f acc (Annotated _ x) = f x acc\n"
"  foldr f acc (Clean x)       = f x acc\n"
"\n"
"Traversable Line where\n"
"  traverse f (Annotated s x) = Annotated s <$> f x\n"
"  traverse f (Clean x)       = Clean <$> f x\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:928
msgid ""
"Below is a function for parsing a line and putting it in its correct "
"category. For simplicity, we just split the line on hashes: If the result "
"consists of exactly two strings, we treat the second part as an annotation, "
"otherwise we treat the whole line as untagged CSV content."
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:929
#, no-wrap
msgid ""
"readLine : String -> Line String\n"
"readLine s = case split ('#' ==) s of\n"
"  h ::: [t] => Annotated t h\n"
"  _         => Clean s\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:938
msgid ""
"We are now going to implement a function for reading whole CSV tables, "
"keeping track of line annotations:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:939
#, no-wrap
msgid ""
"readCSV :  (0 ts : List Type)\n"
"        -> CSVLine (HList ts)\n"
"        => String\n"
"        -> Validated CSVError (List $ Line $ HList ts)\n"
"readCSV ts = evalState 1\n"
"           . traverse @{Compose} @{Compose} (tagAndDecode ts)\n"
"           . map readLine\n"
"           . lines\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:966
msgid ""
"Let's digest this monstrosity. This is written in point-free style, so we "
"have to read it from end to beginning. First, we split the whole string at "
"line breaks, getting a list of strings (function `Data.String.lines`). Next, "
"we analyze each line, keeping track of optional annotations (`map "
"readLine`).  This gives us a value of type `List (Line String)`. Since this "
"is a nesting of traversables, we invoke `traverse` with a named instance "
"from the *Prelude*: `Prelude.Traversable.Compose`.  Idris can disambiguate "
"this based on the types, so we can drop the namespace prefix. But the "
"effectful computation we run over the list of lines results in a composition "
"of applicative functors, so we also need the named implementation for "
"compositions of applicatives in the second constraint (again without need of "
"an explicit prefix, which would be `Prelude.Applicative` here).  Finally, we "
"evaluate the stateful computation with `evalState 1`."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:974
msgid ""
"Honestly, I wrote all of this without verifying if it works, so let's give "
"it a go at the REPL. I'll provide two example strings for this, a valid one "
"without errors, and an invalid one. I use *multiline string literals* here, "
"about which I'll talk in more detail in a later chapter. For the moment, "
"note that these allow us to conveniently enter string literals with line "
"breaks:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:975
#, no-wrap
msgid ""
"validInput : String\n"
"validInput = \"\"\"\n"
"  f,12,-13.01#this is a comment\n"
"  t,100,0.0017\n"
"  t,1,100.8#color: red\n"
"  f,255,0.0\n"
"  f,24,1.12e17\n"
"  \"\"\"\n"
"\n"
"invalidInput : String\n"
"invalidInput = \"\"\"\n"
"  o,12,-13.01#another comment\n"
"  t,100,0.0017\n"
"  t,1,abc\n"
"  f,256,0.0\n"
"  f,24,1.12e17\n"
"  \"\"\"\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:996
msgid "And here's how it goes at the REPL:"
msgstr "以下はREPLでの例です。"

#. type: Fenced code block (repl)
#: ../src/Tutorial/Traverse.md:997
#, no-wrap
msgid ""
"Tutorial.Traverse> readCSV [Bool,Bits8,Double] validInput\n"
"Valid [Annotated \"this is a comment\" [False, 12, -13.01],\n"
"       Clean [True, 100, 0.0017],\n"
"       Annotated \"color: red\" [True, 1, 100.8],\n"
"       Clean [False, 255, 0.0],\n"
"       Clean [False, 24, 1.12e17]]\n"
"\n"
"Tutorial.Traverse> readCSV [Bool,Bits8,Double] invalidInput\n"
"Invalid (Append (FieldError 1 1 \"o\")\n"
"  (Append (FieldError 3 3 \"abc\") (FieldError 4 2 \"256\")))\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:1015
msgid ""
"It is pretty amazing how we wrote dozens of lines of code, always being "
"guided by the type- and totality checkers, arriving eventually at a function "
"for parsing properly typed CSV tables with automatic line numbering and "
"error accumulation, all of which just worked on first try."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:1025
msgid ""
"The *Prelude* provides three additional interfaces for container types "
"parameterized over *two* type parameters such as `Either` or `Pair`: "
"`Bifunctor`, `Bifoldable`, and `Bitraversable`. In the following exercises "
"we get some hands-one experience working with these. You are supposed to "
"look up what functions they provide and how to implement and use them "
"yourself."
msgstr ""

#. type: Bullet: '1. '
#: ../src/Tutorial/Traverse.md:1029
msgid ""
"Assume we'd like to not only interpret CSV content but also the optional "
"comment tags in our CSV files.  For this, we could use a data type such as "
"`Tagged`:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:1030
#, no-wrap
msgid ""
"   data Tagged : (tag, value : Type) -> Type where\n"
"     Tag  : tag -> value -> Tagged tag value\n"
"     Pure : value -> Tagged tag value\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:1039
#, no-wrap
msgid ""
"   Implement interfaces `Functor`, `Foldable`, and `Traversable`\n"
"   but also `Bifunctor`, `Bifoldable`, and `Bitraversable`\n"
"   for `Tagged`.\n"
msgstr ""

#. type: Bullet: '2. '
#: ../src/Tutorial/Traverse.md:1045
msgid ""
"Show that the composition of a bifunctor with two functors such as `Either "
"(List a) (Maybe b)` is again a bifunctor by defining a dedicated wrapper "
"type for such compositions and writing a corresponding implementation of "
"`Bifunctor`.  Likewise for `Bifoldable`/`Foldable` and `Bitraversable`/"
"`Traversable`."
msgstr ""

#. type: Bullet: '3. '
#: ../src/Tutorial/Traverse.md:1051
msgid ""
"Show that the composition of a functor with a bifunctor such as `List "
"(Either a b)` is again a bifunctor by defining a dedicated wrapper type for "
"such compositions and writing a corresponding implementation of "
"`Bifunctor`.  Likewise for `Bifoldable`/`Foldable` and `Bitraversable`/"
"`Traversable`."
msgstr ""

#. type: Bullet: '4. '
#: ../src/Tutorial/Traverse.md:1055
msgid ""
"We are now going to adjust `readCSV` in such a way that it decodes comment "
"tags and CSV content in a single traversal.  We need a new error type to "
"include invalid tags for this:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:1056
#, no-wrap
msgid ""
"   data TagError : Type where\n"
"     CE         : CSVError -> TagError\n"
"     InvalidTag : (line : Nat) -> (tag : String) -> TagError\n"
"     Append     : TagError -> TagError -> TagError\n"
"\n"
"   Semigroup TagError where (<+>) = Append\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:1066
#, no-wrap
msgid "   For testing, we also define a simple data type for color tags:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:1067
#, no-wrap
msgid "   data Color = Red | Green | Blue\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:1076
#, no-wrap
msgid ""
"   You should now implement the following functions, but\n"
"   please note that while `readColor` will need to\n"
"   access the current line number in case of an error,\n"
"   it must *not* increase it, as otherwise line numbers\n"
"   will be wrong in the invocation of `tagAndDecodeTE`.\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:1077
#, no-wrap
msgid ""
"   readColor : String -> State Nat (Validated TagError Color)\n"
"\n"
"   readTaggedLine : String -> Tagged String String\n"
"\n"
"   tagAndDecodeTE :  (0 ts : List Type)\n"
"                  -> CSVLine (HList ts)\n"
"                  => String\n"
"                  -> State Nat (Validated TagError (HList ts))\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:1094
#, no-wrap
msgid ""
"   Finally, implement `readTagged` by using the wrapper type\n"
"   from exercise 3 as well as `readColor` and `tagAndDecodeTE`\n"
"   in a call to `bitraverse`.\n"
"   The implementation will look very similar to `readCSV` but\n"
"   with some additional wrapping and unwrapping at the right\n"
"   places.\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:1095
#, no-wrap
msgid ""
"   readTagged :  (0 ts : List Type)\n"
"              -> CSVLine (HList ts)\n"
"              => String\n"
"              -> Validated TagError (List $ Tagged Color $ HList ts)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:1103
#, no-wrap
msgid "   Test your implementation with some example strings at the REPL.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:1108
msgid ""
"You can find more examples for functor/bifunctor compositions in Haskell's "
"[bifunctors](https://hackage.haskell.org/package/bifunctors)  package."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:1117
msgid ""
"Interface `Traversable` and its main function `traverse` are incredibly "
"powerful forms of abstraction - even more so, because both `Applicative` and "
"`Traversable` are closed under composition. If you are interested in "
"additional use cases, the publication, which introduced `Traversable` to "
"Haskell, is a highly recommended read: [The Essence of the Iterator Pattern]"
"(https://www.cs.ox.ac.uk/jeremy.gibbons/publications/iterator.pdf)"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:1124
msgid ""
"The *base* library provides an extended version of the state monad in module "
"`Control.Monad.State`. We will look at this in more detail when we talk "
"about monad transformers.  Please note also, that `IO` itself is implemented "
"as a [simple state monad](IO.md#how-io-is-implemented)  over an abstract, "
"primitive state type: `%World`."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:1126
msgid "Here's a short summary of what we learned in this chapter:"
msgstr "この章で学んだことは以下です。"

#. type: Bullet: '* '
#: ../src/Tutorial/Traverse.md:1138
msgid ""
"Function `traverse` is used to run effectful computations over container "
"types without affecting their size or shape."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Traverse.md:1138
msgid ""
"We can use `IORef` as mutable references in stateful computations running in "
"`IO`."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Traverse.md:1138
msgid ""
"For referentially transparent computations with \"mutable\" state, the "
"`State` monad is extremely useful."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Traverse.md:1138
msgid ""
"Applicative functors are closed under composition, so we can run several "
"effectful computations in a single traversal."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Traverse.md:1138
msgid ""
"Traversables are also closed under composition, so we can use `traverse` to "
"operate on a nesting of containers."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:1146
msgid ""
"For now, this concludes our introduction of the *Prelude*'s higher-kinded "
"interfaces, which started with the introduction of `Functor`, `Applicative`, "
"and `Monad`, before moving on to `Foldable`, and - last but definitely not "
"least - `Traversable`.  There's one still missing - `Alternative` - but this "
"will have to wait a bit longer, because we need to first make our brains "
"smoke with some more type-level wizardry."
msgstr ""

#. type: Title #
#: ../README.md:1
#, no-wrap
msgid "Functional Programming in Idris 2"
msgstr "関数型プログラミングをIdris 2で"

#. type: Plain text
#: ../README.md:7
msgid ""
"The goal of this project is quickly explained: To become a more or less "
"comprehensive guide to the Idris programming language, with a lot of "
"introductory material targeted at newcomers to functional programming."
msgstr ""
"この企画の目標を手短かに説明すると、\n"
"関数型プログラミングの入門者を対称とした導入例をちりばめつつ、\n"
"Idrisプログラミング言語の多少なりとも網羅的な手引きとなることです。"

#. type: Plain text
#: ../README.md:15
msgid ""
"The content will be organized in several parts, with the part about the core "
"language features being the main guide to functional programming in Idris. "
"Every part consists of several chapters, each trying to cover in depth a "
"certain aspect of the Idris programming language and its core libraries. "
"Most chapters come with (sometimes lots of) exercises, with solutions "
"available in directory `src/Solutions`."
msgstr ""
"内容はいくつかの部にまとまっており、\n"
"中核となる言語の特徴についての部はIdrisでの関数型プログラミングのための手引き"
"の眼目です。\n"
"各部はいくつかの章からなり、\n"
"それぞれの章ではIdrisプログラミング言語や中核にあるライブラリの一側面を踏み込"
"んで扱います。\n"
"ほとんどの章は（しばしば多くの）演習が付録しており、\n"
"ディレクトリ`src/Solutions`から解法が見られます。"

#. type: Plain text
#: ../README.md:20
msgid ""
"Right now, even the part about core language features is not yet finished, "
"but is being actively developed and tried on several of my own students, "
"some of which are completely new to functional programming."
msgstr ""
"現状、言語中核の特徴の部分でさえまだ安定化を終えておらず、\n"
"活発に開発されているところです。\n"
"筆者の生徒にも関数型プログラミングを初めたばかりで開発しようとしている者がい"
"ます。"

#. type: Title ##
#: ../README.md:21
#, no-wrap
msgid "Table of Contents"
msgstr "目次"

#. type: Title ###
#: ../README.md:23
#, no-wrap
msgid "Part 1: Core Language Features"
msgstr "第1部：中核にある言語の特徴"

#. type: Plain text
#: ../README.md:29
msgid ""
"This part tries to give a solid introduction to the Idris programming "
"language. If you are new to functional programming, make sure to follow "
"these chapters in order and *solve all the exercises*."
msgstr ""
"この部ではIdrisプログラミング言語への導入を地道に一歩ずつ進めることを試みま"
"す。\n"
"もし関数型プログラミングが初めてであれば、必ず順番にこの部の章にしたがい、ま"
"た*全ての演習を解いてください*。"

#. type: Plain text
#: ../README.md:34
msgid ""
"If you already used other pure functional programming languages like "
"Haskell, you might go through the introductory material (Functions Part 1, "
"Algebraic Data Types, and Interfaces) pretty quickly, as most of this stuff "
"will already be familiar to you."
msgstr ""
"Haskellのような他の純粋関数型プログラミング言語を使ったことがあるなら、\n"
"導入的な内容（関数 その1、代数的データ型、インターフェース）に素早く目を通す"
"のでもよいでしょう。\n"
"ほとんどは既に馴染みのある事柄でしょうから。"

#. type: Bullet: '1. '
#: ../README.md:103
msgid "[Introduction](src/Tutorial/Intro.md)"
msgstr "[導入](src/Tutorial/Intro.md)"

#. type: Bullet: '   1. '
#: ../README.md:103
msgid ""
"[About the Idris Programming Language](src/Tutorial/Intro.md#about-the-idris-"
"programming-language)"
msgstr ""
"[プログラミング言語Idrisについて](src/Tutorial/Intro.md#about-the-idris-"
"programming-language)"

#. type: Bullet: '   2. '
#: ../README.md:103
msgid "[Using the REPL](src/Tutorial/Intro.md#using-the-repl)"
msgstr "[REPLを使う](src/Tutorial/Intro.md#using-the-repl)"

#. type: Bullet: '   3. '
#: ../README.md:103
msgid "[A First Idris Program](src/Tutorial/Intro.md#a-first-idris-program)"
msgstr "[最初のIdrisプログラム](src/Tutorial/Intro.md#a-first-idris-program)"

#. type: Bullet: '   4. '
#: ../README.md:103
msgid ""
"[The Shape of an Idris Definition](src/Tutorial/Intro.md#the-shape-of-an-"
"idris-definition)"
msgstr ""
"[Idrisの定義の形](src/Tutorial/Intro.md#the-shape-of-an-idris-definition)"

#. type: Bullet: '   5. '
#: ../README.md:103
msgid "[Where to get Help](src/Tutorial/Intro.md#where-to-get-help)"
msgstr "[困ったときは](src/Tutorial/Intro.md#where-to-get-help)"

#. type: Bullet: '2. '
#: ../README.md:103
msgid "[Functions Part 1](src/Tutorial/Functions1.md)"
msgstr "[関数 その1](src/Tutorial/Functions1.md)"

#. type: Bullet: '   1. '
#: ../README.md:103
msgid ""
"[Functions with more that one Argument](src/Tutorial/Functions1.md#functions-"
"with-more-that-one-argument)"
msgstr ""
"[1つ以上の引数を持つ関数](src/Tutorial/Functions1.md#functions-with-more-"
"that-one-argument)"

#. type: Bullet: '   2. '
#: ../README.md:103
msgid "[Function Composition](src/Tutorial/Functions1.md#function-composition)"
msgstr "[関数結合](src/Tutorial/Functions1.md#function-composition)"

#. type: Bullet: '   3. '
#: ../README.md:103
msgid ""
"[Higher-order Functions](src/Tutorial/Functions1.md#higher-order-functions)"
msgstr "[高階関数](src/Tutorial/Functions1.md#higher-order-functions)"

#. type: Bullet: '   4. '
#: ../README.md:103
msgid "[Currying](src/Tutorial/Functions1.md#currying)"
msgstr "[カリー化](src/Tutorial/Functions1.md#currying)"

#. type: Bullet: '   5. '
#: ../README.md:103
msgid "[Anonymous Functions](src/Tutorial/Functions1.md#anonymous-functions)"
msgstr "[匿名関数](src/Tutorial/Functions1.md#anonymous-functions)"

#. type: Bullet: '   6. '
#: ../README.md:103
msgid "[Operators](src/Tutorial/Functions1.md#operators)"
msgstr "[演算子](src/Tutorial/Functions1.md#operators)"

#. type: Bullet: '3. '
#: ../README.md:103
msgid "[Algebraic Data Types](src/Tutorial/DataTypes.md)"
msgstr "[代数的データ型](src/Tutorial/DataTypes.md)"

#. type: Bullet: '   1. '
#: ../README.md:103
msgid "[Enumerations](src/Tutorial/DataTypes.md#enumerations)"
msgstr "[列挙型](src/Tutorial/DataTypes.md#enumerations)"

#. type: Bullet: '   2. '
#: ../README.md:103
msgid "[Sum Types](src/Tutorial/DataTypes.md#sum-types)"
msgstr "[直和型](src/Tutorial/DataTypes.md#sum-types)"

#. type: Bullet: '   3. '
#: ../README.md:103
msgid "[Records](src/Tutorial/DataTypes.md#records)"
msgstr "[レコード](src/Tutorial/DataTypes.md#records)"

#. type: Bullet: '   4. '
#: ../README.md:103
msgid "[Generic Data Types](src/Tutorial/DataTypes.md#generic-data-types)"
msgstr "[汎化データ型](src/Tutorial/DataTypes.md#generic-data-types)"

#. type: Bullet: '   5. '
#: ../README.md:103
msgid ""
"[Alternative Syntax for Data Definitions](src/Tutorial/DataTypes."
"md#alternative-syntax-for-data-definitions)"
msgstr ""
"[データ定義の別の文法](src/Tutorial/DataTypes.md#alternative-syntax-for-data-"
"definitions)"

#. type: Bullet: '4. '
#: ../README.md:103
msgid "[Interfaces](src/Tutorial/Interfaces.md)"
msgstr "[インターフェース](src/Tutorial/Interfaces.md)"

#. type: Bullet: '   1. '
#: ../README.md:103
msgid "[Interface Basics](src/Tutorial/Interfaces.md#interface-basics)"
msgstr "[インターフェースの基本](src/Tutorial/Interfaces.md#interface-basics)"

#. type: Bullet: '   2. '
#: ../README.md:103
msgid ""
"[More about Interfaces](src/Tutorial/Interfaces.md#more-about-interfaces)"
msgstr ""
"[もっとインターフェース](src/Tutorial/Interfaces.md#more-about-interfaces)"

#. type: Bullet: '   3. '
#: ../README.md:103
msgid ""
"[Interfaces in the Prelude](src/Tutorial/Interfaces.md#interfaces-in-the-"
"prelude)"
msgstr ""
"[Preludeにあるインターフェース](src/Tutorial/Interfaces.md#interfaces-in-the-"
"prelude)"

#. type: Bullet: '5. '
#: ../README.md:103
msgid "[Functions Part 2](src/Tutorial/Functions2.md)"
msgstr "[関数 その2](src/Tutorial/Functions2.md)"

#. type: Bullet: '   1. '
#: ../README.md:103
msgid ""
"[Let Bindings and Local Definitions](src/Tutorial/Functions2.md#let-bindings-"
"and-local-definitions)"
msgstr ""
"[let束縛と局所定義](src/Tutorial/Functions2.md#let-bindings-and-local-"
"definitions)"

#. type: Bullet: '   2. '
#: ../README.md:103
msgid ""
"[The Truth about Function Arguments](src/Tutorial/Functions2.md#the-truth-"
"about-function-arguments)"
msgstr ""
"[関数引数の真実](src/Tutorial/Functions2.md#the-truth-about-function-"
"arguments)"

#. type: Bullet: '   3. '
#: ../README.md:103
msgid ""
"[Programming with Holes](src/Tutorial/Functions2.md#programming-with-holes)"
msgstr ""
"[穴開きプログラミング](src/Tutorial/Functions2.md#programming-with-holes)"

#. type: Bullet: '6. '
#: ../README.md:103
msgid "[Dependent Types](src/Tutorial/Dependent.md)"
msgstr "[依存型](src/Tutorial/Dependent.md)"

#. type: Bullet: '   1. '
#: ../README.md:103
msgid "[Length-Indexed Lists](src/Tutorial/Dependent.md#length-indexed-lists)"
msgstr "[長さ指標付きリスト](src/Tutorial/Dependent.md#length-indexed-lists)"

#. type: Bullet: '   2. '
#: ../README.md:103
msgid ""
"[Fin: Safe Indexing into Vectors](src/Tutorial/Dependent.md#fin-safe-"
"indexing-into-vectors)"
msgstr ""
"[Fin: ベクタから安全に指標で引く](src/Tutorial/Dependent.md#fin-safe-"
"indexing-into-vectors)"

#. type: Bullet: '   3. '
#: ../README.md:103
msgid ""
"[Compile-Time Computations](src/Tutorial/Dependent.md#compile-time-"
"computations)"
msgstr ""
"[コンパイル時計算](src/Tutorial/Dependent.md#compile-time-computations)"

#. type: Bullet: '7. '
#: ../README.md:103
msgid "[IO: Programming with Side Effects](src/Tutorial/IO.md)"
msgstr "[IO: 副作用のあるプログラミング](src/Tutorial/IO.md)"

#. type: Bullet: '   1. '
#: ../README.md:103
msgid "[Pure Side Effects?](src/Tutorial/IO.md#pure-side-effects)"
msgstr "[純粋な副作用？](src/Tutorial/IO.md#pure-side-effects)"

#. type: Bullet: '   2. '
#: ../README.md:103
msgid "[Do Blocks, Desugared](src/Tutorial/IO.md#do-blocks-desugared)"
msgstr "[doブロックとその脱糖](src/Tutorial/IO.md#do-blocks-desugared)"

#. type: Bullet: '   3. '
#: ../README.md:103
msgid "[Working with Files](src/Tutorial/IO.md#working-with-files)"
msgstr "[ファイルを取り回す](src/Tutorial/IO.md#working-with-files)"

#. type: Bullet: '   4. '
#: ../README.md:103
msgid "[How IO is Implemented](src/Tutorial/IO.md#how-io-is-implemented)"
msgstr "[どうIOが実装されているか](src/Tutorial/IO.md#how-io-is-implemented)"

#. type: Bullet: '8. '
#: ../README.md:103
msgid "[Functor and Friends](src/Tutorial/Functor.md)"
msgstr "[関手と仲間達](src/Tutorial/Functor.md)"

#. type: Bullet: '   1. '
#: ../README.md:103
msgid "[Functor](src/Tutorial/Functor.md#functor)"
msgstr "[関手](src/Tutorial/Functor.md#functor)"

#. type: Bullet: '   2. '
#: ../README.md:103
msgid "[Applicative](src/Tutorial/Functor.md#applicative)"
msgstr "[アプリカティブ](src/Tutorial/Functor.md#applicative)"

#. type: Bullet: '   3. '
#: ../README.md:103
msgid "[Monad](src/Tutorial/Functor.md#monad)"
msgstr "[モナド](src/Tutorial/Functor.md#monad)"

#. type: Bullet: '   4. '
#: ../README.md:103
msgid ""
"[Background and further Reading](src/Tutorial/Functor.md#background-and-"
"further-reading)"
msgstr ""
"[背景とその先へ](src/Tutorial/Functor.md#background-and-further-reading)"

#. type: Bullet: '9. '
#: ../README.md:103
msgid "[Recursion and Folds](src/Tutorial/Folds.md)"
msgstr "[再帰と畳み込み](src/Tutorial/Folds.md)"

#. type: Bullet: '   1. '
#: ../README.md:103
msgid "[Recursion](src/Tutorial/Folds.md#recursion)"
msgstr "[再帰](src/Tutorial/Folds.md#recursion)"

#. type: Bullet: '   2. '
#: ../README.md:103
msgid ""
"[A few Notes on Totality Checking](src/Tutorial/Folds.md#a-few-notes-on-"
"totality-checking)"
msgstr ""
"[全域性検査についての注意](src/Tutorial/Folds.md#a-few-notes-on-totality-"
"checking)"

#. type: Bullet: '   3. '
#: ../README.md:103
msgid "[Interface Foldable](src/Tutorial/Folds.md#interface-foldable)"
msgstr "[Foldableインターフェース](src/Tutorial/Folds.md#interface-foldable)"

#. type: Bullet: '10. '
#: ../README.md:103
msgid "[Effectful Traversals](src/Tutorial/Traverse.md)"
msgstr "[作用付き巡回](src/Tutorial/Traverse.md)"

#. type: Bullet: '    1. '
#: ../README.md:103
msgid "[Reading CSV Tables](src/Tutorial/Traverse.md#reading-csv-tables)"
msgstr "[CSVの表を読む](src/Tutorial/Traverse.md#reading-csv-tables)"

#. type: Bullet: '    2. '
#: ../README.md:103
msgid ""
"[Programming with State](src/Tutorial/Traverse.md#programming-with-state)"
msgstr ""
"[状態付きプログラミング](src/Tutorial/Traverse.md#programming-with-state)"

#. type: Bullet: '    3. '
#: ../README.md:103
msgid ""
"[The Power of Composition](src/Tutorial/Traverse.md#the-power-of-composition)"
msgstr "[組み立ての強力さ](src/Tutorial/Traverse.md#the-power-of-composition)"

#. type: Bullet: '11. '
#: ../README.md:103
msgid "[Sigma Types](src/Tutorial/DPair.md)"
msgstr "[シグマ型](src/Tutorial/DPair.md)"

#. type: Bullet: '    1. '
#: ../README.md:103
msgid "[Dependent Pairs](src/Tutorial/DPair.md#dependent-pairs)"
msgstr "[依存対](src/Tutorial/DPair.md#dependent-pairs)"

#. type: Bullet: '    2. '
#: ../README.md:103
msgid "[Use Case: Nucleic Acids](src/Tutorial/DPair.md#use-case-nucleic-acids)"
msgstr "[用例：核酸](src/Tutorial/DPair.md#use-case-nucleic-acids)"

#. type: Bullet: '    3. '
#: ../README.md:103
msgid ""
"[Use Case: CSV Files with a Schema](src/Tutorial/DPair.md#use-case-csv-files-"
"with-a-schema)"
msgstr ""
"[用例：スキーマに基づくCSVファイル](src/Tutorial/DPair.md#use-case-csv-files-"
"with-a-schema)"

#. type: Bullet: '12. '
#: ../README.md:103
msgid "[Propositional Equality](src/Tutorial/Eq.md)"
msgstr "[命題の等値性](src/Tutorial/Eq.md)"

#. type: Bullet: '    1. '
#: ../README.md:103
msgid "[Equality as a Type](src/Tutorial/Eq.md#equality-as-a-type)"
msgstr "[型としての等値性](src/Tutorial/Eq.md#equality-as-a-type)"

#. type: Bullet: '    2. '
#: ../README.md:103
msgid "[Programs as Proofs](src/Tutorial/Eq.md#programs-as-proofs)"
msgstr "[証明としてのプログラム](src/Tutorial/Eq.md#programs-as-proofs)"

#. type: Bullet: '    3. '
#: ../README.md:103
msgid "[Into the Void](src/Tutorial/Eq.md#into-the-void)"
msgstr "[Voidへ](src/Tutorial/Eq.md#into-the-void)"

#. type: Bullet: '    4. '
#: ../README.md:103
msgid "[Rewrite Rules](src/Tutorial/Eq.md#rewrite-rules)"
msgstr "[規則を書き換える](src/Tutorial/Eq.md#rewrite-rules)"

#. type: Bullet: '13. '
#: ../README.md:103
msgid "[Predicates and Proof Search](src/Tutorial/Predicates.md)"
msgstr "[前提と証明検索](src/Tutorial/Predicates.md)"

#. type: Bullet: '    1. '
#: ../README.md:103
msgid "[Preconditions](src/Tutorial/Predicates.md#preconditions)"
msgstr "[前提条件](src/Tutorial/Predicates.md#preconditions)"

#. type: Bullet: '    2. '
#: ../README.md:103
msgid ""
"[Contracts between Values](src/Tutorial/Predicates.md#contracts-between-"
"values)"
msgstr "[値同士の契約](src/Tutorial/Predicates.md#contracts-between-values)"

#. type: Bullet: '    3. '
#: ../README.md:103
msgid ""
"[Use Case: Flexible Error Handling](src/Tutorial/Predicates.md#use-case-"
"flexible-error-handling)"
msgstr ""
"[用例：柔軟なエラー制御](src/Tutorial/Predicates.md#use-case-flexible-error-"
"handling)"

#. type: Bullet: '    4. '
#: ../README.md:103
msgid ""
"[The Truth about Interfaces](src/Tutorial/Predicates.md#the-truth-about-"
"interfaces)"
msgstr ""
"[インターフェースの真実](src/Tutorial/Predicates.md#the-truth-about-"
"interfaces)"

#. type: Bullet: '14. '
#: ../README.md:103
msgid "[Primitives](src/Tutorial/Prim.md)"
msgstr "[原始型](src/Tutorial/Prim.md)"

#. type: Bullet: '    1. '
#: ../README.md:103
msgid ""
"[How Primitives are Implemented](src/Tutorial/Prim.md#how-primitives-are-"
"implemented)"
msgstr ""
"[どのように原始型が実装されているか](src/Tutorial/Prim.md#how-primitives-are-"
"implemented)"

#. type: Bullet: '    2. '
#: ../README.md:103
msgid "[Working with Strings](src/Tutorial/Prim.md#working-with-strings)"
msgstr "[文字列を取り回す](src/Tutorial/Prim.md#working-with-strings)"

#. type: Bullet: '    3. '
#: ../README.md:103
msgid "[Integers](src/Tutorial/Prim.md#integers)"
msgstr "[整数](src/Tutorial/Prim.md#integers)"

#. type: Bullet: '    4. '
#: ../README.md:103
msgid "[Refined Primitives](src/Tutorial/Prim.md#refined-primitives)"
msgstr "[精錬後の原始型](src/Tutorial/Prim.md#refined-primitives)"

#. type: Title ###
#: ../README.md:104
#, no-wrap
msgid "Part 2: Appendices"
msgstr "第2部：補遺"

#. type: Plain text
#: ../README.md:110
msgid ""
"The appendices can be used as references for the topics at hand. I plan to "
"eventually have a concise reference on Idris syntax, typical error messages, "
"the module system, interactive editing and possibly others."
msgstr ""
"補遺は卑近な話題の参考書として使えます。\n"
"最終的には、Idrisの文法、典型的なエラー文言、モジュールシステム、対話的編集な"
"どについての簡潔な参考情報にしようと模索しています。"

#. type: Bullet: '1. '
#: ../README.md:112
msgid "[Interactive Editing in Neovim](src/Appendices/Neovim.md)"
msgstr "[Neovimでの対話的編集](src/Appendices/Neovim.md)"

#. type: Title ##
#: ../README.md:113
#, no-wrap
msgid "Prerequisites"
msgstr "予め必要なもの"

#. type: Plain text
#: ../README.md:119
msgid ""
"At the moment, this project is being actively developed and evolved against "
"the main branch of the Idris 2 repository.  It is being tested nightly on "
"GitHub and built against the latest commit of the Idris 2 main branch as "
"well as the Idris 2 commit listed in file `.idris-version`."
msgstr ""
"現時点でこの企画は活発に開発中で、\n"
"Idris 2リポジトリのmainブランチとともに進展し続けています。\n"
"GitHubでnightlyにテストされており、\n"
"Idris 2のmainブランチの最新コミットとファイル`.idris-version`にあるIdris 2の"
"コミット時点でビルドしています。"

#, no-wrap
#~ msgid ""
#~ "   zipWith3 : (a -> b -> c -> d) -> Vect n a -> Vect n b -> Vect n c -> Vect n d\n"
#~ "\n"
#~ "4. Declare and implement a function `foldSemi`\n"
#~ "   for accumulating the values stored\n"
#~ "   in a `List` through `Semigroup`s append operator (`(<+>)`).\n"
#~ "   (Make sure to only use a `Semigroup` constraint, as opposed to\n"
#~ "   a `Monoid` constraint.)\n"
#~ "\n"
#~ "5. Do the same as in Exercise 4, but for non-empty vectors. How\n"
#~ "   does a vector's non-emptiness affect the output type?\n"
#~ "\n"
#~ "6. Given an initial value of type `a` and a function `a -> a`,\n"
#~ "   we'd like to generate `Vect`s of `a`s, the first value of\n"
#~ "   which is `a`, the second value being `f a`, the third\n"
#~ "   being `f (f a)` and so on.\n"
#~ "\n"
#~ "   For instance, if `a` is 1 and `f` is `(* 2)`, we'd like\n"
#~ "   to get results similar to the following: `[1,2,4,8,16,...]`.\n"
#~ "\n"
#~ "   Declare and implement function `iterate`, which should\n"
#~ "   encapsulate this behavior. Get some inspiration from `replicate`\n"
#~ "   if you don't know where to start.\n"
#~ "\n"
#~ "7. Given an initial value of a state type `s` and\n"
#~ "   a function `fun : s -> (s,a)`,\n"
#~ "   we'd like to generate `Vect`s of `a`s. Declare and implement\n"
#~ "   function `generate`, which should encapsulate this behavior. Make sure to use\n"
#~ "   the updated state in every new invocation of `fun`.\n"
#~ "\n"
#~ "   Here's an example how this can be used to generate the first\n"
#~ "   `n` Fibonacci numbers:\n"
#~ "\n"
#~ "   ```repl\n"
#~ "   generate 10 (\\(x,y) => let z = x + y in ((y,z),z)) (0,1)\n"
#~ "   [1, 2, 3, 5, 8, 13, 21, 34, 55, 89]\n"
#~ msgstr ""
#~ "   zipWith3 : (a -> b -> c -> d) -> Vect n a -> Vect n b -> Vect n c -> Vect n d\n"
#~ "\n"
#~ "4. `List`に格納された値を`Semigroup`の結合演算子 (`<+>`) を用いて積み重ねる関数`foldSemi`を宣言し実装してください。\n"
#~ "   （必ず`Semigroup`制約のみを使ってください。`Monoid`制約ではないですよ。）\n"
#~ "\n"
#~ "5. 演習4と同じことを非空のベクタについて行ってください。\n"
#~ "   ベクタが非空であることで出力型にどう影響するでしょうか。\n"
#~ "\n"
#~ "6. 型`a`の初期値と関数`a -> a`が与えられているとき、\n"
#~ "   `a`の`Vect`を生成したいとします。\n"
#~ "   最初の値は`a`、2つ目の値は`f a`、3つ目の値は`f (f a)`、などなど、といった感じです。\n"
#~ "\n"
#~ "   例えば`a`が1で`f`が`(* 2)`のとき、\n"
#~ "   次のような結果が得られます。\n"
#~ "   `[1,2,4,8,16,...]`\n"
#~ "\n"
#~ "   この振舞いを内蔵化する関数`iterate`を宣言し実装してください。\n"
#~ "   どこから手を付ければよいか分からなかったら`replicate`から着想が得られます。\n"
#~ "\n"
#~ "7. 状態型`s`の初期値と関数`fun : s -> (s,a)`が与えられているとき、\n"
#~ "   `a`の`Vect`を生成したいとします。\n"
#~ "   この振舞いを内蔵化する関数`generate`を宣言し実装してください。\n"
#~ "   `fun`を呼び出すときはいつも更新された状態を使うことに気を付けてください。\n"
#~ "\n"
#~ "   これを使って最初から`n`個までのフィボナッチ数を生成する例がこちらです。\n"
#~ "\n"
#~ "   ```repl\n"
#~ "   generate 10 (\\(x,y) => let z = x + y in ((y,z),z)) (0,1)\n"
#~ "   [1, 2, 3, 5, 8, 13, 21, 34, 55, 89]\n"
