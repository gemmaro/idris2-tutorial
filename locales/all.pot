# SOME DESCRIPTIVE TITLE
# Copyright (C) YEAR Free Software Foundation, Inc.
# This file is distributed under the same license as the PACKAGE package.
# FIRST AUTHOR <EMAIL@ADDRESS>, YEAR.
#
#, fuzzy
msgid ""
msgstr ""
"Project-Id-Version: PACKAGE VERSION\n"
"POT-Creation-Date: 2022-08-15 20:56+0900\n"
"PO-Revision-Date: YEAR-MO-DA HO:MI+ZONE\n"
"Last-Translator: FULL NAME <EMAIL@ADDRESS>\n"
"Language-Team: LANGUAGE <LL@li.org>\n"
"Language: en\n"
"MIME-Version: 1.0\n"
"Content-Type: text/plain; charset=UTF-8\n"
"Content-Transfer-Encoding: 8bit\n"

#. type: Title #
#: ../src/Appendices/Neovim.md:1
#, markdown-text, no-wrap
msgid "Interactive Editing in Neovim"
msgstr ""

#. type: Plain text
#: ../src/Appendices/Neovim.md:10
#, markdown-text
msgid ""
"Idris provides extensive capabilities to interactively analyze the types of "
"values and expressions in our programs and fill out skeleton implementations "
"and sometimes even whole programs for us based on the types provided. These "
"interactive editing features are available via plugins in different "
"editors.  Since I am a Neovim user, I explain the Idris related parts of my "
"own setup in detail here."
msgstr ""

#. type: Plain text
#: ../src/Appendices/Neovim.md:20
#, markdown-text
msgid ""
"The main component required to get all these features to run in Neovim is an "
"executable provided by the "
"[idris2-lsp](https://github.com/idris-community/idris2-lsp) project.  This "
"executable makes use of the Idris compiler API (application programming "
"interface) internally and can check the syntax and types of the source code "
"we are working on. It communicates with Neovim via the language server "
"protocol (LSP). This communication is setup through the "
"[idris2-nvim](https://github.com/ShinKage/idris2-nvim)  plugin."
msgstr ""

#. type: Plain text
#: ../src/Appendices/Neovim.md:31
#, markdown-text
msgid ""
"As we will see in this tutorial, the `idris2-lsp` executable not only "
"supports syntax and type checking, but comes also with additional "
"interactive editing features. Finally, the Idris compiler API supports "
"semantic highlighting of Idris source code: Identifiers and keywords are "
"highlighted not only based on the language's syntax (that would be *syntax "
"highlighting*, a feature expected from all modern programming environments "
"and editors), but also based on their *semantics*. For instance, a local "
"variable in a function implementation gets highlighted differently than the "
"name of a top level function, although syntactically these are both just "
"identifiers."
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Appendices/Neovim.md:32
#, no-wrap
msgid ""
"module Appendices.Neovim\n"
"\n"
"import Data.Vect\n"
"\n"
"%default total\n"
msgstr ""

#. type: Title ##
#: ../src/Appendices/Neovim.md:40
#, markdown-text, no-wrap
msgid "Setup"
msgstr ""

#. type: Plain text
#: ../src/Appendices/Neovim.md:44
#, markdown-text
msgid ""
"In order to make full use of interactive Idris editing in Neovim, at least "
"the following tools need to be installed:"
msgstr ""

#. type: Bullet: '* '
#: ../src/Appendices/Neovim.md:52
#, markdown-text
msgid "A recent version of Neovim (version 0.5 or later)."
msgstr ""

#. type: Bullet: '* '
#: ../src/Appendices/Neovim.md:52
#, markdown-text
msgid "A recent version of the Idris compiler (at least version 0.5.1)."
msgstr ""

#. type: Bullet: '* '
#: ../src/Appendices/Neovim.md:52
#, markdown-text
msgid "The Idris compiler API."
msgstr ""

#. type: Bullet: '* '
#: ../src/Appendices/Neovim.md:52
#, markdown-text
msgid "The [idris2-lsp](https://github.com/idris-community/idris2-lsp) package."
msgstr ""

#. type: Bullet: '* '
#: ../src/Appendices/Neovim.md:52
#, markdown-text
msgid "The following Neovim plugins:"
msgstr ""

#. type: Bullet: '  * '
#: ../src/Appendices/Neovim.md:52
#, markdown-text
msgid "[idris2-nvim](https://github.com/ShinKage/idris2-nvim)"
msgstr ""

#. type: Bullet: '  * '
#: ../src/Appendices/Neovim.md:52
#, markdown-text
msgid "[nvim-lspconfig](https://github.com/neovim/nvim-lspconfig)"
msgstr ""

#. type: Plain text
#: ../src/Appendices/Neovim.md:57
#, markdown-text
msgid ""
"The `idris2-lsp` project gives detailed instructions about how to install "
"Idris 2 together with its standard libraries and compiler API. Make sure to "
"follow these instructions so that your compiler and `idris2-lsp` executable "
"are in sync."
msgstr ""

#. type: Plain text
#: ../src/Appendices/Neovim.md:67
#, markdown-text
msgid ""
"If you are new to Neovim, you might want to use the `init.vim` file provided "
"in the `resources` folder. In that case, the necessary Neovim plugins are "
"already included, but you need to install "
"[vim-plug](https://github.com/junegunn/vim-plug), a plugin manager.  "
"Afterwards, copy all or parts of `resources/init.vim` to your own `init.vim` "
"file. (Use `:help init.vim` from within Neovim in order to find out where to "
"look for this file.). After setting up your `init.vim` file, restart Neovim "
"and run `:PlugUpdate` to install the necessary plugins."
msgstr ""

#. type: Title ##
#: ../src/Appendices/Neovim.md:68
#, markdown-text, no-wrap
msgid "A Typical Workflow"
msgstr ""

#. type: Plain text
#: ../src/Appendices/Neovim.md:77
#, markdown-text
msgid ""
"In order to checkout the interactive editing features available to us, we "
"will reimplement some small utilities from the *Prelude*. To follow along, "
"you should have already worked through the "
"[Introduction](../Tutorial/Intro.md), [Functions Part "
"1](../Tutorial/Functions1.md), and at least parts of [Algebraic Data "
"Types](../Tutorial/DataTypes.md), otherwise it will be hard to understand "
"what's going on here."
msgstr ""

#. type: Plain text
#: ../src/Appendices/Neovim.md:83
#, markdown-text
msgid ""
"Before we begin, note that the commands and actions shown in this tutorial "
"might not work correctly after you edited a source file but did not write "
"your changes to disk. Therefore, the first thing you should try if the "
"things described here do not work, is to quickly save the current file "
"(`:w`)."
msgstr ""

#. type: Plain text
#: ../src/Appendices/Neovim.md:85
#, markdown-text
msgid "Let's start with negation of a boolean value:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Appendices/Neovim.md:86
#, no-wrap
msgid "negate1 : Bool -> Bool\n"
msgstr ""

#. type: Plain text
#: ../src/Appendices/Neovim.md:102
#, markdown-text
msgid ""
"Typically, when writing Idris code we follow the mantra \"types "
"first\". Although you might already have an idea about how to implement a "
"certain piece of functionality, you still need to provide an accurate type "
"before you can start writing your implementation. This means, when "
"programming in Idris, we have to mentally keep track of the implementation "
"of an algorithm and the types involved at the same time, both of which can "
"become arbitrarily complex. Or do we? Remember that Idris knows at least as "
"much about the variables and their types available in the current context of "
"a function implementation as we do, so we probably should ask it for "
"guidance instead of trying to do everything on our own."
msgstr ""

#. type: Plain text
#: ../src/Appendices/Neovim.md:112
#, markdown-text, no-wrap
msgid ""
"So, in order to proceed, we ask Idris for a skeleton function\n"
"body: In normal editor mode, move your cursor on the line where\n"
"`negate1` is declared and enter `<LocalLeader>a` in quick\n"
"succession. `<LocalLeader>` is a special key that can be specified\n"
"in the `init.vim` file. If you\n"
"use the `init.vim` from the `resources` folder, it is set to\n"
"the comma character (`,`), in which case the above command\n"
"consists of a comma quickly followed by the lowercase letter \"a\".\n"
"See also `:help leader` and `:help localleader` in Neovim\n"
msgstr ""

#. type: Plain text
#: ../src/Appendices/Neovim.md:115
#, markdown-text
msgid "Idris will generate a skeleton implementation similar to the following:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Appendices/Neovim.md:116
#, no-wrap
msgid ""
"negate2 : Bool -> Bool\n"
"negate2 x = ?negate2_rhs\n"
msgstr ""

#. type: Plain text
#: ../src/Appendices/Neovim.md:139
#, markdown-text, no-wrap
msgid ""
"Note, that on the left hand side a new variable with name\n"
"`x` was introduced, while on the right hand side Idris\n"
"added a *metavariable* (also called a *hole*). This is an\n"
"identifier prefixed with a question mark. It signals to Idris,\n"
"that we will implement this part of the function at a later time.\n"
"The great thing about holes is, that we can *hover* over them\n"
"and inspect their types and the types of values in the\n"
"surrounding context. You can do so by placing the cursor\n"
"on the identifier of a hole and entering `K` (the uppercase letter) in\n"
"normal mode. This will open a popup displaying the type of\n"
"the variable under the cursor plus the types and quantities of the "
"variables\n"
"in the surrounding context. You can also have this information\n"
"displayed in a separate window: Enter `<LocalLeader>so` to\n"
"open this window and repeat the hovering. The information will\n"
"appear in the new window and as an additional benefit, it will\n"
"be semantically highlighted. Enter `<LocalLeader>sc` to close\n"
"this window again. Go ahead and checkout the type and\n"
"context of `?negate2_rhs`.\n"
msgstr ""

#. type: Plain text
#: ../src/Appendices/Neovim.md:148
#, markdown-text, no-wrap
msgid ""
"Most functions in Idris are implemented by pattern matching\n"
"on one or more of the arguments. Idris,\n"
"knowing the data constructors of all non-primitive data types,\n"
"can write such pattern matches for us (a process also called\n"
"*case splitting*). To give this a try, move the cursor onto the `x`\n"
"in the skeleton implementation of `negate2`, and enter\n"
"`<LocalLeader>c` in normal mode. The result will look as\n"
"follows:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Appendices/Neovim.md:149
#, no-wrap
msgid ""
"negate3 : Bool -> Bool\n"
"negate3 False = ?negate3_rhs_0\n"
"negate3 True = ?negate3_rhs_1\n"
msgstr ""

#. type: Plain text
#: ../src/Appendices/Neovim.md:158
#, markdown-text
msgid ""
"As you can see, Idris inserted a hole for each of the cases on the right "
"hand side. We can again inspect their types or replace them with a proper "
"implementation directly."
msgstr ""

#. type: Plain text
#: ../src/Appendices/Neovim.md:164
#, markdown-text
msgid ""
"This concludes the introduction of the (in my opinion) core features of "
"interactive editing: Hovering on metavariables, adding skeleton function "
"implementations, and case splitting (which also works in case blocks and for "
"nested pattern matches). You should start using these all the time *now*!"
msgstr ""

#. type: Title ##
#: ../src/Appendices/Neovim.md:165
#, markdown-text, no-wrap
msgid "Expression Search"
msgstr ""

#. type: Plain text
#: ../src/Appendices/Neovim.md:173
#, markdown-text
msgid ""
"Sometimes, Idris knows enough about the types involved to come up with a "
"function implementation on its own. For instance, let us implement function "
"`either` from the *Prelude*.  After giving its type, creating a skeleton "
"implementation, and case splitting on the `Either` argument, we arrive at "
"something similar to the following:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Appendices/Neovim.md:174
#, no-wrap
msgid ""
"either2 : (a -> c) -> (b -> c) -> Either a b -> c\n"
"either2 f g (Left x) = ?either2_rhs_0\n"
"either2 f g (Right x) = ?either2_rhs_1\n"
msgstr ""

#. type: Plain text
#: ../src/Appendices/Neovim.md:186
#, markdown-text, no-wrap
msgid ""
"Idris can come up with expressions for the two metavariables\n"
"on its own, because the types are specific enough. Move\n"
"the cursor onto one of the metavariables and enter\n"
"`<LocalLeader>o` in normal mode. You will be given\n"
"a selection of possible expressions (only one in this case),\n"
"of which you can choose a fitting one (or abort with `q`).\n"
msgstr ""

#. type: Plain text
#: ../src/Appendices/Neovim.md:190
#, markdown-text
msgid ""
"Here is another example: A reimplementation of function `maybe`.  If you run "
"an expression search on `?maybe2_rhs1`, you will get a larger list of "
"choices."
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Appendices/Neovim.md:191
#, no-wrap
msgid ""
"maybe2 : b -> (a -> b) -> Maybe a -> b\n"
"maybe2 x f Nothing = x\n"
"maybe2 x f (Just y) = ?maybe2_rhs_1\n"
msgstr ""

#. type: Plain text
#: ../src/Appendices/Neovim.md:208
#, markdown-text, no-wrap
msgid ""
"Idris is also sometimes capable of coming up with complete function\n"
"implementations based on a function's type. For this to work well\n"
"in practice, the number of possible implementations satisfying\n"
"the type checker must be pretty small. As an example, here is\n"
"function `zipWith` for vectors. You might not have heard\n"
"about vectors yet: They will be introduced in the chapter about\n"
"[dependent types](../Tutorial/Dependent.md). You can still give\n"
"this a go to check out its effect. Just move the cursor on the\n"
"line declaring `zipWithV`, enter `<LocalLeader>gd` and select the first "
"option.\n"
"This will automatically generate the whole function body including\n"
"case splits and implementations.\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Appendices/Neovim.md:209
#, no-wrap
msgid "zipWithV : (a -> b -> c) -> Vect n a -> Vect n b -> Vect n c\n"
msgstr ""

#. type: Plain text
#: ../src/Appendices/Neovim.md:218
#, markdown-text, no-wrap
msgid ""
"Expression search only works well if the types are specific\n"
"enough. If you feel like that might be the case, go ahead\n"
"and give it a go, either by running `<LocalLeader>o` on\n"
"a metavariable, or by trying `<LocalLeader>gd` on a\n"
"function declaration.\n"
msgstr ""

#. type: Title ##
#: ../src/Appendices/Neovim.md:219
#, markdown-text, no-wrap
msgid "More Code Actions"
msgstr ""

#. type: Plain text
#: ../src/Appendices/Neovim.md:223
#, markdown-text
msgid ""
"There are other shortcuts available for generating part of your code, two of "
"which I'll explain here."
msgstr ""

#. type: Plain text
#: ../src/Appendices/Neovim.md:231
#, markdown-text, no-wrap
msgid ""
"First, it is possible to add a new case block by entering\n"
"`<LocalLeader>mc` in normal mode when on a metavariable.\n"
"For instance, here is part of an implementation of `filterList`,\n"
"which appears in an exercise in the chapter about\n"
"algebraic data types. I arrived at this by letting Idris\n"
"generate a skeleton implementation followed by a case split\n"
"and an expression search on the first metavariable:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Appendices/Neovim.md:232
#, no-wrap
msgid ""
"filterList : (a -> Bool) -> List a -> List a\n"
"filterList f [] = []\n"
"filterList f (x :: xs) = ?filterList_rhs_1\n"
msgstr ""

#. type: Plain text
#: ../src/Appendices/Neovim.md:247
#, markdown-text, no-wrap
msgid ""
"We will next have to pattern match on the result of applying\n"
"`x` to `f`. Idris can introduce a new case block for us,\n"
"if we move the cursor onto metavariable `?filterList_rhs_1`\n"
"and enter `<LocalLeader>mc` in normal mode. We can then\n"
"continue with our implementation by first giving the\n"
"expression to use in the case block (`f x`) followed by a\n"
"case split on the new variable in the case block.\n"
"This will lead us to an implementation similar to the following\n"
"(I had to fix the indentation, though):\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Appendices/Neovim.md:248
#, no-wrap
msgid ""
"filterList2 : (a -> Bool) -> List a -> List a\n"
"filterList2 f [] = []\n"
"filterList2 f (x :: xs) = case f x of\n"
"  False => ?filterList2_rhs_2\n"
"  True => ?filterList2_rhs_3\n"
msgstr ""

#. type: Plain text
#: ../src/Appendices/Neovim.md:266
#, markdown-text, no-wrap
msgid ""
"Sometimes, we want to extract a utility function from\n"
"an implementation we are working on. For instance, this is often\n"
"useful or even necessary when we write proofs about our code\n"
"(see chapters [Propositional Equality](../Tutorial/Eq.md)\n"
"and [Predicates](../Tutorial/Predicates.md), for instance).\n"
"In order to do so, we can move the cursor on a metavariable,\n"
"and enter `<LocalLeader>ml`. Give this a try with\n"
"`?whatNow` in the following example (this will work better\n"
"in a regular Idris source file instead of the literate\n"
"file I use for this tutorial):\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Appendices/Neovim.md:267
#, no-wrap
msgid ""
"traverseEither : (a -> Either e b) -> List a -> Either e (List b)\n"
"traverseEither f [] = Right []\n"
"traverseEither f (x :: xs) = ?whatNow x xs f (f x) (traverseEither f xs)\n"
msgstr ""

#. type: Plain text
#: ../src/Appendices/Neovim.md:279
#, markdown-text
msgid ""
"Idris will create a new function declaration with the type and name of "
"`?whatNow`, which takes as arguments all variables currently in scope. It "
"also replaces the hole in `traverseEither` with a call to this new "
"function. Typically, you will have to manually remove unneeded arguments "
"afterwards. This led me to the following version:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Appendices/Neovim.md:280
#, no-wrap
msgid ""
"whatNow2 : Either e b -> Either e (List b) -> Either e (List b)\n"
"\n"
"traverseEither2 : (a -> Either e b) -> List a -> Either e (List b)\n"
"traverseEither2 f [] = Right []\n"
"traverseEither2 f (x :: xs) = whatNow2 (f x) (traverseEither f xs)\n"
msgstr ""

#. type: Title ##
#: ../src/Appendices/Neovim.md:288
#, markdown-text, no-wrap
msgid "Getting Information"
msgstr ""

#. type: Plain text
#: ../src/Appendices/Neovim.md:294
#, markdown-text
msgid ""
"The `idris2-lsp` executable and through it, the `idris2-nvim` plugin, not "
"only supports the code actions described above. Here is a non-comprehensive "
"list of other capabilities. I suggest you try out each of them from within "
"this source file."
msgstr ""

#. type: Bullet: '* '
#: ../src/Appendices/Neovim.md:329
#, markdown-text
msgid ""
"Typing `K` when on an identifier or operator in normal mode shows its type "
"and namespace (if any). In case of a metavariable, variables in the current "
"context are displayed as well together with their types and quantities "
"(quantities will be explained in [Functions Part "
"2](../Tutorial/Functions2.md)).  If you don't like popups, enter "
"`<LocalLeader>so` to open a new window where this information is displayed "
"and semantically highlighted instead."
msgstr ""

#. type: Bullet: '* '
#: ../src/Appendices/Neovim.md:329
#, markdown-text
msgid ""
"Typing `gd` on a function, operator, data constructor or type constructor in "
"normal mode jumps to the item's definition.  For external modules, this "
"works only if the module in question has been installed together with its "
"source code (by using the `idris2 --install-with-src` command)."
msgstr ""

#. type: Bullet: '* '
#: ../src/Appendices/Neovim.md:329
#, markdown-text
msgid ""
"Typing `<LocalLeader>mm` opens a popup window listing all metavariables in "
"the current module. You can place the cursor on an entry and jump to its "
"location by pressing `<Enter>`."
msgstr ""

#. type: Bullet: '* '
#: ../src/Appendices/Neovim.md:329
#, markdown-text
msgid ""
"Typing `<LocalLeader>mn` (or `<LocalLeader>mp`) jumps to the next (or "
"previous) metavariable in the current module."
msgstr ""

#. type: Bullet: '* '
#: ../src/Appendices/Neovim.md:329
#, markdown-text
msgid ""
"Typing `<LocalLeader>br` opens a popup where you can enter a "
"namespace. Idris will then show all functions (plus their types)  exported "
"from that namespace in a popup window, and you can jump to a function's "
"definition by pressing enter on one of the entries. Note: The module in "
"question must be imported in the current source file."
msgstr ""

#. type: Bullet: '* '
#: ../src/Appendices/Neovim.md:329
#, markdown-text
msgid ""
"Typing `<LocalLeader>x` opens a popup where you can enter a REPL command or "
"Idris expression, and the plugin will reply with a response from the "
"REPL. Whenever REPL examples are shown in the main part of this guide, you "
"can try them from within Neovim with this shortcut if you like."
msgstr ""

#. type: Bullet: '* '
#: ../src/Appendices/Neovim.md:329
#, markdown-text
msgid ""
"Typing `<LocalLeader><LocalLeader>e` will display the error message from the "
"current line in a popup window. This can be highly useful, if error messages "
"are too long to fit on a single line. Likewise, "
"`<LocalLeader><LocalLeader>el` will list all error messages from the current "
"buffer in a new window. You can then select an error message and jump to its "
"origin by pressing `<Enter>`."
msgstr ""

#. type: Plain text
#: ../src/Appendices/Neovim.md:332
#, markdown-text
msgid ""
"Other use cases and examples are described on the GitHub page of the "
"`idris2-nvim` plugin and can be included as described there."
msgstr ""

#. type: Title ##
#: ../src/Appendices/Neovim.md:333
#, markdown-text, no-wrap
msgid "The `%name` Pragma"
msgstr ""

#. type: Plain text
#: ../src/Appendices/Neovim.md:345
#, markdown-text, no-wrap
msgid ""
"When you ask Idris for a skeleton implementation with `<LocalLeader>a`\n"
"or a case split with `<LocalLeader>c`,\n"
"it has to decide on what names to use for the new variables it introduces.\n"
"If these variables already have predefined names (from the function's\n"
"signature, record fields, or named data constructor arguments),\n"
"those names will be used, but\n"
"otherwise Idris will as a default use names `x`, `y`, and `z`, followed\n"
"by other letters. You can change this default behavior by\n"
"specifying a list of names to use for such occasions for any\n"
"data type.\n"
msgstr ""

#. type: Plain text
#: ../src/Appendices/Neovim.md:347
#, markdown-text
msgid "For instance:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Appendices/Neovim.md:348
#, no-wrap
msgid ""
"data Element = H | He | C | N | O | F | Ne\n"
"\n"
"%name Element e,f\n"
msgstr ""

#. type: Plain text
#: ../src/Appendices/Neovim.md:358
#, markdown-text
msgid ""
"Idris will then use these names (followed by these names postfixed with "
"increasing integers), when it has to come up with variable names of this "
"type on its own. For instance, here is a test function and the result of "
"adding a skeleton definition to it:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Appendices/Neovim.md:359
#, no-wrap
msgid ""
"test : Element -> Element -> Element -> Element -> Element -> Element\n"
"test e f e1 f1 e2 = ?test_rhs\n"
msgstr ""

#. type: Title ##
#: ../src/Appendices/Neovim.md:364 ../src/Tutorial/DPair.md:1191
#: ../src/Tutorial/DataTypes.md:1319 ../src/Tutorial/Dependent.md:872
#: ../src/Tutorial/Eq.md:1085 ../src/Tutorial/Folds.md:1051
#: ../src/Tutorial/Functions1.md:524 ../src/Tutorial/Functions2.md:924
#: ../src/Tutorial/Functor.md:1395 ../src/Tutorial/IO.md:1095
#: ../src/Tutorial/Interfaces.md:792 ../src/Tutorial/Predicates.md:1358
#: ../src/Tutorial/Traverse.md:1109
#, markdown-text, no-wrap
msgid "Conclusion"
msgstr ""

#. type: Plain text
#: ../src/Appendices/Neovim.md:372
#, markdown-text
msgid ""
"Neovim, together with the `idris2-lsp` executable and the `idris2-nvim` "
"editor plugin, provides extensive utilities for interactive editing when "
"programming in Idris. Similar functionality is available for some other "
"editors, so feel free to ask what's available for your editor of choice, for "
"instance on the [Idris 2 Discord channel](https://discord.gg/UX68fDs2jc)."
msgstr ""

#. type: Plain text
#: ../src/Appendices/Neovim.md:374 ../src/Tutorial/DPair.md:1206
#: ../src/Tutorial/DataTypes.md:1368 ../src/Tutorial/Dependent.md:910
#: ../src/Tutorial/Eq.md:1098 ../src/Tutorial/Folds.md:1064
#: ../src/Tutorial/Functions1.md:583 ../src/Tutorial/Functions2.md:964
#: ../src/Tutorial/Functor.md:1427 ../src/Tutorial/IO.md:1125
#: ../src/Tutorial/Interfaces.md:821 ../src/Tutorial/Predicates.md:1369
#: ../src/Tutorial/Prim.md:1411 ../src/Tutorial/Traverse.md:1148
#, markdown-text, no-wrap
msgid ""
"<!-- vi: filetype=idris2\n"
"-->\n"
msgstr ""

#. type: Title #
#: ../src/Tutorial/DPair.md:1
#, markdown-text, no-wrap
msgid "Sigma Types"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:18
#, markdown-text
msgid ""
"So far in our examples of dependently typed programming, type indices such "
"as the length of vectors were known at compile time or could be calculated "
"from values known at compile time. In real applications, however, such "
"information is often not available until runtime, where values depend on the "
"decisions made by users or the state of the surrounding world.  For "
"instance, if we store a file's content as a vector of lines of text, the "
"length of this vector is in general unknown until the file has been loaded "
"into memory.  As a consequence, the types of values we work with depend on "
"other values only known at runtime, and we can often only figure out these "
"types by pattern matching on the values they depend on.  To express these "
"dependencies, we need so called [*sigma "
"types*](https://en.wikipedia.org/wiki/Dependent_type#%CE%A3_type): Dependent "
"pairs and their generalization, dependent records."
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:19
#, no-wrap
msgid ""
"module Tutorial.DPair\n"
"\n"
"import Control.Monad.State\n"
"\n"
"import Data.DPair\n"
"import Data.Either\n"
"import Data.HList\n"
"import Data.List\n"
"import Data.List1\n"
"import Data.Singleton\n"
"import Data.String\n"
"import Data.Vect\n"
"\n"
"import Text.CSV\n"
"\n"
"%default total\n"
msgstr ""

#. type: Title ##
#: ../src/Tutorial/DPair.md:38
#, markdown-text, no-wrap
msgid "Dependent Pairs"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:46
#, markdown-text
msgid ""
"We've already seen several examples of how useful the length index of a "
"vector is to describe more precisely in the types what a function can and "
"can't do. For instance, `map` or `traverse` operating on a vector will "
"return a vector of exactly the same length. The types guarantee that this is "
"true, therefore the following function is perfectly safe and provably total:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:47
#, no-wrap
msgid ""
"parseAndDrop : Vect (3 + n) String -> Maybe (Vect n Nat)\n"
"parseAndDrop = map (drop 3) . traverse parsePositive\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:60
#, markdown-text
msgid ""
"Since the argument of `traverse parsePositive` is of type `Vect (3 + n) "
"String`, its result will be of type `Maybe (Vect (3 + n) Nat)`. It is "
"therefore safe to use this in a call to `drop 3`. Note, how all of this is "
"known at compile time: We encoded the prerequisite that the first argument "
"is a vector of at least three elements in the length index and could derive "
"the length of the result from this."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/DPair.md:61
#, markdown-text, no-wrap
msgid "Vectors of Unknown Length"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:65
#, markdown-text
msgid ""
"However, this is not always possible. Consider the following function, "
"defined on `List` and exported by `Data.List`:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/DPair.md:66
#, no-wrap
msgid ""
"Tutorial.Relations> :t takeWhile\n"
"Data.List.takeWhile : (a -> Bool) -> List a -> List a\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:75
#, markdown-text
msgid ""
"This will take the longest prefix of the list argument, for which the given "
"predicate returns `True`. In this case, it depends on the list elements and "
"the predicate, how long this prefix will be.  Can we write such a function "
"for vectors? Let's give it a try:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:76
#, no-wrap
msgid "takeWhile' : (a -> Bool) -> Vect n a -> Vect m a\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:92
#, markdown-text
msgid ""
"Go ahead, and try to implement this. Don't try too long, as you will not be "
"able to do so in a provably total way. The question is: What is the problem "
"here? In order to understand this, we have to realize what the type of "
"`takeWhile'` promises: \"For all predicates operating on values on type `a`, "
"and for all vectors holding values of this type, and for all lengths `m`, I "
"give you a vector of length `m` holding values of type `a`\".  All three "
"arguments are said to be [*universally "
"quantified*](https://en.wikipedia.org/wiki/Universal_quantification): The "
"caller of our function is free to choose the predicate, the input vector, "
"the type of values the vector holds, and *the length of the output "
"vector*. Don't believe me? See here:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:93
#, no-wrap
msgid ""
"-- This looks like trouble: We got a non-empty vector of `Void`...\n"
"voids : Vect 7 Void\n"
"voids = takeWhile' (const True) []\n"
"\n"
"-- ...from which immediately follows a proof of `Void`\n"
"proofOfVoid : Void\n"
"proofOfVoid = head voids\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:108
#, markdown-text
msgid ""
"See how I could freely decide on the value of `m` when invoking "
"`takeWhile'`? Although I passed `takeWhile'` an empty vector (the only "
"existing vector holding values of type `Void`), the function's type promises "
"me to return a possibly non-empty vector holding values of the same type, "
"from which I freely extracted the first one."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:115
#, markdown-text
msgid ""
"Luckily, Idris doesn't allow this: We won't be able to implement "
"`takeWhile'` without cheating (for instance, by turning totality checking "
"off and looping forever).  So, the question remains, how to express the "
"result of `takeWhile'` in a type. The answer to this is: \"Use a *dependent "
"pair*\", a vector paired with a value corresponding to its length."
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:116
#, no-wrap
msgid ""
"record AnyVect a where\n"
"  constructor MkAnyVect\n"
"  length : Nat\n"
"  vect   : Vect length a\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:131
#, markdown-text
msgid ""
"This corresponds to [*existential "
"quantification*](https://en.wikipedia.org/wiki/Existential_quantification)  "
"in predicate logic: There is a natural number, which corresponds to the "
"length of the vector I have here. Note, how from the outside of `AnyVect a`, "
"the length of the wrapped vector is no longer visible at the type level but "
"we can still inspect it and learn something about it at runtime, since it is "
"wrapped up together with the actual vector. We can implement `takeWhile` in "
"such a way that it returns a value of type `AnyVect a`:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:132
#, no-wrap
msgid ""
"takeWhile : (a -> Bool) -> Vect n a -> AnyVect a\n"
"takeWhile f []        = MkAnyVect 0 []\n"
"takeWhile f (x :: xs) = case f x of\n"
"  False => MkAnyVect 0 []\n"
"  True  => let MkAnyVect n ys = takeWhile f xs in MkAnyVect (S n) (x :: "
"ys)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:147
#, markdown-text
msgid ""
"This works in a provably total way, because callers of this function can no "
"longer choose the length of the resulting vector themselves. Our function, "
"`takeWhile`, decides on this length and returns it together with the vector, "
"and the type checker verifies that we make no mistakes when pairing the two "
"values. In fact, the length can be inferred automatically by Idris, so we "
"can replace it with underscores, if we so desire:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:148
#, no-wrap
msgid ""
"takeWhile2 : (a -> Bool) -> Vect n a -> AnyVect a\n"
"takeWhile2 f []        = MkAnyVect _ []\n"
"takeWhile2 f (x :: xs) = case f x of\n"
"  False => MkAnyVect 0 []\n"
"  True  => let MkAnyVect _ ys = takeWhile2 f xs in MkAnyVect _ (x :: ys)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:161
#, markdown-text
msgid ""
"To summarize: Parameters in generic function types are universally "
"quantified, and their values can be decided on at the call site of such "
"functions. Dependent record types allow us to describe existentially "
"quantified values. Callers cannot choose such values freely: They are "
"returned as part of a function's result."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:164
#, markdown-text
msgid ""
"Note, that Idris allows us to be explicit about universal quantification.  "
"The type of `takeWhile'` can also be written like so:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:165
#, no-wrap
msgid "takeWhile'' : forall a, n, m . (a -> Bool) -> Vect n a -> Vect m a\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:173
#, markdown-text
msgid ""
"Universally quantified arguments are desugared to implicit erased arguments "
"by Idris. The above is a less verbose version of the following function "
"type, the likes of which we have seen before:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:174
#, no-wrap
msgid ""
"takeWhile''' :  {0 a : _}\n"
"             -> {0 n : _}\n"
"             -> {0 m : _}\n"
"             -> (a -> Bool)\n"
"             -> Vect n a\n"
"             -> Vect m a\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:189
#, markdown-text
msgid ""
"In Idris, we are free to choose whether we want to be explicit about "
"universal quantification. Sometimes it can help understanding what's going "
"on at the type level. Other languages - for instance "
"[PureScript](https://www.purescript.org/) - are more strict about this: "
"There, explicit annotations on universally quantified parameters are "
"[mandatory](https://github.com/purescript/documentation/blob/master/language/Differences-from-Haskell.md#explicit-forall)."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/DPair.md:190
#, markdown-text, no-wrap
msgid "The Essence of Dependent Pairs"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:202
#, markdown-text
msgid ""
"It can take some time and experience to understand what's going on here. At "
"least in my case, it took many sessions programming in Idris, before I "
"figured out what dependent pairs are about: They pair a *value* of some type "
"with a second value of a type calculated from the first value.  For "
"instance, a natural number `n` (the value)  paired with a vector of length "
"`n` (the second value, the type of which *depends* on the first value).  "
"This is such a fundamental concept of programming with dependent types, that "
"a general dependent pair type is provided by the *Prelude*. Here is its "
"implementation (primed for disambiguation):"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:203
#, no-wrap
msgid ""
"record DPair' (a : Type) (p : a -> Type) where\n"
"  constructor MkDPair'\n"
"  fst : a\n"
"  snd : p fst\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:215
#, markdown-text
msgid ""
"It is essential to understand what's going on here. There are two "
"parameters: A type `a`, and a function `p`, calculating a *type* from a "
"*value* of type `a`. Such a value (`fst`) is then used to calculate the "
"*type* of the second value (`snd`).  For instance, here is `AnyVect a` "
"represented as a `DPair`:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:216
#, no-wrap
msgid ""
"AnyVect' : (a : Type) -> Type\n"
"AnyVect' a = DPair Nat (\\n => Vect n a)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:225
#, markdown-text, no-wrap
msgid ""
"Note, how `\\n => Vect n a` is a function from `Nat` to `Type`.\n"
"Idris provides special syntax for describing dependent pairs, as\n"
"they are important building blocks for programming in languages\n"
"with first class types:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:226
#, no-wrap
msgid ""
"AnyVect'' : (a : Type) -> Type\n"
"AnyVect'' a = (n : Nat ** Vect n a)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:233
#, markdown-text
msgid ""
"We can inspect at the REPL, that the right hand side of `AnyVect''` get's "
"desugared to the right hand side of `AnyVect'`:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/DPair.md:234
#, no-wrap
msgid ""
"Tutorial.Relations> (n : Nat ** Vect n Int)\n"
"DPair Nat (\\n => Vect n Int)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:242
#, markdown-text
msgid ""
"Idris can infer, that `n` must be of type `Nat`, so we can drop this "
"information. (We still need to put the whole expression in parentheses.)"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:243
#, no-wrap
msgid ""
"AnyVect3 : (a : Type) -> Type\n"
"AnyVect3 a = (n ** Vect n a)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:254
#, markdown-text
msgid ""
"This allows us to pair a natural number `n` with a vector of length `n`, "
"which is exactly what we did with `AnyVect`. We can therefore rewrite "
"`takeWhile` to return a `DPair` instead of our custom type `AnyVect`. Note, "
"that like with regular pairs, we can use the same syntax `(x ** y)` for "
"creating and pattern matching on dependent pairs:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:255
#, no-wrap
msgid ""
"takeWhile3 : (a -> Bool) -> Vect m a -> (n ** Vect n a)\n"
"takeWhile3 f []        = (_ ** [])\n"
"takeWhile3 f (x :: xs) = case f x of\n"
"  False => (_ ** [])\n"
"  True  => let (_  ** ys) = takeWhile3 f xs in (_ ** x :: ys)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:265
#, markdown-text
msgid ""
"Just like with regular pairs, we can use the dependent pair syntax to define "
"dependent triples and larger tuples:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:266
#, no-wrap
msgid ""
"AnyMatrix : (a : Type) -> Type\n"
"AnyMatrix a = (m ** n ** Vect m (Vect n a))\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/DPair.md:271
#, markdown-text, no-wrap
msgid "Erased Existentials"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:281
#, markdown-text
msgid ""
"Sometimes, it is possible to determine the value of an index by pattern "
"matching on a value of the indexed type.  For instance, by pattern matching "
"on a vector, we can learn about its length index. In these cases, it is not "
"strictly necessary to carry around the index at runtime, and we can write a "
"special version of a dependent pair where the first argument has quantity "
"zero. Module `Data.DPair` from *base* exports data type `Exists` for this "
"use case."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:284
#, markdown-text
msgid ""
"As an example, here is a version of `takeWhile` returning a value of type "
"`Exists`:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:285
#, no-wrap
msgid ""
"takeWhileExists : (a -> Bool) -> Vect m a -> Exists (\\n => Vect n a)\n"
"takeWhileExists f []        = Evidence _ []\n"
"takeWhileExists f (x :: xs) = case f x of\n"
"  True  => let Evidence _ ys = takeWhileExists f xs\n"
"            in Evidence _ (x :: ys)\n"
"  False => takeWhileExists f xs\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:297
#, markdown-text
msgid ""
"In order to restore an erased value, data type `Singleton` from *base* "
"module `Data.Singleton` can be useful: It is parameterized by the *value* it "
"stores:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:298
#, no-wrap
msgid ""
"true : Singleton True\n"
"true = Val True\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:306
#, markdown-text
msgid ""
"This is called a *singleton* type: A type corresponding to exactly one "
"value. It is a type error to return any other value for constant `true`, and "
"Idris knows this:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:307
#, no-wrap
msgid ""
"true' : Singleton True\n"
"true' = Val _\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:314
#, markdown-text
msgid "We can use this to conjure the (erased!) length of a vector out of thin air:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:315
#, no-wrap
msgid ""
"vectLength : Vect n a -> Singleton n\n"
"vectLength []        = Val 0\n"
"vectLength (x :: xs) = let Val k = vectLength xs in Val (S k)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:326
#, markdown-text
msgid ""
"This function comes with much stronger guarantees than `Data.Vect.length`: "
"The latter claims to just return *any* natural number, while `vectLength` "
"*must* return exactly `n` in order to type check. As a demonstration, here "
"is a well-typed bogus implementation of `length`:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:327
#, no-wrap
msgid ""
"bogusLength : Vect n a -> Nat\n"
"bogusLength = const 0\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:334
#, markdown-text
msgid ""
"This would not be accepted as a valid implementation of `vectLength`, as you "
"may quickly verify yourself."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:338
#, markdown-text
msgid ""
"With the help of `vectLength` (but not with `Data.Vect.length`)  we can "
"convert an erased existential to a proper dependent pair:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:339
#, no-wrap
msgid ""
"toDPair : Exists (\\n => Vect n a) -> (m ** Vect m a)\n"
"toDPair (Evidence _ as) = let Val m = vectLength as in (m ** as)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:347
#, markdown-text
msgid ""
"Again, as a quick exercise, try implementing `toDPair` in terms of `length`, "
"and note how Idris will fail to unify the result of `length` with the actual "
"length of the vector."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/DPair.md:348 ../src/Tutorial/DataTypes.md:261
#: ../src/Tutorial/Dependent.md:444 ../src/Tutorial/Eq.md:279
#: ../src/Tutorial/Folds.md:373 ../src/Tutorial/Functor.md:381
#: ../src/Tutorial/IO.md:317 ../src/Tutorial/Interfaces.md:189
#: ../src/Tutorial/Predicates.md:305 ../src/Tutorial/Prim.md:448
#: ../src/Tutorial/Traverse.md:247
#, markdown-text, no-wrap
msgid "Exercises part 1"
msgstr ""

#. type: Bullet: '1. '
#: ../src/Tutorial/DPair.md:352
#, markdown-text
msgid ""
"Declare and implement a function for filtering a vector similar to "
"`Data.List.filter`."
msgstr ""

#. type: Bullet: '2. '
#: ../src/Tutorial/DPair.md:356
#, markdown-text
msgid ""
"Declare and implement a function for mapping a partial function over the "
"values of a vector similar to `Data.List.mapMaybe`."
msgstr ""

#. type: Bullet: '3. '
#: ../src/Tutorial/DPair.md:360
#, markdown-text
msgid ""
"Declare and implement a function similar to `Data.List.dropWhile` for "
"vectors. Use `Data.DPair.Exists` as your return type."
msgstr ""

#. type: Bullet: '4. '
#: ../src/Tutorial/DPair.md:363
#, markdown-text
msgid ""
"Repeat exercise 3 but return a proper dependent pair. Use the function from "
"exercise 3 in your implementation."
msgstr ""

#. type: Title ##
#: ../src/Tutorial/DPair.md:364
#, markdown-text, no-wrap
msgid "Use Case: Nucleic Acids"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:372
#, markdown-text
msgid ""
"We'd like to come up with a small, simplified library for running "
"computations on nucleic acids: RNA and DNA. These are built from five types "
"of nucleobases, three of which are used in both types of nucleic acids and "
"two bases specific for each type of acid. We'd like to make sure that only "
"valid bases are in strands of nucleic acids.  Here's a possible encoding:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:373
#, no-wrap
msgid ""
"data BaseType = DNABase | RNABase\n"
"\n"
"data Nucleobase : BaseType -> Type where\n"
"  Adenine  : Nucleobase b\n"
"  Cytosine : Nucleobase b\n"
"  Guanine  : Nucleobase b\n"
"  Thymine  : Nucleobase DNABase\n"
"  Uracile  : Nucleobase RNABase\n"
"\n"
"NucleicAcid : BaseType -> Type\n"
"NucleicAcid = List . Nucleobase\n"
"\n"
"RNA : Type\n"
"RNA = NucleicAcid RNABase\n"
"\n"
"DNA : Type\n"
"DNA = NucleicAcid DNABase\n"
"\n"
"encodeBase : Nucleobase b -> Char\n"
"encodeBase Adenine  = 'A'\n"
"encodeBase Cytosine = 'C'\n"
"encodeBase Guanine  = 'G'\n"
"encodeBase Thymine  = 'T'\n"
"encodeBase Uracile  = 'U'\n"
"\n"
"encode : NucleicAcid b -> String\n"
"encode = pack . map encodeBase\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:404
#, markdown-text
msgid "It is a type error to use `Uracile` in a strand of DNA:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:405
#, no-wrap
msgid ""
"failing \"Mismatch between: RNABase and DNABase.\"\n"
"  errDNA : DNA\n"
"  errDNA = [Uracile, Adenine]\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:415
#, markdown-text
msgid ""
"Note, how we used a variable for nucleobases `Adenine`, `Cytosine`, and "
"`Guanine`: These are again universally quantified, and client code is free "
"to choose a value here. This allows us to use these bases in strands of DNA "
"*and* RNA:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:416
#, no-wrap
msgid ""
"dna1 : DNA\n"
"dna1 = [Adenine, Cytosine, Guanine]\n"
"\n"
"rna1 : RNA\n"
"rna1 = [Adenine, Cytosine, Guanine]\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:427
#, markdown-text
msgid ""
"With `Thymine` and `Uracile`, we are more restrictive: `Thymine` is only "
"allowed in DNA, while `Uracile` is restricted to be used in RNA strands.  "
"Let's write parsers for strands of DNA and RNA:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:428
#, no-wrap
msgid ""
"readAnyBase : Char -> Maybe (Nucleobase b)\n"
"readAnyBase 'A' = Just Adenine\n"
"readAnyBase 'C' = Just Cytosine\n"
"readAnyBase 'G' = Just Guanine\n"
"readAnyBase _   = Nothing\n"
"\n"
"readRNABase : Char -> Maybe (Nucleobase RNABase)\n"
"readRNABase 'U' = Just Uracile\n"
"readRNABase c   = readAnyBase c\n"
"\n"
"readDNABase : Char -> Maybe (Nucleobase DNABase)\n"
"readDNABase 'T' = Just Thymine\n"
"readDNABase c   = readAnyBase c\n"
"\n"
"readRNA : String -> Maybe RNA\n"
"readRNA = traverse readRNABase . unpack\n"
"\n"
"readDNA : String -> Maybe DNA\n"
"readDNA = traverse readDNABase . unpack\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:454
#, markdown-text
msgid ""
"Again, in case of the bases appearing in both kinds of strands, users of the "
"universally quantified `readAnyBase` are free to choose what base type they "
"want, but they will never get a `Thymine` or `Uracile` value."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:458
#, markdown-text
msgid ""
"We can now implement some simple calculations on sequences of "
"nucleobases. For instance, we can come up with the complementary strand:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:459
#, no-wrap
msgid ""
"complementRNA' : RNA -> RNA\n"
"complementRNA' = map calc\n"
"  where calc : Nucleobase RNABase -> Nucleobase RNABase\n"
"        calc Guanine  = Cytosine\n"
"        calc Cytosine = Guanine\n"
"        calc Adenine  = Uracile\n"
"        calc Uracile  = Adenine\n"
"\n"
"complementDNA' : DNA -> DNA\n"
"complementDNA' = map calc\n"
"  where calc : Nucleobase DNABase -> Nucleobase DNABase\n"
"        calc Guanine  = Cytosine\n"
"        calc Cytosine = Guanine\n"
"        calc Adenine  = Thymine\n"
"        calc Thymine  = Adenine\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:480
#, markdown-text
msgid ""
"Ugh, code repetition! Not too bad here, but imagine there were dozens of "
"bases with only few specialized ones. Surely, we can do better? "
"Unfortunately, the following won't work:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:481
#, no-wrap
msgid ""
"complementBase' : Nucleobase b -> Nucleobase b\n"
"complementBase' Adenine  = ?what_now\n"
"complementBase' Cytosine = Guanine\n"
"complementBase' Guanine  = Cytosine\n"
"complementBase' Thymine  = Adenine\n"
"complementBase' Uracile  = Adenine\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:497
#, markdown-text
msgid ""
"All goes well with the exception of the `Adenine` case. Remember: Parameter "
"`b` is universally quantified, and the *callers* of our function can decide "
"what `b` is supposed to be. We therefore can't just return `Thymine`: Idris "
"will respond with a type error since callers might want a `Nucleobase "
"RNABase` instead.  One way to go about this is to take an additional "
"unerased argument (explicit or implicit) representing the base type:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:498
#, no-wrap
msgid ""
"complementBase : (b : BaseType) -> Nucleobase b -> Nucleobase b\n"
"complementBase DNABase Adenine  = Thymine\n"
"complementBase RNABase Adenine  = Uracile\n"
"complementBase _       Cytosine = Guanine\n"
"complementBase _       Guanine  = Cytosine\n"
"complementBase _       Thymine  = Adenine\n"
"complementBase _       Uracile  = Adenine\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:512
#, markdown-text
msgid ""
"This is again an example of a dependent *function* type (also called a [*pi "
"type*](https://en.wikipedia.org/wiki/Dependent_type#%CE%A0_type)): The input "
"and output types both *depend* on the *value* of the first argument.  We can "
"now use this to calculate the complement of any nucleic acid:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:513
#, no-wrap
msgid ""
"complement : (b : BaseType) -> NucleicAcid b -> NucleicAcid b\n"
"complement b = map (complementBase b)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:528
#, markdown-text
msgid ""
"Now, here is an interesting use case: We'd like to read a sequence of "
"nucleobases from user input, accepting two strings: The first telling us, "
"whether the user plans to enter a DNA or RNA sequence, the second being the "
"sequence itself. What should be the type of such a function? Well, we're "
"describing computations with side effects, so something involving `IO` seems "
"about right. User input almost always needs to be validated or translated, "
"so something might go wrong and we need an error type for this "
"case. Finally, our users can decide whether they want to enter a strand of "
"RNA or DNA, so this distinction should be encoded as well."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:531
#, markdown-text
msgid ""
"Of course, it is always possible to write a custom sum type for such a use "
"case:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:532
#, no-wrap
msgid ""
"data Result : Type where\n"
"  UnknownBaseType : String -> Result\n"
"  InvalidSequence : String -> Result\n"
"  GotDNA          : DNA -> Result\n"
"  GotRNA          : RNA -> Result\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:544
#, markdown-text
msgid ""
"This has all possible outcomes encoded in a single data type.  However, it "
"is lacking in terms of flexibility. If we want to handle errors early on and "
"just extract a strand of RNA or DNA, we need yet another data type:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:545
#, no-wrap
msgid "data RNAOrDNA = ItsRNA RNA | ItsDNA DNA\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:552
#, markdown-text
msgid ""
"This might be the way to go, but for results with many options, this can get "
"cumbersome quickly. Also: Why come up with a custom data type when we "
"already have the tools to deal with this at our hands?"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:554
#, markdown-text
msgid "Here is how we can encode this with a dependent pair:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:555
#, no-wrap
msgid ""
"namespace InputError\n"
"  public export\n"
"  data InputError : Type where\n"
"    UnknownBaseType : String -> InputError\n"
"    InvalidSequence : String -> InputError\n"
"\n"
"readAcid : (b : BaseType) -> String -> Either InputError (NucleicAcid b)\n"
"readAcid b str =\n"
"  let err = InvalidSequence str\n"
"   in case b of\n"
"        DNABase => maybeToEither err $ readDNA str\n"
"        RNABase => maybeToEither err $ readRNA str\n"
"\n"
"getNucleicAcid : IO (Either InputError (b ** NucleicAcid b))\n"
"getNucleicAcid = do\n"
"  baseString <- getLine\n"
"  case baseString of\n"
"    \"DNA\" => map (MkDPair _) . readAcid DNABase <$> getLine\n"
"    \"RNA\" => map (MkDPair _) . readAcid RNABase <$> getLine\n"
"    _     => pure $ Left (UnknownBaseType baseString)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:583
#, markdown-text
msgid ""
"Note, how we paired the type of nucleobases with the nucleic acid "
"sequence. Assume now we implement a function for transcribing a strand of "
"DNA to RNA, and we'd like to convert a sequence of nucleobases from user "
"input to the corresponding RNA sequence.  Here's how to do this:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:584
#, no-wrap
msgid ""
"transcribeBase : Nucleobase DNABase -> Nucleobase RNABase\n"
"transcribeBase Adenine  = Uracile\n"
"transcribeBase Cytosine = Guanine\n"
"transcribeBase Guanine  = Cytosine\n"
"transcribeBase Thymine  = Adenine\n"
"\n"
"transcribe : DNA -> RNA\n"
"transcribe = map transcribeBase\n"
"\n"
"printRNA : RNA -> IO ()\n"
"printRNA = putStrLn . encode\n"
"\n"
"transcribeProg : IO ()\n"
"transcribeProg = do\n"
"  Right (b ** seq) <- getNucleicAcid\n"
"    | Left (InvalidSequence str) => putStrLn $ \"Invalid sequence: \" ++ "
"str\n"
"    | Left (UnknownBaseType str) => putStrLn $ \"Unknown base type: \" ++ "
"str\n"
"  case b of\n"
"    DNABase => printRNA $ transcribe seq\n"
"    RNABase => printRNA seq\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:611
#, markdown-text
msgid ""
"By pattern matching on the first value of the dependent pair we could "
"determine, whether the second value is an RNA or DNA sequence.  In the first "
"case, we had to transcribe the sequence first, in the second case, we could "
"invoke `printRNA` directly."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:620
#, markdown-text
msgid ""
"In a more interesting scenario, we would *translate* the RNA sequence to the "
"corresponding protein sequence. Still, this example shows how to deal with a "
"simplified real world scenario: Data may be encoded differently and coming "
"from different sources. By using precise types, we are forced to first "
"convert values to the correct format. Failing to do so leads to a compile "
"time exception instead of an error at runtime or - even worse - the program "
"silently running a bogus computation."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/DPair.md:621
#, markdown-text, no-wrap
msgid "Dependent Records vs Sum Types"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:630
#, markdown-text
msgid ""
"Dependent records as shown for `AnyVect a` are a generalization of dependent "
"pairs: We can have an arbitrary number of fields and use the values stored "
"therein to calculate the types of other values. For very simple cases like "
"the example with nucleobases, it doesn't matter too much, whether we use a "
"`DPair`, a custom dependent record, or even a sum type. In fact, the three "
"encodings are equally expressive:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:631
#, no-wrap
msgid ""
"Acid1 : Type\n"
"Acid1 = (b ** NucleicAcid b)\n"
"\n"
"record Acid2 where\n"
"  constructor MkAcid2\n"
"  baseType : BaseType\n"
"  sequence : NucleicAcid baseType\n"
"\n"
"data Acid3 : Type where\n"
"  SomeRNA : RNA -> Acid3\n"
"  SomeDNA : DNA -> Acid3\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:652
#, markdown-text
msgid ""
"It is trivial to write lossless conversions between these encodings, and "
"with each encoding we can decide with a simple pattern match, whether we "
"currently have a sequence of RNA or DNA. However, dependent types can depend "
"on more than one value, as we will see in the exercises. In such cases, sum "
"types and dependent pairs quickly become unwieldy, and you should go for an "
"encoding as a dependent record."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/DPair.md:653 ../src/Tutorial/DataTypes.md:436
#: ../src/Tutorial/Dependent.md:623 ../src/Tutorial/Eq.md:555
#: ../src/Tutorial/Folds.md:668 ../src/Tutorial/Functor.md:962
#: ../src/Tutorial/IO.md:728 ../src/Tutorial/Interfaces.md:352
#: ../src/Tutorial/Predicates.md:672 ../src/Tutorial/Prim.md:712
#: ../src/Tutorial/Traverse.md:574
#, markdown-text, no-wrap
msgid "Exercises part 2"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:661
#, markdown-text
msgid ""
"Sharpen your skills in using dependent pairs and dependent records! In "
"exercises 2 to 7 you have to decide yourself, when a function should return "
"a dependent pair or record, when a function requires additional arguments, "
"on which you can pattern match, and what other utility functions might be "
"necessary."
msgstr ""

#. type: Bullet: '1. '
#: ../src/Tutorial/DPair.md:666
#, markdown-text
msgid ""
"Proof that the three encodings for nucleobases are *isomorphic* (meaning: of "
"the same structure) by writing lossless conversion functions from `Acid1` to "
"`Acid2` and back. Likewise for `Acid1` and `Acid3`."
msgstr ""

#. type: Bullet: '2. '
#: ../src/Tutorial/DPair.md:673
#, markdown-text
msgid ""
"Sequences of nucleobases can be encoded in one of two directions: [*Sense* "
"and *antisense*](https://en.wikipedia.org/wiki/Sense_(molecular_biology)).  "
"Declare a new data type to describe the sense of a sequence of nucleobases, "
"and add this as an additional parameter to type `Nucleobase` and types `DNA` "
"and `RNA`."
msgstr ""

#. type: Bullet: '3. '
#: ../src/Tutorial/DPair.md:677
#, markdown-text
msgid ""
"Refine the types of `complement` and `transcribe`, so that they reflect the "
"changing of *sense*. In case of `transcribe`, a strand of antisense DNA is "
"converted to a strand of sense RNA."
msgstr ""

#. type: Bullet: '4. '
#: ../src/Tutorial/DPair.md:680
#, markdown-text
msgid ""
"Define a dependent record storing the base type and sense together with a "
"sequence of nucleobases."
msgstr ""

#. type: Bullet: '5. '
#: ../src/Tutorial/DPair.md:685
#, markdown-text
msgid ""
"Adjust `readRNA` and `readDNA` in such a way that the *sense* of a sequence "
"is read from the input string.  Sense strands are encoded like so: "
"\"5-CGGTAG-3\". Antisense strands are encoded like so: \"3-CGGTAG-5\"."
msgstr ""

#. type: Bullet: '6. '
#: ../src/Tutorial/DPair.md:688
#, markdown-text
msgid "Adjust `encode` in such a way that it includes the sense in its output."
msgstr ""

#. type: Bullet: '7. '
#: ../src/Tutorial/DPair.md:693
#, markdown-text
msgid ""
"Enhance `getNucleicAcid` and `transcribeProg` in such a way that the sense "
"and base type are stored together with the sequence, and that "
"`transcribeProg` always prints the *sense* RNA strand (after transcription, "
"if necessary)."
msgstr ""

#. type: Bullet: '8. '
#: ../src/Tutorial/DPair.md:695
#, markdown-text
msgid "Enjoy the fruits of your labour and test your program at the REPL."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:703
#, markdown-text
msgid ""
"Note: Instead of using a dependent record, we could again have used a sum "
"type of four constructors to encode the different types of "
"sequences. However, the number of constructors required corresponds to the "
"*product* of the number of values of each type level index. Therefore, this "
"number can grow quickly and sum type encodings can lead to lengthy blocks of "
"pattern matches in these cases."
msgstr ""

#. type: Title ##
#: ../src/Tutorial/DPair.md:704
#, markdown-text, no-wrap
msgid "Use Case: CSV Files with a Schema"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:712
#, markdown-text
msgid ""
"In this section, we are going to look at an extended example based on our "
"previous work on CSV parsers. We'd like to write a small command-line "
"program, where users can specify a schema for the CSV tables they'd like to "
"parse and load into memory. Before we begin, here is a REPL session running "
"the final program, which you will complete in the exercises:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/DPair.md:713
#, no-wrap
msgid ""
"Solutions.DPair> :exec main\n"
"Enter a command: load resources/example\n"
"Table loaded. Schema: str,str,fin2023,str?,boolean?\n"
"Enter a command: get 3\n"
"Row 3:\n"
"\n"
"str   | str    | fin2023 | str? | boolean?\n"
"------------------------------------------\n"
"Floor | Jansen | 1981    |      | t\n"
"\n"
"Enter a command: add Mikael,Stanne,1974,,\n"
"Row prepended:\n"
"\n"
"str    | str    | fin2023 | str? | boolean?\n"
"-------------------------------------------\n"
"Mikael | Stanne | 1974    |      |\n"
"\n"
"Enter a command: get 1\n"
"Row 1:\n"
"\n"
"str    | str    | fin2023 | str? | boolean?\n"
"-------------------------------------------\n"
"Mikael | Stanne | 1974    |      |\n"
"\n"
"Enter a command: delete 1\n"
"Deleted row: 1.\n"
"Enter a command: get 1\n"
"Row 1:\n"
"\n"
"str | str     | fin2023 | str? | boolean?\n"
"-----------------------------------------\n"
"Rob | Halford | 1951    |      |\n"
"\n"
"Enter a command: quit\n"
"Goodbye.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:754
#, markdown-text
msgid ""
"This example was inspired by a similar program used as an example in the "
"[Type-Driven Development with "
"Idris](https://www.manning.com/books/type-driven-development-with-idris)  "
"book."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:756
#, markdown-text
msgid "We'd like to focus on several things here:"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/DPair.md:763
#, markdown-text
msgid ""
"Purity: With the exception of the main program loop, all functions used in "
"the implementation should be pure, which in this context means \"not running "
"in any monad with side effects such as `IO`\"."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/DPair.md:763
#, markdown-text
msgid ""
"Fail early: With the exception of the command parser, all functions updating "
"the table and handling queries should be typed and implemented in such a way "
"that they cannot fail."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:766
#, markdown-text
msgid ""
"We are often well advised to adhere to these two guidelines, as they can "
"make the majority of our functions easier to implement and test."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:772
#, markdown-text
msgid ""
"Since we allow users of our library to specify a schema (order and types of "
"columns) for the table they work with, this information is not known until "
"runtime. The same goes for the current size of the table. We will therefore "
"store both values as fields in a dependent record."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/DPair.md:773
#, markdown-text, no-wrap
msgid "Encoding the Schema"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:780
#, markdown-text
msgid ""
"We need to inspect the table schema at runtime. Although theoretically "
"possible, it is not advisable to operate on Idris types directly here.  We'd "
"rather use a closed custom data type describing the types of columns we "
"understand. In a first try, we only support some Idris primitives:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:781
#, no-wrap
msgid ""
"data ColType = I64 | Str | Boolean | Float\n"
"\n"
"Schema : Type\n"
"Schema = List ColType\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:791
#, markdown-text
msgid ""
"Next, we need a way to convert a `Schema` to a list of Idris types, which we "
"will then use as the index of a heterogeneous list representing the rows in "
"our table:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:792
#, no-wrap
msgid ""
"IdrisType : ColType -> Type\n"
"IdrisType I64     = Int64\n"
"IdrisType Str     = String\n"
"IdrisType Boolean = Bool\n"
"IdrisType Float   = Double\n"
"\n"
"Row : Schema -> Type\n"
"Row = HList . map IdrisType\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:807
#, markdown-text
msgid ""
"We can now describe a table as a dependent record storing the table's "
"content as a vector of rows. In order to safely index rows of the table and "
"parse new rows to be added, the current schema and size of the table must be "
"known at runtime:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:808
#, no-wrap
msgid ""
"record Table where\n"
"  constructor MkTable\n"
"  schema : Schema\n"
"  size   : Nat\n"
"  rows   : Vect size (Row schema)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:823
#, markdown-text
msgid ""
"Finally, we define an indexed data type describing commands operating on the "
"current table. Using the current table as the command's index allows us to "
"make sure that indices for accessing and deleting rows are within bounds and "
"that new rows agree with the current schema. This is necessary to uphold our "
"second design principle: All functions operating on tables must do so "
"without the possibility of failure."
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:824
#, no-wrap
msgid ""
"data Command : (t : Table) -> Type where\n"
"  PrintSchema : Command t\n"
"  PrintSize   : Command t\n"
"  New         : (newSchema : Schema) -> Command t\n"
"  Prepend     : Row (schema t) -> Command t\n"
"  Get         : Fin (size t) -> Command t\n"
"  Delete      : Fin (size t) -> Command t\n"
"  Quit        : Command t\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:839
#, markdown-text
msgid ""
"We can now implement the main application logic: How user entered commands "
"affect the application's current state. As promised, this comes without the "
"risk of failure, so we don't have to wrap the return type in an `Either`:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:840
#, no-wrap
msgid ""
"applyCommand : (t : Table) -> Command t -> Table\n"
"applyCommand t                 PrintSchema = t\n"
"applyCommand t                 PrintSize   = t\n"
"applyCommand _                 (New ts)    = MkTable ts _ []\n"
"applyCommand (MkTable ts n rs) (Prepend r) = MkTable ts _ $ r :: rs\n"
"applyCommand t                 (Get x)     = t\n"
"applyCommand t                 Quit        = t\n"
"applyCommand (MkTable ts n rs) (Delete x)  = case n of\n"
"  S k => MkTable ts k (deleteAt x rs)\n"
"  Z   => absurd x\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:857
#, markdown-text
msgid ""
"Please understand, that the constructors of `Command t` are typed in such a "
"way that indices are always within bounds (constructors `Get` and `Delete`), "
"and new rows adhere to the table's current schema (constructor `Prepend`)."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:866
#, markdown-text
msgid ""
"One thing you might not have seen so far is the call to `absurd` on the last "
"line. This is a derived function of the `Uninhabited` interface, which is "
"used to describe types such as `Void` or - in the case above - `Fin 0`, of "
"which there can be no value. Function `absurd` is then just another "
"manifestation of the principle of explosion. If this doesn't make too much "
"sense yet, don't worry. We will look at `Void` and its uses in the next "
"chapter."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/DPair.md:867
#, markdown-text, no-wrap
msgid "Parsing Commands"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:879
#, markdown-text
msgid ""
"User input validation is an important topic when writing applications. If it "
"happens early, you can keep larger parts of your application pure (which - "
"in this context - means: \"without the possibility of failure\") and "
"provably total.  If done properly, this step encodes and handles most if not "
"all ways in which things can go wrong in your program, allowing you to come "
"up with clear error messages telling users exactly what caused an issue. As "
"you surely have experienced yourself, there are few things more frustrating "
"than a non-trivial computer program terminating with an unhelpful \"There "
"was an error\" message."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:892
#, markdown-text
msgid ""
"So, in order to treat this important topic with all due respect, we are "
"first going to implement a custom error type. This is not *strictly* "
"necessary for small programs, but once your software gets more complex, it "
"can be tremendously helpful for keeping track of what can go wrong where. In "
"order to figure out what can possibly go wrong, we first need to decide on "
"how the commands should be entered.  Here, we use a single keyword for each "
"command, together with an optional number of arguments separated from the "
"keyword by a single space character. For instance: `\"new "
"i64,boolean,str,str\"`, for initializing an empty table with a new "
"schema. With this settled, here is a list of things that can go wrong, and "
"the messages we'd like to print:"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/DPair.md:907
#, markdown-text
msgid ""
"A bogus command is entered. We repeat the input with a message that we don't "
"know the command plus a list of commands we know about."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/DPair.md:907
#, markdown-text
msgid ""
"An invalid schema was entered. In this case, we list the position of the "
"first unknown type, the string we found there, and a list of types we know "
"about."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/DPair.md:907
#, markdown-text
msgid ""
"An invalid CSV encoding of a row was entered. We list the erroneous "
"position, the string encountered there, plus the expected type. In case of a "
"too small or too large number of fields, we also print a corresponding error "
"message."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/DPair.md:907
#, markdown-text
msgid ""
"An index was out of bounds. This can happen, when users try to access or "
"delete specific rows. We print the current number of rows plus the value "
"entered."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/DPair.md:907
#, markdown-text
msgid ""
"A value not representing a natural number was entered as an index.  We print "
"an according error message."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:910
#, markdown-text
msgid "That's a lot of stuff to keep track off, so let's encode this in a sum type:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:911
#, no-wrap
msgid ""
"data Error : Type where\n"
"  UnknownCommand : String -> Error\n"
"  UnknownType    : (pos : Nat) -> String -> Error\n"
"  InvalidField   : (pos : Nat) -> ColType -> String -> Error\n"
"  ExpectedEOI    : (pos : Nat) -> String -> Error\n"
"  UnexpectedEOI  : (pos : Nat) -> String -> Error\n"
"  OutOfBounds    : (size : Nat) -> (index : Nat) -> Error\n"
"  NoNat          : String -> Error\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:929
#, markdown-text
msgid ""
"In order to conveniently construct our error messages, it is best to use "
"Idris' string interpolation facilities: We can enclose arbitrary string "
"expressions in a string literal by enclosing them in curly braces, the first "
"of which must be escaped with a backslash. Like so: `\"foo \\{myExpr a b "
"c}\"`.  We can pair this with multiline string literals to get nicely "
"formatted error messages."
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:930
#, no-wrap
msgid ""
"showColType : ColType -> String\n"
"showColType I64      = \"i64\"\n"
"showColType Str      = \"str\"\n"
"showColType Boolean  = \"boolean\"\n"
"showColType Float    = \"float\"\n"
"\n"
"showSchema : Schema -> String\n"
"showSchema = concat . intersperse \",\" . map showColType\n"
"\n"
"allTypes : String\n"
"allTypes = concat\n"
"         . List.intersperse \", \"\n"
"         . map showColType\n"
"         $ [I64,Str,Boolean,Float]\n"
"\n"
"showError : Error -> String\n"
"showError (UnknownCommand x) = \"\"\"\n"
"  Unknown command: \\{x}.\n"
"  Known commands are: clear, schema, size, new, add, get, delete, quit.\n"
"  \"\"\"\n"
"\n"
"showError (UnknownType pos x) = \"\"\"\n"
"  Unknown type at position \\{show pos}: \\{x}.\n"
"  Known types are: \\{allTypes}.\n"
"  \"\"\"\n"
"\n"
"showError (InvalidField pos tpe x) = \"\"\"\n"
"  Invalid value at position \\{show pos}.\n"
"  Expected type: \\{showColType tpe}.\n"
"  Value found: \\{x}.\n"
"  \"\"\"\n"
"\n"
"showError (ExpectedEOI k x) = \"\"\"\n"
"  Expected end of input.\n"
"  Position: \\{show k}\n"
"  Input: \\{x}\n"
"  \"\"\"\n"
"\n"
"showError (UnexpectedEOI k x) = \"\"\"\n"
"  Unxpected end of input.\n"
"  Position: \\{show k}\n"
"  Input: \\{x}\n"
"  \"\"\"\n"
"\n"
"showError (OutOfBounds size index) = \"\"\"\n"
"  Index out of bounds.\n"
"  Size of table: \\{show size}\n"
"  Index: \\{show index}\n"
"  Note: Indices start at 1.\n"
"  \"\"\"\n"
"\n"
"showError (NoNat x) = \"Not a natural number: \\{x}\"\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:990
#, markdown-text
msgid ""
"We can now write parsers for the different commands. We need facilities to "
"parse vector indices, schemata, and CSV rows.  Since we are using a CSV "
"format for encoding and decoding rows, it makes sense to also encode the "
"schema as a comma-separated list of values:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:991
#, no-wrap
msgid ""
"zipWithIndex : Traversable t => t a -> t (Nat, a)\n"
"zipWithIndex = evalState 1 . traverse pairWithIndex\n"
"  where pairWithIndex : a -> State Nat (Nat,a)\n"
"        pairWithIndex v = (,v) <$> get <* modify S\n"
"\n"
"fromCSV : String -> List String\n"
"fromCSV = forget . split (',' ==)\n"
"\n"
"readColType : Nat -> String -> Either Error ColType\n"
"readColType _ \"i64\"      = Right I64\n"
"readColType _ \"str\"      = Right Str\n"
"readColType _ \"boolean\"  = Right Boolean\n"
"readColType _ \"float\"    = Right Float\n"
"readColType n s          = Left $ UnknownType n s\n"
"\n"
"readSchema : String -> Either Error Schema\n"
"readSchema = traverse (uncurry readColType) . zipWithIndex . fromCSV\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:1018
#, markdown-text
msgid ""
"We also need to decode CSV content based on the current schema.  Note, how "
"we can do so in a type safe manner by pattern matching on the schema, which "
"will not be known until runtime. Unfortunately, we need to reimplement "
"CSV-parsing, because we want to add the expected type to the error messages "
"(a thing that would be much harder to do with interface `CSVLine` and error "
"type `CSVError`)."
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:1019
#, no-wrap
msgid ""
"decodeField : Nat -> (c : ColType) -> String -> Either Error (IdrisType c)\n"
"decodeField k c s =\n"
"  let err = InvalidField k c s\n"
"   in case c of\n"
"        I64     => maybeToEither err $ read s\n"
"        Str     => maybeToEither err $ read s\n"
"        Boolean => maybeToEither err $ read s\n"
"        Float   => maybeToEither err $ read s\n"
"\n"
"decodeRow : {ts : _} -> String -> Either Error (Row ts)\n"
"decodeRow s = go 1 ts $ fromCSV s\n"
"  where go : Nat -> (cs : Schema) -> List String -> Either Error (Row cs)\n"
"        go k []       []         = Right []\n"
"        go k []       (_ :: _)   = Left $ ExpectedEOI k s\n"
"        go k (_ :: _) []         = Left $ UnexpectedEOI k s\n"
"        go k (c :: cs) (s :: ss) = [| decodeField k c s :: go (S k) cs ss "
"|]\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:1040
#, markdown-text
msgid ""
"There is no hard and fast rule about whether to pass an index as an implicit "
"argument or not. Some considerations:"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/DPair.md:1047
#, markdown-text
msgid "Pattern matching on explicit arguments comes with less syntactic overhead."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/DPair.md:1047
#, markdown-text
msgid ""
"If an argument can be inferred from the context most of the time, consider "
"passing it as an implicit to make your function nicer to use in client code."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/DPair.md:1047
#, markdown-text
msgid ""
"Use explicit (possibly erased) arguments for values that can't be inferred "
"by Idris most of the time."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:1052
#, markdown-text
msgid ""
"All that is missing now is a way to parse indices for accessing the current "
"table's rows. We use the conversion for indices to start at one instead of "
"zero, which feels more natural for most non-programmers."
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:1053
#, no-wrap
msgid ""
"readFin : {n : _} -> String -> Either Error (Fin n)\n"
"readFin s = do\n"
"  S k <- maybeToEither (NoNat s) $ parsePositive {a = Nat} s\n"
"    | Z => Left $ OutOfBounds n Z\n"
"  maybeToEither (OutOfBounds n $ S k) $ natToFin k n\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:1067
#, markdown-text
msgid ""
"We are finally able to implement a parser for user commands.  Function "
"`Data.String.words` is used for splitting a string at space characters. In "
"most cases, we expect the name of the command plus a single argument without "
"additional spaces.  CSV rows can have additional space characters, however, "
"so we use `Data.String.unwords` on the split string."
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:1068
#, no-wrap
msgid ""
"readCommand :  (t : Table) -> String -> Either Error (Command t)\n"
"readCommand _                \"schema\"  = Right PrintSchema\n"
"readCommand _                \"size\"    = Right PrintSize\n"
"readCommand _                \"quit\"    = Right Quit\n"
"readCommand (MkTable ts n _) s         = case words s of\n"
"  [\"new\",    str] => New     <$> readSchema str\n"
"  \"add\" ::   ss   => Prepend <$> decodeRow (unwords ss)\n"
"  [\"get\",    str] => Get     <$> readFin str\n"
"  [\"delete\", str] => Delete  <$> readFin str\n"
"  _               => Left $ UnknownCommand s\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/DPair.md:1081
#, markdown-text, no-wrap
msgid "Running the Application"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:1087
#, markdown-text
msgid ""
"All that's left to do is to write functions for printing the results of "
"commands to users and run the application in a loop until command `\"quit\"` "
"is entered."
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DPair.md:1088
#, no-wrap
msgid ""
"encodeField : (t : ColType) -> IdrisType t -> String\n"
"encodeField I64     x     = show x\n"
"encodeField Str     x     = show x\n"
"encodeField Boolean True  = \"t\"\n"
"encodeField Boolean False = \"f\"\n"
"encodeField Float   x     = show x\n"
"\n"
"encodeRow : (ts : List ColType) -> Row ts -> String\n"
"encodeRow ts = concat . intersperse \",\" . go ts\n"
"  where go : (cs : List ColType) -> Row cs -> Vect (length cs) String\n"
"        go []        []        = []\n"
"        go (c :: cs) (v :: vs) = encodeField c v :: go cs vs\n"
"\n"
"result :  (t : Table) -> Command t -> String\n"
"result t PrintSchema = \"Current schema: \\{showSchema t.schema}\"\n"
"result t PrintSize   = \"Current size: \\{show t.size}\"\n"
"result _ (New ts)    = \"Created table. Schema: \\{showSchema ts}\"\n"
"result t (Prepend r) = \"Row prepended: \\{encodeRow t.schema r}\"\n"
"result _ (Delete x)  = \"Deleted row: \\{show $ FS x}.\"\n"
"result _ Quit        = \"Goodbye.\"\n"
"result t (Get x)     =\n"
"  \"Row \\{show $ FS x}: \\{encodeRow t.schema (index x t.rows)}\"\n"
"\n"
"covering\n"
"runProg : Table -> IO ()\n"
"runProg t = do\n"
"  putStr \"Enter a command: \"\n"
"  str <- getLine\n"
"  case readCommand t str of\n"
"    Left err   => putStrLn (showError err) >> runProg t\n"
"    Right Quit => putStrLn (result t Quit)\n"
"    Right cmd  => putStrLn (result t cmd) >>\n"
"                  runProg (applyCommand t cmd)\n"
"\n"
"covering\n"
"main : IO ()\n"
"main = runProg $ MkTable [] _ []\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/DPair.md:1128 ../src/Tutorial/DataTypes.md:742
#: ../src/Tutorial/Dependent.md:843 ../src/Tutorial/Eq.md:826
#: ../src/Tutorial/Folds.md:988 ../src/Tutorial/Functor.md:1232
#: ../src/Tutorial/IO.md:949 ../src/Tutorial/Interfaces.md:624
#: ../src/Tutorial/Predicates.md:1020 ../src/Tutorial/Prim.md:936
#: ../src/Tutorial/Traverse.md:1016
#, markdown-text, no-wrap
msgid "Exercises part 3"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:1136
#, markdown-text
msgid ""
"The challenges presented here all deal with enhancing our table editor in "
"several interesting ways. Some of them are more a matter of style and less a "
"matter of learning to write dependently typed programs, so feel free to "
"solve these as you please. Exercises 1 to 3 should be considered to be "
"mandatory."
msgstr ""

#. type: Bullet: '1. '
#: ../src/Tutorial/DPair.md:1139
#, markdown-text
msgid "Add support for storing Idris types `Integer` and `Nat` in CSV columns"
msgstr ""

#. type: Bullet: '2. '
#: ../src/Tutorial/DPair.md:1142
#, markdown-text
msgid ""
"Add support for `Fin n` to CSV columns. Note: We need runtime access to `n` "
"in order for this to work."
msgstr ""

#. type: Bullet: '3. '
#: ../src/Tutorial/DPair.md:1148
#, markdown-text
msgid ""
"Add support for optional types to CSV columns. Since missing values should "
"be encoded by empty strings, it makes no sense to allow for nested optional "
"types, meaning that types like `Maybe Nat` should be allowed while `Maybe "
"(Maybe Nat)` should not."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:1151
#, markdown-text, no-wrap
msgid ""
"   Hint: There are several ways to encode these, one being\n"
"   to add a boolean index to `ColType`.\n"
msgstr ""

#. type: Bullet: '4. '
#: ../src/Tutorial/DPair.md:1154
#, markdown-text
msgid ""
"Add a command for printing the whole table. Bonus points if all columns are "
"properly aligned."
msgstr ""

#. type: Bullet: '5. '
#: ../src/Tutorial/DPair.md:1158
#, markdown-text
msgid ""
"Add support for simple queries: Given a column number and a value, list all "
"rows where entries match the given value."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:1160
#, markdown-text, no-wrap
msgid "   This might be a challenge, as the types get pretty interesting.\n"
msgstr ""

#. type: Bullet: '6. '
#: ../src/Tutorial/DPair.md:1164
#, markdown-text
msgid ""
"Add support for loading and saving tables from and to disk.  A table should "
"be stored in two files: One for the schema and one for the CSV content."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:1179
#, markdown-text, no-wrap
msgid ""
"   Note: Reading files in a provably total way can be pretty\n"
"   hard and will be a topic for another day. For now,\n"
"   just use function `readFile` exported from\n"
"   `System.File` in base for reading a file as a whole.\n"
"   This function is partial, because\n"
"   it will not terminate when used with an infinite input\n"
"   stream such as `/dev/urandom` or `/dev/zero`.\n"
"   It is important to *not* use `assert_total` here.\n"
"   Using partial functions like `readFile` might well impose\n"
"   a security risk in a real world application, so eventually,\n"
"   we'd have to deal with this and allow for some way to\n"
"   limit the size of accepted input. It is therefore best\n"
"   to make this partiality visible and annotate all downstream\n"
"   functions accordingly.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:1183
#, markdown-text
msgid ""
"You can find an implementation of these additions in the solutions. A small "
"example table can be found in folder `resources`."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:1190
#, markdown-text
msgid ""
"Note: There are of course tons of projects to pursue from here, such as "
"writing a proper query language, calculating new rows from existing ones, "
"accumulating values in a column, concatenating and zipping tables, and so "
"on.  We will stop for now, probably coming back to this in later examples."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:1198
#, markdown-text
msgid ""
"Dependent pairs and records are necessary to at runtime inspect the values "
"defining the types we work with. By pattern matching on these values, we "
"learn about the types and possible shapes of other values, allowing us to "
"reduce the number of potential bugs in our programs."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DPair.md:1204
#, markdown-text
msgid ""
"In the [next chapter](Eq.md) we start learning about how to write data "
"types, which we use as proofs that certain contracts between values "
"hold. These will eventually allow us to define pre- and post conditions for "
"our function arguments and output types."
msgstr ""

#. type: Title #
#: ../src/Tutorial/DataTypes.md:1
#, markdown-text, no-wrap
msgid "Algebraic Data Types"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:8
#, markdown-text
msgid ""
"In the [previous chapter](Functions1.md), we learned how to write our own "
"functions and combine them to create more complex functionality. Of equal "
"importance is the ability to define our own data types and use them as "
"arguments and results in functions."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:15
#, markdown-text
msgid ""
"This is a lengthy chapter, densely packed with information.  If you are new "
"to Idris and functional programming, make sure to follow along slowly, "
"experimenting with the examples, and possibly coming up with your own. Make "
"sure to try and solve *all* exercises. The solutions to the exercises can be "
"found [here](../Solutions/DataTypes.idr)."
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:16
#, no-wrap
msgid "module Tutorial.DataTypes\n"
msgstr ""

#. type: Title ##
#: ../src/Tutorial/DataTypes.md:20
#, markdown-text, no-wrap
msgid "Enumerations"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:24
#, markdown-text
msgid "Let's start with a data type for the days of the week as an example."
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:25
#, no-wrap
msgid ""
"data Weekday = Monday\n"
"             | Tuesday\n"
"             | Wednesday\n"
"             | Thursday\n"
"             | Friday\n"
"             | Saturday\n"
"             | Sunday\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:38
#, markdown-text
msgid ""
"The declaration above defines a new *type* (`Weekday`) and several new "
"*values* (`Monday` to `Sunday`) of the given type. Go ahead, and verify this "
"at the REPL:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/DataTypes.md:39
#, no-wrap
msgid ""
"Tutorial.DataTypes> :t Monday\n"
"Tutorial.DataTypes.Monday : Weekday\n"
"Tutorial.DataTypes> :t Weekday\n"
"Tutorial.DataTypes.Weekday : Type\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:48
#, markdown-text
msgid "So, `Monday` is of type `Weekday`, while `Weekday` itself is of type `Type`."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:52
#, markdown-text
msgid ""
"It is important to note, that a value of type `Weekday` can only ever be one "
"of the values listed above. It is a *type error* to use anything else where "
"a `Weekday` is expected."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:53
#, markdown-text, no-wrap
msgid "Pattern Matching"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:59
#, markdown-text
msgid ""
"In order to use our new data type as a function argument, we need to learn "
"about an important concept in functional programming languages: Pattern "
"matching. Let's implement a function, which calculates the successor of a "
"weekday:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:60
#, no-wrap
msgid ""
"total\n"
"next : Weekday -> Weekday\n"
"next Monday    = Tuesday\n"
"next Tuesday   = Wednesday\n"
"next Wednesday = Thursday\n"
"next Thursday  = Friday\n"
"next Friday    = Saturday\n"
"next Saturday  = Sunday\n"
"next Sunday    = Monday\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:81
#, markdown-text
msgid ""
"In order to inspect a `Weekday` argument, we match on the different possible "
"values and return a result for each of them.  This is a very powerful "
"concept, as it allows us to match on and extract values from deeply nested "
"data structures.  The different cases in a pattern match are inspected from "
"top to bottom, each being compared against the current function "
"argument. Once a matching pattern is found, the computation on the right "
"hand side of this pattern is evaluated. Later patterns are then ignored."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:89
#, markdown-text
msgid ""
"For instance, if we invoke `next` with argument `Thursday`, the first three "
"patterns (`Monaday`, `Tuesday`, and `Wednesday`)  will be checked against "
"the argument, but they do not match.  The fourth pattern is a match, and "
"result `Friday` is being returned. Later patterns are then ignored, even if "
"they would also match the input (this becomes relevant with catch-all "
"patterns, which we will talk about in a moment)."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:98
#, markdown-text
msgid ""
"The function above is provably total. Idris knows about the possible values "
"of type `Weekday`, and can therefore figure out that our pattern match "
"covers all possible cases. We can therefore annotate the function with the "
"`total` keyword, and Idris will answer with a type error, if it can't verify "
"the function's totality. (Go ahead, and try removing one of the clauses in "
"`next` to get an idea about how an error message from the coverage checker "
"looks like.)"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:105
#, markdown-text
msgid ""
"Please remember, that these are very strong guarantees from the type "
"checker: Given enough resources, a provably total function will *always* "
"return a result of the given type in a finite amount of time (*resources* "
"here meaning computational resources like memory or, in case of recursive "
"functions, stack space)."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:106
#, markdown-text, no-wrap
msgid "Catch-all Patterns"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:111
#, markdown-text
msgid ""
"Sometimes, it is convenient to only match on a subset of the possible values "
"and collect the remaining possibilities in a catch-all clause:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:112
#, no-wrap
msgid ""
"total\n"
"isWeekend : Weekday -> Bool\n"
"isWeekend Saturday = True\n"
"isWeekend Sunday   = True\n"
"isWeekend _        = False\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:125
#, markdown-text
msgid ""
"The final line with the catch-all pattern is only invoked, if the argument "
"is not equal to `Saturday` or `Sunday`.  Remember: Patterns in a pattern "
"match are matched against the input from top to bottom and the first match "
"decides, which path on the right hand side will be taken."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:129
#, markdown-text
msgid ""
"We can use catch-all patterns to implement an equality test for `Weekday` "
"(we will not yet use the `==` operator for this; this will have to wait "
"until we learn about *interfaces*):"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:130
#, no-wrap
msgid ""
"total\n"
"eqWeekday : Weekday -> Weekday -> Bool\n"
"eqWeekday Monday Monday        = True\n"
"eqWeekday Tuesday Tuesday      = True\n"
"eqWeekday Wednesday Wednesday  = True\n"
"eqWeekday Thursday Thursday    = True\n"
"eqWeekday Friday Friday        = True\n"
"eqWeekday Saturday Saturday    = True\n"
"eqWeekday Sunday Sunday        = True\n"
"eqWeekday _ _                  = False\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:143
#, markdown-text, no-wrap
msgid "Enumeration Types in the Prelude"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:151
#, markdown-text
msgid ""
"Data types like `Weekday` consisting of a finite set of values are sometimes "
"called *enumerations*. The Idris *Prelude* defines some common enumerations "
"for us, for instance `Bool` and `Ordering`. As with `Weekday`, we can use "
"pattern matching when implementing functions on these types:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:152
#, no-wrap
msgid ""
"-- this is how `not` is implemented in the *Prelude*\n"
"total\n"
"negate : Bool -> Bool\n"
"negate False = True\n"
"negate True  = False\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:162
#, markdown-text
msgid ""
"The `Ordering` data type describes an ordering relation between two "
"values. For instance:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:163
#, no-wrap
msgid ""
"total\n"
"compareBool : Bool -> Bool -> Ordering\n"
"compareBool False False = EQ\n"
"compareBool False True  = LT\n"
"compareBool True True   = EQ\n"
"compareBool True False  = GT\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:176
#, markdown-text
msgid ""
"Here, `LT` means that the first argument is *less than* the second, `EQ` "
"means that the two arguments are *equal* and `GT` means, that the first "
"argument is *greater than* the second."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:177
#, markdown-text, no-wrap
msgid "Case Expressions"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:183
#, markdown-text
msgid ""
"Sometimes we need to perform a computation with one of the arguments and "
"want to pattern match on the result of this computation. We can use *case "
"expressions* in this situation:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:184
#, no-wrap
msgid ""
"-- returns the larger of the two arguments\n"
"total\n"
"maxBits8 : Bits8 -> Bits8 -> Bits8\n"
"maxBits8 x y =\n"
"  case compare x y of\n"
"    LT => y\n"
"    _  => x\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:202
#, markdown-text
msgid ""
"The first line of the case expression (`case compare x y of`)  will invoke "
"function `compare` with arguments `x` and `y`. On the following (indented) "
"lines, we pattern match on the result of this computation. This is of type "
"`Ordering`, so we expect one of the three constructors `LT`, `EQ`, or `GT` "
"as the result.  On the first line, we handle the `LT` case explicitly, while "
"the other two cases are handled with an underscore as a catch-all pattern."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:206
#, markdown-text
msgid ""
"Note, that indentation matters here: The case block as a whole must be "
"indented (if it starts on a new line), and the different cases must also be "
"indented by the same amount of whitespace."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:209
#, markdown-text
msgid ""
"Function `compare` is overloaded for many data types. We will learn how this "
"works when we talk about interfaces."
msgstr ""

#. type: Title ####
#: ../src/Tutorial/DataTypes.md:210
#, markdown-text, no-wrap
msgid "If Then Else"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:214
#, markdown-text
msgid ""
"When working with `Bool`, there is an alternative to pattern matching common "
"to most programming languages:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:215
#, no-wrap
msgid ""
"total\n"
"maxBits8' : Bits8 -> Bits8 -> Bits8\n"
"maxBits8' x y = if compare x y == LT then y else x\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:225
#, markdown-text
msgid ""
"Note, that the `if then else` expression always returns a value and "
"therefore, the `else` branch cannot be dropped. This is different from the "
"behavior in typical imperative languages, where `if` is a statement with "
"possible side effects."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:226
#, markdown-text, no-wrap
msgid "Naming Conventions: Identifiers"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:233
#, markdown-text
msgid ""
"While we are free to use lower-case and upper-case identifiers for function "
"names, type- and data constructors must be given upper-case identifiers in "
"order not to confuse Idris (operators are also fine).  For instance, the "
"following data definition is not valid, and Idris will complain that it "
"expected upper-case identifiers:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/DataTypes.md:234
#, no-wrap
msgid "data foo = bar | baz\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:240
#, markdown-text
msgid ""
"The same goes for similar data definitions like records and sum types (both "
"will be explained below):"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/DataTypes.md:241
#, no-wrap
msgid ""
"-- not valid Idris\n"
"record Foo where\n"
"  constructor mkfoo\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:252
#, markdown-text
msgid ""
"On the other hand, we typically use lower-case identifiers for function "
"names, unless we plan to use them mostly during type checking (more on this "
"later). This is not enforced by Idris, however, so if you are working in a "
"domain where upper-case identifiers are preferable, feel free to use those:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:253
#, no-wrap
msgid ""
"foo : Bits32 -> Bits32\n"
"foo = (* 2)\n"
"\n"
"Bar : Bits32 -> Bits32\n"
"Bar = foo\n"
msgstr ""

#. type: Bullet: '1. '
#: ../src/Tutorial/DataTypes.md:267
#, markdown-text
msgid ""
"Use pattern matching to implement your own versions of boolean operators "
"`(&&)` and `(||)` calling them `and` and `or` respectively."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:274
#, markdown-text, no-wrap
msgid ""
"   Note: One way to go about this is to enumerate\n"
"   all four possible combinations of two boolean\n"
"   values and give the result for each. However, there\n"
"   is a shorter, more clever way,\n"
"   requiring only two pattern matches for each of the\n"
"   two functions.\n"
msgstr ""

#. type: Bullet: '2. '
#: ../src/Tutorial/DataTypes.md:282
#, markdown-text
msgid ""
"Define your own data type representing different units of time (seconds, "
"minutes, hours, days, weeks), and implement the following functions for "
"converting between time spans using different units. Hint: Use integer "
"division (`div`)  when going from seconds to some larger unit like hours)."
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:283
#, no-wrap
msgid ""
"   data UnitOfTime = Second -- add additional values\n"
"\n"
"   -- calculate the number of seconds from a\n"
"   -- number of steps in the given unit of time\n"
"   total\n"
"   toSeconds : UnitOfTime -> Integer -> Integer\n"
"\n"
"   -- Given a number of seconds, calculate the\n"
"   -- number of steps in the given unit of time\n"
"   total\n"
"   fromSeconds : UnitOfTime -> Integer -> Integer\n"
"\n"
"   -- convert the number of steps in a given unit of time\n"
"   -- to the number of steps in another unit of time.\n"
"   -- use `fromSeconds` and `toSeconds` in your implementation\n"
"   total\n"
"   convert : UnitOfTime -> Integer -> UnitOfTime -> Integer\n"
msgstr ""

#. type: Bullet: '3. '
#: ../src/Tutorial/DataTypes.md:306
#, markdown-text
msgid ""
"Define a data type for representing a subset of the chemical elements: "
"Hydrogen (H), Carbon (C), Nitrogen (N), Oxygen (O), and Fluorine (F)."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:309
#, markdown-text, no-wrap
msgid ""
"   Declare and implement function `atomicMass`, which for each element\n"
"   returns its atomic mass in dalton:\n"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/DataTypes.md:310
#, no-wrap
msgid ""
"   Hydrogen : 1.008\n"
"   Carbon : 12.011\n"
"   Nitrogen : 14.007\n"
"   Oxygen : 15.999\n"
"   Fluorine : 18.9984\n"
msgstr ""

#. type: Title ##
#: ../src/Tutorial/DataTypes.md:318
#, markdown-text, no-wrap
msgid "Sum Types"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:326
#, markdown-text
msgid ""
"Assume we'd like to write some web form, where users of our web application "
"can decide how they like to be addressed.  We give them a choice between two "
"common predefined forms of address (Mr and Mrs), but also allow them to "
"decide on a customized form. The possible choices can be encapsulated in an "
"Idris data type:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:327
#, no-wrap
msgid "data Title = Mr | Mrs | Other String\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:336
#, markdown-text
msgid ""
"This looks almost like an enumeration type, with the exception that there is "
"a new thing, called a *data constructor*, which accepts a `String` argument "
"(actually, the values in an enumeration are also called (nullary) data "
"constructors).  If we inspect the types at the REPL, we learn the following:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/DataTypes.md:337
#, no-wrap
msgid ""
"Tutorial.DataTypes> :t Mr\n"
"Tutorial.DataTypes.Mr : Title\n"
"Tutorial.DataTypes> :t Other\n"
"Tutorial.DataTypes.Other : String -> Title\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:347
#, markdown-text
msgid ""
"So, `Other` is a *function* from `String` to `Title`. This means, that we "
"can pass `Other` a `String` argument and get a `Title` as the result:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:348
#, no-wrap
msgid ""
"total\n"
"dr : Title\n"
"dr = Other \"Dr.\"\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:358
#, markdown-text
msgid ""
"Again, a value of type `Title` can only consist of one of the three choices "
"listed above, and again, we can use pattern matching to implement functions "
"on the `Title` data type in a provably total way:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:359
#, no-wrap
msgid ""
"total\n"
"showTitle : Title -> String\n"
"showTitle Mr        = \"Mr.\"\n"
"showTitle Mrs       = \"Mrs.\"\n"
"showTitle (Other x) = x\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:372
#, markdown-text
msgid ""
"Note, how in the last pattern match, the string value stored in the `Other` "
"data constructor is *bound* to local variable `x`.  Also, the `Other x` "
"pattern has to be wrapped in parentheses, as otherwise Idris would think "
"`Other` and `x` were to distinct function arguments."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:377
#, markdown-text
msgid ""
"This is a very common way to extract the values from data constructors.  We "
"can use `showTitle` to implement a function for creating a courteous "
"greeting:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:378
#, no-wrap
msgid ""
"total\n"
"greet : Title -> String -> String\n"
"greet t name = \"Hello, \" ++ showTitle t ++ \" \" ++ name ++ \"!\"\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:387
#, markdown-text
msgid ""
"In the implementation of `greet`, we use string literals and the string "
"concatenation operator `(++)` to assemble the greeting from its parts."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:389
#, markdown-text
msgid "At the REPL:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/DataTypes.md:390
#, no-wrap
msgid ""
"Tutorial.DataTypes> greet dr \"Hck\"\n"
"\"Hello, Dr. Hck!\"\n"
"Tutorial.DataTypes> greet Mrs \"Smith\"\n"
"\"Hello, Mrs. Smith!\"\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:400
#, markdown-text
msgid ""
"Data types like `Title` are called *sum types* as they consist of the sum of "
"their different parts: A value of type `Title` is either a `Mr`, a `Mrs`, or "
"a `String` wrapped up in `Other`."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:407
#, markdown-text
msgid ""
"Here's another (drastically simplified) example of a sum type.  Assume we "
"allow two forms of authentication in our web application: Either by entering "
"a username plus a password (for which we'll use an unsigned 64 bit integer "
"here), or by providing user name plus a (very complex) secret key.  Here's a "
"data type to encapsulate this use case:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:408
#, no-wrap
msgid "data Credentials = Password String Bits64 | Key String String\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:414
#, markdown-text
msgid ""
"As an example of a very primitive login function, we can hard-code some "
"known credentials:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:415
#, no-wrap
msgid ""
"total\n"
"login : Credentials -> String\n"
"login (Password \"Anderson\" 6665443) = greet Mr \"Anderson\"\n"
"login (Key \"Y\" \"xyz\")               = greet (Other \"Agent\") \"Y\"\n"
"login _                             = \"Access denied!\"\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:426
#, markdown-text
msgid ""
"As can be seen in the example above, we can also pattern match against "
"primitive values by using integer and string literals. Give `login` a go at "
"the REPL:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/DataTypes.md:427
#, no-wrap
msgid ""
"Tutorial.DataTypes> login (Password \"Anderson\" 6665443)\n"
"\"Hello, Mr. Anderson!\"\n"
"Tutorial.DataTypes> login (Key \"Y\" \"xyz\")\n"
"\"Hello, Agent Y!\"\n"
"Tutorial.DataTypes> login (Key \"Y\" \"foo\")\n"
"\"Access denied!\"\n"
msgstr ""

#. type: Bullet: '1. '
#: ../src/Tutorial/DataTypes.md:440
#, markdown-text
msgid ""
"Implement an equality test for `Title` (you can use the equality operator "
"`(==)` for comparing two `String`s):"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:441
#, no-wrap
msgid ""
"   total\n"
"   eqTitle : Title -> Title -> Bool\n"
msgstr ""

#. type: Bullet: '2. '
#: ../src/Tutorial/DataTypes.md:448
#, markdown-text
msgid ""
"For `Title`, implement a simple test to check, whether a custom title is "
"being used:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:449
#, no-wrap
msgid ""
"   total\n"
"   isOther : Title -> Bool\n"
msgstr ""

#. type: Bullet: '3. '
#: ../src/Tutorial/DataTypes.md:456
#, markdown-text
msgid ""
"Given our simple `Credentials` type, there are three ways for authentication "
"to fail:"
msgstr ""

#. type: Bullet: '   * '
#: ../src/Tutorial/DataTypes.md:461
#, markdown-text
msgid "An unknown username was used."
msgstr ""

#. type: Bullet: '   * '
#: ../src/Tutorial/DataTypes.md:461
#, markdown-text
msgid "The password given does not match the one associated with the username."
msgstr ""

#. type: Bullet: '   * '
#: ../src/Tutorial/DataTypes.md:461
#, markdown-text
msgid "An invalid key was used."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:467
#, markdown-text, no-wrap
msgid ""
"   Encapsulate these three possibilities in a sum type\n"
"   called `LoginError`,\n"
"   but make sure not to disclose any confidential information:\n"
"   An invalid username should be stored in the corresponding\n"
"   error value, but an invalid password or key should not.\n"
msgstr ""

#. type: Bullet: '4. '
#: ../src/Tutorial/DataTypes.md:471
#, markdown-text
msgid ""
"Implement function `showError : LoginError -> String`, which can be used to "
"display an error message to the user who unsuccessfully tried to login into "
"our web application."
msgstr ""

#. type: Title ##
#: ../src/Tutorial/DataTypes.md:472
#, markdown-text, no-wrap
msgid "Records"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:481
#, markdown-text
msgid ""
"It is often useful to group together several values as a logical unit. For "
"instance, in our web application we might want to group information about a "
"user in a single data type. Such data types are often called *product types* "
"(see below for an explanation).  The most common and convenient way to "
"define them is the `record` construct:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:482
#, no-wrap
msgid ""
"record User where\n"
"  constructor MkUser\n"
"  name  : String\n"
"  title : Title\n"
"  age   : Bits8\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:493
#, markdown-text
msgid ""
"The declaration above creates a new *type* called `User`, and a new *data "
"constructor* called `MkUser`. As usual, have a look at their types in the "
"REPL:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/DataTypes.md:494
#, no-wrap
msgid ""
"Tutorial.DataTypes> :t User\n"
"Tutorial.DataTypes.User : Type\n"
"Tutorial.DataTypes> :t MkUser\n"
"Tutorial.DataTypes.MkUser : String -> Title -> Bits8 -> User\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:504
#, markdown-text
msgid ""
"We can use `MkUser` (which is a function from `String` to `Title` to `Bits8` "
"to `User`)  to create values of type `User`:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:505
#, no-wrap
msgid ""
"total\n"
"agentY : User\n"
"agentY = MkUser \"Y\" (Other \"Agent\") 51\n"
"\n"
"total\n"
"drNo : User\n"
"drNo = MkUser \"No\" dr 73\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:517
#, markdown-text
msgid ""
"We can also use pattern matching to extract the fields from a `User` value "
"(they can again be bound to local variables):"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:518
#, no-wrap
msgid ""
"total\n"
"greetUser : User -> String\n"
"greetUser (MkUser n t _) = greet t n\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:530
#, markdown-text
msgid ""
"In the example above, the `name` and `title` field are bound to two new "
"local variables (`n` and `t` respectively), which can then be used on the "
"right hand side of `greetUser`'s implementation. For the `age` field, which "
"is not used on the right hand side, we can use an underscore as a catch-all "
"pattern."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:545
#, markdown-text
msgid ""
"Note, how Idris will prevent us from making a common mistake: If we confuse "
"the order of arguments, the implementation will no longer type check. We can "
"verify this by putting the erroneous code in a `failing` block: This is an "
"indented code block, which will lead to an error during elaboration (type "
"checking). We can give part of the expected error message as an optional "
"string argument to a failing block. If this does not match part of the error "
"message (or the whole code block does not fail to type check) the `failing` "
"block itself fails to type check. This is a useful tool to demonstrate that "
"type safety works in two directions: We can show that valid code type checks "
"but also that invalid code is rejected by the Idris elaborator:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:546
#, no-wrap
msgid ""
"failing \"Mismatch between: String and Title\"\n"
"  greetUser' : User -> String\n"
"  greetUser' (MkUser n t _) = greet n t\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:558
#, markdown-text
msgid ""
"In addition, for every record field, Idris creates an extractor function of "
"the same name. This can either be used as a regular function, or it can be "
"used in postfix notation by appending it to a variable of the record type "
"separated by a dot. Here are two examples for extracting the age from a "
"user:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:559
#, no-wrap
msgid ""
"getAgeFunction : User -> Bits8\n"
"getAgeFunction u = age u\n"
"\n"
"getAgePostfix : User -> Bits8\n"
"getAgePostfix u = u.age\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:567
#, markdown-text, no-wrap
msgid "Syntactic Sugar for Records"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:581
#, markdown-text
msgid ""
"As was already mentioned in the [intro](Intro.md), Idris is a *pure* "
"functional programming language. In pure functions, we are not allowed to "
"modify global mutable state. As such, if we want to modify a record value, "
"we will always create a *new* value with the original value remaining "
"unchanged: Records and other Idris values are *immutable*.  While this *can* "
"have a slight impact on performance, it has the benefit that we can freely "
"pass a record value to different functions, without fear of the functions "
"modifying the value by in-place mutation. These are, again, very strong "
"guarantees, which makes it drastically easier to reason about our code."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:586
#, markdown-text
msgid ""
"There are several ways to modify a record, the most general being to pattern "
"match on the record and adjust each field as desired. If, for instance, we'd "
"like to increase the age of a `User` by one, we could do the following:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:587
#, no-wrap
msgid ""
"total\n"
"incAge : User -> User\n"
"incAge (MkUser name title age) = MkUser name title (age + 1)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:597
#, markdown-text
msgid ""
"That's a lot of code for such a simple thing, so Idris offers several "
"syntactic conveniences for this. For instance, using *record* syntax, we can "
"just access and update the `age` field of a value:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:598
#, no-wrap
msgid ""
"total\n"
"incAge2 : User -> User\n"
"incAge2 u = { age := u.age + 1 } u\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:607
#, markdown-text
msgid ""
"Assignment operator `:=` assigns a new value to the `age` field in "
"`u`. Remember, that this will create a new `User` value. The original value "
"`u` remains unaffected by this."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:613
#, markdown-text
msgid ""
"We can access a record field, either by using the field name as a projection "
"function (`age u`; also have a look at `:t age` in the REPL), or by using "
"dot syntax: `u.age`. This is special syntax and *not* related to the dot "
"operator for function composition (`(.)`)."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:616
#, markdown-text
msgid ""
"The use case of modifying a record field is so common that Idris provides "
"special syntax for this as well:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:617
#, no-wrap
msgid ""
"total\n"
"incAge3 : User -> User\n"
"incAge3 u = { age $= (+ 1) } u\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:627
#, markdown-text
msgid ""
"Here, I used an *operator section* (`(+ 1)`) to make the code more concise.  "
"As an alternative to an operator section, we could have used an anonymous "
"function like so:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:628
#, no-wrap
msgid ""
"total\n"
"incAge4 : User -> User\n"
"incAge4 u = { age $= \\x => x + 1 } u\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:637
#, markdown-text
msgid ""
"Finally, since our function's argument `u` is only used once at the very "
"end, we can drop it altogether, to get the following, highly concise "
"version:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:638
#, no-wrap
msgid ""
"total\n"
"incAge5 : User -> User\n"
"incAge5 = { age $= (+ 1) }\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:645
#, markdown-text
msgid "As usual, we should have a look at the result at the REPL:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/DataTypes.md:646
#, no-wrap
msgid ""
"Tutorial.DataTypes> incAge5 drNo\n"
"MkUser \"No\" (Other \"Dr.\") 74\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:653
#, markdown-text
msgid ""
"It is possible to use this syntax to set and/or update several record fields "
"at once:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:654
#, no-wrap
msgid ""
"total\n"
"drNoJunior : User\n"
"drNoJunior = { name $= (++ \" Jr.\"), title := Mr, age := 17 } drNo\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:660
#, markdown-text, no-wrap
msgid "Tuples"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:666
#, markdown-text
msgid ""
"I wrote above that a record is also called a *product type*.  This is quite "
"obvious when we consider the number of possible values inhabiting a given "
"type. For instance, consider the following custom record:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:667
#, no-wrap
msgid ""
"record Foo where\n"
"  constructor MkFoo\n"
"  wd   : Weekday\n"
"  bool : Bool\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:678
#, markdown-text
msgid ""
"How many possible values of type `Foo` are there? The answer is `7 * 2 = "
"14`, as we can pair every possible `Weekday` (seven in total) with every "
"possible `Bool` (two in total). So, the number of possible values of a "
"record type is the *product* of the number of possible values for each "
"field."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:680
#, markdown-text
msgid ""
"The canonical product type is the `Pair`, which is available from the "
"*Prelude*:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:681
#, no-wrap
msgid ""
"total\n"
"weekdayAndBool : Weekday -> Bool -> Pair Weekday Bool\n"
"weekdayAndBool wd b = MkPair wd b\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:692
#, markdown-text
msgid ""
"Since it is quite common to return several values from a function wrapped in "
"a `Pair` or larger tuple, Idris provides some syntactic sugar for working "
"with these. Instead of `Pair Weekday Bool`, we can just write `(Weekday, "
"Bool)`. Likewise, instead of `MkPair wd b`, we can just write `(wd, b)` (the "
"space is optional):"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:693
#, no-wrap
msgid ""
"total\n"
"weekdayAndBool2 : Weekday -> Bool -> (Weekday, Bool)\n"
"weekdayAndBool2 wd b = (wd, b)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:700
#, markdown-text
msgid "This works also for nested tuples:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:701
#, no-wrap
msgid ""
"total\n"
"triple : Pair Bool (Pair Weekday String)\n"
"triple = MkPair False (Friday, \"foo\")\n"
"\n"
"total\n"
"triple2 : (Bool, Weekday, String)\n"
"triple2 = (False, Friday, \"foo\")\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:713
#, markdown-text
msgid ""
"In the example above, `triple2` is converted to the form used in `triple` by "
"the Idris compiler."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:715
#, markdown-text
msgid "We can even use tuple syntax in pattern matches:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:716
#, no-wrap
msgid ""
"total\n"
"bar : Bool\n"
"bar = case triple of\n"
"  (b,wd,_) => b && isWeekend wd\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:723
#, markdown-text, no-wrap
msgid "As Patterns"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:728
#, markdown-text
msgid ""
"Sometimes, we'd like to take apart a value by pattern matching on it but "
"still retain the value as a whole for using it in further computations:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:729
#, no-wrap
msgid ""
"total\n"
"baz : (Bool,Weekday,String) -> (Nat,Bool,Weekday,String)\n"
"baz t@(_,_,s) = (length s, t)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:741
#, markdown-text
msgid ""
"In `baz`, variable `t` is *bound* to the triple as a whole, which is then "
"reused to construct the resulting quadruple. Remember, that "
"`(Nat,Bool,Weekday,String)` is just sugar for `Pair Nat "
"(Bool,Weekday,String)`, and `(length s, t)` is just sugar for `MkPair "
"(length s) t`. Hence, the implementation above is correct as is confirmed by "
"the type checker."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:748
#, markdown-text, no-wrap
msgid ""
"1. Define a record type for time spans by pairing a `UnitOfTime`\n"
"with an integer representing the duration of the time span in\n"
"the given unit of time. Define also a function for converting\n"
"a time span to an `Integer` representing the duration in seconds.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:752
#, markdown-text, no-wrap
msgid ""
"2. Implement an equality check for time spans: Two time spans\n"
"should be considered equal, if and only if they correspond to\n"
"the same number of seconds.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:757
#, markdown-text, no-wrap
msgid ""
"3. Implement a function for pretty printing time spans:\n"
"The resulting string should display the time span in its\n"
"given unit, plus show the number of seconds in parentheses,\n"
"if the unit is not already seconds.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:761
#, markdown-text, no-wrap
msgid ""
"4. Implement a function for adding two time spans. If the\n"
"two time spans use different units of time, use the smaller\n"
"unit of time to ensure a lossless conversion.\n"
msgstr ""

#. type: Title ##
#: ../src/Tutorial/DataTypes.md:762
#, markdown-text, no-wrap
msgid "Generic Data Types"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:772
#, markdown-text
msgid ""
"Sometimes, a concept is general enough that we'd like to apply it not only "
"to a single type, but to all kinds of types. For instance, we might not want "
"to define data types for lists of integers, lists of strings, and lists of "
"booleans, as this would lead to a lot of code duplication.  Instead, we'd "
"like to have a single generic list type *parameterized* by the type of "
"values it stores. This section explains how to define and use generic types."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:773
#, markdown-text, no-wrap
msgid "Maybe"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:786
#, markdown-text
msgid ""
"Consider the case of parsing a `Weekday` from user input. Surely, such a "
"function should return `Saturday`, if the string input was `\"Saturday\"`, "
"but what if the input was `\"sdfkl332\"`? We have several options here.  For "
"instance, we could just return a default result (`Sunday` perhaps?). But is "
"this the behavior programmers expect when using our library? Maybe not. To "
"silently continue with a default value in the face of invalid user input is "
"hardly ever the best choice and may lead to a lot of confusion."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:792
#, markdown-text
msgid ""
"In an imperative language, our function would probably throw an "
"exception. We could do this in Idris as well (there is function "
"`idris_crash` in the *Prelude* for this), but doing so, we would abandon "
"totality! A high price to pay for such a common thing as a parsing error."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:803
#, markdown-text
msgid ""
"In languages like Java, our function might also return some kind of `null` "
"value (leading to the dreaded `NullPointerException`s if not handled "
"properly in client code). Our solution will be similar, but instead of "
"silently returning `null`, we will make the possibility of failure visible "
"in the types! We define a custom data type, which encapsulates the "
"possibility of failure. Defining new data types in Idris is very cheap (in "
"terms of the amount of code needed), therefore this is often the way to go "
"in order to increase type safety.  Here's an example how to do this:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:804
#, no-wrap
msgid ""
"data MaybeWeekday = WD Weekday | NoWeekday\n"
"\n"
"total\n"
"readWeekday : String -> MaybeWeekday\n"
"readWeekday \"Monday\"    = WD Monday\n"
"readWeekday \"Tuesday\"   = WD Tuesday\n"
"readWeekday \"Wednesday\" = WD Wednesday\n"
"readWeekday \"Thursday\"  = WD Thursday\n"
"readWeekday \"Friday\"    = WD Friday\n"
"readWeekday \"Saturday\"  = WD Saturday\n"
"readWeekday \"Sunday\"    = WD Sunday\n"
"readWeekday _           = NoWeekday\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:823
#, markdown-text
msgid ""
"But assume now, we'd also like to read `Bool` values from user input. We'd "
"now have to write a custom data type `MaybeBool` and so on for all types "
"we'd like to read from `String`, and the conversion of which might fail."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:827
#, markdown-text
msgid ""
"Idris, like many other programming languages, allows us to generalize this "
"behavior by using *generic data types*. Here's an example:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:828
#, no-wrap
msgid ""
"data Option a = Some a | None\n"
"\n"
"total\n"
"readBool : String -> Option Bool\n"
"readBool \"True\"    = Some True\n"
"readBool \"False\"   = Some False\n"
"readBool _         = None\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:839
#, markdown-text
msgid "It is important to go to the REPL and look at the types:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/DataTypes.md:840
#, no-wrap
msgid ""
"Tutorial.DataTypes> :t Some\n"
"Tutorial.DataTypes.Some : a -> Option a\n"
"Tutorial.DataTypes> :t None\n"
"Tutorial.DataTypes.None : Optin a\n"
"Tutorial.DataTypes> :t Option\n"
"Tutorial.DataTypes.Option : Type -> Type\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:857
#, markdown-text
msgid ""
"We need to introduce some jargon here. `Option` is what we call a *type "
"constructor*. It is not yet a saturated type: It is a function from `Type` "
"to `Type`.  However, `Option Bool` is a type, as is `Option Weekday`.  Even "
"`Option (Option Bool)` is a valid type. `Option` is a type constructor "
"*parameterized* over a *parameter* of type `Type`.  `Some` and `None` are "
"`Option`s *data constructors*: The functions used to create values of type "
"`Option a` for a type `a`."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:860
#, markdown-text
msgid ""
"Let's see some other use cases for `Option`. Below is a safe division "
"operation:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:861
#, no-wrap
msgid ""
"total\n"
"safeDiv : Integer -> Integer -> Option Integer\n"
"safeDiv n 0 = None\n"
"safeDiv n k = Some (n `div` k)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:872
#, markdown-text
msgid ""
"The possibility of returning some kind of *null* value in the face of "
"invalid input is so common, that there is a data type like `Option` already "
"in the *Prelude*: `Maybe`, with data constructors `Just` and `Nothing`."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:884
#, markdown-text
msgid ""
"It is important to understand the difference between returning `Maybe "
"Integer` in a function, which might fail, and returning `null` in languages "
"like Java: In the former case, the possibility of failure is visible in the "
"types. The type checker will force us to treat `Maybe Integer` differently "
"than `Integer`: Idris will *not* allow us to forget to eventually handle the "
"failure case.  Not so, if `null` is silently returned without adjusting the "
"types. Programmers may (and often *will*) forget to handle the `null` case, "
"leading to unexpected and sometimes hard to debug runtime exceptions."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:885
#, markdown-text, no-wrap
msgid "Either"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:896
#, markdown-text
msgid ""
"While `Maybe` is very useful to quickly provide a default value to signal "
"some kind of failure, this value (`Nothing`) is not very informative. It "
"will not tell us *what exactly* went wrong. For instance, in case of our "
"`Weekday` reading function, it might be interesting later on to know the "
"value of the invalid input string. And just like with `Maybe` and `Option` "
"above, this concept is general enough that we might encounter other types of "
"invalid values.  Here's a data type to encapsulate this:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:897
#, no-wrap
msgid "data Validated e a = Invalid e | Valid a\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:907
#, markdown-text
msgid ""
"`Validated` is a type constructor parameterized over two type parameters `e` "
"and `a`. It's data constructors are `Invalid` and `Valid`, the former "
"holding a value describing some error condition, the latter the result in "
"case of a successful computation.  Let's see this in action:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:908
#, no-wrap
msgid ""
"total\n"
"readWeekdayV : String -> Validated String Weekday\n"
"readWeekdayV \"Monday\"    = Valid Monday\n"
"readWeekdayV \"Tuesday\"   = Valid Tuesday\n"
"readWeekdayV \"Wednesday\" = Valid Wednesday\n"
"readWeekdayV \"Thursday\"  = Valid Thursday\n"
"readWeekdayV \"Friday\"    = Valid Friday\n"
"readWeekdayV \"Saturday\"  = Valid Saturday\n"
"readWeekdayV \"Sunday\"    = Valid Sunday\n"
"readWeekdayV s           = Invalid (\"Not a weekday: \" ++ s)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:929
#, markdown-text
msgid ""
"Again, this is such a general concept that a data type similar to "
"`Validated` is already available from the *Prelude*: `Either` with data "
"constructors `Left` and `Right`.  It is very common for functions to "
"encapsulate the possibility of failure by returning an `Either err val`, "
"where `err` is the error type and `val` is the desired return type. This is "
"the type safe (and total!) alternative to throwing a catchable exception in "
"an imperative language."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:934
#, markdown-text
msgid ""
"Note, however, that the semantics of `Either` are not always \"`Left` is an "
"error and `Right` a success\". A function returning an `Either` just means "
"that it can have to different types of results, each of which are *tagged* "
"with the corresponding data constructor."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:935
#, markdown-text, no-wrap
msgid "List"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:941
#, markdown-text
msgid ""
"One of the most important data structures in pure functional programming is "
"the singly linked list. Here is its definition (called `Seq` in order for it "
"not to collide with `List`, which is of course already available from the "
"Prelude):"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:942
#, no-wrap
msgid "data Seq a = Nil | (::) a (Seq a)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:953
#, markdown-text
msgid ""
"This calls for some explanations. `Seq` consists of two *data constructors*: "
"`Nil` (representing an empty sequence of values) and `(::)` (also called the "
"*cons operator*), which prepends a new value of type `a` to an already "
"existing list of values of the same type. As you can see, we can also use "
"operators as data constructors, but please do not overuse this. Use clear "
"names for your functions and data constructors and only introduce new "
"operators when it truly helps readability!"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:956
#, markdown-text
msgid ""
"Here is an example of how to use the `List` constructors (I use `List` here, "
"as this is what you should use in your own code):"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:957
#, no-wrap
msgid ""
"total\n"
"ints : List Int64\n"
"ints = 1 :: 2 :: -3 :: Nil\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:966
#, markdown-text
msgid ""
"However, there is a more concise way of writing the above. Idris accepts "
"special syntax for constructing data types consisting exactly of the two "
"constructors `Nil` and `(::)`:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:967
#, no-wrap
msgid ""
"total\n"
"ints2 : List Int64\n"
"ints2 = [1, 2, -3]\n"
"\n"
"total\n"
"ints3 : List Int64\n"
"ints3 = []\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:980
#, markdown-text
msgid ""
"The two definitions `ints` and `ints2` are treated identically by the "
"compiler.  Note, that list syntax can also be used in pattern matches."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:991
#, markdown-text
msgid ""
"There is another thing that's special about `Seq` and `List`: Each of them "
"is defined in terms of itself (the cons operator accepts a value and another "
"`Seq` as arguments). We call such data types *recursive* data types, and "
"their recursive nature means, that in order to decompose or consume them, we "
"typically require recursive functions. In an imperative language, we might "
"use a for loop or similar construct to iterate over the values of a `List` "
"or a `Seq`, but these things do not exist in a language without in-place "
"mutation. Here's how to sum a list of integers:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:992
#, no-wrap
msgid ""
"total\n"
"intSum : List Integer -> Integer\n"
"intSum Nil       = 0\n"
"intSum (n :: ns) = n + intSum ns\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1004
#, markdown-text
msgid ""
"Recursive functions can be hard to grasp at first, so I'll break this down a "
"bit. If we invoke `intSum` with the empty list, the first pattern matches "
"and the function returns zero immediately.  If, however, we invoke `intSum` "
"with a non-empty list - `[7,5,9]` for instance - the following happens:"
msgstr ""

#. type: Bullet: '1. '
#: ../src/Tutorial/DataTypes.md:1008
#, markdown-text
msgid ""
"The second pattern matches and splits the list into two parts: Its head "
"(`7`) is bound to variable `n` and its tail (`[5,9]`) is bound to `ns`:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/DataTypes.md:1009
#, no-wrap
msgid "   7 + intSum [5,9]\n"
msgstr ""

#. type: Bullet: '2. '
#: ../src/Tutorial/DataTypes.md:1015
#, markdown-text
msgid ""
"In a second invocation, `intSum` is called with a new list: `[5,9]`.  The "
"second pattern matches and `n` is bound to `5` and `ns` is bound to `[9]`:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/DataTypes.md:1016
#, no-wrap
msgid "   7 + (5 + intSum [9])\n"
msgstr ""

#. type: Bullet: '3. '
#: ../src/Tutorial/DataTypes.md:1023
#, markdown-text
msgid ""
"In a third invocation `intSum` is called with list `[9]`.  The second "
"pattern matches and `n` is bound to `9` and `ns` is bound to `[]`:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/DataTypes.md:1024
#, no-wrap
msgid "   7 + (5 + (9 + intSum [])\n"
msgstr ""

#. type: Bullet: '4. '
#: ../src/Tutorial/DataTypes.md:1030
#, markdown-text
msgid ""
"In a fourth invocation, `intSum` is called with list `[]` and returns `0` "
"immediately:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/DataTypes.md:1031
#, no-wrap
msgid "   7 + (5 + (9 + 0)\n"
msgstr ""

#. type: Bullet: '5. '
#: ../src/Tutorial/DataTypes.md:1037
#, markdown-text
msgid "In the third invocation, `9` and `0` are added and `9` is returned:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/DataTypes.md:1038
#, no-wrap
msgid "   7 + (5 + 9)\n"
msgstr ""

#. type: Bullet: '6. '
#: ../src/Tutorial/DataTypes.md:1044
#, markdown-text
msgid "In the second invocation, `5` and `9` are added and `14` is returned:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/DataTypes.md:1045
#, no-wrap
msgid "   7 + 14\n"
msgstr ""

#. type: Bullet: '7. '
#: ../src/Tutorial/DataTypes.md:1051
#, markdown-text
msgid ""
"Finally, our initial invocation of `intSum` adds `7` and `14` and returns "
"`21`."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1055
#, markdown-text
msgid ""
"Thus, the recursive implementation of `intSum` leads to a sequence of nested "
"calls to `intSum`, which terminates once the argument is the empty list."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:1056
#, markdown-text, no-wrap
msgid "Generic Functions"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1062
#, markdown-text
msgid ""
"In order to fully appreciate the versatility that comes with generic data "
"types, we also need to talk about generic functions.  Like generic types, "
"these are parameterized over one or more type parameters."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1068
#, markdown-text
msgid ""
"Consider for instance the case of breaking out of the `Option` data type. In "
"case of a `Some`, we'd like to return the stored value, while for the `None` "
"case we provide a default value. Here's how to do this, specialized to "
"`Integer`s:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:1069
#, no-wrap
msgid ""
"total\n"
"integerFromOption : Integer -> Option Integer -> Integer\n"
"integerFromOption _ (Some y) = y\n"
"integerFromOption x None     = x\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1080
#, markdown-text
msgid ""
"It's pretty obvious that this, again, is not general enough.  Surely, we'd "
"also like to break out of `Option Bool` or `Option String` in a similar "
"fashion. That's exactly what the generic function `fromOption` does:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:1081
#, no-wrap
msgid ""
"total\n"
"fromOption : a -> Option a -> a\n"
"fromOption _ (Some y) = y\n"
"fromOption x None     = x\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1095
#, markdown-text
msgid ""
"The lower-case `a` is again a *type parameter*. You can read the type "
"signature as follows: \"For any type `a`, given a *value* of type `a`, and "
"an `Option a`, we can return a value of type `a`.\" Note, that `fromOption` "
"knows nothing else about `a`, other than it being a type. It is therefore "
"not possible, to conjure a value of type `a` out of thin air. We *must* have "
"a value available to deal with the `None` case."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1098
#, markdown-text
msgid ""
"The pendant to `fromOption` for `Maybe` is called `fromMaybe` and is "
"available from module `Data.Maybe` from the *base* library."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1104
#, markdown-text
msgid ""
"Sometimes, `fromOption` is not general enough. Assume we'd like to print the "
"value of a freshly parsed `Bool`, giving some generic error message in case "
"of a `None`. We can't use `fromOption` for this, as we have an `Option Bool` "
"and we'd like to return a `String`. Here's how to do this:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:1105
#, no-wrap
msgid ""
"total\n"
"option : b -> (a -> b) -> Option a -> b\n"
"option _ f (Some y) = f y\n"
"option x _ None     = x\n"
"\n"
"total\n"
"handleBool : Option Bool -> String\n"
"handleBool = option \"Not a boolean value.\" show\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1121
#, markdown-text, no-wrap
msgid ""
"Function `option` is parameterized over *two* type parameters:\n"
"`a` represents the type of values stored in the `Option`,\n"
"while `b` is the return type. In case of a `Just`, we need\n"
"a way to convert the stored `a` to a `b`, an that's done\n"
"using the function argument of type `a -> b`.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1126
#, markdown-text
msgid ""
"In Idris, lower-case identifiers in function types are treated as *type "
"parameters*, while upper-case identifiers are treated as types or type "
"constructors that must be in scope."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:1127 ../src/Tutorial/Eq.md:1056
#, markdown-text, no-wrap
msgid "Exercises part 4"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1137
#, markdown-text
msgid ""
"If this is your first time programming in a purely functional language, the "
"exercises below are *very* important. Do not skip any of them! Take your "
"time and work through them all. In most cases, the types should be enough to "
"explain what's going on, even though they might appear cryptic in the "
"beginning. Otherwise, have a look at the comments (if any)  of each "
"exercise."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1140
#, markdown-text
msgid ""
"Remember, that lower-case identifiers in a function signature are treated as "
"type parameters."
msgstr ""

#. type: Bullet: '1. '
#: ../src/Tutorial/DataTypes.md:1142
#, markdown-text
msgid "Implement the following generic functions for `Maybe`:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:1143
#, no-wrap
msgid ""
"   -- make sure to map a `Just` to a `Just`.\n"
"   total\n"
"   mapMaybe : (a -> b) -> Maybe a -> Maybe b\n"
"\n"
"   -- Example: `appMaybe (Just (+2)) (Just 20) = Just 22`\n"
"   total\n"
"   appMaybe : Maybe (a -> b) -> Maybe a -> Maybe b\n"
"\n"
"   -- Example: `bindMaybe (Just 12) Just = Just 12`\n"
"   total\n"
"   bindMaybe : Maybe a -> (a -> Maybe b) -> Maybe b\n"
"\n"
"   -- keep the value in a `Just` only if the given predicate holds\n"
"   total\n"
"   filterMaybe : (a -> Bool) -> Maybe a -> Maybe a\n"
"\n"
"   -- keep the first value that is not a `Nothing` (if any)\n"
"   total\n"
"   first : Maybe a -> Maybe a -> Maybe a\n"
"\n"
"   -- keep the last value that is not a `Nothing` (if any)\n"
"   total\n"
"   last : Maybe a -> Maybe a -> Maybe a\n"
"\n"
"   -- this is another general way to extract a value from a `Maybe`.\n"
"   -- Make sure the following holds:\n"
"   -- `foldMaybe (+) 5 Nothing = 5`\n"
"   -- `foldMaybe (+) 5 (Just 12) = 17`\n"
"   total\n"
"   foldMaybe : (acc -> el -> acc) -> acc -> Maybe el -> acc\n"
msgstr ""

#. type: Bullet: '2. '
#: ../src/Tutorial/DataTypes.md:1177
#, markdown-text
msgid "Implement the following generic functions for `Either`:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:1178
#, no-wrap
msgid ""
"   total\n"
"   mapEither : (a -> b) -> Either e a -> Either e b\n"
"\n"
"   -- In case of both `Either`s being `Left`s, keep the\n"
"   -- value stored in the first `Left`.\n"
"   total\n"
"   appEither : Either e (a -> b) -> Either e a -> Either e b\n"
"\n"
"   total\n"
"   bindEither : Either e a -> (a -> Either e b) -> Either e b\n"
"\n"
"   -- Keep the first value that is not a `Left`\n"
"   -- If both `Either`s are `Left`s, use the given accumulator\n"
"   -- for the error values\n"
"   total\n"
"   firstEither : (e -> e -> e) -> Either e a -> Either e a -> Either e a\n"
"\n"
"   -- Keep the last value that is not a `Left`\n"
"   -- If both `Either`s are `Left`s, use the given accumulator\n"
"   -- for the error values\n"
"   total\n"
"   lastEither : (e -> e -> e) -> Either e a -> Either e a -> Either e a\n"
"\n"
"   total\n"
"   fromEither : (e -> c) -> (a -> c) -> Either e a -> c\n"
msgstr ""

#. type: Bullet: '3. '
#: ../src/Tutorial/DataTypes.md:1207
#, markdown-text
msgid "Implement the following generic functions for `List`:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:1208
#, no-wrap
msgid ""
"   total\n"
"   mapList : (a -> b) -> List a -> List b\n"
"\n"
"   total\n"
"   filterList : (a -> Bool) -> List a -> List a\n"
"\n"
"   -- return the first value of a list, if it is non-empty\n"
"   total\n"
"   headMaybe : List a -> Maybe a\n"
"\n"
"   -- return everything but the first value of a list, if it is non-empty\n"
"   total\n"
"   tailMaybe : List a -> Maybe (List a)\n"
"\n"
"   -- return the last value of a list, if it is non-empty\n"
"   total\n"
"   lastMaybe : List a -> Maybe a\n"
"\n"
"   -- return everything but the last value of a list,\n"
"   -- if it is non-empty\n"
"   total\n"
"   initMaybe : List a -> Maybe (List a)\n"
"\n"
"   -- accumulate the values in a list using the given\n"
"   -- accumulator function and initial value\n"
"   --\n"
"   -- Examples:\n"
"   -- `foldList (+) 10 [1,2,7] = 20`\n"
"   -- `foldList String.(++) \"\" [\"Hello\",\"World\"] = \"HelloWorld\"`\n"
"   -- `foldList last Nothing (mapList Just [1,2,3]) = Just 3`\n"
"   total\n"
"   foldList : (acc -> el -> acc) -> acc -> List el -> acc\n"
msgstr ""

#. type: Bullet: '4. '
#: ../src/Tutorial/DataTypes.md:1245
#, markdown-text
msgid "Assume we store user data for our web application in the following record:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:1246
#, no-wrap
msgid ""
"   record Client where\n"
"     constructor MkClient\n"
"     name          : String\n"
"     title         : Title\n"
"     age           : Bits8\n"
"     passwordOrKey : Either Bits64 String\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1260
#, markdown-text, no-wrap
msgid ""
"   Using `LoginError` from an earlier exercise,\n"
"   implement function `login`, which, given a list of `Client`s\n"
"   plus a value of type `Credentials` will return either a `LoginError`\n"
"   in case no valid credentials where provided, or the first `Client`\n"
"   for whom the credentials match.\n"
msgstr ""

#. type: Bullet: '5. '
#: ../src/Tutorial/DataTypes.md:1264
#, markdown-text
msgid ""
"Using your data type for chemical elements from an earlier exercise, "
"implement a function for calculating the molar mass of a molecular formula."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1268
#, markdown-text, no-wrap
msgid ""
"   Use a list of elements each paired with its count\n"
"   (a natural number) for representing formulae. For\n"
"   instance:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:1269
#, no-wrap
msgid ""
"   ethanol : List (Element,Nat)\n"
"   ethanol = [(C,2),(H,6),(O,1)]\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1276
#, markdown-text, no-wrap
msgid ""
"   Hint: You can use function `cast` to convert a natural\n"
"   number to a `Double`.\n"
msgstr ""

#. type: Title ##
#: ../src/Tutorial/DataTypes.md:1277
#, markdown-text, no-wrap
msgid "Alternative Syntax for Data Definitions"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1285
#, markdown-text
msgid ""
"While the examples in the section about parameterized data types are short "
"and concise, there is a slightly more verbose but much more general form for "
"writing such definitions, which makes it much clearer what's going on.  In "
"my opinion, this more general form should be preferred in all but the most "
"simple data definitions."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1290
#, markdown-text
msgid ""
"Here are the definitions of `Option`, `Validated`, and `Seq` again, using "
"this more general form (I put them in their own *namespace*, so Idris will "
"not complain about identical names in the same source file):"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/DataTypes.md:1291
#, no-wrap
msgid ""
"-- GADT is an acronym for \"generalized algebraic data type\"\n"
"namespace GADT\n"
"  data Option : Type -> Type where\n"
"    Some : a -> Option a\n"
"    None : Option a\n"
"\n"
"  data Validated : Type -> Type -> Type where\n"
"    Invalid : e -> Validated e a\n"
"    Valid   : a -> Validated e a\n"
"\n"
"  data Seq : Type -> Type where\n"
"    Nil  : Seq a\n"
"    (::) : a -> GADT.Seq a -> Seq a\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1318
#, markdown-text, no-wrap
msgid ""
"Here, `Option` is clearly declared as a type constructor\n"
"(a function of type `Type -> Type`), while `Some`\n"
"is a generic function of type `a -> Option a` (where `a` is\n"
"a *type parameter*)\n"
"and `None` is a nullary generic function of type `Option a`\n"
"(`a` again being a type parameter).\n"
"Likewise for `Validated` and `Seq`. Note, that in case\n"
"of `Seq` we had to disambiguate between the different\n"
"`Seq` definitions in the recursive case. Since we will\n"
"usually not define several data types with the same name in\n"
"a source file, this is not necessary most of the time.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1323
#, markdown-text
msgid ""
"We covered a lot of ground in this chapter, so I'll summarize the most "
"important points below:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1326
#, markdown-text, no-wrap
msgid ""
"* Enumerations are data types consisting of a finite\n"
"number of possible *values*.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1330
#, markdown-text, no-wrap
msgid ""
"* Sum types are data types with more than one data\n"
"constructor, where each constructor describes a\n"
"*choice* that can be made.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1333
#, markdown-text, no-wrap
msgid ""
"* Product types are data types with a single constructor\n"
"used to group several values of possibly different types.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1337
#, markdown-text, no-wrap
msgid ""
"* We use pattern matching to deconstruct immutable\n"
"values in Idris. The possible patterns correspond to\n"
"a data type's data constructors.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1341
#, markdown-text, no-wrap
msgid ""
"* We can *bind* variables to values in a pattern or\n"
"use an underscore as a placeholder for a value that's\n"
"not needed on the right hand side of an implementation.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1344
#, markdown-text, no-wrap
msgid ""
"* We can pattern match on an intermediary result by introducing\n"
"a *case block*.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1349
#, markdown-text, no-wrap
msgid ""
"* The preferred way to define new product types is\n"
"to define them as *records*, since these come with\n"
"additional syntactic conveniences for setting and\n"
"modifying individual *record fields*.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1354
#, markdown-text, no-wrap
msgid ""
"* Generic types and functions allow us generalize\n"
"certain concepts and make them available for many\n"
"types by using *type parameters* instead of\n"
"concrete types in function and type signatures.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1361
#, markdown-text, no-wrap
msgid ""
"* Common concepts like *nullary values* (`Maybe`),\n"
"computations that might fail with some error\n"
"condition (`Either`), and handling collections\n"
"of values of the same type at once (`List`) are\n"
"example use cases of generic types and functions\n"
"already provided by the *Prelude*.\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/DataTypes.md:1362 ../src/Tutorial/Dependent.md:904
#: ../src/Tutorial/Functions1.md:575 ../src/Tutorial/Functions2.md:954
#: ../src/Tutorial/IO.md:1118 ../src/Tutorial/Interfaces.md:813
#, markdown-text, no-wrap
msgid "What's next"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/DataTypes.md:1366
#, markdown-text
msgid ""
"In the [next section](Interfaces.md), we will introduce *interfaces*, "
"another approach to *function overloading*."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Dependent.md:1 ../src/Tutorial/Intro.md:76
#, markdown-text, no-wrap
msgid "Dependent Types"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:9
#, markdown-text
msgid ""
"The ability to calculate types from values, pass them as arguments to "
"functions, and return them as results from functions - in short, being a "
"dependently typed language - is one of the most distinguishing features of "
"Idris. Many of the more advanced type level extensions of languages like "
"Haskell (and quite a bit more) can be treated in one fell swoop with "
"dependent types."
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:10
#, no-wrap
msgid ""
"module Tutorial.Dependent\n"
"\n"
"%default total\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:17
#, markdown-text
msgid "Consider the following functions:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:18
#, no-wrap
msgid ""
"bogusMapList : (a -> b) -> List a -> List b\n"
"bogusMapList _ _ = []\n"
"\n"
"bogusZipList : (a -> b -> c) -> List a -> List b -> List c\n"
"bogusZipList _ _ _ = []\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:35
#, markdown-text
msgid ""
"The implementations type check, and still, they are obviously not what users "
"of our library would expect. In the first example, we'd expect the "
"implementation to apply the function argument to all values stored in the "
"list, without dropping any of them or changing their order.  The second is "
"trickier: The two list arguments might be of different length.  What are we "
"supposed to do when that's the case? Return a list of the same length as the "
"smaller of the two? Return an empty list? Or shouldn't we in most use cases "
"expect the two lists to be of the same length? How could we even describe "
"such a precondition?"
msgstr ""

#. type: Title ##
#: ../src/Tutorial/Dependent.md:36
#, markdown-text, no-wrap
msgid "Length-Indexed Lists"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:41
#, markdown-text
msgid ""
"The answer to the issues described above is of course: Dependent types.  And "
"the most common introductory example is the *vector*: A list indexed by its "
"length:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:42
#, no-wrap
msgid ""
"data Vect : (len : Nat) -> (a : Type) -> Type where\n"
"  Nil  : Vect 0 a\n"
"  (::) : (x : a) -> (xs : Vect n a) -> Vect (S n) a\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:58
#, markdown-text, no-wrap
msgid ""
"Before we move on, please compare this with the implementation of `Seq` in\n"
"the [section about algebraic data types](DataTypes.md). The constructors\n"
"are exactly the same: `Nil` and `(::)`. But there is an important "
"difference:\n"
"`Vect`, unlike `Seq` or `List`, is not a function from `Type` to `Type`, it "
"is\n"
"a function from `Nat` to `Type` to `Type`. Go ahead! Open the REPL and\n"
"verify this! The `Nat` argument (also called an *index*) represents\n"
"the *length* of the vector here.\n"
"`Nil` has type `Vect 0 a`: A vector of length\n"
"zero. *Cons* has type `a -> Vect n a -> Vect (S n) a`: It is exactly one\n"
"element longer (`S n`) than its second argument, which is of length `n`.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:61
#, markdown-text
msgid ""
"Let's experiment with this idea to gain a better understanding.  There is "
"only one way to come up with a vector of length zero:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:62
#, no-wrap
msgid ""
"ex1 : Vect 0 Integer\n"
"ex1 = Nil\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:69
#, markdown-text
msgid ""
"The following, on the other hand, leads to a type error (a pretty "
"complicated one, actually):"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:70
#, no-wrap
msgid ""
"failing \"Mismatch between: S ?n and 0.\"\n"
"  ex2 : Vect 0 Integer\n"
"  ex2 = [12]\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:80
#, markdown-text
msgid ""
"The problem: `[12]` gets desugared to `12 :: Nil`, but this has the wrong "
"type! Since `Nil` has type `Vect 0 Integer` here, `12 :: Nil` has type `Vect "
"(S 0) Integer`, which is identical to `Vect 1 Integer`. Idris verifies, at "
"compile time, that our vector is of the correct length!"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:81
#, no-wrap
msgid ""
"ex3 : Vect 1 Integer\n"
"ex3 = [12]\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:93
#, markdown-text
msgid ""
"So, we found a way to encode the *length* of a list-like data structure in "
"its *type*, and it is a *type error* if the number of elements in a vector "
"does not agree with then length given in its type. We will shortly see "
"several use cases, where this additional piece of information allows us to "
"be more precise in the types and rule out additional programming "
"mistakes. But first, we need to quickly clarify some terminology."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Dependent.md:94
#, markdown-text, no-wrap
msgid "Type Indices versus Type Parameters"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:101
#, markdown-text
msgid ""
"`Vect` is not only a generic type, parameterized over the type of elements "
"it holds, it is actually a *family of types*, each of them associated with a "
"natural number representing it's length. We also say, the type family `Vect` "
"is *indexed* by its length."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:108
#, markdown-text
msgid ""
"The difference between a type parameter and an index is, that the latter can "
"and does change across data constructors, while the former is the same for "
"all data constructors. Or, put differently, we can learn about the *value* "
"of an index by pattern matching on a *value* of the type family, while this "
"is not possible with a type parameter."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:110
#, markdown-text
msgid "Let's demonstrate this with a contrived example:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:111
#, no-wrap
msgid ""
"data Indexed : Nat -> Type where\n"
"  I0 : Indexed 0\n"
"  I3 : Indexed 3\n"
"  I4 : String -> Indexed 4\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:124
#, markdown-text
msgid ""
"Here, `Indexed` is indexed over its `Nat` argument, as values of the index "
"changes across constructors (I chose some arbitrary value for each "
"constructor), and we can learn about these values by pattern matching on "
"`Indexed` values.  We can use this, for instance, to create a `Vect` of the "
"same length as the index of `Indexed`:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:125
#, no-wrap
msgid "fromIndexed : Indexed n -> a -> Vect n a\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:133
#, markdown-text
msgid ""
"Go ahead, and try implementing this yourself! Work with holes, pattern match "
"on the `Indexed` argument, and learn about the expected output type in each "
"case by inspecting the holes and their context."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:135
#, markdown-text
msgid "Here is my implementation:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:136
#, no-wrap
msgid ""
"fromIndexed I0     va = []\n"
"fromIndexed I3     va = [va, va, va]\n"
"fromIndexed (I4 _) va = [va, va, va, va]\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:146
#, markdown-text
msgid ""
"As you can see, by pattern matching on the value of the `Indexed n` "
"argument, we learned about the value of the `n` index itself, which was "
"necessary to return a `Vect` of the correct length."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Dependent.md:147
#, markdown-text, no-wrap
msgid "Length-Preserving `map`"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:154
#, markdown-text
msgid ""
"Function `bogusMapList` behaved unexpectedly, because it always returned the "
"empty list. With `Vect`, we need to be true to the types here. If we map "
"over a `Vect`, the argument *and* output type contain a length index, and "
"these length indices will tell us *exactly*, if and how the lengths of our "
"vectors are modified:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:155
#, no-wrap
msgid ""
"map3_1 : (a -> b) -> Vect 3 a -> Vect 1 b\n"
"map3_1 f [_,y,_] = [f y]\n"
"\n"
"map5_0 : (a -> b) -> Vect 5 a -> Vect 0 b\n"
"map5_0 f _ = []\n"
"\n"
"map5_10 : (a -> b) -> Vect 5 a -> Vect 10 b\n"
"map5_10 f [u,v,w,x,y] = [f u, f u, f v, f v, f w, f w, f x, f x, f y, f y]\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:173
#, markdown-text
msgid ""
"While these examples are quite interesting, they are not really useful, are "
"they? That's because they are too specialized. We'd like to have a *general* "
"function for mapping vectors of any length.  Instead of using concrete "
"lengths in type signatures, we can also use *variables* as already seen in "
"the definition of `Vect`.  This allows us to declare the general case:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:174
#, no-wrap
msgid "mapVect' : (a -> b) -> Vect n a -> Vect n b\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:181
#, markdown-text
msgid ""
"This type describes a length-preserving map. It is actually more instructive "
"(but not necessary) to include the implicit arguments as well:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:182
#, no-wrap
msgid "mapVect : {0 a,b : _} -> {0 n : Nat} -> (a -> b) -> Vect n a -> Vect n b\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:196
#, markdown-text
msgid ""
"We ignore the two type parameters `a`, and `b`, as these just describe a "
"generic function (note, however, that we can group arguments of the same "
"type and quantity in a single pair of curly braces; this is optional, but it "
"sometimes helps making type signatures a bit shorter). The implicit argument "
"of type `Nat`, however, tells us that the input and output `Vect` are of the "
"same length. It is a type error to not uphold to this contract. When "
"implementing `mapVect`, it is very instructive to follow along and use some "
"holes. In order to get *any* information about the length of the `Vect` "
"argument, we need to pattern match on it:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Dependent.md:197
#, no-wrap
msgid ""
"mapVect _ Nil       = ?impl_0\n"
"mapVect f (x :: xs) = ?impl_1\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:203
#, markdown-text
msgid "At the REPL, we learn the following:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Dependent.md:204
#, no-wrap
msgid ""
"Tutorial.Dependent> :t impl_0\n"
" 0 a : Type\n"
" 0 b : Type\n"
" 0 n : Nat\n"
"------------------------------\n"
"impl_0 : Vect 0 b\n"
"\n"
"\n"
"Tutorial.Dependent> :t impl_1\n"
" 0 a : Type\n"
" 0 b : Type\n"
"   x : a\n"
"   xs : Vect n a\n"
"   f : a -> b\n"
" 0 n : Nat\n"
"------------------------------\n"
"impl_1 : Vect (S n) b\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:226
#, markdown-text
msgid ""
"The first hole, `impl_0` is of type `Vect 0 b`. There is only one such "
"value, as discussed above:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:227
#, no-wrap
msgid "mapVect _ Nil       = Nil\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:238
#, markdown-text
msgid ""
"The second case is again more interesting. We note, that `xs` is of type "
"`Vect n a`, for an arbitrary length `n` (given as an erased argument), while "
"the result is of type `Vect (S n) b`. So, the result has to be one element "
"longer than `xs`. Luckily, we already have a value of type `a` (bound to "
"variable `x`) and a function from `a` to `b` (bound to variable `f`), so we "
"can apply `f` to `x` and prepend the result to a yet unknown remainder:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Dependent.md:239
#, no-wrap
msgid "mapVect f (x :: xs) = f x :: ?rest\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:244
#, markdown-text
msgid "Let's inspect the new hole at the REPL:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Dependent.md:245
#, no-wrap
msgid ""
"Tutorial.Dependent> :t rest\n"
" 0 a : Type\n"
" 0 b : Type\n"
"   x : a\n"
"   xs : Vect n a\n"
"   f : a -> b\n"
" 0 n : Nat\n"
"------------------------------\n"
"rest : Vect n b\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:265
#, markdown-text
msgid ""
"Now, we have a `Vect n a` and need a `Vect n b`, without knowing anything "
"else about `n`. We *could* learn more about `n` by pattern matching further "
"on `xs`, but this would quickly lead us down a rabbit hole, since after such "
"a pattern match, we'd end up with another `Nil` case and another *cons* "
"case, with a new tail of unknown length. Instead, we can invoke `mapVect` "
"recursively to convert the remainder (`xs`) to a `Vect n b`.  The type "
"checker guarantees, that the lengths of `xs` and `mapVect f xs` are the "
"same, so the whole expression type checks and we are done:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:266
#, no-wrap
msgid "mapVect f (x :: xs) = f x :: mapVect f xs\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Dependent.md:270
#, markdown-text, no-wrap
msgid "Zipping Vectors"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:277
#, markdown-text
msgid ""
"Let us now have a look at `bogusZipList`: We'd like to pairwise merge two "
"lists holding elements of (possibly) distinct types through a given binary "
"function. As discussed above, the most reasonable thing to do is to expect "
"the two lists as well as the result to be of equal length.  With `Vect`, "
"this can be expressed and implemented as follows:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:278
#, no-wrap
msgid ""
"zipWith : (a -> b -> c) -> Vect n a -> Vect n b -> Vect n c\n"
"zipWith f []        []         = Nil\n"
"zipWith f (x :: xs) (y :: ys)  = f x y :: zipWith f xs ys\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:295
#, markdown-text
msgid ""
"Now, here is an interesting thing: The totality checker (activated "
"throughout this source file due to the initial `%default total` pragma)  "
"accepts the above implementation as being total, although it is missing two "
"more cases. This works, because Idris can figure out on its own, that the "
"other two cases are *impossible*.  From the pattern match on the first "
"`Vect` argument, Idris learns whether `n` is zero or the successor of "
"another natural number. But from this it can derive, whether the second "
"vector, being also of length `n`, is a `Nil` or a *cons*. Still, it can be "
"informative to add the impossible cases explicitly. We can use keyword "
"`impossible` to do so:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:296
#, no-wrap
msgid ""
"zipWith _ [] (_ :: _) impossible\n"
"zipWith _ (_ :: _) [] impossible\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:306
#, markdown-text
msgid ""
"It is - of course - a type error to annotate a case in a pattern match with "
"`impossible`, if Idris cannot verify that this case is indeed impossible. We "
"will learn in a later section what to do, when we think we are right about "
"an impossible case and Idris is not."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:308
#, markdown-text
msgid "Let's give `zipWith` a spin at the REPL:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Dependent.md:309
#, no-wrap
msgid ""
"Tutorial.Dependent> zipWith (*) [1,2,3] [10,20,30]\n"
"[10, 40, 90]\n"
"Tutorial.Dependent> zipWith (\\x,y => x ++ \": \" ++ show y) [\"The "
"answer\"] [42]\n"
"[\"The answer: 42\"]\n"
"Tutorial.Dependent> zipWith (*) [1,2,3] [10,20]\n"
"... Nasty type error ...\n"
msgstr ""

#. type: Title ####
#: ../src/Tutorial/Dependent.md:318
#, markdown-text, no-wrap
msgid "Simplifying Type Errors"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:329
#, markdown-text
msgid ""
"It is amazing to experience the amount of work Idris can do for us and the "
"amount of things it can infer on its own when things go well. When things "
"don't go well, however, the error messages we get from Idris can be quite "
"long and hard to understand, especially for programmers new to the "
"language. For instance, the error message in the last REPL example above was "
"pretty long, listing different things Idris tried to do together with the "
"reason why each of them failed."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:341
#, markdown-text
msgid ""
"If this happens, it often means that a combination of a type error and an "
"ambiguity resulting from overloaded function names is at work. In the "
"example above, the two vectors are of distinct length, which leads to a type "
"error if we interpret the list literals as vectors. However, list literals "
"are overloaded to work with all data types with constructors `Nil` and "
"`(::)`, so Idris will now try other data constructors than those of `Vect` "
"(the ones of `List` and `Stream` from the *Prelude* in this case), each of "
"which will again fail with a type error since `zipWith` expects arguments of "
"type `Vect`, and neither `List` nor `Stream` will work."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:345
#, markdown-text
msgid ""
"If this happens, prefixing overloaded function names with their namespaces "
"can often simplify things, as Idris no longer needs to disambiguate these "
"functions:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Dependent.md:346
#, no-wrap
msgid ""
"Tutorial.Dependent> zipWith (*) (Dependent.(::) 1 Dependent.Nil) "
"Dependent.Nil\n"
"Error: When unifying:\n"
"    Vect 0 ?c\n"
"and:\n"
"    Vect 1 ?c\n"
"Mismatch between: 0 and 1.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:360
#, markdown-text
msgid ""
"Here, the message is much clearer: Idris can't *unify* the lengths of the "
"two vectors. *Unification* means: Idris tries to at compile time convert two "
"expressions to the same normal form. If this succeeds, the two expressions "
"are considered to be equivalent, if it doesn't, Idris fails with a "
"unification error."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:363
#, markdown-text
msgid ""
"As an alternative to prefixing overloaded functions with their namespace, we "
"can use `the` to help with type inference:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Dependent.md:364
#, no-wrap
msgid ""
"Tutorial.Dependent> zipWith (*) (the (Vect 3 _) [1,2,3]) (the (Vect 2 _) "
"[10,20])\n"
"Error: When unifying:\n"
"    Vect 2 ?c\n"
"and:\n"
"    Vect 3 ?c\n"
"Mismatch between: 0 and 1.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:379
#, markdown-text
msgid ""
"It is interesting to note, that the error above is not \"Mismatch between: 2 "
"and 3\" but \"Mismatch between: 0 and 1\" instead. Here's what's going on: "
"Idris tries to unify integer literals `2` and `3`, which are first converted "
"to the corresponding `Nat` values `S (S Z)` and `S (S (S Z))`, "
"respectively.  The two patterns match until we arrive at `Z` vs `S Z`, "
"corresponding to values `0` and `1`, which is the discrepancy reported in "
"the error message."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Dependent.md:380
#, markdown-text, no-wrap
msgid "Creating Vectors"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:387
#, markdown-text
msgid ""
"So far, we were able to learn something about the lengths of vectors by "
"pattern matching on them. In the `Nil` case, it was clear that the length is "
"0, while in the *cons* case the length was the successor of another natural "
"number.  This is not possible when we want to create a new vector:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:388
#, no-wrap
msgid ""
"failing \"Mismatch between: S ?n and n.\"\n"
"  fill : a -> Vect n a\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:395
#, markdown-text
msgid ""
"You will have a hard time implementing `fill`. The following, for instance, "
"leads to a type error:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:396
#, no-wrap
msgid "  fill va = [va,va]\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:403
#, markdown-text
msgid ""
"The problem is, that *the callers of our function decide about the length of "
"the resulting vector*. The full type of `fill` is actually the following:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:404
#, no-wrap
msgid "fill' : {0 a : Type} -> {0 n : Nat} -> a -> Vect n a\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:415
#, markdown-text
msgid ""
"You can read this type as follows: For every type `a` and for every natural "
"number `n` (about which I know *nothing* at runtime, since it has quantity "
"zero), given a value of type `a`, I'll give you a vector holding exactly `n` "
"elements of type `a`. This is like saying: \"Think about a natural number "
"`n`, and I'll give you `n` apples without you telling me the value of "
"`n`\".  Idris is powerful, but it is not a clairvoyant."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:420
#, markdown-text
msgid ""
"In order to implement `fill`, we need to know what `n` actually is: We need "
"to pass `n` as an explicit, unerased argument, which will allow us to "
"pattern match on it and decide - based on this pattern match - which "
"constructors of `Vect` to use:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:421
#, no-wrap
msgid "replicate : (n : Nat) -> a -> Vect n a\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:428
#, markdown-text
msgid ""
"Now, `replicate` is a *dependent function type*: The output type *depends* "
"on the value of one of the arguments. It is straight forward to implement "
"`replicate` by pattern matching on `n`:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:429
#, no-wrap
msgid ""
"replicate 0     _  = []\n"
"replicate (S k) va = va :: replicate k va\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:443
#, markdown-text
msgid ""
"This is a pattern that comes up often when working with indexed types: We "
"can learn about the values of the indices by pattern matching on the values "
"of the type family. However, in order to return a value of the type family "
"from a function, we need to either know the values of the indices at compile "
"time (see constants `ex1` or `ex3`, for instance), or we need to have access "
"to the values of the indices at runtime, in which case we can pattern match "
"on them and learn from this, which constructor(s) of the type family to use."
msgstr ""

#. type: Bullet: '1. '
#: ../src/Tutorial/Dependent.md:447
#, markdown-text
msgid "Implement function `head` for non-empty vectors:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:448
#, no-wrap
msgid "   head : Vect (S n) a -> a\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:457
#, markdown-text, no-wrap
msgid ""
"   Note, how we can describe non-emptiness by using a *pattern*\n"
"   in the length of `Vect`. This rules out the `Nil` case, and we can\n"
"   return a value of type `a`, without having to wrap it in\n"
"   a `Maybe`! Make sure to add an `impossible` clause for the `Nil`\n"
"   case (although this is not strictly necessary here).\n"
msgstr ""

#. type: Bullet: '2. '
#: ../src/Tutorial/Dependent.md:461
#, markdown-text
msgid ""
"Using `head` as a reference, declare and implement function `tail` for "
"non-empty vectors. The types should reflect that the output is exactly one "
"element shorter than the input."
msgstr ""

#. type: Bullet: '3. '
#: ../src/Tutorial/Dependent.md:464
#, markdown-text
msgid ""
"Implement `zipWith3`. If possible, try to doing so without looking at the "
"implementation of `zipWith`:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:465
#, no-wrap
msgid ""
"   zipWith3 : (a -> b -> c -> d) -> Vect n a -> Vect n b -> Vect n c -> Vect "
"n d\n"
msgstr ""

#. type: Bullet: '4. '
#: ../src/Tutorial/Dependent.md:474
#, markdown-text
msgid ""
"Declare and implement a function `foldSemi` for accumulating the values "
"stored in a `List` through `Semigroup`s append operator (`(<+>)`).  (Make "
"sure to only use a `Semigroup` constraint, as opposed to a `Monoid` "
"constraint.)"
msgstr ""

#. type: Bullet: '5. '
#: ../src/Tutorial/Dependent.md:477
#, markdown-text
msgid ""
"Do the same as in Exercise 4, but for non-empty vectors. How does a vector's "
"non-emptiness affect the output type?"
msgstr ""

#. type: Bullet: '6. '
#: ../src/Tutorial/Dependent.md:482
#, markdown-text
msgid ""
"Given an initial value of type `a` and a function `a -> a`, we'd like to "
"generate `Vect`s of `a`s, the first value of which is `a`, the second value "
"being `f a`, the third being `f (f a)` and so on."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:485
#, markdown-text, no-wrap
msgid ""
"   For instance, if `a` is 1 and `f` is `(* 2)`, we'd like\n"
"   to get results similar to the following: `[1,2,4,8,16,...]`.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:489
#, markdown-text, no-wrap
msgid ""
"   Declare and implement function `iterate`, which should\n"
"   encapsulate this behavior. Get some inspiration from `replicate`\n"
"   if you don't know where to start.\n"
msgstr ""

#. type: Bullet: '7. '
#: ../src/Tutorial/Dependent.md:495
#, markdown-text
msgid ""
"Given an initial value of a state type `s` and a function `fun : s -> "
"(s,a)`, we'd like to generate `Vect`s of `a`s. Declare and implement "
"function `generate`, which should encapsulate this behavior. Make sure to "
"use the updated state in every new invocation of `fun`."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:498
#, markdown-text, no-wrap
msgid ""
"   Here's an example how this can be used to generate the first\n"
"   `n` Fibonacci numbers:\n"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Dependent.md:499
#, no-wrap
msgid ""
"   generate 10 (\\(x,y) => let z = x + y in ((y,z),z)) (0,1)\n"
"   [1, 2, 3, 5, 8, 13, 21, 34, 55, 89]\n"
msgstr ""

#. type: Bullet: '8. '
#: ../src/Tutorial/Dependent.md:507
#, markdown-text
msgid ""
"Implement function `fromList`, which converts a list of values to a `Vect` "
"of the same length. Use holes if you get stuck:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:508
#, no-wrap
msgid "   fromList : (as : List a) -> Vect (length as) a\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:515
#, markdown-text, no-wrap
msgid ""
"   Note how, in the type of `fromList`, we can *calculate* the\n"
"   length of the resulting vector by passing the list argument\n"
"   to function *length*.\n"
msgstr ""

#. type: Bullet: '9. '
#: ../src/Tutorial/Dependent.md:517
#, markdown-text
msgid "Consider the following declarations:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:518
#, no-wrap
msgid ""
"   maybeSize : Maybe a -> Nat\n"
"\n"
"   fromMaybe : (m : Maybe a) -> Vect (maybeSize m) a\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:526
#, markdown-text, no-wrap
msgid ""
"   Choose a reasonable implementation for `maybeSize` and\n"
"   implement `fromMaybe` afterwards.\n"
msgstr ""

#. type: Title ##
#: ../src/Tutorial/Dependent.md:527
#, markdown-text, no-wrap
msgid "`Fin`: Safe Indexing into Vectors"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:531
#, markdown-text
msgid ""
"Consider function `index`, which tries to extract a value from a `List` at "
"the given position:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:532
#, no-wrap
msgid ""
"indexList : (pos : Nat) -> List a -> Maybe a\n"
"indexList _     []        = Nothing\n"
"indexList 0     (x :: _)  = Just x\n"
"indexList (S k) (_ :: xs) = indexList k xs\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:553
#, markdown-text
msgid ""
"Now, here is a thing to consider when writing functions like `indexList`: Do "
"we want to express the possibility of failure in the output type, or do we "
"want to restrict the accepted arguments, so the function can no longer fail? "
"These are important design decisions, especially in larger applications.  "
"Returning a `Maybe` or `Either` from a function forces client code to "
"eventually deal with the `Nothing` or `Left` case, and until this happens, "
"all intermediary results will carry the `Maybe` or `Either` stain, which "
"will make it more cumbersome to run calculations with these intermediary "
"results.  On the other hand, restricting the values accepted as input will "
"complicate the argument types and will put the burden of input validation on "
"our functions' callers, (although, at compile time we can get help from "
"Idris, as we will see when we talk about auto implicits) while keeping the "
"output pure and clean."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:558
#, markdown-text
msgid ""
"Languages without dependent types (like Haskell), can often only take the "
"route described above: To wrap the result in a `Maybe` or `Either`.  "
"However, in Idris we can often *refine* the input types to restrict the set "
"of accepted values, thus ruling out the possibility of failure."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:564
#, markdown-text
msgid ""
"Assume, as an example, we'd like to extract a value from a `Vect n a` at "
"(zero-based) index `k`. Surely, this can succeed if and only if `k` is a "
"natural number strictly smaller than the length `n` of the vector. Luckily, "
"we can express this precondition in an indexed type:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:565
#, no-wrap
msgid ""
"data Fin : (n : Nat) -> Type where\n"
"  FZ : {0 n : Nat} -> Fin (S n)\n"
"  FS : (k : Fin n) -> Fin (S n)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:577
#, markdown-text
msgid ""
"`Fin n` is the type of natural numbers strictly smaller than `n`.  It is "
"defined inductively: `FZ` corresponds to natural number *zero*, which, as "
"can be seen in its type, is strictly smaller than `S n` for any natural "
"number `n`. `FS` is the inductive case: If `k` is strictly smaller than `n` "
"(`k` being of type `Fin n`), then `FS k` is strictly smaller than `S n`."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:579
#, markdown-text
msgid "Let's come up with some values of type `Fin`:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:580
#, no-wrap
msgid ""
"fin0_5 : Fin 5\n"
"fin0_5 = FZ\n"
"\n"
"fin0_7 : Fin 7\n"
"fin0_7 = FZ\n"
"\n"
"fin1_3 : Fin 3\n"
"fin1_3 = FS FZ\n"
"\n"
"fin4_5 : Fin 5\n"
"fin4_5 = FS (FS (FS (FS FZ)))\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:597
#, markdown-text
msgid ""
"Note, that there is no value of type `Fin 0`. We will learn in a later "
"session, how to express \"there is no value of type `x`\" in a type."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:600
#, markdown-text
msgid "Let us now check, whether we can use `Fin` to safely index into a `Vect`:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:601
#, no-wrap
msgid "index : Fin n -> Vect n a -> a\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:607
#, markdown-text
msgid ""
"Before you continue, try to implement `index` yourself, making use of holes "
"if you get stuck."
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:608
#, no-wrap
msgid ""
"index FZ     (x :: _) = x\n"
"index (FS k) (_ :: xs) = index k xs\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:617
#, markdown-text
msgid ""
"Note, how there is no `Nil` case and the totality checker is still "
"happy. That's because `Nil` is of type `Vect 0 a`, but there is no value of "
"type `Fin 0`! We can verify this by adding the missing impossible clauses:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:618
#, no-wrap
msgid ""
"index FZ     Nil impossible\n"
"index (FS _) Nil impossible\n"
msgstr ""

#. type: Bullet: '1. '
#: ../src/Tutorial/Dependent.md:627
#, markdown-text
msgid ""
"Implement function `update`, which, given a function of type `a -> a`, "
"updates the value in a`Vect n a` at position `k < n`."
msgstr ""

#. type: Bullet: '2. '
#: ../src/Tutorial/Dependent.md:631
#, markdown-text
msgid ""
"Implement function `insert`, which inserts a value of type `a` at position "
"`k <= n` in a `Vect n a`. Note, that `k` is the index of the freshly "
"inserted value, so that the following holds:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Dependent.md:632
#, no-wrap
msgid "   index k (insert k v vs) = v\n"
msgstr ""

#. type: Bullet: '3. '
#: ../src/Tutorial/Dependent.md:638
#, markdown-text
msgid ""
"Implement function `delete`, which deletes a value from a vector at the "
"given index."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:641
#, markdown-text, no-wrap
msgid ""
"   This is trickier than Exercises 1 and 2, as we have to properly\n"
"   encode in the types that the vector is getting one element shorter.\n"
msgstr ""

#. type: Bullet: '4. '
#: ../src/Tutorial/Dependent.md:644
#, markdown-text
msgid ""
"We can use `Fin` to implement safe indexing into `List`s as well. Try to "
"come up with a type and implementation for `safeIndexList`."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:648
#, markdown-text, no-wrap
msgid ""
"   Note: If you don't know how to start, look at the type of `fromList`\n"
"   for some inspiration. You might also need give the arguments in\n"
"   a different order than for `index`.\n"
msgstr ""

#. type: Bullet: '5. '
#: ../src/Tutorial/Dependent.md:653
#, markdown-text
msgid ""
"Implement function `finToNat`, which converts a `Fin n` to the corresponding "
"natural number, and use this to declare and implement function `take` for "
"splitting of the first `k` elements of a `Vect n a` with `k <= n`."
msgstr ""

#. type: Bullet: '6. '
#: ../src/Tutorial/Dependent.md:656
#, markdown-text
msgid ""
"Implement function `minus` for subtracting a value `k` from a natural number "
"`n` with `k <= n`."
msgstr ""

#. type: Bullet: '7. '
#: ../src/Tutorial/Dependent.md:660
#, markdown-text
msgid ""
"Use `minus` from Exercise 6 to declare and implement function `drop`, for "
"dropping the first `k` values from a `Vect n a`, with `k <= n`."
msgstr ""

#. type: Bullet: '8. '
#: ../src/Tutorial/Dependent.md:664
#, markdown-text
msgid ""
"Implement function `splitAt` for splitting a `Vect n a` at position `k <= "
"n`, returning the prefix and suffix of the vector wrapped in a pair."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:666
#, markdown-text, no-wrap
msgid "   Hint: Use `take` and `drop` in your implementation.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:670
#, markdown-text
msgid ""
"Hint: Since `Fin n` consists of the values strictly smaller than `n`, `Fin "
"(S n)` consists of the values smaller than or equal to `n`."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:675
#, markdown-text
msgid ""
"Note: Functions `take`, `drop`, and `splitAt`, while correct and provably "
"total, are rather cumbersome to type.  There is an alternative way to "
"declare their types, as we will see in the next section."
msgstr ""

#. type: Title ##
#: ../src/Tutorial/Dependent.md:676
#, markdown-text, no-wrap
msgid "Compile-Time Computations"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:683
#, markdown-text
msgid ""
"In the last section - especially in some of the exercises - we started more "
"and more to use compile time computations to describe the types of our "
"functions and values.  This is a very powerful concept, as it allows us to "
"compute output types from input types. Here's an example:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:690
#, markdown-text
msgid ""
"It is possible to concatenate two `List`s with the `(++)` operator. Surely, "
"this should also be possible for `Vect`. But `Vect` is indexed by its "
"length, so we have to reflect in the types exactly how the lengths of the "
"inputs affect the lengths of the output. Here's how to do this:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:691
#, no-wrap
msgid ""
"(++) : Vect m a -> Vect n a -> Vect (m + n) a\n"
"(++) []        ys = ys\n"
"(++) (x :: xs) ys = x :: (xs ++ ys)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:700
#, markdown-text
msgid ""
"Note, how we keep track of the lengths at the type-level, again ruling out "
"certain common programming errors like inadvertently dropping some values."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:705
#, markdown-text
msgid ""
"We can also use type-level computations as patterns on the input types. Here "
"is an alternative type and implementation for `drop`, which you implemented "
"in the exercises by using a `Fin n` argument:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:706
#, no-wrap
msgid ""
"drop' : (m : Nat) -> Vect (m + n) a -> Vect n a\n"
"drop' 0     xs        = xs\n"
"drop' (S k) (_ :: xs) = drop' k xs\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Dependent.md:712
#, markdown-text, no-wrap
msgid "Limitations"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:718
#, markdown-text
msgid ""
"After all the examples and exercises in this section you might have come to "
"the conclusion that we can use arbitrary expressions in the types and Idris "
"will happily evaluate and unify all of them for us."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:724
#, markdown-text
msgid ""
"I'm afraid that's not even close to the truth. The examples in this section "
"were hand-picked because they are known to *just work*. The reason being, "
"that there was always a direct link between our own pattern matches and the "
"implementations of functions we used at compile time."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:727
#, markdown-text
msgid "For instance, here is the implementation of addition of natural numbers:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:728
#, no-wrap
msgid ""
"add : Nat -> Nat -> Nat\n"
"add Z     n = n\n"
"add (S k) n = S $ add k n\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:745
#, markdown-text
msgid ""
"As you can see, `add` is implemented via a pattern match on its *first* "
"argument, while the second argument is never inspected. Note, how this is "
"exactly how `(++)` for `Vect` is implemented: There, we also pattern match "
"on the first argument, returning the second unmodified in the `Nil` case, "
"and prepending the head to the result of appending the tail in the *cons* "
"case. Since there is a direct correspondence between the two pattern "
"matches, it is possible for Idris to unify `0 + n` with `n` in the `Nil` "
"case, and `(S k) + n` with `S (k + n)` in the *cons* case."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:748
#, markdown-text
msgid ""
"Here is a simple example, where Idris will not longer be convinced without "
"some help from us:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:749
#, no-wrap
msgid ""
"failing \"Can't solve constraint\"\n"
"  reverse : Vect n a -> Vect n a\n"
"  reverse []        = []\n"
"  reverse (x :: xs) = reverse xs ++ [x]\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:768
#, markdown-text
msgid ""
"When we type-check the above, Idris will fail with the following error "
"message: \"Can't solve constraint between: plus n 1 and S n.\" Here's what's "
"going on: From the pattern match on the left hand side, Idris knows that the "
"length of the vector is `S n`, for some natural number `n` corresponding to "
"the length of `xs`. The length of the vector on the right hand side is `n + "
"1`, according to the type of `(++)` and the lengths of `xs` and "
"`[x]`. Overloaded operator `(+)` is implemented via function `Prelude.plus`, "
"that's why Idris replaces `(+)` with `plus` in the error message."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:780
#, markdown-text
msgid ""
"As you can see from the above, Idris can't verify on its own that `1 + n` is "
"the same thing as `n + 1`.  It can accept some help from us, though. If we "
"come up with a *proof* that the above equality holds (or - more generally - "
"that our implementation of addition for natural numbers is *commutative*), "
"we can use this proof to *rewrite* the types on the right hand side of "
"`reverse`. Writing proofs and using `rewrite` will require some in-depth "
"explanations and examples. Therefore, these things will have to wait until "
"another chapter."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Dependent.md:781
#, markdown-text, no-wrap
msgid "Unrestricted Implicits"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:789
#, markdown-text
msgid ""
"In functions like `replicate`, we pass a natural number `n` as an explicit, "
"unrestricted argument from which we infer the length of the vector to "
"return.  In some circumstances, `n` can be inferred from the context.  For "
"instance, in the following example it is tedious to pass `n` explicitly:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:790
#, no-wrap
msgid ""
"ex4 : Vect 3 Integer\n"
"ex4 = zipWith (*) (replicate 3 10) (replicate 3 11)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:797
#, markdown-text
msgid ""
"The value `n` is clearly derivable from the context, which can be confirmed "
"by replacing it with underscores:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:798
#, no-wrap
msgid ""
"ex5 : Vect 3 Integer\n"
"ex5 = zipWith (*) (replicate _ 10) (replicate _ 11)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:806
#, markdown-text
msgid ""
"We therefore can implement an alternative version of `replicate`, where we "
"pass `n` as an implicit argument of *unrestricted* quantity:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:807
#, no-wrap
msgid ""
"replicate' : {n : _} -> a -> Vect n a\n"
"replicate' = replicate n\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:814
#, markdown-text
msgid ""
"Note how, in the implementation of `replicate'`, we can refer to `n` and "
"pass it as an explicit argument to `replicate`."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:820
#, markdown-text
msgid ""
"Deciding whether to pass potentially inferable arguments to a function "
"implicitly or explicitly is a question of how often the arguments actually "
"*are* inferable by Idris. Sometimes it might even be useful to have both "
"verions of a function. Remember, however, that even in case of an implicit "
"argument we can still pass the value explicitly:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:821
#, no-wrap
msgid ""
"ex6 : Vect ? Bool\n"
"ex6 = replicate' {n = 2} True\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:829
#, markdown-text
msgid ""
"In the type signature above, the question mark (`?`) means, that Idris "
"should try and figure out the value on its own by unification. This forces "
"us to specify `n` explicitly on the right hand side of `ex6`."
msgstr ""

#. type: Title ####
#: ../src/Tutorial/Dependent.md:830
#, markdown-text, no-wrap
msgid "Pattern Matching on Implicits"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:836
#, markdown-text
msgid ""
"The implementation of `replicate'` makes use of function `replicate`, where "
"we could pattern match on the explicit argument `n`. However, it is also "
"possible to pattern match on implicit, named arguments of non-zero quantity:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:837
#, no-wrap
msgid ""
"replicate'' : {n : _} -> a -> Vect n a\n"
"replicate'' {n = Z}   _ = Nil\n"
"replicate'' {n = S _} v = v :: replicate'' v\n"
msgstr ""

#. type: Bullet: '1. '
#: ../src/Tutorial/Dependent.md:846
#, markdown-text
msgid "Here is a function declaration for flattening a `List` of `List`s:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Dependent.md:847
#, no-wrap
msgid "   flattenList : List (List a) -> List a\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:853
#, markdown-text, no-wrap
msgid ""
"   Implement `flattenList` and declare and implement a similar\n"
"   function `flattenVect` for flattening vectors of vectors.\n"
msgstr ""

#. type: Bullet: '2. '
#: ../src/Tutorial/Dependent.md:857
#, markdown-text
msgid ""
"Implement functions `take'` and `splitAt'` like in the exercises of the "
"previous section but using the technique shown for `drop'`."
msgstr ""

#. type: Bullet: '3. '
#: ../src/Tutorial/Dependent.md:861
#, markdown-text
msgid ""
"Implement function `transpose` for converting an `m x n`-matrix (represented "
"as a `Vect m (Vect n a)`)  to an `n x m`-matrix."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:864
#, markdown-text, no-wrap
msgid ""
"   Note: This might be a challenging exercise, but make sure\n"
"   to give it a try. As usual, make use of holes if you get stuck!\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:866
#, markdown-text, no-wrap
msgid "   Here is an example how this should work in action:\n"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Dependent.md:867
#, no-wrap
msgid ""
"   Solutions.Dependent> transpose [[1,2,3],[4,5,6]]\n"
"   [[1, 4], [2, 5], [3, 6]]\n"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Dependent.md:878
#, markdown-text
msgid ""
"Dependent types allow us to calculate types from values.  This makes it "
"possible to encode properties of values at the type-level and verify these "
"properties at compile time."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Dependent.md:882
#, markdown-text
msgid ""
"Length-indexed lists (vectors) let us rule out certain implementation "
"errors, by forcing us to be precise about the lengths of input and output "
"vectors."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Dependent.md:886
#, markdown-text
msgid ""
"We can use patterns in type signatures, for instance to express that the "
"length of a vector is non-zero and therefore, the vector is non-empty."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Dependent.md:891
#, markdown-text
msgid ""
"When creating values of a type family, the values of the indices need to be "
"known at compile time, or they need to be passed as arguments to the "
"function creating the values, where we can pattern match on them to figure "
"out, which constructors to use."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Dependent.md:894
#, markdown-text
msgid ""
"We can use `Fin n`, the type of natural numbers strictly smaller than `n`, "
"to safely index into a vector of length `n`."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Dependent.md:899
#, markdown-text
msgid ""
"Sometimes, it is convenient to pass inferable arguments as non-erased "
"implicits, in which case we can still inspect them by pattern matching or "
"pass them to other functions, while Idris will try and fill in the values "
"for us."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:903
#, markdown-text
msgid ""
"Note, that data type `Vect` together with many of the functions we "
"implemented here is available from module `Data.Vect` from the *base* "
"library. Likewise, `Fin` is available from `Data.Fin` from *base*."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Dependent.md:908
#, markdown-text
msgid ""
"In the [next section](IO.md), it is time to learn how to write effectful "
"programs and how to do this while still staying *pure*."
msgstr ""

#. type: Title #
#: ../src/Tutorial/Eq.md:1
#, markdown-text, no-wrap
msgid "Propositional Equality"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:9
#, markdown-text
msgid ""
"In the [last chapter](DPair.md) we learned, how dependent pairs and records "
"can be used to calculate *types* from values only known at runtime by "
"pattern matching on these values. We will now look at how we can describe "
"relations - or *contracts* - between values as types, and how we can use "
"values of these types as proofs that the contracts hold."
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:10
#, no-wrap
msgid ""
"module Tutorial.Eq\n"
"\n"
"import Data.Either\n"
"import Data.HList\n"
"import Data.Vect\n"
"import Data.String\n"
"\n"
"%default total\n"
msgstr ""

#. type: Title ##
#: ../src/Tutorial/Eq.md:21
#, markdown-text, no-wrap
msgid "Equality as a Type"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:26
#, markdown-text
msgid ""
"Imagine, we'd like to concatenate the contents of two CSV files, both of "
"which we stored on disk as tables together with their schemata as shown in "
"our discussion about dependent pairs:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:27
#, no-wrap
msgid ""
"data ColType = I64 | Str | Boolean | Float\n"
"\n"
"Schema : Type\n"
"Schema = List ColType\n"
"\n"
"IdrisType : ColType -> Type\n"
"IdrisType I64     = Int64\n"
"IdrisType Str     = String\n"
"IdrisType Boolean = Bool\n"
"IdrisType Float   = Double\n"
"\n"
"Row : Schema -> Type\n"
"Row = HList . map IdrisType\n"
"\n"
"record Table where\n"
"  constructor MkTable\n"
"  schema : Schema\n"
"  size   : Nat\n"
"  rows   : Vect size (Row schema)\n"
"\n"
"concatTables1 : Table -> Table -> Maybe Table\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:55
#, markdown-text
msgid ""
"We will not be able to implement `concatTables` by appending the two row "
"vectors, unless we can somehow verify that the two schemata are "
"identical. \"Well,\" I hear you say, \"that shouldn't be a big issue! Just "
"implement `Eq` for `ColType`\". Let's give this a try:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:56
#, no-wrap
msgid ""
"Eq ColType where\n"
"  I64     == I64     = True\n"
"  Str     == Str     = True\n"
"  Boolean == Boolean = True\n"
"  Float   == Float   = True\n"
"  _       == _       = False\n"
"\n"
"concatTables1 (MkTable s1 m rs1) (MkTable s2 n rs2) = case s1 == s2 of\n"
"  True  => ?what_now\n"
"  False => Nothing\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:73
#, markdown-text
msgid ""
"Somehow, this doesn't seem to work. If we inspect the context of hole "
"`what_now`, Idris still thinks that `s1` and `s2` are different, and if we "
"go ahead and invoke `Vect.(++)` anyway in the `True` case, Idris will "
"respond with a type error."
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Eq.md:74
#, no-wrap
msgid ""
"Tutorial.Relations> :t what_now\n"
"   m : Nat\n"
"   s1 : List ColType\n"
"   rs1 : Vect m (HList (map IdrisType s1))\n"
"   n : Nat\n"
"   s2 : List ColType\n"
"   rs2 : Vect n (HList (map IdrisType s2))\n"
"------------------------------\n"
"what_now : Maybe Table\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:92
#, markdown-text
msgid ""
"The problem is, that there is no reason for Idris to unify the two values, "
"even though `(==)` returned `True` because the result of `(==)` holds no "
"other information than the type being a `Bool`. *We* think, if this is "
"`True` the two values should be identical, but Idris is not convinced. In "
"fact, the following implementation of `Eq ColType` would be perfectly fine "
"as far as the type checker is concerned:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Eq.md:93
#, no-wrap
msgid ""
"Eq ColType where\n"
"  _       == _       = True\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:106
#, markdown-text
msgid ""
"So Idris is right in not trusting us. You might expect it to inspect the "
"implementation of `(==)` and figure out on its own, what the `True` result "
"means, but this is not how these things work in general, because most of the "
"time the number of computational paths to check would be far too large.  As "
"a consequence, Idris is able to evaluate functions during unification, but "
"it will not trace back information about function arguments from a "
"function's result for us. We can do so manually, however, as we will see "
"later."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Eq.md:107
#, markdown-text, no-wrap
msgid "A Type for equal Schemata"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:114
#, markdown-text
msgid ""
"The problem described above is similar to what we saw when we talked about "
"the benefit of [singleton types](DPair.md#erased-existentials): The types "
"are not precise enough. What we are going to do now, is something we'll "
"repeat time again for different use cases: We encode a contract between "
"values in an indexed data type:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:115
#, no-wrap
msgid ""
"data SameSchema : (s1 : Schema) -> (s2 : Schema) -> Type where\n"
"  Same : SameSchema s s\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:124
#, markdown-text
msgid ""
"First, note how `SameSchema` is a family of types indexed over two values of "
"type `Schema`. But note also that the sole constructor restricts the values "
"we allow for `s1` and `s2`: The two indices *must* be identical."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:128
#, markdown-text
msgid ""
"Why is this useful? Well, imagine we had a function for checking the "
"equality of two schemata, which would try and return a value of type "
"`SameSchema s1 s2`:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:129
#, no-wrap
msgid "sameSchema : (s1, s2 : Schema) -> Maybe (SameSchema s1 s2)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:134
#, markdown-text
msgid "We could then use this function to implement `concatTables`:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:135
#, no-wrap
msgid ""
"concatTables : Table -> Table -> Maybe Table\n"
"concatTables (MkTable s1 m rs1) (MkTable s2 n rs2) = case sameSchema s1 s2 "
"of\n"
"  Just Same => Just $ MkTable s1 _ (rs1 ++ rs2)\n"
"  Nothing   => Nothing\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:143
#, markdown-text
msgid "It worked! What's going on here? Well, let's inspect the types involved:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:144
#, no-wrap
msgid ""
"concatTables2 : Table -> Table -> Maybe Table\n"
"concatTables2 (MkTable s1 m rs1) (MkTable s2 n rs2) = case sameSchema s1 s2 "
"of\n"
"  Just Same => ?almost_there\n"
"  Nothing   => Nothing\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:152
#, markdown-text
msgid "At the REPL, we get the following context for `almost_there`:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Eq.md:153
#, no-wrap
msgid ""
"Tutorial.Relations> :t almost_there\n"
"   m : Nat\n"
"   s2 : List ColType\n"
"   rs1 : Vect m (HList (map IdrisType s2))\n"
"   n : Nat\n"
"   rs2 : Vect n (HList (map IdrisType s2))\n"
"   s1 : List ColType\n"
"------------------------------\n"
"almost_there : Maybe Table\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:168
#, markdown-text
msgid ""
"See, how the types of `rs1` and `rs2` unify? Value `Same`, coming as the "
"result of `sameSchema s1 s2`, is a *witness* that `s1` and `s2` are actually "
"identical, because this is what we specified in the definition of `Same`."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:172
#, markdown-text
msgid ""
"All that remains to do is to implement `sameSchema`. For this, we will write "
"another data type for specifying when two values of type `ColType` are "
"identical:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:173
#, no-wrap
msgid ""
"data SameColType : (c1, c2 : ColType) -> Type where\n"
"  SameCT : SameColType c1 c1\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:180
#, markdown-text
msgid ""
"We can now define several utility functions. First, one for figuring out if "
"two column types are identical:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:181
#, no-wrap
msgid ""
"sameColType : (c1, c2 : ColType) -> Maybe (SameColType c1 c2)\n"
"sameColType I64     I64     = Just SameCT\n"
"sameColType Str     Str     = Just SameCT\n"
"sameColType Boolean Boolean = Just SameCT\n"
"sameColType Float   Float   = Just SameCT\n"
"sameColType _ _             = Nothing\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:195
#, markdown-text
msgid ""
"This will convince Idris, because in each pattern match, the return type "
"will be adjusted according to the values we matched on. For instance, on the "
"first line, the output type is `Maybe (SameColType I64 I64)` as you can "
"easily verify yourself by inserting a hole and checking its type at the "
"REPL."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:203
#, markdown-text
msgid ""
"We will need two additional utilities: Functions for creating values of type "
"`SameSchema` for the nil and cons cases. Please note, how the "
"implementations are trivial. Still, we often have to quickly write such "
"small proofs (I'll explain in the next section, why I call them *proofs*), "
"which will then be used to convince the type checker about some fact we "
"already take for granted but Idris does not."
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:204
#, no-wrap
msgid ""
"sameNil : SameSchema [] []\n"
"sameNil = Same\n"
"\n"
"sameCons :  SameColType c1 c2\n"
"         -> SameSchema s1 s2\n"
"         -> SameSchema (c1 :: s1) (c2 :: s2)\n"
"sameCons SameCT Same = Same\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:221
#, markdown-text
msgid ""
"As usual, it can help understanding what's going on by replacing the right "
"hand side of `sameCons` with a hole an check out its type and context at the "
"REPL. The presence of values `SameCT` and `Same` on the left hand side "
"forces Idris to unify `c1` and `c2` as well as `s1` and `s2`, from which the "
"unification of `c1 :: s1` and `c2 :: s2` immediately follows.  With these, "
"we can finally implement `sameSchema`:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:222
#, no-wrap
msgid ""
"sameSchema []        []        = Just sameNil\n"
"sameSchema (x :: xs) (y :: ys) =\n"
"  [| sameCons (sameColType x y) (sameSchema xs ys) |]\n"
"sameSchema (x :: xs) []        = Nothing\n"
"sameSchema []        (x :: xs) = Nothing\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:238
#, markdown-text
msgid ""
"What we described here is a far stronger form of equality than what is "
"provided by interface `Eq` and the `(==)` operator: Equality of values that "
"is accepted by the type checker when trying to unify type level indices.  "
"This is also called *propositional equality*: We will see below, that we can "
"view types as mathematical *propositions*, and values of these types a "
"*proofs* that these propositions hold."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Eq.md:239
#, markdown-text, no-wrap
msgid "Type `Equal`"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:251
#, markdown-text
msgid ""
"Propositional equality is such a fundamental concept, that the *Prelude* "
"exports a general data type for this already: `Equal`, with its only data "
"constructor `Refl`. In addition, there is a built-in operator for expressing "
"propositional equality, which gets desugared to `Equal`: `(=)`. This can "
"sometimes lead to some confusion, because the equals symbol is also used for "
"*definitional equality*: Describing in function implementations that the "
"left-hand side and right-hand side are defined to be equal. If you want to "
"disambiguate propositional from definitional equality, you can also use "
"operator `(===)` for the former."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:253
#, markdown-text
msgid "Here is another implementation of `concatTables`:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:254
#, no-wrap
msgid ""
"eqColType : (c1,c2 : ColType) -> Maybe (c1 = c2)\n"
"eqColType I64     I64     = Just Refl\n"
"eqColType Str     Str     = Just Refl\n"
"eqColType Boolean Boolean = Just Refl\n"
"eqColType Float   Float   = Just Refl\n"
"eqColType _ _             = Nothing\n"
"\n"
"eqCons :  {0 c1,c2 : a}\n"
"       -> {0 s1,s2 : List a}\n"
"       -> c1 = c2 -> s1 = s2 ->  c1 :: s1 = c2 :: s2\n"
"eqCons Refl Refl = Refl\n"
"\n"
"eqSchema : (s1,s2 : Schema) -> Maybe (s1 = s2)\n"
"eqSchema []        []        = Just Refl\n"
"eqSchema (x :: xs) (y :: ys) = [| eqCons (eqColType x y) (eqSchema xs ys) "
"|]\n"
"eqSchema (x :: xs) []        = Nothing\n"
"eqSchema []        (x :: xs) = Nothing\n"
"\n"
"concatTables3 : Table -> Table -> Maybe Table\n"
"concatTables3 (MkTable s1 m rs1) (MkTable s2 n rs2) = case eqSchema s1 s2 "
"of\n"
"  Just Refl => Just $ MkTable _ _ (rs1 ++ rs2)\n"
"  Nothing   => Nothing\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:285
#, markdown-text
msgid ""
"In the following exercises, you are going to implement some very basic "
"properties of equality proofs. You'll have to come up with the types of the "
"functions yourself, as the implementations will be incredibly simple."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:289
#, markdown-text
msgid ""
"Note: If you can't remember what the terms \"reflexive\", \"symmetric\", and "
"\"transitive\" mean, quickly read about equivalence relations "
"[here](https://en.wikipedia.org/wiki/Equivalence_relation)."
msgstr ""

#. type: Bullet: '1. '
#: ../src/Tutorial/Eq.md:291
#, markdown-text
msgid "Show that `SameColType` is a reflexive relation."
msgstr ""

#. type: Bullet: '2. '
#: ../src/Tutorial/Eq.md:293
#, markdown-text
msgid "Show that `SameColType` is a symmetric relation."
msgstr ""

#. type: Bullet: '3. '
#: ../src/Tutorial/Eq.md:295
#, markdown-text
msgid "Show that `SameColType` is a transitive relation."
msgstr ""

#. type: Bullet: '4. '
#: ../src/Tutorial/Eq.md:299
#, markdown-text
msgid ""
"Let `f` be a function of type `ColType -> a` for an arbitrary type `a`. Show "
"that from a value of type `SameColType c1 c2` follows that `f c1` and `f c2` "
"are equal."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:303
#, markdown-text
msgid ""
"For `(=)` the above properties are available from the *Prelude* as functions "
"`sym`, `trans`, and `cong`. Reflexivity comes from the data constructor "
"`Refl` itself."
msgstr ""

#. type: Bullet: '5. '
#: ../src/Tutorial/Eq.md:307
#, markdown-text
msgid ""
"Implement a function for verifying that two natural numbers are "
"identical. Try using `cong` in your implementation."
msgstr ""

#. type: Bullet: '6. '
#: ../src/Tutorial/Eq.md:310
#, markdown-text
msgid ""
"Use the function from exercise 5 for zipping two `Table`s if they have the "
"same number of rows."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:315
#, markdown-text, no-wrap
msgid ""
"   Hint: Use `Vect.zipWith`. You will need to implement\n"
"   custom function `appRows` for this, since Idris will\n"
"   not automatically figure out that the types unify when\n"
"   using `HList.(++)`:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:316
#, no-wrap
msgid "   appRows : {ts1 : _} -> Row ts1 -> Row ts2 -> Row (ts1 ++ ts2)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:323
#, markdown-text
msgid ""
"We will later learn how to use *rewrite rules* to circumvent the need of "
"writing custom functions like `appRows` and use `(++)` in `zipWith` "
"directly."
msgstr ""

#. type: Title ##
#: ../src/Tutorial/Eq.md:324
#, markdown-text, no-wrap
msgid "Programs as Proofs"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:333
#, markdown-text
msgid ""
"A famous observation by mathematician *Haskell Curry* and logician *William "
"Alvin Howard* leads to the conclusion, that we can view a *type* in a "
"programming language with a sufficiently rich type system as a mathematical "
"proposition and a total program calculating a *value* of this type as a "
"proof that the proposition holds. This is also known as the [Curry-Howard "
"isomorphism](https://en.wikipedia.org/wiki/Curry%E2%80%93Howard_correspondence)."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:336
#, markdown-text
msgid "For instance, here is a simple proof that one plus one equals two:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:337
#, no-wrap
msgid ""
"onePlusOne : the Nat 1 + 1 = 2\n"
"onePlusOne = Refl\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:346
#, markdown-text
msgid ""
"The above proof is trivial, as Idris solves this by unification.  But we "
"already stated some more interesting things in the exercises. For instance, "
"the symmetry and transitivity of `SameColType`:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:347
#, no-wrap
msgid ""
"sctSymmetric : SameColType c1 c2 -> SameColType c2 c1\n"
"sctSymmetric SameCT = SameCT\n"
"\n"
"sctTransitive : SameColType c1 c2 -> SameColType c2 c3 -> SameColType c1 "
"c3\n"
"sctTransitive SameCT SameCT = SameCT\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:357
#, markdown-text
msgid ""
"Note, that a type alone is not a proof. For instance, we are free to state "
"that one plus one equals three:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:358
#, no-wrap
msgid "onePlusOneWrong : the Nat 1 + 1 = 3\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:365
#, markdown-text
msgid ""
"We will, however, have a hard time implementing this in a provably total "
"way. We say: \"The type `the Nat 1 + 1 = 3` is *uninhabited*\", meaning, "
"that there is no value of this type."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Eq.md:366
#, markdown-text, no-wrap
msgid "When Proofs replace Tests"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:373
#, markdown-text
msgid ""
"We will see several different use cases for compile time proofs, a very "
"straight forward one being to show that our functions behave as they should "
"by proofing some properties about them. For instance, here is a proposition "
"that `map` on list does not change the number of elements in the list:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:374
#, no-wrap
msgid ""
"mapListLength : (f : a -> b) -> (as : List a) -> length as = length (map f "
"as)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:381
#, markdown-text
msgid ""
"Read this as a universally quantified statement: For all functions `f` from "
"`a` to `b` and for all lists `as` holding values of type `a`, the length of "
"`map f as` is the same the as the length of the original list."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:387
#, markdown-text
msgid ""
"We can implement `mapListLength` by pattern matching on `as`. The `Nil` case "
"will be trivial: Idris solves this by unification. It knows the value of the "
"input list (`Nil`), and since `map` is implemented by pattern matching on "
"the input as well, it follows immediately that the result will be `Nil` as "
"well:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:388
#, no-wrap
msgid "mapListLength f []        = Refl\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:395
#, markdown-text
msgid ""
"The `cons` case is more involved, and we will do this stepwise.  First, note "
"that we can proof that the length of a map over the tail will stay the same "
"by means of recursion:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Eq.md:397
#, no-wrap
msgid ""
"mapListLength f (x :: xs) = case mapListLength f xs of\n"
"  prf => ?mll1\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:403
#, markdown-text
msgid "Let's inspect the types and context we have here:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Eq.md:404
#, no-wrap
msgid ""
" 0 b : Type\n"
" 0 a : Type\n"
"   xs : List a\n"
"   f : a -> b\n"
"   x : a\n"
"   prf : length xs = length (map f xs)\n"
"------------------------------\n"
"mll1 : S (length xs) = S (length (map f xs))\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:422
#, markdown-text
msgid ""
"So, we have a proof of type `length xs = length (map f xs)`, and from the "
"implementation of `map` Idris concludes that what we are actually looking "
"for is a result of type `S (length xs) = S (length (map f xs))`. This is "
"exactly what function `cong` from the *Prelude* is for (\"cong\" is an "
"abbreviation for *congruence*). We can thus implement the *cons* case "
"concisely like so:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:423
#, no-wrap
msgid "mapListLength f (x :: xs) = cong S $ mapListLength f xs\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:431
#, markdown-text
msgid ""
"Please take a moment to appreciate what we achieved here: A *proof* in the "
"mathematical sense that our function will not affect the length of our "
"list. We no longer need a unit test or similar program to verify this."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:435
#, markdown-text
msgid ""
"Before we continue, please note an important thing: In our case expression, "
"we used a *variable* for the result from the recursive call:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Eq.md:436
#, no-wrap
msgid ""
"mapListLength f (x :: xs) = case mapListLength f xs of\n"
"  prf => cong S prf\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:448
#, markdown-text
msgid ""
"Here, we did not want the two lengths to unify, because we needed the "
"distinction in our call to `cong`. Therefore: If you need a proof of type `x "
"= y` in order for two variables to unify, use the `Refl` data constructor in "
"the pattern match.  If, on the other hand, you need to run further "
"computations on such a proof, use a variable and the left and right-hand "
"sides will remain distinct."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:453
#, markdown-text
msgid ""
"Here is another example from the last chapter: We want to show that parsing "
"and printing column types behaves correctly.  Writing proofs about parsers "
"can be very hard in general, but here it can be done with a mere pattern "
"match:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:454
#, no-wrap
msgid ""
"showColType : ColType -> String\n"
"showColType I64      = \"i64\"\n"
"showColType Str      = \"str\"\n"
"showColType Boolean  = \"boolean\"\n"
"showColType Float    = \"float\"\n"
"\n"
"readColType : String -> Maybe ColType\n"
"readColType \"i64\"      = Just I64\n"
"readColType \"str\"      = Just Str\n"
"readColType \"boolean\"  = Just Boolean\n"
"readColType \"float\"    = Just Float\n"
"readColType s          = Nothing\n"
"\n"
"showReadColType : (c : ColType) -> readColType (showColType c) = Just c\n"
"showReadColType I64     = Refl\n"
"showReadColType Str     = Refl\n"
"showReadColType Boolean = Refl\n"
"showReadColType Float   = Refl\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:477
#, markdown-text
msgid ""
"Such simple proofs give us quick but strong guarantees that we did not make "
"any stupid mistakes."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:485
#, markdown-text
msgid ""
"The examples we saw so far were very easy to implement. In general, this is "
"not the case, and we will have to learn about several additional techniques "
"in order to proof interesting things about our programs. However, when we "
"use Idris as a general purpose programming language and not as a proof "
"assistant, we are free to choose whether some aspect of our code needs such "
"strong guarantees or not."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Eq.md:486
#, markdown-text, no-wrap
msgid "A Note of Caution: Lowercase Identifiers in Function Types"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:494
#, markdown-text
msgid ""
"When writing down the types of proofs as we did above, one has to be very "
"careful not to fall into the following trap: In general, Idris will treat "
"lowercase identifiers in function types as type parameters (erased implicit "
"arguments).  For instance, here is a try at proofing the identity functor "
"law for `Maybe`:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:495
#, no-wrap
msgid ""
"mapMaybeId1 : (ma : Maybe a) -> map id ma = ma\n"
"mapMaybeId1 Nothing  = Refl\n"
"mapMaybeId1 (Just x) = ?mapMaybeId1_rhs\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:504
#, markdown-text
msgid ""
"You will not be able to implement the `Just` case, because Idris treats `id` "
"as an implicit argument as can easily be seen when inspecting the context of "
"`mapMaybeId1_rhs`:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Eq.md:505
#, no-wrap
msgid ""
"Tutorial.Relations> :t mapMaybeId1_rhs\n"
" 0 a : Type\n"
" 0 id : a -> a\n"
"   x : a\n"
"------------------------------\n"
"mapMaybeId1_rhs : Just (id x) = Just x\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:517
#, markdown-text, no-wrap
msgid ""
"As you can see, `id` is an erased argument of type `a -> a`. And in\n"
"fact, when type-checking this module, Idris will issue a warning that\n"
"parameter `id` is shadowing an existing function:\n"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Eq.md:518
#, no-wrap
msgid ""
"Warning: We are about to implicitly bind the following lowercase names.\n"
"You may be unintentionally shadowing the associated global definitions:\n"
"  id is shadowing Prelude.Basics.id\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:527
#, markdown-text
msgid ""
"The same is not true for `map`: Since we explicitly pass arguments to `map`, "
"Idris treats this as a function name and not as an implicit argument."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:530
#, markdown-text
msgid ""
"You have several options here. For instance, you could use an uppercase "
"identifier, as these will never be treated as implicit arguments:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:531
#, no-wrap
msgid ""
"Id : a -> a\n"
"Id = id\n"
"\n"
"mapMaybeId2 : (ma : Maybe a) -> map Id ma = ma\n"
"mapMaybeId2 Nothing  = Refl\n"
"mapMaybeId2 (Just x) = Refl\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:543
#, markdown-text
msgid ""
"As an alternative - and this is the preferred way to handle this case - you "
"can prefix `id` with part of its namespace, which will immediately resolve "
"the issue:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:544
#, no-wrap
msgid ""
"mapMaybeId : (ma : Maybe a) -> map Prelude.id ma = ma\n"
"mapMaybeId Nothing  = Refl\n"
"mapMaybeId (Just x) = Refl\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:554
#, markdown-text
msgid ""
"Note: If you have semantic highlighting turned on in your editor (for "
"instance, by using the [idris2-lsp "
"plugin](https://github.com/idris-community/idris2-lsp)), you will note that "
"`map` and `id` in `mapMaybeId1` get highlighted differently: `map` as a "
"function name, `id` as a bound variable."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:562
#, markdown-text
msgid ""
"In these exercises, you are going to proof several simple properties of "
"small functions. When writing proofs, it is even more important to use holes "
"to figure out what Idris expects from you next. Use the tools given to you, "
"instead of trying to find your way in the dark!"
msgstr ""

#. type: Bullet: '1. '
#: ../src/Tutorial/Eq.md:564
#, markdown-text
msgid "Proof that `map id` on an `Either e` returns the value unmodified."
msgstr ""

#. type: Bullet: '2. '
#: ../src/Tutorial/Eq.md:566
#, markdown-text
msgid "Proof that `map id` on a list returns the list unmodified."
msgstr ""

#. type: Bullet: '3. '
#: ../src/Tutorial/Eq.md:570
#, markdown-text
msgid ""
"Proof that complementing a strand of a nucleobase (see the [previous "
"chapter](DPair.md#use-case-nucleic-acids))  twice leads to the original "
"strand."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:574
#, markdown-text, no-wrap
msgid ""
"   Hint: Proof this for single bases first, and use `cong2`\n"
"   from the *Prelude* in your implementation for sequences\n"
"   of nucleic acids.\n"
msgstr ""

#. type: Bullet: '4. '
#: ../src/Tutorial/Eq.md:576
#, markdown-text
msgid "Implement function `replaceVect`:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:577
#, no-wrap
msgid "   replaceVect : (ix : Fin n) -> a -> Vect n a -> Vect n a\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:584
#, markdown-text, no-wrap
msgid ""
"   Now proof, that after replacing an element in a vector\n"
"   using `replaceAt` accessing the same element using\n"
"   `index` will return the value we just added.\n"
msgstr ""

#. type: Bullet: '5. '
#: ../src/Tutorial/Eq.md:586
#, markdown-text
msgid "Implement function `insertVect`:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:587
#, no-wrap
msgid "   insertVect : (ix : Fin (S n)) -> a -> Vect n a -> Vect (S n) a\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:593
#, markdown-text, no-wrap
msgid ""
"   Use a similar proof as in exercise 4 to show that this\n"
"   behaves correctly.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:596
#, markdown-text
msgid ""
"Note: Functions `replaceVect` and `insertVect` are available from "
"`Data.Vect` as `replaceAt` and `insertAt`."
msgstr ""

#. type: Title ##
#: ../src/Tutorial/Eq.md:597
#, markdown-text, no-wrap
msgid "Into the Void"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:612
#, markdown-text
msgid ""
"Remember function `onePlusOneWrong` from above? This was definitely a wrong "
"statement: One plus one does not equal three. Sometimes, we want to express "
"exactly this: That a certain statement is false and does not hold. Consider "
"for a moment what it means to proof a statement in Idris: Such a statement "
"(or proposition) is a type, and a proof of the statement is a value or "
"expression of this type: The type is said to be *inhabited*.  If a statement "
"is not true, there can be no value of the given type. We say, the given type "
"is *uninhabited*.  If we still manage to get our hands on a value of an "
"uninhabited type, that is a logical contradiction and from this, anything "
"follows (remember [ex falso "
"quodlibet](https://en.wikipedia.org/wiki/Principle_of_explosion))."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:617
#, markdown-text
msgid ""
"So this is how to express that a proposition does not hold: We state that if "
"it *would* hold, this would lead to a contradiction.  The most natural way "
"to express a contradiction in Idris is to return a value of type `Void`:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:618
#, no-wrap
msgid ""
"onePlusOneWrongProvably : the Nat 1 + 1 = 3 -> Void\n"
"onePlusOneWrongProvably Refl impossible\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:628
#, markdown-text
msgid ""
"See how this is a provably total implementation of the given type: A "
"function from `1 + 1 = 3` to `Void`. We implement this by pattern matching, "
"and there is only one constructor to match on, which leads to an impossible "
"case."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:633
#, markdown-text
msgid ""
"We can also use contradictory statements to proof other such statements. For "
"instance, here is a proof that if the lengths of two lists are not the same, "
"then the two list can't be the same either:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:634
#, no-wrap
msgid ""
"notSameLength1 : (List.length as = length bs -> Void) -> as = bs -> Void\n"
"notSameLength1 f prf = f (cong length prf)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:642
#, markdown-text
msgid ""
"This is cumbersome to write and pretty hard to read, so there is function "
"`Not` in the prelude to express the same thing more naturally:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:643
#, no-wrap
msgid ""
"notSameLength : Not (List.length as = length bs) -> Not (as = bs)\n"
"notSameLength f prf = f (cong length prf)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:651
#, markdown-text
msgid ""
"Actually, this is just a specialized version of the contraposition of "
"`cong`: If from `a = b` follows `f a = f b`, then from `not (f a = f b)` "
"follows `not (a = b)`:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:652
#, no-wrap
msgid ""
"contraCong : {0 f : _} -> Not (f a = f b) -> Not (a = b)\n"
"contraCong fun = fun . cong f\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Eq.md:657
#, markdown-text, no-wrap
msgid "Interface `Uninhabited`"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:664
#, markdown-text
msgid ""
"There is an interface in the *Prelude* for uninhabited types: `Uninhabited` "
"with its sole function `uninhabited`. Have a look at its documentation at "
"the REPL. You will see, that there is already an impressive number of "
"implementations available, many of which involve data type `Equal`."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:667
#, markdown-text
msgid ""
"We can use `Uninhabited`, to for instance express that the empty schema is "
"not equal to a non-empty schema:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:668
#, no-wrap
msgid ""
"Uninhabited (SameSchema [] (h :: t)) where\n"
"  uninhabited Same impossible\n"
"\n"
"Uninhabited (SameSchema (h :: t) []) where\n"
"  uninhabited Same impossible\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:678
#, markdown-text
msgid ""
"There is a related function you need to know about: `absurd`, which combines "
"`uninhabited` with `void`:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Eq.md:679
#, no-wrap
msgid ""
"Tutorial.Eq> :printdef absurd\n"
"Prelude.absurd : Uninhabited t => t -> a\n"
"absurd h = void (uninhabited h)\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Eq.md:685
#, markdown-text, no-wrap
msgid "Decidable Equality"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:703
#, markdown-text, no-wrap
msgid ""
"When we implemented `sameColType`, we got a proof that two\n"
"column types are indeed the same, from which we could figure out,\n"
"whether two schemata are identical. The types guarantee\n"
"we do not generate any false positives: If we generate a value\n"
"of type `SameSchema s1 s2`, we have a proof that `s1` and `s2`\n"
"are indeed identical.\n"
"However, `sameColType` and thus `sameSchema` could theoretically\n"
"still produce false negatives by returning `Nothing`\n"
"although the two values are identical. For instance,\n"
"we could implement `sameColType` in such a way that it\n"
"always returns `Nothing`. This would be in agreement with\n"
"the types, but definitely not what we want. So, here is\n"
"what we'd like to do in order to get yet stronger guarantees:\n"
"We'd either want to return a proof that the two schemata\n"
"are the same, or return a proof that the two schemata\n"
"are not the same. (Remember that `Not a` is an alias for `a -> Void`).\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:708
#, markdown-text
msgid ""
"We call a property, which either holds or leads to a contradiction a "
"*decidable property*, and the *Prelude* exports data type `Dec prop`, which "
"encapsulates this distinction."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:710
#, markdown-text
msgid "Here is a way to encode this for `ColType`:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:711
#, no-wrap
msgid ""
"decSameColType :  (c1,c2 : ColType) -> Dec (SameColType c1 c2)\n"
"decSameColType I64 I64         = Yes SameCT\n"
"decSameColType I64 Str         = No $ \\case SameCT impossible\n"
"decSameColType I64 Boolean     = No $ \\case SameCT impossible\n"
"decSameColType I64 Float       = No $ \\case SameCT impossible\n"
"\n"
"decSameColType Str I64         = No $ \\case SameCT impossible\n"
"decSameColType Str Str         = Yes SameCT\n"
"decSameColType Str Boolean     = No $ \\case SameCT impossible\n"
"decSameColType Str Float       = No $ \\case SameCT impossible\n"
"\n"
"decSameColType Boolean I64     = No $ \\case SameCT impossible\n"
"decSameColType Boolean Str     = No $ \\case SameCT impossible\n"
"decSameColType Boolean Boolean = Yes SameCT\n"
"decSameColType Boolean Float   = No $ \\case SameCT impossible\n"
"\n"
"decSameColType Float I64       = No $ \\case SameCT impossible\n"
"decSameColType Float Str       = No $ \\case SameCT impossible\n"
"decSameColType Float Boolean   = No $ \\case SameCT impossible\n"
"decSameColType Float Float     = Yes SameCT\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:741
#, markdown-text
msgid ""
"First, note how we could use a pattern match in a single argument lambda "
"directly. This is sometimes called the *lambda case* style, named after an "
"extension of the Haskell programming language. If we use the `SameCT` "
"constructor in the pattern match, Idris is forced to try and unify for "
"instance `Float` with `I64`. This is not possible, so the case as a whole is "
"impossible."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:749
#, markdown-text
msgid ""
"Yet, this was pretty cumbersome to implement. In order to convince Idris we "
"did not miss a case, there is no way around treating every possible pairing "
"of constructors explicitly.  However, we get *much* stronger guarantees out "
"of this: We can no longer create false positives *or* false negatives, and "
"therefore, `decSameColType` is provably correct."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:752
#, markdown-text
msgid ""
"Doing the same thing for schemata requires some utility functions, the types "
"of which we can figure out by placing some holes:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:753
#, no-wrap
msgid ""
"decSameSchema' :  (s1, s2 : Schema) -> Dec (SameSchema s1 s2)\n"
"decSameSchema' []        []        = Yes Same\n"
"decSameSchema' []        (y :: ys) = No ?decss1\n"
"decSameSchema' (x :: xs) []        = No ?decss2\n"
"decSameSchema' (x :: xs) (y :: ys) = case decSameColType x y of\n"
"  Yes SameCT => case decSameSchema' xs ys of\n"
"    Yes Same => Yes Same\n"
"    No  contra => No $ \\prf => ?decss3\n"
"  No  contra => No $ \\prf => ?decss4\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:770
#, markdown-text, no-wrap
msgid ""
"The first two cases are not too hard. The type of `decss1` is\n"
"`SameSchema [] (y :: ys) -> Void`, which you can easily verify\n"
"at the REPL. But that's just `uninhabited`, specialized to\n"
"`SameSchema [] (y :: ys)`, and this we already implemented\n"
"further above. The same goes for `decss2`.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:777
#, markdown-text
msgid ""
"The other two cases are harder, so I already filled in as much stuff as "
"possible. We know that we want to return a `No`, if either the heads or "
"tails are provably distinct. The `No` holds a function, so I already added a "
"lambda, leaving a hole only for the return value. Here are the type and - "
"more important - context of `decss3`:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Eq.md:778
#, no-wrap
msgid ""
"Tutorial.Relations> :t decss3\n"
"   y : ColType\n"
"   xs : List ColType\n"
"   ys : List ColType\n"
"   x : ColType\n"
"   contra : SameSchema xs ys -> Void\n"
"   prf : SameSchema (y :: xs) (y :: ys)\n"
"------------------------------\n"
"decss3 : Void\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:797
#, markdown-text
msgid ""
"The types of `contra` and `prf` are what we need here: If `xs` and `ys` are "
"distinct, then `y :: xs` and `y :: ys` must be distinct as well. This is the "
"contraposition of the following statement: If `x :: xs` is the same as `y :: "
"ys`, then `xs` and `ys` are the same as well. We must therefore implement a "
"lemma, which proves that the *cons* constructor is "
"[*injective*](https://en.wikipedia.org/wiki/Injective_function):"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:798
#, no-wrap
msgid ""
"consInjective :  SameSchema (c1 :: cs1) (c2 :: cs2)\n"
"              -> (SameColType c1 c2, SameSchema cs1 cs2)\n"
"consInjective Same = (SameCT, Same)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:809
#, markdown-text
msgid ""
"We can now pass `prf` to `consInjective` to extract a value of type "
"`SameSchema xs ys`, which we then pass to `contra` in order to get the "
"desired value of type `Void`.  With these observations and utilities, we can "
"now implement `decSameSchema`:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:810
#, no-wrap
msgid ""
"decSameSchema :  (s1, s2 : Schema) -> Dec (SameSchema s1 s2)\n"
"decSameSchema []        []        = Yes Same\n"
"decSameSchema []        (y :: ys) = No absurd\n"
"decSameSchema (x :: xs) []        = No absurd\n"
"decSameSchema (x :: xs) (y :: ys) = case decSameColType x y of\n"
"  Yes SameCT => case decSameSchema xs ys of\n"
"    Yes Same   => Yes Same\n"
"    No  contra => No $ contra . snd . consInjective\n"
"  No  contra => No $ contra . fst . consInjective\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:825
#, markdown-text
msgid ""
"There is an interface called `DecEq` exported by module `Decidable.Equality` "
"for types for which we can implement a decision procedure for propositional "
"equality. We can implement this to figure out if two values are equal or "
"not."
msgstr ""

#. type: Bullet: '1. '
#: ../src/Tutorial/Eq.md:830
#, markdown-text
msgid ""
"Show that there can be no non-empty vector of `Void` by writing a "
"corresponding implementation of uninhabited"
msgstr ""

#. type: Bullet: '2. '
#: ../src/Tutorial/Eq.md:832
#, markdown-text
msgid "Generalize exercise 1 for all uninhabited element types."
msgstr ""

#. type: Bullet: '3. '
#: ../src/Tutorial/Eq.md:835
#, markdown-text
msgid "Show that if `a = b` cannot hold, then `b = a` cannot hold either."
msgstr ""

#. type: Bullet: '4. '
#: ../src/Tutorial/Eq.md:838
#, markdown-text
msgid ""
"Show that if `a = b` holds, and `b = c` cannot hold, then `a = c` cannot "
"hold either."
msgstr ""

#. type: Bullet: '5. '
#: ../src/Tutorial/Eq.md:841
#, markdown-text
msgid "Implement `Uninhabited` for `Crud i a`. Try to be as general as possible."
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:842 ../src/Tutorial/Folds.md:996
#: ../src/Tutorial/Functor.md:417 ../src/Tutorial/Traverse.md:285
#, no-wrap
msgid ""
"   data Crud : (i : Type) -> (a : Type) -> Type where\n"
"     Create : (value : a) -> Crud i a\n"
"     Update : (id : i) -> (value : a) -> Crud i a\n"
"     Read   : (id : i) -> Crud i a\n"
"     Delete : (id : i) -> Crud i a\n"
msgstr ""

#. type: Bullet: '6. '
#: ../src/Tutorial/Eq.md:851
#, markdown-text
msgid "Implement `DecEq` for `ColType`."
msgstr ""

#. type: Bullet: '7. '
#: ../src/Tutorial/Eq.md:856
#, markdown-text
msgid ""
"Implementations such as the one from exercise 6 are cumbersome to write as "
"they require a quadratic number of pattern matches with relation to the "
"number of data constructors. Here is a trick how to make this more bearable."
msgstr ""

#. type: Bullet: '   1. '
#: ../src/Tutorial/Eq.md:859
#, markdown-text
msgid ""
"Implement a function `ctNat`, which assigns every value of type `ColType` a "
"unique natural number."
msgstr ""

#. type: Bullet: '   2. '
#: ../src/Tutorial/Eq.md:864
#, markdown-text
msgid ""
"Proof that `ctNat` is injective.  Hint: You will need to pattern match on "
"the `ColType` values, but four matches should be enough to satisfy the "
"coverage checker."
msgstr ""

#. type: Bullet: '   3. '
#: ../src/Tutorial/Eq.md:869
#, markdown-text
msgid ""
"In your implementation of `DecEq` for `ColType`, use `decEq` on the result "
"of applying both column types to `ctNat`, thus reducing it to only two lines "
"of code."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:877
#, markdown-text, no-wrap
msgid ""
"   We will later talk about `with` rules: Special forms of\n"
"   dependent pattern matches, that allow us to learn something\n"
"   about the shape of function arguments by performing\n"
"   computations on them. These will allow us to use\n"
"   a similar technique as shown here to implement `DecEq`\n"
"   requiring only `n` pattern matches\n"
"   for arbitrary sum types with `n` data constructors.\n"
msgstr ""

#. type: Title ##
#: ../src/Tutorial/Eq.md:878
#, markdown-text, no-wrap
msgid "Rewrite Rules"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:888
#, markdown-text
msgid ""
"One of the most important use cases of propositional equality is to replace "
"or *rewrite* existing types, which Idris can't unify automatically "
"otherwise. For instance, the following is no problem: Idris know that `0 + "
"n` equals `n`, because `plus` on natural numbers is implemented by pattern "
"matching on the first argument. The two vector lengths therefore unify just "
"fine."
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:889
#, no-wrap
msgid ""
"leftZero :  List (Vect n Nat)\n"
"         -> List (Vect (0 + n) Nat)\n"
"         -> List (Vect n Nat)\n"
"leftZero = (++)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:899
#, markdown-text
msgid ""
"However, the example below can't be implemented as easily (try id!), because "
"Idris can't figure out on its own that the two lengths unify."
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:900
#, no-wrap
msgid ""
"rightZero' :  List (Vect n Nat)\n"
"           -> List (Vect (n + 0) Nat)\n"
"           -> List (Vect n Nat)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:909
#, markdown-text
msgid ""
"Probably for the first time we realize, just how little Idris knows about "
"the laws of arithmetics. Idris is able to unify values when"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Eq.md:913
#, markdown-text
msgid "all values in a computation are known at compile time"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Eq.md:913
#, markdown-text
msgid ""
"one expression follows directly from the other due to the pattern matches "
"used in a function's implementation."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:917
#, markdown-text
msgid ""
"In expression `n + 0`, not all values are known (`n` is a variable), and "
"`(+)` is implemented by pattern matching on the first argument, about which "
"we know nothing here."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:923
#, markdown-text
msgid ""
"However, we can teach Idris. If we can proof that the two expressions are "
"equivalent, we can replace one expression for the other, so that the two "
"unify again. Here is a lemma and its proof, that `n + 0` equals `n`, for all "
"natural numbers `n`."
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:924
#, no-wrap
msgid ""
"addZeroRight : (n : Nat) -> n + 0 = n\n"
"addZeroRight 0     = Refl\n"
"addZeroRight (S k) = cong S $ addZeroRight k\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:935
#, markdown-text
msgid ""
"Note, how the base case is trivial: Since there are no variables left, Idris "
"can immediately figure out that `0 + 0 = 0`. In the recursive case, it can "
"be instructive to replace `cong S` with a hole and look at its type and "
"context to figure out how to proceed."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:940
#, markdown-text
msgid ""
"The *Prelude* exports function `replace` for substituting one variable in a "
"term by another, based on a proof of equality.  Make sure to inspect its "
"type first before looking at the example below:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:941
#, no-wrap
msgid ""
"replaceVect : Vect (n + 0) a -> Vect n a\n"
"replaceVect as = replace {p = \\k => Vect k a} (addZeroRight n) as\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:952
#, markdown-text, no-wrap
msgid ""
"As you can see, we *replace* a value of type `p x` with a value\n"
"of type `p y` based on a proof that `x = y`,\n"
"where `p` is a function from some type `t` to\n"
"`Type`, and `x` and `y` are values of type `t`. In our\n"
"`replaceVect` example, `t` equals `Nat`, `x` equals `n + 0`,\n"
"`y` equals `n`, and `p` equals `\\k => Vect k a`.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:960
#, markdown-text
msgid ""
"Using `replace` directly is not very convenient, because Idris can often not "
"infer the value of `p` on its own. Indeed, we had to give its type "
"explicitly in `replaceVect`.  Idris therefore provides special syntax for "
"such *rewrite rules*, which will get desugared to calls to `replace` with "
"all the details filled in for us. Here is an implementation of `replaceVect` "
"with a rewrite rule:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:961
#, no-wrap
msgid ""
"rewriteVect : Vect (n + 0) a -> Vect n a\n"
"rewriteVect as = rewrite sym (addZeroRight n) in as\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:970
#, markdown-text
msgid ""
"One source of confusion is that *rewrite* uses proofs of equality the other "
"way round: Given an `y = x` it replaces `p x` with `p y`. Hence the need to "
"call `sym` in our implementation above."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Eq.md:971
#, markdown-text, no-wrap
msgid "Use Case: Reversing Vectors"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:982
#, markdown-text
msgid ""
"Rewrite rules are often required when we perform interesting type-level "
"computations. For instance, we have already seen many interesting examples "
"of functions operating on `Vect`, which allowed us to keep track of the "
"exact lengths of the vectors involved, but one key functionality has been "
"missing from our discussions so far, and for good reasons: Function "
"`reverse`. Here is a possible implementation, which is how `reverse` is "
"implemented for lists:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Eq.md:984
#, no-wrap
msgid ""
"reverseOnto' : Vect m a -> Vect n a -> Vect (m + n) a\n"
"reverseOnto' xs []        = xs\n"
"reverseOnto' xs (x :: ys) = reverseOnto' (x :: xs) ys\n"
"\n"
"\n"
"reverseVect' : Vect n a -> Vect n a\n"
"reverseVect' = reverseOnto' []\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:997
#, markdown-text
msgid ""
"As you might have guessed, this will not compile as the length indices in "
"the two clauses of `reverseOnto'` do not unify."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:1001
#, markdown-text
msgid ""
"The *nil* case is a case we've already seen above: Here `n` is zero, because "
"the second vector is empty, so we have to convince Idris once again that `m "
"+ 0 = m`:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:1002
#, no-wrap
msgid ""
"reverseOnto : Vect m a -> Vect n a -> Vect (m + n) a\n"
"reverseOnto xs [] = rewrite addZeroRight m in xs\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:1013
#, markdown-text
msgid ""
"The second case is more complex. Here, Idris fails to unify `S (m + len)` "
"with `m + S len`, where `len` is the length of `ys`, the tail of the second "
"vector. Module `Data.Nat` provides many proofs about arithmetic operations "
"on natural numbers, one of which is `plusSuccRightSucc`. Here's its type:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Eq.md:1014
#, no-wrap
msgid ""
"Tutorial.Eq> :t plusSuccRightSucc\n"
"Data.Nat.plusSuccRightSucc :  (left : Nat)\n"
"                           -> (right : Nat)\n"
"                           -> S (left + right) = left + S right\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:1032
#, markdown-text
msgid ""
"In our case, we want to replace `S (m + len)` with `m + S len`, so we will "
"need the version with arguments flipped. However, there is one more "
"obstacle: We need to invoke `plusSuccRightSucc` with the length of `ys`, "
"which is not given as an implicit function argument of `reverseOnto`. We "
"therefore need to pattern match on `n` (the length of the second vector), in "
"order to bind the length of the tail to a variable. Remember, that we are "
"allowed to pattern match on an erased argument only if the constructor used "
"follows from a match on another, unerased, argument (`ys` in this "
"case). Here's the implementation of the second case:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:1033
#, no-wrap
msgid ""
"reverseOnto {n = S len} xs (x :: ys) =\n"
"  rewrite sym (plusSuccRightSucc m len) in reverseOnto (x :: xs) ys\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:1043
#, markdown-text
msgid ""
"I know from my own experience that this can be highly confusing at first. If "
"you use Idris as a general purpose programming language and not as a proof "
"assistant, you probably will not have to use rewrite rules too often. Still, "
"it is important to know that they exist, as they allow us to teach complex "
"equivalences to Idris."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Eq.md:1044
#, markdown-text, no-wrap
msgid "A Note on Erasure"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:1055
#, markdown-text
msgid ""
"Single value data types like `Unit`, `Equal`, or `SameSchema` have not "
"runtime relevance, as values of these types are always identical.  We can "
"therefore always use them as erased function arguments while still being "
"able to pattern match on these values.  For instance, when you look at the "
"type of `replace`, you will see that the equality proof is an erased "
"argument.  This allows us to run arbitrarily complex computations to produce "
"such values without fear of these computations slowing down the compiled "
"Idris program."
msgstr ""

#. type: Bullet: '1. '
#: ../src/Tutorial/Eq.md:1059
#, markdown-text
msgid "Implement `plusSuccRightSucc` yourself."
msgstr ""

#. type: Bullet: '2. '
#: ../src/Tutorial/Eq.md:1061
#, markdown-text
msgid "Proof that `minus n n` equals zero for all natural numbers `n`."
msgstr ""

#. type: Bullet: '3. '
#: ../src/Tutorial/Eq.md:1063
#, markdown-text
msgid "Proof that `minus n 0` equals n for all natural numbers `n`"
msgstr ""

#. type: Bullet: '4. '
#: ../src/Tutorial/Eq.md:1066
#, markdown-text
msgid "Proof that `n * 1 = n` and `1 * n = n` for all natural numbers `n`."
msgstr ""

#. type: Bullet: '5. '
#: ../src/Tutorial/Eq.md:1069
#, markdown-text
msgid "Proof that addition of natural numbers is commutative."
msgstr ""

#. type: Bullet: '6. '
#: ../src/Tutorial/Eq.md:1071
#, markdown-text
msgid "Implement a tail-recursive version of `map` for vectors."
msgstr ""

#. type: Bullet: '7. '
#: ../src/Tutorial/Eq.md:1073
#, markdown-text
msgid "Proof the following proposition:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Eq.md:1074
#, no-wrap
msgid ""
"   mapAppend :  (f : a -> b)\n"
"             -> (xs : List a)\n"
"             -> (ys : List a)\n"
"             -> map f (xs ++ ys) = map f xs ++ map f ys\n"
msgstr ""

#. type: Bullet: '8. '
#: ../src/Tutorial/Eq.md:1084
#, markdown-text
msgid ""
"Use the proof from exercise 7 to implement again a function for zipping two "
"`Table`s, this time using a rewrite rule plus `Data.HList.(++)` instead of "
"custom function `appRows`."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Eq.md:1096
#, markdown-text
msgid ""
"The concept of *types as propositions, values as proofs* is a very powerful "
"tool for writing provably correct programs. We will therefore spend some "
"more time defining data types for describing contracts between values, and "
"values of these types as proofs that the contracts hold. This will allow us "
"to describe necessary pre- and postconditions for our functions, thus "
"reducing the need to return a `Maybe` or other failure type, because due to "
"the restricted input, our functions can no longer fail."
msgstr ""

#. type: Title #
#: ../src/Tutorial/Folds.md:1
#, markdown-text, no-wrap
msgid "Recursion and Folds"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:12
#, markdown-text
msgid ""
"In this chapter, we are going to have a closer look at the computations we "
"typically perform with *container types*: Parameterized data types like "
"`List`, `Maybe`, or `Identity`, holding zero or more values of the "
"parameter's type. Many of these functions are recursive in nature, so we "
"start with a discourse about recursion in general, and tail recursion as an "
"important optimization technique in particular. Most recursive functions in "
"this part will describe pure iterations over lists."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:17
#, markdown-text
msgid ""
"It is recursive functions, for which totality is hard to determine, so we "
"will next have a quick look at the totality checker and learn, when it will "
"refuse to accept a function as being total and what to do about this."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:22
#, markdown-text
msgid ""
"Finally, we will start looking for common patterns in the recursive "
"functions from the first part and will eventually introduce a new interface "
"for consuming container types: Interface `Foldable`."
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Folds.md:23
#, no-wrap
msgid ""
"module Tutorial.Folds\n"
"\n"
"import Data.List1\n"
"import Data.Maybe\n"
"import Data.Vect\n"
"import Debug.Trace\n"
"\n"
"%default total\n"
msgstr ""

#. type: Title ##
#: ../src/Tutorial/Folds.md:34
#, markdown-text, no-wrap
msgid "Recursion"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:38
#, markdown-text
msgid ""
"In this section, we are going to have a closer look at recursion in general "
"and at tail recursion in particular."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:47
#, markdown-text
msgid ""
"Recursive functions are functions, which call themselves to repeat a task or "
"calculation until a certain aborting condition (called the *base case*) "
"holds.  Please note, that it is recursive functions, which make it hard to "
"verify totality: Non-recursive functions, which are *covering* (they cover "
"all possible cases in their pattern matches) are automatically total if they "
"only invoke other total functions."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:50
#, markdown-text
msgid ""
"Here is an example of a recursive function: It generates a list of the given "
"length filling it with identical values:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Folds.md:51
#, no-wrap
msgid ""
"replicateList : Nat -> a -> List a\n"
"replicateList 0     _ = []\n"
"replicateList (S k) x = x :: replicateList k x\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:63
#, markdown-text
msgid ""
"As you can see (this module has the `%default total` pragma at the top), "
"this function is provably total. Idris verifies, that the `Nat` argument "
"gets *strictly smaller* in each recursive call, and that therefore, the "
"function *must* eventually come to an end. Of course, we can do the same "
"thing for `Vect`, where we can even show that the length of the resulting "
"vector matches the given natural number:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Folds.md:64
#, no-wrap
msgid ""
"replicateVect : (n : Nat) -> a -> Vect n a\n"
"replicateVect 0     _ = []\n"
"replicateVect (S k) x = x :: replicateVect k x\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:73
#, markdown-text
msgid ""
"While we often use recursion to *create* values of data types like `List` or "
"`Vect`, we also use recursion, when we *consume* such values.  For instance, "
"here is a function for calculating the length of a list:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Folds.md:74
#, no-wrap
msgid ""
"len : List a -> Nat\n"
"len []        = 0\n"
"len (_ :: xs) = 1 + len xs\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:82
#, markdown-text
msgid ""
"Again, Idris can verify that `len` is total, as the list we pass in the "
"recursive case is strictly smaller than the original list argument."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:88
#, markdown-text
msgid ""
"But when is a recursive function non-total? Here is an example: The "
"following function creates a sequence of values until the given generation "
"function (`gen`) returns a `Nothing`. Note, how we use a *state* value (of "
"generic type `s`) and use `gen` to calculate a value together with the next "
"state:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Folds.md:89
#, no-wrap
msgid ""
"covering\n"
"unfold : (gen : s -> Maybe (s,a)) -> s -> List a\n"
"unfold gen vs = case gen vs of\n"
"  Just (vs',va) => va :: unfold gen vs'\n"
"  Nothing       => []\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:103
#, markdown-text
msgid ""
"With `unfold`, Idris can't verify that any of its arguments is converging "
"towards the base case. It therefore rightfully refuses to accept that "
"`unfold` is total. And indeed, the following function produces an infinite "
"list (so please, don't try to inspect this at the REPL, as doing so will "
"consume all your computer's memory):"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Folds.md:104
#, no-wrap
msgid ""
"fiboHelper : (Nat,Nat) -> ((Nat,Nat),Nat)\n"
"fiboHelper (f0,f1) = ((f1, f0 + f1), f0)\n"
"\n"
"covering\n"
"fibonacci : List Nat\n"
"fibonacci = unfold (Just . fiboHelper) (1,1)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:117
#, markdown-text
msgid ""
"In order to safely create a (finite) sequence of Fibonacci numbers, we need "
"to make sure the function generating the sequence will stop after a finite "
"number of steps, for instance by limiting the length of the list:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Folds.md:118
#, no-wrap
msgid ""
"unfoldTot : Nat -> (gen : s -> Maybe (s,a)) -> s -> List a\n"
"unfoldTot 0     _   _  = []\n"
"unfoldTot (S k) gen vs = case gen vs of\n"
"  Just (vs',va) => va :: unfoldTot k gen vs'\n"
"  Nothing       => []\n"
"\n"
"fibonacciN : Nat -> List Nat\n"
"fibonacciN n = unfoldTot n (Just . fiboHelper) (1,1)\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Folds.md:129
#, markdown-text, no-wrap
msgid "The Call Stack"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:133
#, markdown-text
msgid ""
"In order to demonstrate what tail recursion is about, we require the "
"following `main` function:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Folds.md:134
#, no-wrap
msgid ""
"main : IO ()\n"
"main = printLn . len $ replicateList 10000 10\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:144
#, markdown-text
msgid ""
"If you have [Node.js](https://nodejs.org/en/) installed on your system, you "
"might try the following experiment. Compile and run this module using the "
"*Node.js* backend of Idris instead of the default *Chez Scheme* backend and "
"run the resulting JavaScript source file with the Node.js binary:"
msgstr ""

#. type: Fenced code block (sh)
#: ../src/Tutorial/Folds.md:145
#, no-wrap
msgid ""
"idris2 --cg node -o test.js --find-ipkg -src/Tutorial/Folds.md\n"
"node build/exec/test.js\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:154
#, markdown-text
msgid ""
"Node.js will fail with the following error message and a lengthy stack "
"trace: `RangeError: Maximum call stack size exceeded`.  What's going on "
"here? How can it be that `main` fails with an exception although it is "
"provably total?"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:169
#, markdown-text
msgid ""
"First, remember that a function being total means that it will eventually "
"produce a value of the given type in a finite amount of time, *given enough "
"resources like computer memory*. Here, `main` hasn't been given enough "
"resources as Node.js has a very small size limit on its call stack. The "
"*call stack* can be thought of as a stack data structure (first in, last "
"out), where nested function calls are put. In case of recursive functions, "
"the stack size increases by one with every recursive function call. In case "
"of our `main` function, we create and consume a list of length 10'000, so "
"the call stack will hold at least 10'000 function calls before they are "
"being invoked and the stack's size is reduced again. This exceeds Node.js's "
"stack size limit by far, hence the overflow error."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:180
#, markdown-text
msgid ""
"Now, before we look at a solution how to circumvent this issue, please note "
"that this is a very serious and limiting source of bugs when using the "
"JavaScript backends of Idris. In Idris, having no access to control "
"structures like `for` or `while` loops, we *always* have to resort to "
"recursion in order to describe iterative computations. Luckily (or should I "
"say \"unfortunately\", since otherwise this issue would already have been "
"addressed with all seriousness), the Scheme backends don't have this issue, "
"as their stack size limit is much larger and they perform all kinds of "
"optimizations internally to prevent the call stack from overflowing."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Folds.md:181
#, markdown-text, no-wrap
msgid "Tail Recursion"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:187
#, markdown-text
msgid ""
"A recursive function is said to be *tail recursive*, if all recursive calls "
"occur at *tail position*: The last function call in a (sub)expression. For "
"instance, the following version of `len` is tail recursive:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Folds.md:188
#, no-wrap
msgid ""
"lenOnto : Nat -> List a -> Nat\n"
"lenOnto k []        = k\n"
"lenOnto k (_ :: xs) = lenOnto (k + 1) xs\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:197
#, markdown-text
msgid ""
"Compare this to `len` as defined above: There, the last function call is an "
"invocation of operator `(+)`, and the recursive call happens in one of its "
"arguments:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Folds.md:198
#, no-wrap
msgid "len (_ :: xs) = 1 + len xs\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:204
#, markdown-text
msgid ""
"We can use `lenOnto` as a utility to implement a tail recursive version of "
"`len` without the additional `Nat` argument:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Folds.md:205
#, no-wrap
msgid ""
"lenTR : List a -> Nat\n"
"lenTR = lenOnto 0\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:215
#, markdown-text
msgid ""
"This is a common pattern when writing tail recursive functions: We typically "
"add an additional function argument for accumulating intermediary results, "
"which is then passed on explicitly at each recursive call. For instance, "
"here is a tail recursive version of `replicateList`:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Folds.md:216
#, no-wrap
msgid ""
"replicateListTR : Nat -> a -> List a\n"
"replicateListTR n v = go Nil n\n"
"  where go : List a -> Nat -> List a\n"
"        go xs 0     = xs\n"
"        go xs (S k) = go (v :: xs) k\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:229
#, markdown-text
msgid ""
"The big advantage of tail recursive functions is, that they can be easily "
"converted to efficient, imperative loops by the Idris compiler, and are thus "
"*stack safe*: Recursive function calls are *not* added to the call stack, "
"thus avoiding the dreaded stack overflow errors."
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Folds.md:230
#, no-wrap
msgid ""
"main1 : IO ()\n"
"main1 = printLn . lenTR $ replicateListTR 10000 10\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:240
#, markdown-text
msgid ""
"We can again run `main1` using the *Node.js* backend. This time, we use "
"slightly different syntax to execute a function other than `main` (Remember: "
"The dollar prefix is only there to distinghish a terminal command from its "
"output. It is not part of the command you enter in a terminal sesssion.):"
msgstr ""

#. type: Fenced code block (sh)
#: ../src/Tutorial/Folds.md:241
#, no-wrap
msgid ""
"$ idris2 --cg node --exec main1 --find-ipkg src/Tutorial/Folds.md\n"
"10000\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:248
#, markdown-text
msgid ""
"As you can see, this time the computation finished without overflowing the "
"call stack."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:253
#, markdown-text
msgid ""
"Tail recursive functions are allowed to consist of (possibly nested) pattern "
"matches, with recursive calls at tail position in several of the branches.  "
"Here is an example:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Folds.md:254
#, no-wrap
msgid ""
"countTR : (a -> Bool) -> List a -> Nat\n"
"countTR p = go 0\n"
"  where go : Nat -> List a -> Nat\n"
"        go k []        = k\n"
"        go k (x :: xs) = case p x of\n"
"          True  => go (S k) xs\n"
"          False => go k xs\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:266
#, markdown-text
msgid ""
"Note, how each invocation of `go` is in tail position in its branch of the "
"case expression."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Folds.md:267
#, markdown-text, no-wrap
msgid "Mutual Recursion"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:281
#, markdown-text
msgid ""
"It is sometimes convenient to implement several related functions, which "
"call each other recursively. In Idris, unlike in many other programming "
"languages, a function must be declared in a source file *before* it can be "
"called by other functions, as in general a function's implementation must be "
"available during type checking (because Idris has dependent types). There "
"are two ways around this, which actually result in the same internal "
"representation in the compiler. Our first option is to write down the "
"functions' declarations first with the implementations following "
"after. Here's a silly example:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Folds.md:282
#, no-wrap
msgid ""
"even : Nat -> Bool\n"
"\n"
"odd : Nat -> Bool\n"
"\n"
"even 0     = True\n"
"even (S k) = odd k\n"
"\n"
"odd 0     = False\n"
"odd (S k) = even k\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:297
#, markdown-text
msgid ""
"As you can see, function `even` is allowed to call function `odd` in its "
"implementation, since `odd` has already been declared (but not yet "
"implemented)."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:302
#, markdown-text
msgid ""
"If you're like me and want to keep declarations and implementations next to "
"each other, you can introduce a `mutual` block, which has the same "
"effect. Like with other code blocks, functions in a `mutual` block must all "
"be indented by the same amount of whitespace:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Folds.md:303
#, no-wrap
msgid ""
"mutual\n"
"  even' : Nat -> Bool\n"
"  even' 0     = True\n"
"  even' (S k) = odd' k\n"
"\n"
"  odd' : Nat -> Bool\n"
"  odd' 0     = False\n"
"  odd' (S k) = even' k\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:319
#, markdown-text
msgid ""
"Just like with single recursive functions, mutually recursive functions can "
"be optimized to imperative loops if all recursive calls occur at tail "
"position. This is the case with functions `even` and `odd`, as can again be "
"verified at the *Node.js* backend:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Folds.md:320
#, no-wrap
msgid ""
"main2 : IO ()\n"
"main2 =  printLn (even 100000)\n"
"      >> printLn (odd 100000)\n"
msgstr ""

#. type: Fenced code block (sh)
#: ../src/Tutorial/Folds.md:326
#, no-wrap
msgid ""
"$ idris2 --cg node --exec main2 --find-ipkg src/Tutorial/Folds.md\n"
"True\n"
"False\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Folds.md:332
#, markdown-text, no-wrap
msgid "Final Remarks"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:336
#, markdown-text
msgid ""
"In this section, we learned about several important aspects of recursion and "
"totality checking, which are summarized here:"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Folds.md:339
#, markdown-text
msgid ""
"In pure functional programming, recursion is the way to implement iterative "
"procedures."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Folds.md:343
#, markdown-text
msgid ""
"Recursive functions pass the totality checker, if it can verify that one of "
"the arguments is getting strictly smaller in every recursive function call."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Folds.md:346
#, markdown-text
msgid ""
"Arbitrary recursion can lead to stack overflow exceptions on backends with "
"small stack size limits."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Folds.md:350
#, markdown-text
msgid ""
"The JavaScript backends of Idris perform mutual tail call optimization: Tail "
"recursive functions are converted to stack safe, imperative loops."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:354
#, markdown-text
msgid ""
"Note, that not all Idris backends you will come across in the wild will "
"perform tail call optimization. Please check the corresponding "
"documentation."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:372
#, markdown-text
msgid ""
"Note also, that most recursive functions in the core libraries (*prelude* "
"and *base*) do not yet make use of tail recursion. There is an important "
"reason for this: In many cases, non-tail recursive functions are easier to "
"use in compile-time proofs, as they unify more naturally than their tail "
"recursive counterparts.  Compile-time proofs are an important aspect of "
"programming in Idris (as we will see in later chapters), so there is a "
"compromise to be made between what performs well at runtime and what works "
"well at compile time. Eventually, the way to go might be to provide two "
"implementations for most recursive functions with a *transform rule* telling "
"the compiler to use the optimized version at runtime whenever programmers "
"use the non-optimized version in their code.  Such transform rules have - "
"for instance - already been written for functions `pack` and `unpack` (which "
"use `fastPack` and `fastUnpack` at runtime; see the corresponding rules in "
"[the following source "
"file](https://github.com/idris-lang/Idris2/blob/main/libs/prelude/Prelude/Types.idr))."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:379
#, markdown-text
msgid ""
"In these exercises you are going to implement several recursive "
"functions. Make sure to use tail recursion whenever possible and quickly "
"verify the correct behavior of all functions at the REPL."
msgstr ""

#. type: Bullet: '1. '
#: ../src/Tutorial/Folds.md:383
#, markdown-text
msgid ""
"Implement functions `anyList` and `allList`, which return `True` if any "
"element (or all elements in case of `allList`) in a list fulfills the given "
"predicate:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Folds.md:384
#, no-wrap
msgid ""
"   anyList : (a -> Bool) -> List a -> Bool\n"
"\n"
"   allList : (a -> Bool) -> List a -> Bool\n"
msgstr ""

#. type: Bullet: '2. '
#: ../src/Tutorial/Folds.md:392
#, markdown-text
msgid ""
"Implement function `findList`, which returns the first value (if any) "
"fulfilling the given predicate:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Folds.md:393
#, no-wrap
msgid "   findList : (a -> Bool) -> List a -> Maybe a\n"
msgstr ""

#. type: Bullet: '3. '
#: ../src/Tutorial/Folds.md:399
#, markdown-text
msgid ""
"Implement function `collectList`, which returns the first value (if any), "
"for which the given function returns a `Just`:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Folds.md:400
#, no-wrap
msgid "   collectList : (a -> Maybe b) -> List a -> Maybe b\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:405
#, markdown-text, no-wrap
msgid "   Implement `lookupList` in terms of `collectList`:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Folds.md:406
#, no-wrap
msgid "   lookupList : Eq a => a -> List (a,b) -> Maybe b\n"
msgstr ""

#. type: Bullet: '4. '
#: ../src/Tutorial/Folds.md:423
#, markdown-text
msgid ""
"For functions like `map` or `filter`, which must loop over a list without "
"affecting the order of elements, it is harder to write a tail recursive "
"implementation.  The safest way to do so is by using a `SnocList` (a "
"*reverse* kind of list that's built from head to tail instead of from tail "
"to head) to accumulate intermediate results. Its two constructors are `Lin` "
"and `(:<)` (called the *snoc* operator).  Module `Data.SnocList` exports two "
"tail recursive operators called *fish* and *chips* (`(<><)` and `(<>>)`) for "
"going from `SnocList` to `List` and vice versa. Have a look at the types of "
"all new data constructors and operators before continuing with the exercise."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:428
#, markdown-text, no-wrap
msgid ""
"   Implement a tail recursive version of `map` for `List`\n"
"   by using a `SnocList` to reassemble the mapped list. Use then\n"
"   the *chips* operator with a `Nil` argument to\n"
"   in the end convert the `SnocList` back to a `List`.\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Folds.md:429
#, no-wrap
msgid "   mapTR : (a -> b) -> List a -> List b\n"
msgstr ""

#. type: Bullet: '5. '
#: ../src/Tutorial/Folds.md:437
#, markdown-text
msgid ""
"Implement a tail recursive version of `filter`, which only keeps those "
"values in a list, which fulfill the given predicate. Use the same technique "
"as described in exercise 4."
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Folds.md:438
#, no-wrap
msgid "   filterTR : (a -> Bool) -> List a -> List a\n"
msgstr ""

#. type: Bullet: '6. '
#: ../src/Tutorial/Folds.md:445
#, markdown-text
msgid ""
"Implement a tail recursive version of `mapMaybe`, which only keeps those "
"values in a list, for which the given function argument returns a `Just`:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Folds.md:446
#, no-wrap
msgid "   mapMaybeTR : (a -> Maybe b) -> List a -> List b\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:451
#, markdown-text, no-wrap
msgid "   Implement `catMaybesTR` in terms of `mapMaybeTR`:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Folds.md:452
#, no-wrap
msgid "   catMaybesTR : List (Maybe a) -> List a\n"
msgstr ""

#. type: Bullet: '7. '
#: ../src/Tutorial/Folds.md:457
#, markdown-text
msgid "Implement a tail recursive version of list concatenation:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Folds.md:458
#, no-wrap
msgid "   concatTR : List a -> List a -> List a\n"
msgstr ""

#. type: Bullet: '8. '
#: ../src/Tutorial/Folds.md:464
#, markdown-text
msgid "Implement tail recursive versions of *bind* and `join` for `List`:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Folds.md:465
#, no-wrap
msgid ""
"   bindTR : List a -> (a -> List b) -> List b\n"
"\n"
"   joinTR : List (List a) -> List a\n"
msgstr ""

#. type: Title ##
#: ../src/Tutorial/Folds.md:471
#, markdown-text, no-wrap
msgid "A few Notes on Totality Checking"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:482
#, markdown-text
msgid ""
"The totality checker in Idris verifies, that at least one (possibly erased!) "
"argument in a recursive call converges towards a base case. For instance, "
"with natural numbers, if the base case is zero (corresponding to data "
"constructor `Z`), and we continue with `k` after pattern matching on `S k`, "
"Idris can derive from `Nat`'s constructors, that `k` is strictly smaller "
"than `S k` and therefore the recursive call must converge towards a base "
"case.  Exactly the same reasoning is used when pattern matching on a list "
"and continuing only with its tail in the recursive call."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:487
#, markdown-text
msgid ""
"While this works in many cases, it doesn't always go as expected.  Below, "
"I'll show you a couple of examples where totality checking fails, although "
"*we* know, that the functions in question are definitely total."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Folds.md:488
#, markdown-text, no-wrap
msgid "Case 1: Recursion over a Primitive"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:494
#, markdown-text
msgid ""
"Idris doesn't know anything about the internal structure of primitive data "
"types. So the following function, although being obviously total, will not "
"be accepted by the totality checker:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Folds.md:495
#, no-wrap
msgid ""
"covering\n"
"replicatePrim : Bits32 -> a -> List a\n"
"replicatePrim 0 v = []\n"
"replicatePrim x v = v :: replicatePrim (x - 1) v\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:514
#, markdown-text
msgid ""
"Unlike with natural numbers (`Nat`), which are defined as an inductive data "
"type and are only converted to integer primitives during compilation, Idris "
"can't tell that `x - 1` is strictly smaller than `x`, and so it fails to "
"verify that this must converge towards the base case.  (The reason is, that "
"`x - 1` is implemented in terms of primitive function `prim__sub_Bits32`, "
"which is built into the compiler and must be implemented by each backend "
"individually. The totality checker knows about data types, constructors, and "
"functions defined in Idris, but not about (primitive) functions and foreign "
"functions implemented at the backends. While it is theoretically possible to "
"also define and use laws for primitive and foreign functions, this hasn't "
"yet been done for most of them.)"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:520
#, markdown-text
msgid ""
"Since non-totality is highly contagious (all functions invoking a partial "
"function are themselves considered to be partial by the totality checker), "
"there is utility function `assert_smaller`, which we can use to convince the "
"totality checker and still annotate our functions with the `total` keyword:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Folds.md:521
#, no-wrap
msgid ""
"replicatePrim' : Bits32 -> a -> List a\n"
"replicatePrim' 0 v = []\n"
"replicatePrim' x v = v :: replicatePrim' (assert_smaller x $ x - 1) v\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:532
#, markdown-text
msgid ""
"Please note, though, that whenever you use `assert_smaller` to silence the "
"totality checker, the burden of proving totality rests on your "
"shoulders. Failing to do so can lead to arbitrary and unpredictable program "
"behavior (which is the default with most other programming languages)."
msgstr ""

#. type: Title ####
#: ../src/Tutorial/Folds.md:533
#, markdown-text, no-wrap
msgid "Ex Falso Quodlibet"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:543
#, markdown-text
msgid ""
"Below - as a demonstration - is a simple proof of `Void`.  `Void` is an "
"*uninhabited type*: a type with no values.  *Proofing `Void`* means, that we "
"implement a function accepted by the totality checker, which returns a value "
"of type `Void`, although this is supposed to be impossible as there is no "
"such value. Doing so allows us to completely disable the type system "
"together with all the guarantees it provides.  Here's the code and its dire "
"consequences:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Folds.md:544
#, no-wrap
msgid ""
"-- In order to proof `Void`, we just loop forever, using\n"
"-- `assert_smaller` to silence the totality checker.\n"
"proofOfVoid : Bits8 -> Void\n"
"proofOfVoid n = proofOfVoid (assert_smaller n n)\n"
"\n"
"-- From a value of type `Void`, anything follows!\n"
"-- This function is safe and total, as there is no\n"
"-- value of type `Void`!\n"
"exFalsoQuodlibet : Void -> a\n"
"exFalsoQuodlibet _ impossible\n"
"\n"
"-- By passing our proof of void to `exFalsoQuodlibet`\n"
"-- (exported by the *Prelude* by the name of `void`), we\n"
"-- can coerce any value to a value of any other type.\n"
"-- This renders type checking completely useless, as\n"
"-- we can freely convert between values of different\n"
"-- types.\n"
"coerce : a -> b\n"
"coerce _ = exFalsoQuodlibet (proofOfVoid 0)\n"
"\n"
"-- Finally, we invoke `putStrLn` with a number instead\n"
"-- of a string. `coerce` allows us to do just that.\n"
"pain : IO ()\n"
"pain = putStrLn $ coerce 0\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:576
#, markdown-text
msgid ""
"Please take a moment to marvel at provably total function `coerce`: It "
"claims to convert *any* value to a value of *any* other type.  And it is "
"completely safe, as it only uses total functions in its implementation. The "
"problem is - of course - that `proofOfVoid` should never ever have been a "
"total function."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:581
#, markdown-text
msgid ""
"In `pain` we use `coerce` to conjure a string from an integer.  In the end, "
"we get what we deserve: The program crashes with an error.  While things "
"could have been much worse, it can still be quite time consuming and "
"annoying to localize the source of such an error."
msgstr ""

#. type: Fenced code block (sh)
#: ../src/Tutorial/Folds.md:582
#, no-wrap
msgid ""
"$ idris2 --cg node --exec pain --find-ipkg src/Tutorial/Folds.md\n"
"ERROR: No clauses\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:590
#, markdown-text
msgid ""
"So, with a single thoughtless placement of `assert_smaller` we wrought havoc "
"within our pure and total codebase sacrificing totality and type safety in "
"one fell swoop. Therefore: Use at your own risk!"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:594
#, markdown-text
msgid ""
"Note: I do not expect you to understand all the dark magic at work in the "
"code above. I'll explain the details in due time in another chapter."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:602
#, markdown-text
msgid ""
"Second note: *Ex falso quodlibet*, also called [the principle of "
"explosion](https://en.wikipedia.org/wiki/Principle_of_explosion)  is a law "
"in classical logic: From a contradiction, any statement can be proven.  In "
"our case, the contradiction was our proof of `Void`: The claim that we wrote "
"a total function producing such a value, although `Void` is an uninhabited "
"type.  You can verify this by inspecting `Void` at the REPL with `:doc "
"Void`: It has no data constructors."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Folds.md:603
#, markdown-text, no-wrap
msgid "Case 2: Recursion via Function Calls"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:608
#, markdown-text
msgid ""
"Below is an implementation of a [*rose "
"tree*](https://en.wikipedia.org/wiki/Rose_tree).  Rose trees can represent "
"search paths in computer algorithms, for instance in graph theory."
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Folds.md:609
#, no-wrap
msgid ""
"record Tree a where\n"
"  constructor Node\n"
"  value  : a\n"
"  forest : List (Tree a)\n"
"\n"
"Forest : Type -> Type\n"
"Forest = List . Tree\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:620
#, markdown-text
msgid "We could try and compute the size of such a tree as follows:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Folds.md:621
#, no-wrap
msgid ""
"covering\n"
"size : Tree a -> Nat\n"
"size (Node _ forest) = S . sum $ map size forest\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:632
#, markdown-text
msgid ""
"In the code above, the recursive call happens within `map`. *We* know that "
"we are using only subtrees in the recursive calls (since we know how `map` "
"is implemented for `List`), but Idris can't know this (teaching a totality "
"checker how to figure this out on its own seems to be an open research "
"question). So it will refuse to accept the function as being total."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:637
#, markdown-text
msgid ""
"There are two ways to handle the case above. If we don't mind writing a bit "
"of otherwise unneeded boilerplate code, we can use explicit recursion.  In "
"fact, since we often also work with search *forests*, this is the preferable "
"way here."
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Folds.md:638
#, no-wrap
msgid ""
"mutual\n"
"  treeSize : Tree a -> Nat\n"
"  treeSize (Node _ forest) = S $ forestSize forest\n"
"\n"
"  forestSize : Forest a -> Nat\n"
"  forestSize []        = 0\n"
"  forestSize (x :: xs) = treeSize x + forestSize xs\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:652
#, markdown-text
msgid ""
"In the case above, Idris can verify that we don't blow up our trees behind "
"its back as we are explicit about what happens in each recursive step.  This "
"is the safe, preferable way of going about this, especially if you are new "
"to the language and totality checking in general."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:655
#, markdown-text
msgid ""
"However, sometimes the solution presented above is just too cumbersome to "
"write. For instance, here is an implementation of `Show` for rose trees:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Folds.md:656
#, no-wrap
msgid ""
"Show a => Show (Tree a) where\n"
"  showPrec p (Node v ts) =\n"
"    assert_total $ showCon p \"Node\" (showArg v ++ showArg ts)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:667
#, markdown-text
msgid ""
"In this case, we'd have to manually reimplement `Show` for lists of trees: A "
"tedious task - and error-prone on its own. Instead, we resort to using the "
"mighty sledgehammer of totality checking: `assert_total`. Needless to say "
"that this comes with the same risks as `assert_smaller`, so be very careful."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:673
#, markdown-text
msgid ""
"Implement the following functions in a provably total way without "
"\"cheating\". Note: It is not necessary to implement these in a tail "
"recursive way."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:682
#, markdown-text, no-wrap
msgid ""
"<!-- textlint-disable terminology -->\n"
"1. Implement function `depth` for rose trees. This\n"
"   should return the maximal number of `Node` constructors\n"
"   from the current node to the farthest child node.\n"
"   For instance, the current node should be at depth one,\n"
"   all its direct child nodes are at depth two, their\n"
"   immediate child nodes at depth three and so on.\n"
"<!-- textlint-enable -->\n"
msgstr ""

#. type: Bullet: '2. '
#: ../src/Tutorial/Folds.md:684
#, markdown-text
msgid "Implement interface `Eq` for rose trees."
msgstr ""

#. type: Bullet: '3. '
#: ../src/Tutorial/Folds.md:686
#, markdown-text
msgid "Implement interface `Functor` for rose trees."
msgstr ""

#. type: Bullet: '4. '
#: ../src/Tutorial/Folds.md:688
#, markdown-text
msgid "For the fun of it: Implement interface `Show` for rose trees."
msgstr ""

#. type: Bullet: '5. '
#: ../src/Tutorial/Folds.md:692
#, markdown-text
msgid ""
"In order not to forget how to program with dependent types, implement "
"function `treeToVect` for converting a rose tree to a vector of the correct "
"size."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:696
#, markdown-text, no-wrap
msgid ""
"   Hint: Make sure to follow the same recursion scheme as in\n"
"   the implementation of `treeSize`. Otherwise, this might be\n"
"   very hard to get to work.\n"
msgstr ""

#. type: Title ##
#: ../src/Tutorial/Folds.md:697
#, markdown-text, no-wrap
msgid "Interface Foldable"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:707
#, markdown-text
msgid ""
"When looking back at all the exercises we solved in the section about "
"recursion, most tail recursive functions on lists were of the following "
"pattern: Iterate over all list elements from head to tail while passing "
"along some state for accumulating intermediate results. At the end of the "
"list, return the final state or convert it with an additional function call."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Folds.md:708
#, markdown-text, no-wrap
msgid "Left Folds"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:719
#, markdown-text, no-wrap
msgid ""
"This is functional programming, and we'd like to abstract\n"
"over such reoccurring patterns. In order to tail recursively\n"
"iterate over a list, all we need is an accumulator function\n"
"and some initial state. But what should be the type of\n"
"the accumulator? Well, it combines the current state\n"
"with the list's next element and returns an updated\n"
"state: `state -> elem -> state`. Surely, we can come\n"
"up with a higher-order function to encapsulate this\n"
"behavior:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Folds.md:720
#, no-wrap
msgid ""
"leftFold : (acc : state -> el -> state) -> (st : state) -> List el -> "
"state\n"
"leftFold _   st []        = st\n"
"leftFold acc st (x :: xs) = leftFold acc (acc st x) xs\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:734
#, markdown-text
msgid ""
"We call this function a *left fold*, as it iterates over the list from left "
"to right (head to tail), collapsing (or *folding*) the list until just a "
"single value remains.  This new value might still be a list or other "
"container type, but the original list has been consumed from head to tail.  "
"Note how `leftFold` is tail recursive, and therefore all functions "
"implemented in terms of `leftFold` are tail recursive (and thus, stack "
"safe!) as well."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:736
#, markdown-text
msgid "Here are a few examples:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Folds.md:737
#, no-wrap
msgid ""
"sumLF : Num a => List a -> a\n"
"sumLF = leftFold (+) 0\n"
"\n"
"reverseLF : List a -> List a\n"
"reverseLF = leftFold (flip (::)) Nil\n"
"\n"
"-- this is more natural than `reverseLF`!\n"
"toSnocListLF : List a -> SnocList a\n"
"toSnocListLF = leftFold (:<) Lin\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Folds.md:749
#, markdown-text, no-wrap
msgid "Right Folds"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:760
#, markdown-text
msgid ""
"The example functions we implemented in terms of `leftFold` had to always "
"completely traverse the whole list, as every single element was required to "
"compute the result. This is not always necessary, however. For instance, if "
"you look at `findList` from the exercises, we could abort iterating over the "
"list as soon as our search was successful. It is *not* possible to implement "
"this more efficient behavior in terms of `leftFold`: There, the result will "
"only be returned when our pattern match reaches the `Nil` case."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:765
#, markdown-text
msgid ""
"Interestingly, there is another, non-tail recursive fold, which reflects the "
"list structure more naturally, we can use for breaking out early from an "
"iteration. We call this a *right fold*. Here is its implementation:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Folds.md:766
#, no-wrap
msgid ""
"rightFold : (acc : el -> state -> state) -> state -> List el -> state\n"
"rightFold acc st []        = st\n"
"rightFold acc st (x :: xs) = acc x (rightFold acc st xs)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:775
#, markdown-text
msgid ""
"Now, it might not immediately be obvious how this differs from `leftFold`.  "
"In order to see this, we will have to talk about lazy evaluation first."
msgstr ""

#. type: Title ####
#: ../src/Tutorial/Folds.md:776
#, markdown-text, no-wrap
msgid "Lazy Evaluation in Idris"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:784
#, markdown-text
msgid ""
"For some computations, it is not necessary to evaluate all function "
"arguments in order to return a result. For instance, consider boolean "
"operator `(&&)`: If the first argument evaluates to `False`, we already know "
"that the result is `False` without even looking at the second argument. In "
"such a case, we don't want to unnecessarily evaluate the second argument, as "
"this might include a lengthy computation."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:786
#, markdown-text
msgid "Consider the following REPL session:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Folds.md:787
#, no-wrap
msgid ""
"Tutorial.Folds> False && (length [1..10000000000] > 100)\n"
"False\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:797
#, markdown-text
msgid ""
"If the second argument were evaluated, this computation would most certainly "
"blow up your computer's memory, or at least take a very long time to run to "
"completion. However, in this case, the result `False` is printed "
"immediately. If you look at the type of `(&&)`, you'll see the following:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Folds.md:798
#, no-wrap
msgid ""
"Tutorial.Folds> :t (&&)\n"
"Prelude.&& : Bool -> Lazy Bool -> Bool\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:816
#, markdown-text
msgid ""
"As you can see, the second argument is wrapped in a `Lazy` type "
"constructor. This is a built-in type, and the details are handled by Idris "
"automatically most of the time. For instance, when passing arguments to "
"`(&&)`, we don't have to manually wrap the values in some data constructor.  "
"A lazy function argument will only be evaluated at the moment it is "
"*required* in the function's implementation, for instance, because it is "
"being pattern matched on, or it is being passed as a strict argument to "
"another function. In the implementation of `(&&)`, the pattern match happens "
"on the first argument, so the second will only be evaluated if the first "
"argument is `True` and the second is returned as the function's (strict) "
"result."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:821
#, markdown-text
msgid ""
"There are two utility functions for working with lazy evaluation: Function "
"`delay` wraps a value in the `Lazy` data type. Note, that the argument of "
"`delay` is strict, so the following might take several seconds to print its "
"result:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Folds.md:822
#, no-wrap
msgid ""
"Tutorial.Folds> False && (delay $ length [1..10000] > 100)\n"
"False\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:829
#, markdown-text
msgid ""
"In addition, there is function `force`, which forces evaluation of a `Lazy` "
"value."
msgstr ""

#. type: Title ####
#: ../src/Tutorial/Folds.md:830
#, markdown-text, no-wrap
msgid "Lazy Evaluation and Right Folds"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:838
#, markdown-text
msgid ""
"We will now learn how to make use of `rightFold` and lazy evaluation to "
"implement folds, which can break out from iteration early.  Note, that in "
"the implementation of `rightFold` the result of folding over the remainder "
"of the list is passed as an argument to the accumulator (instead of the "
"result of invoking the accumulator being used in the recursive call):"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Folds.md:839
#, no-wrap
msgid "rightFold acc st (x :: xs) = acc x (rightFold acc st xs)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:846
#, markdown-text
msgid ""
"If the second argument of `acc` were lazily evaluated, it would be possible "
"to abort the computation of `acc`'s result without having to iterate till "
"the end of the list:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Folds.md:847
#, no-wrap
msgid ""
"foldHead : List a -> Maybe a\n"
"foldHead = force . rightFold first Nothing\n"
"  where first : a -> Lazy (Maybe a) -> Lazy (Maybe a)\n"
"        first v _ = Just v\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:858
#, markdown-text
msgid ""
"Note, how Idris takes care of the bookkeeping of laziness most of the "
"time. (It doesn't handle the curried invocation of `rightFold` correctly, "
"though, so we either must pass on the list argument of `foldHead` "
"explicitly, or compose the curried function with `force` to get the types "
"right.)"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:865
#, markdown-text
msgid ""
"In order to verify that this works correctly, we need a debugging utility "
"called `trace` from module `Debug.Trace`. This \"function\" allows us to "
"print debugging messages to the console at certain points in our pure "
"code. Please note, that this is for debugging purposes only and should never "
"be left lying around in production code, as, strictly speaking, printing "
"stuff to the console breaks referential transparency."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:868
#, markdown-text
msgid ""
"Here is an adjusted version of `foldHead`, which prints \"folded\" to "
"standard output every time utility function `first` is being invoked:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Folds.md:869
#, no-wrap
msgid ""
"foldHeadTraced : List a -> Maybe a\n"
"foldHeadTraced = force . rightFold first Nothing\n"
"  where first : a -> Lazy (Maybe a) -> Lazy (Maybe a)\n"
"        first v _ = trace \"folded\" (Just v)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:879
#, markdown-text
msgid ""
"In order to test this at the REPL, we need to know that `trace` uses "
"`unsafePerformIO` internally and therefore will not reduce during "
"evaluation. We have to resort to the `:exec` command to see this in action "
"at the REPL:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Folds.md:880
#, no-wrap
msgid ""
"Tutorial.Folds> :exec printLn $ foldHeadTraced [1..10]\n"
"folded\n"
"Just 1\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:888
#, markdown-text
msgid ""
"As you can see, although the list holds ten elements, `first` is only called "
"once resulting in a considerable increase of efficiency."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:891
#, markdown-text
msgid ""
"Let's see what happens, if we change the implementation of `first` to use "
"strict evaluation:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Folds.md:892
#, no-wrap
msgid ""
"foldHeadTracedStrict : List a -> Maybe a\n"
"foldHeadTracedStrict = rightFold first Nothing\n"
"  where first : a -> Maybe a -> Maybe a\n"
"        first v _ = trace \"folded\" (Just v)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:903
#, markdown-text
msgid ""
"Although we don't use the second argument in the implementation of `first`, "
"it is still being evaluated before evaluating the body of `first`, because "
"Idris - unlike Haskell! - defaults to use strict semantics. Here's how this "
"behaves at the REPL:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Folds.md:904
#, no-wrap
msgid ""
"Tutorial.Folds> :exec printLn $ foldHeadTracedStrict [1..10]\n"
"folded\n"
"folded\n"
"folded\n"
"folded\n"
"folded\n"
"folded\n"
"folded\n"
"folded\n"
"folded\n"
"folded\n"
"Just 1\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:925
#, markdown-text
msgid ""
"While this technique can sometimes lead to very elegant code, always "
"remember that `rightFold` is not stack safe in the general case. So, unless "
"your accumulator is not guaranteed to return a result after not too many "
"iterations, consider implementing your function tail recursively with an "
"explicit pattern match. Your code will be slightly more verbose, but with "
"the guaranteed benefit of stack safety."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Folds.md:926
#, markdown-text, no-wrap
msgid "Folds and Monoids"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:934
#, markdown-text
msgid ""
"Left and right folds share a common pattern: In both cases, we start with an "
"initial *state* value and use an accumulator function for combining the "
"current state with the current element. This principle of *combining values* "
"after starting from an *initial value* lies at the heart of an interface "
"we've already learned about: `Monoid`.  It therefore makes sense to fold a "
"list over a monoid:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Folds.md:935
#, no-wrap
msgid ""
"foldMapList : Monoid m => (a -> m) -> List a -> m\n"
"foldMapList f = leftFold (\\vm,va => vm <+> f va) neutral\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:946
#, markdown-text
msgid ""
"Note how, with `foldMapList`, we no longer need to pass an accumulator "
"function. All we need is a conversion from the element type to a type with "
"an implementation of `Monoid`. As we have already seen in the chapter about "
"[interfaces](Interfaces.md), there are *many* monoids in functional "
"programming, and therefore, `foldMapList` is an incredibly useful function."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:950
#, markdown-text
msgid ""
"We could make this even shorter: If the elements in our list already are of "
"a type with a monoid implementation, we don't even need a conversion "
"function to collapse the list:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Folds.md:951
#, no-wrap
msgid ""
"concatList : Monoid m => List m -> m\n"
"concatList = foldMapList id\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Folds.md:956
#, markdown-text, no-wrap
msgid "Stop Using `List` for Everything"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:971
#, markdown-text
msgid ""
"And here we are, finally, looking at a large pile of utility functions all "
"dealing in some way with the concept of collapsing (or folding)  a list of "
"values into a single result. But all of these folding functions are just as "
"useful when working with vectors, with non-empty lists, with rose trees, "
"even with single-value containers like `Maybe`, `Either e`, or "
"`Identity`. Heck, for the sake of completeness, they are even useful when "
"working with zero-value containers like `Control.Applicative.Const e`! And "
"since there are so many of these functions, we'd better look out for an "
"essential set of them in terms of which we can implement all the others, and "
"wrap up the whole bunch in an interface. This interface is called "
"`Foldable`, and is available from the `Prelude`. When you look at its "
"definition in the REPL (`:doc Foldable`), you'll see that it consists of six "
"essential functions:"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Folds.md:978
#, markdown-text
msgid "`foldr`, for folds from the right"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Folds.md:978
#, markdown-text
msgid "`foldl`, for folds from the left"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Folds.md:978
#, markdown-text
msgid "`null`, for testing if the container is empty or not"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Folds.md:978
#, markdown-text
msgid "`foldlM`, for effectful folds in a monad"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Folds.md:978
#, markdown-text
msgid "`toList`, for converting the container to a list of values"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Folds.md:978
#, markdown-text
msgid "`foldMap`, for folding over a monoid"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:987
#, markdown-text
msgid ""
"For a minimal implementation of `Foldable`, it is sufficient to only "
"implement `foldr`. However, consider implementing all six functions "
"manually, because folds over container types are often performance critical "
"operations, and each of them should be optimized accordingly.  For instance, "
"implementing `toList` in terms of `foldr` for `List` just makes no sense, as "
"this is a non-tail recursive function running in linear time complexity, "
"while a hand-written implementation can just return its argument without any "
"modifications."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:993
#, markdown-text
msgid ""
"In these exercises, you are going to implement `Foldable` for different data "
"types. Make sure to try and manually implement all six functions of the "
"interface."
msgstr ""

#. type: Bullet: '1. '
#: ../src/Tutorial/Folds.md:995
#, markdown-text
msgid "Implement `Foldable` for `Crud i`:"
msgstr ""

#. type: Bullet: '2. '
#: ../src/Tutorial/Folds.md:1005
#, markdown-text
msgid "Implement `Foldable` for `Response e i`:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Folds.md:1006 ../src/Tutorial/Functor.md:429
#: ../src/Tutorial/Traverse.md:295
#, no-wrap
msgid ""
"   data Response : (e, i, a : Type) -> Type where\n"
"     Created : (id : i) -> (value : a) -> Response e i a\n"
"     Updated : (id : i) -> (value : a) -> Response e i a\n"
"     Found   : (values : List a) -> Response e i a\n"
"     Deleted : (id : i) -> Response e i a\n"
"     Error   : (err : e) -> Response e i a\n"
msgstr ""

#. type: Bullet: '3. '
#: ../src/Tutorial/Folds.md:1018
#, markdown-text
msgid ""
"Implement `Foldable` for `List01`. Use tail recursion in the implementations "
"of `toList`, `foldMap`, and `foldl`."
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Folds.md:1019 ../src/Tutorial/IO.md:753
#: ../src/Tutorial/Traverse.md:267
#, no-wrap
msgid ""
"   data List01 : (nonEmpty : Bool) -> Type -> Type where\n"
"     Nil  : List01 False a\n"
"     (::) : a -> List01 False a -> List01 ne a\n"
msgstr ""

#. type: Bullet: '4. '
#: ../src/Tutorial/Folds.md:1030
#, markdown-text
msgid ""
"Implement `Foldable` for `Tree`. There is no need to use tail recursion in "
"your implementations, but your functions must be accepted by the totality "
"checker, and you are not allowed to cheat by using `assert_smaller` or "
"`assert_total`."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:1034
#, markdown-text, no-wrap
msgid ""
"   Hint: You can test the correct behavior of your implementations\n"
"   by running the same folds on the result of `treeToVect` and\n"
"   verify that the outcome is the same.\n"
msgstr ""

#. type: Bullet: '5. '
#: ../src/Tutorial/Folds.md:1039
#, markdown-text
msgid ""
"Like `Functor` and `Applicative`, `Foldable` composes: The product and "
"composition of two foldable container types are again foldable container "
"types. Proof this by implementing `Foldable` for `Comp` and `Product`:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Folds.md:1040 ../src/Tutorial/Traverse.md:308
#, no-wrap
msgid ""
"   record Comp (f,g : Type -> Type) (a : Type) where\n"
"     constructor MkComp\n"
"     unComp  : f (g a)\n"
"\n"
"   record Product (f,g : Type -> Type) (a : Type) where\n"
"     constructor MkProduct\n"
"     fst : f a\n"
"     snd : g a\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:1058
#, markdown-text
msgid ""
"We learned a lot about recursion, totality checking, and folds in this "
"chapter, all of which are important concepts in pure functional programming "
"in general. Wrapping one's head around recursion takes time and "
"experience. Therefore - as usual - try to solve as many exercises as you "
"can."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Folds.md:1062
#, markdown-text
msgid ""
"In the next chapter, we are taking the concept of iterating over container "
"types one step further and look at effectful data traversals."
msgstr ""

#. type: Title #
#: ../src/Tutorial/Functions1.md:1
#, markdown-text, no-wrap
msgid "Functions Part 1"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:12
#, markdown-text
msgid ""
"Idris is a *functional* programming language. This means, that functions are "
"its main form of abstraction (unlike for instance in an object oriented "
"language like Java, where *objects* and *classes* are the main form of "
"abstraction). It also means that we expect Idris to make it very easy for us "
"to compose and combine functions to create new functions. In fact, in Idris "
"functions are *first class*: Functions can take other functions as arguments "
"and can return functions as their results."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:16
#, markdown-text
msgid ""
"We already learned about the basic shape of top level function declarations "
"in Idris in the [introduction](Intro.md), so we will continue from what we "
"learned there."
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions1.md:17
#, no-wrap
msgid "module Tutorial.Functions1\n"
msgstr ""

#. type: Title ##
#: ../src/Tutorial/Functions1.md:21
#, markdown-text, no-wrap
msgid "Functions with more than one Argument"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:28
#, markdown-text
msgid ""
"Let's implement a function, which checks if its three `Integer` arguments "
"form a [Pythagorean "
"triple](https://en.wikipedia.org/wiki/Pythagorean_triple).  We get to use a "
"new operator for this: `==`, the equality operator."
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions1.md:29
#, no-wrap
msgid ""
"isTriple : Integer -> Integer -> Integer -> Bool\n"
"isTriple x y z = x * x + y * y == z * z\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:36
#, markdown-text
msgid "Let's give this a spin at the REPL before we talk a bit about the types:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions1.md:37
#, no-wrap
msgid ""
"Tutorial.Functions1> isTriple 1 2 3\n"
"False\n"
"Tutorial.Functions1> isTriple 3 4 5\n"
"True\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:49
#, markdown-text, no-wrap
msgid ""
"As can be seen from this example, the type of a function\n"
"of several arguments consists just of a sequence\n"
"of argument types (also called *input types*)\n"
"chained by function arrows (`->`), which\n"
"is terminated by an output type (`Bool` in this case).\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:61
#, markdown-text
msgid ""
"The implementation looks a bit like a mathematical equation: We list the "
"arguments on the left hand side of `=` and describe the computation(s) to "
"perform with them on the right hand side. Function implementations in "
"functional programming languages often have this more mathematical look "
"compared to implementations in imperative languages, which often describe "
"not *what* to compute, but *how* to compute it by describing an algorithm as "
"a sequence of imperative statements. We will later see that this imperative "
"style is also available in Idris, but whenever possible we prefer the "
"declarative style."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:68
#, markdown-text
msgid ""
"As can be seen in the REPL example, functions can be invoked by passing the "
"arguments separated by whitespace. No parentheses are necessary unless one "
"of the expressions we pass as the function's arguments contains itself "
"additional whitespace.  This comes in very handy when we apply functions "
"only partially (see later in this chapter)."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:74
#, markdown-text
msgid ""
"Note that, unlike `Integer` or `Bits8`, `Bool` is not a primitive data type "
"built into the Idris language but just a custom data type that you could "
"have written yourself. We will learn more about declaring new data types in "
"the next chapter."
msgstr ""

#. type: Title ##
#: ../src/Tutorial/Functions1.md:75
#, markdown-text, no-wrap
msgid "Function Composition"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:79
#, markdown-text
msgid ""
"Functions can be combined in several ways, the most direct probably being "
"the dot operator:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions1.md:80
#, no-wrap
msgid ""
"square : Integer -> Integer\n"
"square n = n * n\n"
"\n"
"times2 : Integer -> Integer\n"
"times2 n = 2 * n\n"
"\n"
"squareTimes2 : Integer -> Integer\n"
"squareTimes2 = times2 . square\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:92
#, markdown-text
msgid "Give this a try at the REPL! Does it do what you'd expect?"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:95
#, markdown-text
msgid ""
"We could have implemented `squareTimes2` without using the dot operator as "
"follows:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions1.md:96
#, no-wrap
msgid ""
"squareTimes2' : Integer -> Integer\n"
"squareTimes2' n = times2 (square n)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:105
#, markdown-text, no-wrap
msgid ""
"It is important to note, that functions chained by the dot\n"
"operator are invoked from right to left: `times2 . square`\n"
"is the same as `\\n => times2 (square n)` and not\n"
"`\\n => square (times2 n)`.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:108
#, markdown-text
msgid ""
"We can conveniently chain several functions using the dot operator to write "
"more complex functions:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions1.md:109
#, no-wrap
msgid ""
"dotChain : Integer -> String\n"
"dotChain = reverse . show . square . square . times2 . times2\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:119
#, markdown-text
msgid ""
"This will first multiply the argument by four, then square it twice before "
"converting it to a string (`show`) and reversing the resulting `String` "
"(functions `show` and `reverse` are part of the Idris *Prelude* and as such "
"are available in every Idris program)."
msgstr ""

#. type: Title ##
#: ../src/Tutorial/Functions1.md:120
#, markdown-text, no-wrap
msgid "Higher-order Functions"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:126
#, markdown-text
msgid ""
"Functions can take other functions as arguments. This is an incredibly "
"powerful concept and we can go crazy with this very easily. But for sanity's "
"sake, we'll start slowly:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions1.md:127
#, no-wrap
msgid ""
"isEven : Integer -> Bool\n"
"isEven n = mod n 2 == 0\n"
"\n"
"testSquare : (Integer -> Bool) -> Integer -> Bool\n"
"testSquare fun n = fun (square n)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:142
#, markdown-text
msgid ""
"First `isEven` uses the `mod` function to check, whether an integer is "
"divisible by two. But the interesting function is `testSquare`. It takes two "
"arguments: The first argument is of type *function from `Integer` to "
"`Bool`*, and the second of type `Integer`. This second argument is squared "
"before being passed to the first argument. Again, give this a go at the "
"REPL:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions1.md:143
#, no-wrap
msgid ""
"Tutorial.Functions1> testSquare isEven 12\n"
"True\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:154
#, markdown-text
msgid ""
"Take your time to understand what's going on here. We pass function `isEven` "
"as an argument to `testSquare`. The second argument is an integer, which "
"will first be squared and then passed to `isEven`. While this is not very "
"interesting, we will see lots of use cases for passing functions as "
"arguments to other functions."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:157
#, markdown-text
msgid ""
"I said above, we could go crazy pretty easily.  Consider for instance the "
"following example:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions1.md:158
#, no-wrap
msgid ""
"twice : (Integer -> Integer) -> Integer -> Integer\n"
"twice f n = f (f n)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:164 ../src/Tutorial/Functions1.md:227
#: ../src/Tutorial/Interfaces.md:504 ../src/Tutorial/Predicates.md:461
#: ../src/Tutorial/Prim.md:646
#, markdown-text
msgid "And at the REPL:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions1.md:165
#, no-wrap
msgid ""
"Tutorial.Functions1> twice square 2\n"
"16\n"
"Tutorial.Functions1> (twice . twice) square 2\n"
"65536\n"
"Tutorial.Functions1> (twice . twice . twice . twice) square 2\n"
"*** huge number ***\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:177
#, markdown-text
msgid ""
"You might be surprised about this behavior, so we'll try and break it "
"down. The following two expressions are identical in their behavior:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions1.md:178
#, no-wrap
msgid ""
"expr1 : Integer -> Integer\n"
"expr1 = (twice . twice . twice . twice) square\n"
"\n"
"expr2 : Integer -> Integer\n"
"expr2 = twice (twice (twice (twice square)))\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:194
#, markdown-text
msgid ""
"So, `square` raises its argument to the 2nd power, `twice square` raises it "
"to its 4th power (by invoking `square` twice in succession), `twice (twice "
"square)` raises it to its 16th power (by invoking `twice square` twice in "
"succession), and so on, until `twice (twice (twice (twice square)))` raises "
"it to its 65536th power resulting in an impressively huge result."
msgstr ""

#. type: Title ##
#: ../src/Tutorial/Functions1.md:195
#, markdown-text, no-wrap
msgid "Currying"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:201
#, markdown-text
msgid ""
"Once we start using higher-order functions, the concept of partial function "
"application (also called *currying* after mathematician and logician Haskell "
"Curry) becomes very important."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:203
#, markdown-text
msgid "Load this file in a REPL session and try the following:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions1.md:204
#, no-wrap
msgid ""
"Tutorial.Functions1> :t testSquare isEven\n"
"testSquare isEven : Integer -> Bool\n"
"Tutorial.Functions1> :t isTriple 1\n"
"isTriple 1 : Integer -> Integer -> Bool\n"
"Tutorial.Functions1> :t isTriple 1 2\n"
"isTriple 1 2 : Integer -> Bool\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:220
#, markdown-text, no-wrap
msgid ""
"Note, how in Idris we can partially apply a function\n"
"with more than one argument and as a result get a new function\n"
"back. For instance, `isTriple 1` applies argument `1` to function\n"
"`isTriple` and as a result returns a new function of\n"
"type `Integer -> Integer -> Bool`. We can even\n"
"use the result of such a partially applied function in\n"
"a new top level definition:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions1.md:221
#, no-wrap
msgid ""
"partialExample : Integer -> Bool\n"
"partialExample = isTriple 3 4\n"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions1.md:228
#, no-wrap
msgid ""
"Tutorial.Functions1> partialExample 5\n"
"True\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:236
#, markdown-text
msgid ""
"We already used partial function application in our `twice` examples above "
"to get some impressive results with very little code."
msgstr ""

#. type: Title ##
#: ../src/Tutorial/Functions1.md:237
#, markdown-text, no-wrap
msgid "Anonymous Functions"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:245
#, markdown-text
msgid ""
"Sometimes we'd like to pass a small custom function to a higher-order "
"function without bothering to write a top level definition. For instance, in "
"the following example, function `someTest` is very specific and probably not "
"very useful in general, but we'd still like to pass it to higher-order "
"function `testSquare`:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions1.md:246
#, no-wrap
msgid ""
"someTest : Integer -> Bool\n"
"someTest n = n >= 3 || n <= 10\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:252
#, markdown-text
msgid "Here's, how to pass it to `testSquare`:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions1.md:253
#, no-wrap
msgid ""
"Tutorial.Functions1> testSquare someTest 100\n"
"True\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:260
#, markdown-text
msgid "Instead of defining and using `someTest`, we can use an anonymous function:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions1.md:261
#, no-wrap
msgid ""
"Tutorial.Functions1> testSquare (\\n => n >= 3 || n <= 10) 100\n"
"True\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:277
#, markdown-text, no-wrap
msgid ""
"Anonymous functions are sometimes also called *lambdas* (from\n"
"[lambda calculus](https://en.wikipedia.org/wiki/Lambda_calculus)),\n"
"and the backslash is chosen since it resembles the Greek\n"
"letter *lambda*. The `\\n =>` syntax introduces a new anonymous\n"
"function of one argument called `n`, the implementation of\n"
"which is on the right hand side of the function arrow.\n"
"Like other top level functions, lambdas can have more\n"
"than one arguments, separated by commas: `\\x,y => x * x + y`.\n"
"When we pass lambdas as arguments to higher-order functions,\n"
"they typically need to be wrapped in parentheses or separated\n"
"by the dollar operator `($)` (see the next section about this).\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:280
#, markdown-text
msgid ""
"Note that, in a lambda, arguments are not annotated with types, so Idris has "
"to be able to infer them from the current context."
msgstr ""

#. type: Title ##
#: ../src/Tutorial/Functions1.md:281
#, markdown-text, no-wrap
msgid "Operators"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:288
#, markdown-text
msgid ""
"In Idris, infix operators like `.`, `*` or `+` are not built into the "
"language, but are just regular Idris function with some special support for "
"using them in infix notation.  When we don't use operators in infix "
"notation, we have to wrap them in parentheses."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:291
#, markdown-text, no-wrap
msgid ""
"As an example, let us define a custom operator for sequencing\n"
"functions of type `Bits8 -> Bits8`:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions1.md:292
#, no-wrap
msgid ""
"infixr 4 >>>\n"
"\n"
"(>>>) : (Bits8 -> Bits8) -> (Bits8 -> Bits8) -> Bits8 -> Bits8\n"
"f1 >>> f2 = f2 . f1\n"
"\n"
"foo : Bits8 -> Bits8\n"
"foo n = 2 * n + 3\n"
"\n"
"test : Bits8 -> Bits8\n"
"test = foo >>> foo >>> foo >>> foo\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:311
#, markdown-text, no-wrap
msgid ""
"In addition to declaring and defining the operator\n"
"itself, we also have to specify its fixity: `infixr 4 >>>` means,\n"
"that `(>>>)` associates to the right (meaning, that\n"
"`f >>> g >>> h` is to be interpreted as `f >>> (g >>> h)`)\n"
"with a priority of `4`. You can also have a look at the fixity\n"
"of operators exported by the *Prelude* in the REPL:\n"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions1.md:312
#, no-wrap
msgid ""
"Tutorial.Functions1> :doc (.)\n"
"Prelude.. : (b -> c) -> (a -> b) -> a -> c\n"
"  Function composition.\n"
"  Totality: total\n"
"  Fixity Declaration: infixr operator, level 9\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:325
#, markdown-text
msgid ""
"When you mix infix operators in an expression, those with a higher priority "
"bind more tightly. For instance, `(+)` is left associated with a priority of "
"8, while `(*)` is left associated with a priority of 9. Hence, `a * b + c` "
"is the same as `(a * b) + c` instead of `a * (b + c)`."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Functions1.md:326
#, markdown-text, no-wrap
msgid "Operator Sections"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:332
#, markdown-text
msgid ""
"Operators can be partially applied just like regular functions. In this "
"case, the whole expression has to be wrapped in parentheses and is called an "
"*operator section*. Here are two examples:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions1.md:333
#, no-wrap
msgid ""
"Tutorial.Functions1> testSquare (< 10) 5\n"
"False\n"
"Tutorial.Functions1> testSquare (10 <) 5\n"
"True\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:344
#, markdown-text, no-wrap
msgid ""
"As you can see, there is a difference between `(< 10)`\n"
"and `(10 <)`. The first tests, whether its argument is\n"
"less than 10, the second, whether 10 is less than its\n"
"argument.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:348
#, markdown-text
msgid ""
"One exception where operator sections will not work is with the *minus* "
"operator `(-)`. Here is an example to demonstrate this:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions1.md:349
#, no-wrap
msgid ""
"applyToTen : (Integer -> Integer) -> Integer\n"
"applyToTen f = f 10\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:357
#, markdown-text
msgid ""
"This is just a higher-order function applying the number ten to its function "
"argument. This works very well in the following example:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions1.md:358
#, no-wrap
msgid ""
"Tutorial.Functions1> applyToThen (* 2)\n"
"20\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:365
#, markdown-text
msgid "However, if we want to subtract five from ten, the following will fail:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions1.md:366
#, no-wrap
msgid ""
"Tutorial.Functions1> applyToTen (- 5)\n"
"Error: Can't find an implementation for Num (Integer -> Integer).\n"
"\n"
"(Interactive):1:12--1:17\n"
" 1 | applyToTen (- 5)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:377
#, markdown-text
msgid ""
"The problem here is, that Idris treats `- 5` as an integer literal instead "
"of an operator section. In this special case, we therefore have to use an "
"anonymous function instead:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions1.md:378
#, no-wrap
msgid ""
"Tutorial.Functions1> applyToTen (\\x => x - 5)\n"
"5\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Functions1.md:383
#, markdown-text, no-wrap
msgid "Infix Notation for Non-Operators"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:390
#, markdown-text
msgid ""
"In Idris, it is possible to use infix notation for regular binary functions, "
"by wrapping them in backticks.  It is even possible to define a precedence "
"(fixity) for these and use them in operator sections, just like regular "
"operators:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions1.md:391
#, no-wrap
msgid ""
"infixl 8 `plus`\n"
"\n"
"infixl 9 `mult`\n"
"\n"
"plus : Integer -> Integer -> Integer\n"
"plus = (+)\n"
"\n"
"mult : Integer -> Integer -> Integer\n"
"mult = (*)\n"
"\n"
"arithTest : Integer\n"
"arithTest = 5 `plus` 10 `mult` 12\n"
"\n"
"arithTest' : Integer\n"
"arithTest' = 5 + 10 * 12\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Functions1.md:409
#, markdown-text, no-wrap
msgid "Operators exported by the *Prelude*"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:419
#, markdown-text
msgid ""
"Here is a list of important operators exported by the *Prelude*.  Most of "
"these are *constrained*, that is they work only for types implementing a "
"certain *interface*. Don't worry about this right now. We will learn about "
"interfaces in due time, and the operators behave as they intuitively "
"should.  For instance, addition and multiplication work for all numeric "
"types, comparison operators work for almost all types in the *Prelude* with "
"the exception of functions."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Functions1.md:429
#, markdown-text
msgid "`(.)`: Function composition"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Functions1.md:429
#, markdown-text
msgid "`(+)`: Addition"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Functions1.md:429
#, markdown-text
msgid "`(*)`: Multiplication"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Functions1.md:429
#, markdown-text
msgid "`(-)`: Subtraction"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Functions1.md:429
#, markdown-text
msgid "`(/)`: Division"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Functions1.md:429
#, markdown-text
msgid "`(==)` : True, if two values are equal"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Functions1.md:429
#, markdown-text
msgid "`(/=)` : True, if two values are not equal"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Functions1.md:429
#, markdown-text
msgid "`(<=)`, `(>=)`, `(<)`, and `(>)` : Comparison operators"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Functions1.md:429
#, markdown-text
msgid "`($)`: Function application"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:440
#, markdown-text
msgid ""
"The most special of the above is the last one. It has a priority of 0, so "
"all other operators bind more tightly.  In addition, function application "
"binds more tightly, so this can be used to reduce the number of parentheses "
"required. For instance, instead of writing `isTriple 3 4 (2 + 3 * 1)` we can "
"write `isTriple 3 4 $ 2 + 3 * 1`, which is exactly the same. Sometimes, this "
"helps readability, sometimes, it doesn't. The important thing to remember is "
"that `fun $ x y` is just the same as `fun (x y)`."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Functions1.md:441 ../src/Tutorial/Functions2.md:339
#, markdown-text, no-wrap
msgid "Exercises"
msgstr ""

#. type: Bullet: '1. '
#: ../src/Tutorial/Functions1.md:450
#, markdown-text
msgid ""
"Reimplement functions `testSquare` and `twice` by using the dot operator and "
"dropping the second arguments (have a look at the implementation of "
"`squareTimes2` to get an idea where this should lead you). This highly "
"concise way of writing function implementations is sometimes called "
"*point-free style* and is often the preferred way of writing small utility "
"functions."
msgstr ""

#. type: Bullet: '2. '
#: ../src/Tutorial/Functions1.md:453
#, markdown-text
msgid ""
"Declare and implement function `isOdd` by combining functions `isEven` from "
"above and `not` (from the Idris *Prelude*). Use point-free style."
msgstr ""

#. type: Bullet: '3. '
#: ../src/Tutorial/Functions1.md:456
#, markdown-text
msgid ""
"Declare and implement function `isSquareOf`, which checks whether its first "
"`Integer` argument is the square of the second argument."
msgstr ""

#. type: Bullet: '4. '
#: ../src/Tutorial/Functions1.md:460
#, markdown-text
msgid ""
"Declare and implement function `isSmall`, which checks whether its `Integer` "
"argument is less than or equal to 100. Use one of the comparison operators "
"`<=` or `>=` in your implementation."
msgstr ""

#. type: Bullet: '5. '
#: ../src/Tutorial/Functions1.md:465
#, markdown-text
msgid ""
"Declare and implement function `absIsSmall`, which checks whether the "
"absolute value of its `Integer` argument is less than or equal to 100.  Use "
"functions `isSmall` and `abs` (from the Idris *Prelude*) in your "
"implementation, which should be in point-free style."
msgstr ""

#. type: Bullet: '6. '
#: ../src/Tutorial/Functions1.md:471
#, markdown-text
msgid ""
"In this slightly extended exercise we are going to implement some utilities "
"for working with `Integer` predicates (functions from `Integer` to "
"`Bool`). Implement the following higher-order functions (use boolean "
"operators `&&`, `||`, and function `not` in your implementations):"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions1.md:472
#, no-wrap
msgid ""
"   -- return true, if and only if both predicates hold\n"
"   and : (Integer -> Bool) -> (Integer -> Bool) -> Integer -> Bool\n"
"\n"
"   -- return true, if and only if at least one predicate holds\n"
"   or : (Integer -> Bool) -> (Integer -> Bool) -> Integer -> Bool\n"
"\n"
"   -- return true, if the predicate does not hold\n"
"   negate : (Integer -> Bool) -> Integer -> Bool\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:487
#, markdown-text, no-wrap
msgid ""
"   After solving this exercise, give it a go in the REPL. In the\n"
"   example below, we use binary function `and` in infix notation\n"
"   by wrapping it in backticks. This is just a syntactic convenience\n"
"   to make certain function applications more readable:\n"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions1.md:488
#, no-wrap
msgid ""
"   Tutorial.Functions1> negate (isSmall `and` isOdd) 73\n"
"   False\n"
msgstr ""

#. type: Bullet: '7. '
#: ../src/Tutorial/Functions1.md:500
#, markdown-text
msgid ""
"As explained above, Idris allows us to define our own infix operators.  Even "
"better, Idris supports *overloading* of function names, that is, two "
"functions or operators can have the same name, but different types and "
"implementations.  Idris will make use of the types to distinguish between "
"equally named operators and functions."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:504
#, markdown-text, no-wrap
msgid ""
"   This allows us, to reimplement functions `and`, `or`, and `negate`\n"
"   from Exercise 6 by using the existing operator and function\n"
"   names from boolean algebra:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions1.md:505
#, no-wrap
msgid ""
"   -- return true, if and only if both predicates hold\n"
"   (&&) : (Integer -> Bool) -> (Integer -> Bool) -> Integer -> Bool\n"
"   x && y = and x y\n"
"\n"
"   -- return true, if and only if at least one predicate holds\n"
"   (||) : (Integer -> Bool) -> (Integer -> Bool) -> Integer -> Bool\n"
"\n"
"   -- return true, if the predicate does not hold\n"
"   not : (Integer -> Bool) -> Integer -> Bool\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:518
#, markdown-text, no-wrap
msgid "   Implement the other two functions and test them at the REPL:\n"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions1.md:519
#, no-wrap
msgid ""
"   Tutorial.Functions1> not (isSmall && isOdd) 73\n"
"   False\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:527
#, markdown-text
msgid "What we learned in this chapter:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:530
#, markdown-text, no-wrap
msgid ""
"* A function in Idris can take an arbitrary number of arguments,\n"
"separated by `->` in the function's type.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:534
#, markdown-text, no-wrap
msgid ""
"* Functions can be combined\n"
"sequentially using the dot operator, which leads to highly\n"
"concise code.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:539
#, markdown-text, no-wrap
msgid ""
"* Functions can be partially applied by passing them fewer\n"
"arguments than they expect. The result is a new function\n"
"expecting the remaining arguments. This technique is called\n"
"*currying*.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:543
#, markdown-text, no-wrap
msgid ""
"* Functions can be passed as arguments to other functions, which\n"
"allows us to easily combine small coding units to create\n"
"more complex behavior.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:547
#, markdown-text, no-wrap
msgid ""
"* We can pass anonymous functions (*lambdas*) to higher-order\n"
"functions, if writing a corresponding top level\n"
"function would be too cumbersome.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:551
#, markdown-text, no-wrap
msgid ""
"* Idris allows us to define our own infix operators. These\n"
"have to be written in parentheses unless they are being used\n"
"in infix notation.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:556
#, markdown-text, no-wrap
msgid ""
"* Infix operators can also be partially applied. These *operator sections*\n"
"have to be wrapped in parentheses, and the position of the\n"
"argument determines, whether it is used as the operator's first\n"
"or second argument.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:560
#, markdown-text, no-wrap
msgid ""
"* Idris supports name overloading: Functions can have the same\n"
"names but different implementations. Idris will decide, which function\n"
"to used based to the types involved.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:567
#, markdown-text
msgid ""
"Please note, that function and operator names in a module must be unique. In "
"order to define two functions with the same name, they have to be declared "
"in distinct modules. If Idris is not able to decide, which of the two "
"functions to use, we can help name resolution by prefixing a function with "
"(a part of) its *namespace*:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions1.md:568
#, no-wrap
msgid ""
"Tutorial.Functions1> :t Prelude.not\n"
"Prelude.not : Bool -> Bool\n"
"Tutorial.Functions1> :t Functions1.not\n"
"Tutorial.Functions1.not : (Integer -> Bool) -> (Integer -> Bool) -> Integer "
"-> Bool\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions1.md:581
#, markdown-text
msgid ""
"In the [next section](DataTypes.md), we will learn how to define our own "
"data types and how to construct and deconstruct values of these new "
"types. We will also learn about generic types and functions."
msgstr ""

#. type: Title #
#: ../src/Tutorial/Functions2.md:1
#, markdown-text, no-wrap
msgid "Functions Part 2"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:9
#, markdown-text
msgid ""
"So far, we learned about the core features of the Idris language, which it "
"has in common with several other pure, strongly typed programming languages "
"like Haskell: (Higher order) Functions, algebraic data types, pattern "
"matching, parametric polymorphism (generic types and functions), and ad hoc "
"polymorphism (interfaces and constrained functions)."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:15
#, markdown-text
msgid ""
"In this chapter, we start to dissect Idris functions and their types for "
"real. We learn about implicit arguments, named arguments, as well as erasure "
"and quantities. But first, we'll look at `let` bindings and `where` blocks, "
"which help us implement functions too complex to fit on a single line of "
"code. Let's get started!"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:16
#, no-wrap
msgid ""
"module Tutorial.Functions2\n"
"\n"
"%default total\n"
msgstr ""

#. type: Title ##
#: ../src/Tutorial/Functions2.md:22
#, markdown-text, no-wrap
msgid "Let Bindings and Local Definitions"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:31
#, markdown-text
msgid ""
"The functions we looked at so far were simple enough to be implemented "
"directly via pattern matching without the need of additional auxiliary "
"functions or variables. This is not always the case, and there are two "
"important language constructs for introducing and reusing new local "
"variables and functions. We'll look at these in two case studies."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Functions2.md:32
#, markdown-text, no-wrap
msgid "Use Case 1: Arithmetic Mean and Standard Deviation"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:37
#, markdown-text
msgid ""
"In this example, we'd like to calculate the arithmetic mean and the standard "
"deviation of a list of floating point values.  There are several things we "
"need to consider."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:41
#, markdown-text
msgid ""
"First, we need a function for calculating the sum of a list of numeric "
"values. The *Prelude* exports function `sum` for this:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions2.md:42
#, no-wrap
msgid ""
"Main> :t sum\n"
"Prelude.sum : Num a => Foldable t => t a -> a\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:51
#, markdown-text
msgid ""
"This is - of course - similar to `sumList` from Exercise 10 of the [last "
"section](Interfaces.md), but generalized to all container types with a "
"`Foldable` implementation. We will learn about interface `Foldable` in a "
"later section."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:62
#, markdown-text
msgid ""
"In order to also calculate the variance, we need to convert every value in "
"the list to a new value, as we have to subtract the mean from every value in "
"the list and square the result. In the previous section's exercises, we "
"defined function `mapList` for this. The *Prelude* - of course - already "
"exports a similar function called `map`, which is again more general and "
"works also like our `mapMaybe` for `Maybe` and `mapEither` for `Either "
"e`. Here's its type:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions2.md:63
#, no-wrap
msgid ""
"Main> :t map\n"
"Prelude.map : Functor f => (a -> b) -> f a -> f b\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:70
#, markdown-text
msgid "Interface `Functor` is another one we'll talk about in a later section."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:73
#, markdown-text
msgid ""
"Finally, we need a way to calculate the length of a list of values. We use "
"function `length` for this:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions2.md:74
#, no-wrap
msgid ""
"Main> :t List.length\n"
"Prelude.List.length : List a -> Nat\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:87
#, markdown-text, no-wrap
msgid ""
"Here, `Nat` is the type of natural numbers\n"
"(unbounded, unsigned integers). `Nat` is actually not a primitive data\n"
"type but a sum type defined in the *Prelude* with\n"
"data constructors `Z : Nat` (for zero)\n"
"and `S : Nat -> Nat` (for successor). It might seem highly inefficient\n"
"to define natural numbers this way, but the Idris compiler\n"
"treats these and several other *number-like* types specially, and\n"
"replaces them with primitive integers during code generation.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:93
#, markdown-text
msgid ""
"We are now ready to give the implementation of `mean` a go.  Since this is "
"Idris, and we care about clear semantics, we will quickly define a custom "
"record type instead of just returning a tuple of `Double`s. This makes it "
"clearer, which floating point number corresponds to which statistic entity:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:94
#, no-wrap
msgid ""
"square : Double -> Double\n"
"square n = n * n\n"
"\n"
"record Stats where\n"
"  constructor MkStats\n"
"  mean      : Double\n"
"  variance  : Double\n"
"  deviation : Double\n"
"\n"
"stats : List Double -> Stats\n"
"stats xs =\n"
"  let len      := cast (length xs)\n"
"      mean     := sum xs / len\n"
"      variance := sum (map (\\x => square (x - mean)) xs) / len\n"
"   in MkStats mean variance (sqrt variance)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:113
#, markdown-text
msgid "As usual, we first try this at the REPL:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions2.md:114
#, no-wrap
msgid ""
"Tutorial.Functions2> stats [2,4,4,4,5,5,7,9]\n"
"MkStats 5.0 4.0 2.0\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:133
#, markdown-text
msgid ""
"Seems to work, so let's digest this step by step.  We introduce several new "
"local variables (`len`, `mean`, and `variance`), which all will be used more "
"than once in the remainder of the implementation. To do so, we use a `let` "
"binding. This consists of the `let` keyword, followed by one or more "
"variable assignments, followed by the final expression, which has to be "
"prefixed by `in`. Note, that whitespace is significant again: We need to "
"properly align the three variable names. Go ahead, and try out what happens "
"if you remove a space in front of `mean` or `variance`.  Note also, that the "
"alignment of assignment operators `:=` is optional. I do this, since I "
"thinks it helps readability."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:149
#, markdown-text
msgid ""
"Let's also quickly look at the different variables and their types. `len` is "
"the length of the list cast to a `Double`, since this is what's needed later "
"on, where we divide other values of type `Double` by the length. Idris is "
"very strict about this: We are not allowed to mix up numeric types without "
"explicit casts. Please note, that in this case Idris is able to *infer* the "
"type of `len` from the surrounding context. `mean` is straight forward: We "
"`sum` up the values stored in the list and divide by the list's "
"length. `variance` is the most involved of the three: We map each item in "
"the list to a new value using an anonymous function to subtract the mean and "
"square the result. We then sum up the new terms and divide again by the "
"number of values."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Functions2.md:150
#, markdown-text, no-wrap
msgid "Use Case 2: Simulating a Simple Web Server"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:156
#, markdown-text
msgid ""
"In the second use case, we are going to write a slightly larger "
"application. This should give you an idea about how to design data types and "
"functions around some business logic you'd like to implement."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:161
#, markdown-text
msgid ""
"Assume we run a music streaming web server, where users can buy whole albums "
"and listen to them online. We'd like to simulate a user connecting to the "
"server and getting access to one of the albums they bought."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:163
#, markdown-text
msgid "We first define a bunch of record types:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:164
#, no-wrap
msgid ""
"record Artist where\n"
"  constructor MkArtist\n"
"  name : String\n"
"\n"
"record Album where\n"
"  constructor MkAlbum\n"
"  name   : String\n"
"  artist : Artist\n"
"\n"
"record Email where\n"
"  constructor MkEmail\n"
"  value : String\n"
"\n"
"record Password where\n"
"  constructor MkPassword\n"
"  value : String\n"
"\n"
"record User where\n"
"  constructor MkUser\n"
"  name     : String\n"
"  email    : Email\n"
"  password : Password\n"
"  albums   : List Album\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:202
#, markdown-text
msgid ""
"Most of these should be self-explanatory. Note, however, that in several "
"cases (`Email`, `Artist`, `Password`) we wrap a single value in a new record "
"type. Of course, we *could* have used the unwrapped `String` type instead, "
"but we'd have ended up with many `String` fields, which can be hard to "
"disambiguate.  In order not to confuse an email string with a password "
"string, it can therefore be helpful to wrap both of them in a new record "
"type to drastically increase type safety at the cost of having to "
"reimplement some interfaces.  Utility function `on` from the *Prelude* is "
"very useful for this. Don't forget to inspect its type at the REPL, and try "
"to understand what's going on here."
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:203
#, no-wrap
msgid ""
"Eq Artist where (==) = (==) `on` name\n"
"\n"
"Eq Email where (==) = (==) `on` value\n"
"\n"
"Eq Password where (==) = (==) `on` value\n"
"\n"
"Eq Album where (==) = (==) `on` \\a => (a.name, a.artist)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:216
#, markdown-text
msgid ""
"In case of `Album`, we wrap the two fields of the record in a `Pair`, which "
"already comes with an implementation of `Eq`.  This allows us to again use "
"function `on`, which is very convenient."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:219
#, markdown-text
msgid ""
"Next, we have to define the data types representing server requests and "
"responses:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:220
#, no-wrap
msgid ""
"record Credentials where\n"
"  constructor MkCredentials\n"
"  email    : Email\n"
"  password : Password\n"
"\n"
"record Request where\n"
"  constructor MkRequest\n"
"  credentials : Credentials\n"
"  album       : Album\n"
"\n"
"data Response : Type where\n"
"  UnknownUser     : Email -> Response\n"
"  InvalidPassword : Response\n"
"  AccessDenied    : Email -> Album -> Response\n"
"  Success         : Album -> Response\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:243
#, markdown-text
msgid ""
"For server responses, we use a custom sum type encoding the possible "
"outcomes of a client request. In practice, the `Success` case would return "
"some kind of connection to start the actual album stream, but we just wrap "
"up the album we found to simulate this behavior."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:248
#, markdown-text
msgid ""
"We can now go ahead and simulate the handling of a request at the server. To "
"emulate our user data base, a simple list of users will do. Here's the type "
"of the function we'd like to implement:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:249
#, no-wrap
msgid ""
"DB : Type\n"
"DB = List User\n"
"\n"
"handleRequest : DB -> Request -> Response\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:265
#, markdown-text
msgid ""
"Note, how we defined a short alias for `List User` called `DB`.  This is "
"often useful to make lengthy type signatures more readable and communicate "
"the meaning of a type in the given context. However, this will *not* "
"introduce a new type, nor will it increase type safety: `DB` is *identical* "
"to `List User`, and as such, a value of type `DB` can be used wherever a "
"`List User` is expected and vice versa. In more complex programs it is "
"therefore usually preferable to define new types by wrapping values in "
"single-field records."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:274
#, markdown-text
msgid ""
"The implementation will proceed as follows: It will first try and lookup a "
"`User` by is email address in the data base. If this is successful, it will "
"compare the provided password with the user's actual password. If the two "
"match, it will lookup the requested album in the user's list of albums.  If "
"all of these steps succeed, the result will be an `Album` wrapped in a "
"`Success`. If any of the steps fails, the result will describe exactly what "
"went wrong."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:276
#, markdown-text
msgid "Here's a possible implementation:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:277
#, no-wrap
msgid ""
"handleRequest db (MkRequest (MkCredentials email pw) album) =\n"
"  case lookupUser db of\n"
"    Just (MkUser _ _ password albums)  =>\n"
"      if password == pw then lookupAlbum albums else InvalidPassword\n"
"\n"
"    Nothing => UnknownUser email\n"
"\n"
"  where lookupUser : List User -> Maybe User\n"
"        lookupUser []        = Nothing\n"
"        lookupUser (x :: xs) =\n"
"          if x.email == email then Just x else lookupUser xs\n"
"\n"
"        lookupAlbum : List Album -> Response\n"
"        lookupAlbum []        = AccessDenied email album\n"
"        lookupAlbum (x :: xs) =\n"
"          if x == album then Success album else lookupAlbum xs\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:305
#, markdown-text
msgid ""
"I'd like to point out several things in this example. First, note how we can "
"extract values from nested records in a single pattern match.  Second, we "
"defined two *local* functions in a `where` block: `lookupUser`, and "
"`lookupAlbum`. Both of these have access to all variables in the surrounding "
"scope. For instance, `lookupUser` uses the `album` variable from the pattern "
"match in the implementation's first line. Likewise, `lookupAlbum` makes use "
"of the `album` variable."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:310
#, markdown-text
msgid ""
"A `where` block introduces new local definitions, accessible only from the "
"surrounding scope and from other functions defined later in the same `where` "
"block. These need to be explicitly typed and indented by the same amount of "
"whitespace."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:318
#, markdown-text
msgid ""
"Local definitions can also be introduce *before* a function's implementation "
"by using the `let` keyword. This usage of `let` is not to be confused with "
"*let bindings* described above, which are used to bind and reuse the results "
"of intermediate computations. Below is how we could have implemented "
"`handleRequest` with local definitions introduced by the `let` "
"keyword. Again, all definitions have to be properly typed and indented:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:319
#, no-wrap
msgid ""
"handleRequest' : DB -> Request -> Response\n"
"handleRequest' db (MkRequest (MkCredentials email pw) album) =\n"
"  let lookupUser : List User -> Maybe User\n"
"      lookupUser []        = Nothing\n"
"      lookupUser (x :: xs) =\n"
"        if x.email == email then Just x else lookupUser xs\n"
"\n"
"      lookupAlbum : List Album -> Response\n"
"      lookupAlbum []        = AccessDenied email album\n"
"      lookupAlbum (x :: xs) =\n"
"        if x == album then Success album else lookupAlbum xs\n"
"\n"
"   in case lookupUser db of\n"
"        Just (MkUser _ _ password albums)  =>\n"
"          if password == pw then lookupAlbum albums else InvalidPassword\n"
"\n"
"        Nothing => UnknownUser email\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:345
#, markdown-text
msgid ""
"The exercises in this section are supposed to increase you experience in "
"writing purely functional code. In some cases it might be useful to use "
"`let` expressions or `where` blocks, but this will not always be required."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:350
#, markdown-text
msgid ""
"Exercise 3 is again of utmost importance. `traverseList` is a specialized "
"version of the more general `traverse`, one of the most powerful and "
"versatile functions available in the *Prelude* (check out its type!)."
msgstr ""

#. type: Bullet: '1. '
#: ../src/Tutorial/Functions2.md:355
#, markdown-text
msgid ""
"Module `Data.List` in *base* exports functions `find` and `elem`.  Inspect "
"their types and use these in the implementation of `handleRequest`. This "
"should allow you to completely get rid of the `where` block."
msgstr ""

#. type: Bullet: '2. '
#: ../src/Tutorial/Functions2.md:365
#, markdown-text
msgid ""
"Define an enumeration type listing the four "
"[nucleobases](https://en.wikipedia.org/wiki/Nucleobase)  occurring in DNA "
"strands. Define also a type alias `DNA` for lists of nucleobases.  Declare "
"and implement function `readBase` for converting a single character (type "
"`Char`) to a nucleobase.  You can use character literals in your "
"implementation like so: `'A'`, `'a'`. Note, that this function might fail, "
"so adjust the result type accordingly."
msgstr ""

#. type: Bullet: '3. '
#: ../src/Tutorial/Functions2.md:371
#, markdown-text
msgid ""
"Implement the following function, which tries to convert all values in a "
"list with a function, which might fail. The result should be a `Just` "
"holding the list of converted values in unmodified order, if and only if "
"every single conversion was successful."
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:372
#, no-wrap
msgid "   traverseList : (a -> Maybe b) -> List a -> Maybe (List b)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:378
#, markdown-text, no-wrap
msgid ""
"   You can verify, that the function behaves correctly with\n"
"   the following test: `traverseList Just [1,2,3] = Just [1,2,3]`.\n"
msgstr ""

#. type: Bullet: '4. '
#: ../src/Tutorial/Functions2.md:382
#, markdown-text
msgid ""
"Implement function `readDNA : String -> Maybe DNA` using the functions and "
"types defined in exercises 2 and 3.  You will also need function `unpack` "
"from the *Prelude*."
msgstr ""

#. type: Bullet: '5. '
#: ../src/Tutorial/Functions2.md:385
#, markdown-text
msgid ""
"Implement function `complement : DNA -> DNA` to calculate the complement of "
"a strand of DNA."
msgstr ""

#. type: Title ##
#: ../src/Tutorial/Functions2.md:386
#, markdown-text, no-wrap
msgid "The Truth about Function Arguments"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:390
#, markdown-text
msgid ""
"So far, when we defined a top level function, it looked something like the "
"following:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:391
#, no-wrap
msgid ""
"zipEitherWith : (a -> b -> c) -> Either e a -> Either e b -> Either e c\n"
"zipEitherWith f (Right va) (Right vb) = Right (f va vb)\n"
"zipEitherWith f (Left e)   _          = Left e\n"
"zipEitherWith f _          (Left e)   = Left e\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:401
#, markdown-text
msgid ""
"Function `zipEitherWith` is a generic higher-order function combining the "
"values stored in two `Either`s via a binary function. If either of the "
"`Either` arguments is a `Left`, the result is also a `Left`."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:407
#, markdown-text
msgid ""
"This is a *generic function* with *type parameters* `a`, `b`, `c`, and `e`.  "
"However, there is a more verbose type for `zipEitherWith`, which is visible "
"in the REPL when entering `:ti zipEitherWith` (the `i` here tells Idris to "
"include `implicit` arguments). You will get a type similar to this:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:408
#, no-wrap
msgid ""
"zipEitherWith' :  {0 a : Type}\n"
"               -> {0 b : Type}\n"
"               -> {0 c : Type}\n"
"               -> {0 e : Type}\n"
"               -> (a -> b -> c)\n"
"               -> Either e a\n"
"               -> Either e b\n"
"               -> Either e c\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:421
#, markdown-text
msgid ""
"In order to understand what's going on here, we will have to talk about "
"named arguments, implicit arguments, and quantities."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Functions2.md:422
#, markdown-text, no-wrap
msgid "Named Arguments"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:425
#, markdown-text
msgid "In a function type, we can give each argument a name. Like so:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:426
#, no-wrap
msgid ""
"fromMaybe : (deflt : a) -> (ma : Maybe a) -> a\n"
"fromMaybe deflt Nothing = deflt\n"
"fromMaybe _    (Just x) = x\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:439
#, markdown-text
msgid ""
"Here, the first argument is given name `deflt`, the second `ma`. These names "
"can be reused in a function's implementation, as was done for `deflt`, but "
"this is not mandatory: We are free to use different names in the "
"implementation. There are several reasons, why we'd choose to name our "
"arguments: It can serve as documentation, but it also allows us to pass the "
"arguments to a function in arbitrary order when using the following syntax:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:440
#, no-wrap
msgid ""
"extractBool : Maybe Bool -> Bool\n"
"extractBool v = fromMaybe { ma = v, deflt = False }\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:446
#, markdown-text
msgid "Or even :"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:447
#, no-wrap
msgid ""
"extractBool2 : Maybe Bool -> Bool\n"
"extractBool2 = fromMaybe { deflt = False }\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:454
#, markdown-text
msgid ""
"The arguments in a record's constructor are automatically named in "
"accordance with the field names:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:455
#, no-wrap
msgid ""
"record Dragon where\n"
"  constructor MkDragon\n"
"  name      : String\n"
"  strength  : Nat\n"
"  hitPoints : Int16\n"
"\n"
"gorgar : Dragon\n"
"gorgar = MkDragon { strength = 150, name = \"Gorgar\", hitPoints = 10000 }\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:471
#, markdown-text
msgid ""
"For the use cases described above, named arguments are merely a convenience "
"and completely optional. However, Idris is a *dependently typed* programming "
"language: Types can be calculated from and depend on values. For instance, "
"the *result type* of a function can *depend* on the *value* of one of its "
"arguments. Here's a contrived example:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:472
#, no-wrap
msgid ""
"IntOrString : Bool -> Type\n"
"IntOrString True  = Integer\n"
"IntOrString False = String\n"
"\n"
"intOrString : (v : Bool) -> IntOrString v\n"
"intOrString False = \"I'm a String\"\n"
"intOrString True  = 1000\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:489
#, markdown-text
msgid ""
"If you see such a thing for the first time, it can be hard to understand "
"what's going on here. First, function `IntOrString` computes a `Type` from a "
"`Bool` value: If the argument is `True`, it returns type `Integer`, if the "
"argument is `False` it returns `String`. We use this to calculate the return "
"type of function `intOrString` based on its boolean argument `v`: If `v` is "
"`True`, the return type is (in accordance with `IntOrString True = Integer`) "
"`Integer`, otherwise it is `String`."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:493
#, markdown-text
msgid ""
"Note, how in the type signature of `intOrString`, we *must* give the "
"argument of type `Bool` a name (`v`) in order to reference it in the result "
"type `IntOrString v`."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:500
#, markdown-text
msgid ""
"You might wonder at this moment, why this is useful and why we would ever "
"want to define a function with such a strange type. We will see lots of very "
"useful examples in due time! For now, suffice to say that in order to "
"express dependent function types, we need to name at least some of the "
"function's arguments and refer to them by name in the types of other "
"arguments."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Functions2.md:501
#, markdown-text, no-wrap
msgid "Implicit Arguments"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:509
#, markdown-text
msgid ""
"Implicit arguments are arguments, the values of which the compiler should "
"infer and fill in for us automatically. For instance, in the following "
"function signature, we expect the compiler to infer the value of type "
"parameter `a` automatically from the types of the other arguments (ignore "
"the 0 quantity for the moment; I'll explain it in the next subsection):"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:510
#, no-wrap
msgid ""
"maybeToEither : {0 a : Type} -> Maybe a -> Either String a\n"
"maybeToEither Nothing  = Left \"Nope\"\n"
"maybeToEither (Just x) = Right x\n"
"\n"
"-- Please remember, that the above is\n"
"-- equivalent to the following:\n"
"maybeToEither' : Maybe a -> Either String a\n"
"maybeToEither' Nothing  = Left \"Nope\"\n"
"maybeToEither' (Just x) = Right x\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:527
#, markdown-text
msgid ""
"As you can see, implicit arguments are wrapped in curly braces, unlike "
"explicit named arguments, which are wrapped in parentheses.  Inferring the "
"value of an implicit argument is not always possible.  For instance, if we "
"enter the following at the REPL, Idris will fail with an error:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions2.md:528
#, no-wrap
msgid ""
"Tutorial.Functions2> show (maybeToEither Nothing)\n"
"Error: Can't find an implementation for Show (Either String ?a).\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:540
#, markdown-text
msgid ""
"Idris is unable to find an implementation of `Show (Either String a)` "
"without knowing what `a` actually is.  Note the question mark in front of "
"the type parameter: `?a`.  If this happens, there are several ways to help "
"the type checker.  We could, for instance, pass a value for the implicit "
"argument explicitly. Here's the syntax to do this:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions2.md:541
#, no-wrap
msgid ""
"Tutorial.Functions2> show (maybeToEither {a = Int8} Nothing)\n"
"\"Left \"Nope\"\"\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:549
#, markdown-text
msgid ""
"As you can see, we use the same syntax as shown above for explicit named "
"arguments and the two forms of argument passing can be mixed."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:552
#, markdown-text
msgid ""
"We could also specify the type of the whole expression using utility "
"function `the` from the *Prelude*:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions2.md:553
#, no-wrap
msgid ""
"Tutorial.Functions2> show (the (Either String Int8) (maybeToEither "
"Nothing))\n"
"\"Left \"Nope\"\"\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:559
#, markdown-text
msgid "It is instructive to have a look at the type of `the`:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions2.md:560
#, no-wrap
msgid ""
"Tutorial.Functions2> :ti the\n"
"Prelude.the : (0 a : Type) -> a -> a\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:566
#, markdown-text
msgid "Compare this with the identity function `id`:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions2.md:567
#, no-wrap
msgid ""
"Tutorial.Functions2> :ti id\n"
"Prelude.id : {0 a : Type} -> a -> a\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:581
#, markdown-text
msgid ""
"The only difference between the two: In case of `the`, the type parameter "
"`a` is an *explicit* argument, while in case of `id`, it is an *implicit* "
"argument. Although the two functions have almost identical types (and "
"implementations!), they serve quite different purposes: `the` is used to "
"help type inference, while `id` is used whenever we'd like to return an "
"argument without modifying it at all (which, in the presence of higher-order "
"functions, happens surprisingly often)."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:585
#, markdown-text
msgid ""
"Both ways to improve type inference shown above are used quite often, and "
"must be understood by Idris programmers."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Functions2.md:586
#, markdown-text, no-wrap
msgid "Multiplicities"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:593
#, markdown-text
msgid ""
"Finally, we need to talk about the zero multiplicity, which appeared in "
"several of the type signatures in this section. Idris 2, unlike its "
"predecessor Idris 1, is based on a core language called *quantitative type "
"theory* (QTT): Every variable in Idris 2 is associated with one of three "
"possible multiplicities:"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Functions2.md:598
#, markdown-text
msgid "`0`, meaning that the variable is *erased* at runtime."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Functions2.md:598
#, markdown-text
msgid "`1`, meaning that the variable is used *exactly once* at runtime."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:598
#, markdown-text, no-wrap
msgid ""
"* *Unrestricted* (the default), meaning that the variable is used\n"
"   an arbitrary number of times at runtime.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:604
#, markdown-text
msgid ""
"We will not talk about the most complex of the three, multiplicity `1`, "
"here.  We are, however, often interested in multiplicity `0`: A variable "
"with multiplicity `0` is only relevant at *compile time*. It will not make "
"any appearance at runtime, and the computation of such a variable will never "
"affect a program's runtime performance."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:609
#, markdown-text
msgid ""
"In the type signature of `maybeToEither` we see that type parameter `a` has "
"multiplicity `0`, and will therefore be erased and is only relevant at "
"compile time, while the `Maybe a` argument has *unrestricted* multiplicity."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:613
#, markdown-text
msgid ""
"It is also possible to annotate explicit arguments with multiplicities, in "
"which case the argument must again be put in parentheses. For an example, "
"look again at the type signature of `the`."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Functions2.md:614
#, markdown-text, no-wrap
msgid "Underscores"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:623
#, markdown-text
msgid ""
"It is often desirable, to only write as little code as necessary and let "
"Idris figure out the rest.  We have already learned about one such occasion: "
"Catch-all patterns.  If a variable in a pattern match is not used on the "
"right hand side, we can't just drop it, as this would make it impossible for "
"Idris, which of several arguments we were planning to drop, but we can use "
"an underscore as a placeholder instead:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:624
#, no-wrap
msgid ""
"isRight : Either a b -> Bool\n"
"isRight (Right _) = True\n"
"isRight _         = False\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:633
#, markdown-text
msgid ""
"But when we look at the type signature of `isRight`, we will note that type "
"parameters `a` and `b` are also only used once, and are therefore of no "
"importance. Let's get rid of them:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:634
#, no-wrap
msgid ""
"isRight' : Either _ _ -> Bool\n"
"isRight' (Right _) = True\n"
"isRight' _         = False\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:645
#, markdown-text, no-wrap
msgid ""
"In the detailed type signature of `zipEitherWith`, it should\n"
"be obvious for Idris that the implicit arguments are of type `Type`.\n"
"After all, all of them are later on applied to the `Either` type\n"
"constructor, which is of type `Type -> Type -> Type`. Let's get rid\n"
"of them:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:646
#, no-wrap
msgid ""
"zipEitherWith'' :  {0 a : _}\n"
"                -> {0 b : _}\n"
"                -> {0 c : _}\n"
"                -> {0 e : _}\n"
"                -> (a -> b -> c)\n"
"                -> Either e a\n"
"                -> Either e b\n"
"                -> Either e c\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:658
#, markdown-text
msgid "Consider the following contrived example:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:659
#, no-wrap
msgid ""
"foo : Integer -> String\n"
"foo n = show (the (Either String Integer) (Right n))\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:669
#, markdown-text
msgid ""
"Since we wrap an `Integer` in a `Right`, it is obvious that the second "
"argument in `Either String Integer` is `Integer`. Only the `String` argument "
"can't be inferred by Idris. Even better, the `Either` itself is obvious! "
"Let's get rid of the unnecessary noise:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:670
#, no-wrap
msgid ""
"foo' : Integer -> String\n"
"foo' n = show (the (_ String _) (Right n))\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:680
#, markdown-text
msgid ""
"Please note, that using underscores as in `foo'` is not always desirable, as "
"it can quite drastically obfuscate the written code. Always use a syntactic "
"convenience to make code more readable, and not to show people how clever "
"you are."
msgstr ""

#. type: Title ##
#: ../src/Tutorial/Functions2.md:681
#, markdown-text, no-wrap
msgid "Programming with Holes"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:696
#, markdown-text
msgid ""
"Solved all the exercises so far? Got angry at the type checker for always "
"complaining and never being really helpful? It's time to change that. Idris "
"comes with several highly useful interactive editing features. Sometimes, "
"the compiler is able to implement complete functions for us (if the types "
"are specific enough). Even if that's not possible, there's an incredibly "
"useful and important feature, which can help us when the types are getting "
"too complicated: Holes.  Holes are variables, the names of which are "
"prefixed with a question mark.  We can use them as placeholders whenever we "
"plan to implement a piece of functionality at a later time. In addition, "
"their types and the types and quantities of all other variables in scope can "
"be inspected at the REPL (or in your editor, if you setup the necessary "
"plugin).  Let's see them holes in action."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:704
#, markdown-text
msgid ""
"Remember the `traverseList` example from an Exercise earlier in this "
"section? If this was your first encounter with applicative list traversals, "
"this might have been a nasty bit of work. Well, let's just make it a wee bit "
"harder still. We'd like to implement the same piece of functionality for "
"functions returning `Either e`, where `e` is a type with a `Semigroup` "
"implementation, and we'd like to accumulate the values in all `Left`s we "
"meet along the way."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:706
#, markdown-text
msgid "Here's the type of the function:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:707
#, no-wrap
msgid ""
"traverseEither :  Semigroup e\n"
"               => (a -> Either e b)\n"
"               -> List a\n"
"               -> Either e (List b)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:718
#, markdown-text
msgid ""
"Now, in order to follow along, you might want to start your own Idris source "
"file, load it into a REPL session and adjust the code as described here. The "
"first thing we'll do, is write a skeleton implementation with a hole on the "
"right hand side:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions2.md:719
#, no-wrap
msgid "traverseEither fun as = ?impl\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:725
#, markdown-text
msgid ""
"When you now go to the REPL and reload the file using command `:r`, you can "
"enter `:m` to list all the *metavariables*:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions2.md:726
#, no-wrap
msgid ""
"Tutorial.Functions2> :m\n"
"1 hole:\n"
"  Tutorial.Functions2.impl : Either e (List b)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:734
#, markdown-text
msgid ""
"Next, we'd like to display the hole's type (including all variables in the "
"surrounding context plus their types):"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions2.md:735
#, no-wrap
msgid ""
"Tutorial.Functions2> :t impl\n"
" 0 b : Type\n"
" 0 a : Type\n"
" 0 e : Type\n"
"   as : List a\n"
"   fun : a -> Either e b\n"
"------------------------------\n"
"impl : Either e (List b)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:750
#, markdown-text
msgid ""
"So, we have some erased type parameters (`a`, `b`, and `e`), a value of type "
"`List a` called `as`, and a function from `a` to `Either e b` called "
"`fun`. Our goal is to come up with a value of type `Either a (List b)`."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:754
#, markdown-text
msgid ""
"We *could* just return a `Right []`, but that only make sense if our input "
"list is indeed the empty list. We therefore should start with a pattern "
"match on the list:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions2.md:755
#, no-wrap
msgid ""
"traverseEither fun []        = ?impl_0\n"
"traverseEither fun (x :: xs) = ?impl_1\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:762
#, markdown-text
msgid ""
"The result is two holes, which must be given distinct names. When inspecting "
"`impl_0`, we get the following result:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions2.md:763
#, no-wrap
msgid ""
"Tutorial.Functions2> :t impl_0\n"
" 0 b : Type\n"
" 0 a : Type\n"
" 0 e : Type\n"
"   fun : a -> Either e b\n"
"------------------------------\n"
"impl_0 : Either e (List b)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:779
#, markdown-text
msgid ""
"Now, this is an interesting situation. We are supposed to come up with a "
"value of type `Either e (List b)` with nothing to work with. We know nothing "
"about `a`, so we can't provide an argument with which to invoke `fun`.  "
"Likewise, we know nothing about `e` or `b` either, so we can't produce any "
"values of these either. The *only* option we have is to replace `impl_0` "
"with an empty list wrapped in a `Right`:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:780
#, no-wrap
msgid "traverseEither fun []        = Right []\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:786
#, markdown-text
msgid ""
"The non-empty case is of course slightly more involved. Here's the context "
"of `?impl_1`:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions2.md:787
#, no-wrap
msgid ""
"Tutorial.Functions2> :t impl_1\n"
" 0 b : Type\n"
" 0 a : Type\n"
" 0 e : Type\n"
"   x : a\n"
"   xs : List a\n"
"   fun : a -> Either e b\n"
"------------------------------\n"
"impl_1 : Either e (List b)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:810
#, markdown-text
msgid ""
"Since `x` is of type `a`, we can either use it as an argument to `fun` or "
"drop and ignore it. `xs`, on the other hand, is the remainder of the list of "
"type `List a`. We could again drop it or process it further by invoking "
"`traverseEither` recursively. Since the goal is to try and convert *all* "
"values, we should drop neither. Since in case of two `Left`s we are supposed "
"to accumulate the values, we eventually need to run both computations anyway "
"(invoking `fun`, and recursively calling `traverseEither`). We therefore can "
"do both at the same time and analyze the results in a single pattern match "
"by wrapping both in a `Pair`:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions2.md:811
#, no-wrap
msgid ""
"traverseEither fun (x :: xs) =\n"
"  case (fun x, traverseEither fun xs) of\n"
"   p => ?impl_2\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:818
#, markdown-text
msgid "Once again, we inspect the context:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions2.md:819
#, no-wrap
msgid ""
"Tutorial.Functions2> :t impl_2\n"
" 0 b : Type\n"
" 0 a : Type\n"
" 0 e : Type\n"
"   xs : List a\n"
"   fun : a -> Either e b\n"
"   x : a\n"
"   p : (Either e b, Either e (List b))\n"
"------------------------------\n"
"impl_2 : Either e (List b)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:834
#, markdown-text
msgid ""
"We'll definitely need to pattern match on pair `p` next to figure out, which "
"of the two computations succeeded:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions2.md:835
#, no-wrap
msgid ""
"traverseEither fun (x :: xs) =\n"
"  case (fun x, traverseEither fun xs) of\n"
"    (Left y, Left z)   => ?impl_6\n"
"    (Left y, Right _)  => ?impl_7\n"
"    (Right _, Left z)  => ?impl_8\n"
"    (Right y, Right z) => ?impl_9\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:847
#, markdown-text
msgid ""
"At this point we might have forgotten what we actually wanted to do (at "
"least to me, this happens annoyingly often), so we'll just quickly check "
"what our goal is:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions2.md:848
#, no-wrap
msgid ""
"Tutorial.Functions2> :t impl_6\n"
" 0 b : Type\n"
" 0 a : Type\n"
" 0 e : Type\n"
"   xs : List a\n"
"   fun : a -> Either e b\n"
"   x : a\n"
"   y : e\n"
"   z : e\n"
"------------------------------\n"
"impl_6 : Either e (List b)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:868
#, markdown-text
msgid ""
"So, we are still looking for a value of type `Either e (List b)`, and we "
"have two values of type `e` in scope. According to the spec we want to "
"accumulate these using `e`s `Semigroup` implementation.  We can proceed for "
"the other cases in a similar manner, remembering that we should return a "
"`Right`, if and only if all conversions where successful:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:869
#, no-wrap
msgid ""
"traverseEither fun (x :: xs) =\n"
"  case (fun x, traverseEither fun xs) of\n"
"    (Left y, Left z)   => Left (y <+> z)\n"
"    (Left y, Right _)  => Left y\n"
"    (Right _, Left z)  => Left z\n"
"    (Right y, Right z) => Right (y :: z)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:879
#, markdown-text
msgid "To reap the fruits of our labour, let's show off with a small example:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functions2.md:880
#, no-wrap
msgid ""
"data Nucleobase = Adenine | Cytosine | Guanine | Thymine\n"
"\n"
"readNucleobase : Char -> Either (List String) Nucleobase\n"
"readNucleobase 'A' = Right Adenine\n"
"readNucleobase 'C' = Right Cytosine\n"
"readNucleobase 'G' = Right Guanine\n"
"readNucleobase 'T' = Right Thymine\n"
"readNucleobase c   = Left [\"Unknown nucleobase: \" ++ show c]\n"
"\n"
"DNA : Type\n"
"DNA = List Nucleobase\n"
"\n"
"readDNA : String -> Either (List String) DNA\n"
"readDNA = traverseEither readNucleobase . unpack\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:898
#, markdown-text
msgid "Let's try this at the REPL:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functions2.md:899
#, no-wrap
msgid ""
"Tutorial.Functions2> readDNA \"CGTTA\"\n"
"Right [Cytosine, Guanine, Thymine, Thymine, Adenine]\n"
"Tutorial.Functions2> readDNA \"CGFTAQ\"\n"
"Left [\"Unknown nucleobase: 'F'\", \"Unknown nucleobase: 'Q'\"]\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Functions2.md:906
#, markdown-text, no-wrap
msgid "Interactive Editing"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:916
#, markdown-text
msgid ""
"There are plugins available for several editors and programming "
"environments, which facilitate interacting with the Idris compiler when "
"implementing your functions.  One editor, which is well supported in the "
"Idris community, is Neovim. Since I am a Neovim user myself, I added some "
"examples of what's possible to the [appendix](../Appendices/Neovim.md). Now "
"would be a good time to start using the utilities discussed there."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:923
#, markdown-text
msgid ""
"If you use a different editor, probably with less support for the Idris "
"programming language, you should at the very least have a REPL session open "
"all the time, where the source file you are currently working on is "
"loaded. This allows you to introduce new metavariables and inspect their "
"types and context as you develop your code."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:929
#, markdown-text
msgid ""
"We again covered a lot of ground in this section. I can't stress enough that "
"you should get yourselves accustomed to programming with holes and let the "
"type checker help you figure out what to do next."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:932
#, markdown-text, no-wrap
msgid ""
"* When in need of local utility functions, consider defining them\n"
"as local definitions in a *where block*.\n"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Functions2.md:934
#, markdown-text
msgid "Use *let expressions* to define and reuse local variables."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:938
#, markdown-text, no-wrap
msgid ""
"* Function arguments can be given a name, which can serve as "
"documentation,\n"
"can be used to pass arguments in any order, and is used to refer to\n"
"them in dependent types.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:942
#, markdown-text, no-wrap
msgid ""
"* Implicit arguments are wrapped in curly braces. The compiler is\n"
"supposed to infer them from the context. If that's not possible,\n"
"they can be passed explicitly as other named arguments.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:945
#, markdown-text, no-wrap
msgid ""
"* Whenever possible, Idris adds implicit erased arguments for all\n"
"type parameters automatically.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:948
#, markdown-text, no-wrap
msgid ""
"* Quantities allow us to track how often a function argument is\n"
"used. Quantity 0 means, the argument is erased at runtime.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:953
#, markdown-text, no-wrap
msgid ""
"* Use *holes* as placeholders for pieces of code you plan to fill\n"
"in at a later time. Use the REPL (or your editor) to inspect\n"
"the types of holes together with the names, types, and quantities of all\n"
"variables in their context.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functions2.md:962
#, markdown-text
msgid ""
"In the [next chapter](Dependent.md)  we'll start using dependent types to "
"help us write provably correct code.  Having a good understanding of how to "
"read Idris' type signatures will be of paramount importance there. Whenever "
"you feel lost, add one or more holes and inspect their context to decide "
"what to do next."
msgstr ""

#. type: Title #
#: ../src/Tutorial/Functor.md:1
#, markdown-text, no-wrap
msgid "Functor and Friends"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:6
#, markdown-text
msgid ""
"Programming, like mathematics, is about abstraction. We try to model parts "
"of the real world, reusing recurring patterns by abstracting over them."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:17
#, markdown-text
msgid ""
"In this chapter, we will learn about several related interfaces, which are "
"all about abstraction and therefore can be hard to understand at the "
"beginning. Especially figuring out *why* they are useful and *when* to use "
"them will take time and experience. This chapter therefore comes with tons "
"of exercises, most of which can be solved with only a few short lines of "
"code. Don't skip them.  Come back to them several times until these things "
"start feeling natural to you. You will then realize that their initial "
"complexity has vanished."
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:18
#, no-wrap
msgid ""
"module Tutorial.Functor\n"
"\n"
"import Data.List1\n"
"import Data.String\n"
"import Data.Vect\n"
"\n"
"%default total\n"
msgstr ""

#. type: Title ##
#: ../src/Tutorial/Functor.md:28
#, markdown-text, no-wrap
msgid "Functor"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:42
#, markdown-text, no-wrap
msgid ""
"What do type constructors like `List`, `List1`, `Maybe`, or\n"
"`IO` have in common? First, all of them are of type\n"
"`Type -> Type`. Second, they all put values of a given type\n"
"in a certain *context*. With `List`,\n"
"the *context* is *non-determinism*: We know there to\n"
"be zero or more values, but we don't know the exact number\n"
"until we start taking the list apart by pattern matching\n"
"on it. Likewise for `List1`, though we know for sure that\n"
"there is at least one value. For `Maybe`, we are still not\n"
"sure about how many values there are, but the possibilities\n"
"are much smaller: Zero or one. With `IO`, the context is a different one:\n"
"Arbitrary side effects.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:49
#, markdown-text
msgid ""
"Although the type constructors discussed above are quite different in how "
"they behave and when they are useful, there are certain operations that keep "
"coming up when working with them. The first such operation is *mapping a "
"pure function over the data type, without affecting its underlying "
"structure*."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:53
#, markdown-text
msgid ""
"For instance, given a list of numbers, we'd like to multiply each number by "
"two, without changing their order or removing any values:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:54
#, no-wrap
msgid ""
"multBy2List : Num a => List a -> List a\n"
"multBy2List []        = []\n"
"multBy2List (x :: xs) = 2 * x :: multBy2List xs\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:62
#, markdown-text
msgid ""
"But we might just as well convert every string in a list of strings to upper "
"case characters:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:63
#, no-wrap
msgid ""
"toUpperList : List String -> List String\n"
"toUpperList []        = []\n"
"toUpperList (x :: xs) = toUpper x :: toUpperList xs\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:72
#, markdown-text
msgid ""
"Sometimes, the type of the stored value changes. In the next example, we "
"calculate the lengths of the strings stored in a list:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:73
#, no-wrap
msgid ""
"toLengthList : List String -> List Nat\n"
"toLengthList []        = []\n"
"toLengthList (x :: xs) = length x :: toLengthList xs\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:83
#, markdown-text
msgid ""
"I'd like you to appreciate, just how boring these functions are. They are "
"almost identical, with the only interesting part being the function we apply "
"to each element. Surely, there must be a pattern to abstract over:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:84
#, no-wrap
msgid ""
"mapList : (a -> b) -> List a -> List b\n"
"mapList f []        = []\n"
"mapList f (x :: xs) = f x :: mapList f xs\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:94
#, markdown-text
msgid ""
"This is often the first step of abstraction in functional programming: Write "
"a (possibly generic) higher-order function.  We can now concisely implement "
"all examples shown above in terms of `mapList`:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:95
#, no-wrap
msgid ""
"multBy2List' : Num a => List a -> List a\n"
"multBy2List' = mapList (2 *)\n"
"\n"
"toUpperList' : List String -> List String\n"
"toUpperList' = mapList toUpper\n"
"\n"
"toLengthList' : List String -> List Nat\n"
"toLengthList' = mapList length\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:110
#, markdown-text
msgid ""
"But surely we'd like to do the same kind of thing with `List1` and `Maybe`! "
"After all, they are just container types like `List`, the only difference "
"being some detail about the number of values they can or can't hold:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:111
#, no-wrap
msgid ""
"mapMaybe : (a -> b) -> Maybe a -> Maybe b\n"
"mapMaybe f Nothing  = Nothing\n"
"mapMaybe f (Just v) = Just (f v)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:125
#, markdown-text
msgid ""
"Even with `IO`, we'd like to be able to map pure functions over effectful "
"computations. The implementation is a bit more involved, due to the nested "
"layers of data constructors, but if in doubt, the types will surely guide "
"us. Note, however, that `IO` is not publicly exported, so its data "
"constructor is unavailable to us. We can use functions `toPrim` and "
"`fromPrim`, however, for converting `IO` from and to `PrimIO`, which we can "
"freely dissect:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:126
#, no-wrap
msgid ""
"mapIO : (a -> b) -> IO a -> IO b\n"
"mapIO f io = fromPrim $ mapPrimIO (toPrim io)\n"
"  where mapPrimIO : PrimIO a -> PrimIO b\n"
"        mapPrimIO prim w =\n"
"          let MkIORes va w2 = prim w\n"
"           in MkIORes (f va) w2\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:138
#, markdown-text
msgid ""
"From the concept of *mapping a pure function over values in a context* "
"follow some derived functions, which are often useful. Here are some of them "
"for `IO`:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:139
#, no-wrap
msgid ""
"mapConstIO : b -> IO a -> IO b\n"
"mapConstIO = mapIO . const\n"
"\n"
"forgetIO : IO a -> IO ()\n"
"forgetIO = mapConstIO ()\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:151
#, markdown-text
msgid ""
"Of course, we'd want to implement `mapConst` and `forget` as well for "
"`List`, `List1`, and `Maybe` (and dozens of other type constructors with "
"some kind of mapping function), and they'd all look the same and be equally "
"boring."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:161
#, markdown-text, no-wrap
msgid ""
"When we come upon a recurring class of functions with\n"
"several useful derived functions, we should consider defining\n"
"an interface. But how should we go about this here?\n"
"When you look at the types of `mapList`, `mapMaybe`, and `mapIO`,\n"
"you'll see that it's the `List`, `List1`, and `IO` types we\n"
"need to get rid of. These are not of type `Type` but of type\n"
"`Type -> Type`. Luckily, there is nothing preventing us\n"
"from parametrizing an interface over something else than\n"
"a `Type`.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:166
#, markdown-text
msgid ""
"The interface we are looking for is called `Functor`.  Here is its "
"definition and an example implementation (I appended a tick at the end of "
"the names for them not to overlap with the interface and functions exported "
"by the *Prelude*):"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:167
#, no-wrap
msgid ""
"interface Functor' (0 f : Type -> Type) where\n"
"  map' : (a -> b) -> f a -> f b\n"
"\n"
"implementation Functor' Maybe where\n"
"  map' _ Nothing  = Nothing\n"
"  map' f (Just v) = Just $ f v\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:179
#, markdown-text
msgid ""
"Note, that we had to give the type of parameter `f` explicitly, and in that "
"case it needs to be annotated with quantity zero if you want it to be erased "
"at runtime (which you almost always want)."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:186
#, markdown-text
msgid ""
"Now, reading type signatures consisting only of type parameters like the one "
"of `map'` can take some time to get used to, especially when some type "
"parameters are applied to other parameters as in `f a`. It can be very "
"helpful to inspect these signatures together with all implicit arguments at "
"the REPL (I formatted the output to make it more readable):"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functor.md:187
#, no-wrap
msgid ""
"Tutorial.Functor> :ti map'\n"
"Tutorial.Functor.map' :  {0 b : Type}\n"
"                      -> {0 a : Type}\n"
"                      -> {0 f : Type -> Type}\n"
"                      -> Functor' f\n"
"                      => (a -> b)\n"
"                      -> f a\n"
"                      -> f b\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:200
#, markdown-text
msgid ""
"It can also be helpful to replace type parameter `f` with a concrete value "
"of the same type:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functor.md:201
#, no-wrap
msgid ""
"Tutorial.Functor> :t map' {f = Maybe}\n"
"map' : (?a -> ?b) -> Maybe ?a -> Maybe ?b\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:209
#, markdown-text
msgid ""
"Remember, being able to interpret type signatures is paramount to "
"understanding what's going on in an Idris declaration. You *must* practice "
"this and make use of the tools and utilities given to you."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Functor.md:210
#, markdown-text, no-wrap
msgid "Derived Functions"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:215
#, markdown-text
msgid ""
"There are several functions and operators directly derivable from interface "
"`Functor`. Eventually, you should know and remember all of them as they are "
"highly useful. Here they are together with their types:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functor.md:216
#, no-wrap
msgid ""
"Tutorial.Functor> :t (<$>)\n"
"Prelude.<$> : Functor f => (a -> b) -> f a -> f b\n"
"\n"
"Tutorial.Functor> :t (<&>)\n"
"Prelude.<&> : Functor f => f a -> (a -> b) -> f b\n"
"\n"
"Tutorial.Functor> :t ($>)\n"
"Prelude.$> : Functor f => f a -> b -> f b\n"
"\n"
"Tutorial.Functor> :t (<$)\n"
"Prelude.<$ : Functor f => b -> f a -> f b\n"
"\n"
"Tutorial.Functor> :t ignore\n"
"Prelude.ignore : Functor f => f a -> f ()\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:235
#, markdown-text, no-wrap
msgid ""
"`(<$>)` is an operator alias for `map` and allows you to sometimes\n"
"drop some parentheses. For instance:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:236
#, no-wrap
msgid ""
"tailShowReversNoOp : Show a => List1 a -> List String\n"
"tailShowReversNoOp xs = map (reverse . show) (tail xs)\n"
"\n"
"tailShowReverse : Show a => List1 a -> List String\n"
"tailShowReverse xs = reverse . show <$> tail xs\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:249
#, markdown-text, no-wrap
msgid ""
"`(<&>)` is an alias for `(<$>)` with the arguments flipped.\n"
"The other three (`ignore`, `($>)`, and `(<$)`) are all used\n"
"to replace the values in a context with a constant. They are often useful\n"
"when you don't care about the values themselves but\n"
"want to keep the underlying structure.\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Functor.md:250
#, markdown-text, no-wrap
msgid "Functors with more than one Type Parameter"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:259
#, markdown-text, no-wrap
msgid ""
"The type constructors we looked at so far were all\n"
"of type `Type -> Type`. However, we can also implement `Functor`\n"
"for other type constructors. The only prerequisite is that\n"
"the type parameter we'd like to change with function `map` must\n"
"be the last in the argument list. For instance, here is the\n"
"`Functor` implementation for `Either e` (note, that `Either e`\n"
"has of course type `Type -> Type` as required):\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:260
#, no-wrap
msgid ""
"implementation Functor' (Either e) where\n"
"  map' _ (Left ve)  = Left ve\n"
"  map' f (Right va) = Right $ f va\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:269
#, markdown-text, no-wrap
msgid ""
"Here is another example, this time for a type constructor of\n"
"type `Bool -> Type -> Type` (you might remember this from\n"
"the exercises in the [last chapter](IO.md)):\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:270
#, no-wrap
msgid ""
"data List01 : (nonEmpty : Bool) -> Type -> Type where\n"
"  Nil  : List01 False a\n"
"  (::) : a -> List01 False a -> List01 ne a\n"
"\n"
"implementation Functor (List01 ne) where\n"
"  map _ []        = []\n"
"  map f (x :: xs) = f x :: map f xs\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Functor.md:280
#, markdown-text, no-wrap
msgid "Functor Composition"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:284
#, markdown-text
msgid ""
"The nice thing about functors is how they can be paired and nested with "
"other functors and the results are functors again:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:285
#, no-wrap
msgid ""
"record Product (f,g : Type -> Type) (a : Type) where\n"
"  constructor MkProduct\n"
"  fst : f a\n"
"  snd : g a\n"
"\n"
"implementation Functor f => Functor g => Functor (Product f g) where\n"
"  map f (MkProduct l r) = MkProduct (map f l) (map f r)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:297
#, markdown-text
msgid ""
"The above allows us to conveniently map over a pair of functors. Note, "
"however, that Idris needs some help with inferring the types involved:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:298
#, no-wrap
msgid ""
"toPair : Product f g a -> (f a, g a)\n"
"toPair (MkProduct fst snd) = (fst, snd)\n"
"\n"
"fromPair : (f a, g a) -> Product f g a\n"
"fromPair (x,y) = MkProduct x y\n"
"\n"
"productExample :  Show a\n"
"               => (Either e a, List a)\n"
"               -> (Either e String, List String)\n"
"productExample = toPair . map show . fromPair {f = Either e, g = List}\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:313
#, markdown-text
msgid ""
"More often, we'd like to map over several layers of nested functors at "
"once. Here's how to do this with an example:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:314
#, no-wrap
msgid ""
"record Comp (f,g : Type -> Type) (a : Type) where\n"
"  constructor MkComp\n"
"  unComp  : f (g a)\n"
"\n"
"implementation Functor f => Functor g => Functor (Comp f g) where\n"
"  map f (MkComp v) = MkComp $ map f <$> v\n"
"\n"
"compExample :  Show a => List (Either e a) -> List (Either e String)\n"
"compExample = unComp . map show . MkComp {f = List, g = Either e}\n"
msgstr ""

#. type: Title ####
#: ../src/Tutorial/Functor.md:326
#, markdown-text, no-wrap
msgid "Named Implementations"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:334
#, markdown-text
msgid ""
"Sometimes, there are more ways to implement an interface for a given "
"type. For instance, for numeric types we can have a `Monoid` representing "
"addition and one representing multiplication.  Likewise, for nested "
"functors, `map` can be interpreted as a mapping over only the first layer of "
"values, or a mapping over several layers of values."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:339
#, markdown-text
msgid ""
"One way to go about this is to define single-field wrappers as shown with "
"data type `Comp` above. However, Idris also allows us to define additional "
"interface implementations, which must then be given a name. For instance:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:340
#, no-wrap
msgid ""
"[Compose'] Functor f => Functor g => Functor (f . g) where\n"
"  map f = (map . map) f\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:350
#, markdown-text
msgid ""
"Note, that this defines a new implementation of `Functor`, which will *not* "
"be considered during implicit resolution in order to avoid "
"ambiguities. However, it is possible to explicitly choose to use this "
"implementation by passing it as an explicit argument to `map`, prefixed with "
"an `@`:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:351
#, no-wrap
msgid ""
"compExample2 :  Show a => List (Either e a) -> List (Either e String)\n"
"compExample2 = map @{Compose} show\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:358
#, markdown-text
msgid ""
"In the example above, we used `Compose` instead of `Compose'`, since the "
"former is already exported by the *Prelude*."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Functor.md:359
#, markdown-text, no-wrap
msgid "Functor Laws"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:365
#, markdown-text
msgid ""
"Implementations of `Functor` are supposed to adhere to certain laws, just "
"like implementations of `Eq` or `Ord`. Again, these laws are not verified by "
"Idris, although it would be possible (and often cumbersome) to do so."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:370
#, markdown-text, no-wrap
msgid ""
"1. `map id = id`: Mapping the identity function over a functor\n"
"    must not have any visible effect such as changing a container's\n"
"    structure or affecting the side effects perfomed when\n"
"    running an `IO` action.\n"
msgstr ""

#. type: Bullet: '2. '
#: ../src/Tutorial/Functor.md:373
#, markdown-text
msgid ""
"`map (f . g) = map f . map g`: Sequencing two mappings must be identical to "
"a single mapping using the composition of the two functions."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:380
#, markdown-text
msgid ""
"Both of these laws request, that `map` is preserving the *structure* of "
"values. This is easier to understand with container types like `List`, "
"`Maybe`, or `Either e`, where `map` is not allowed to add or remove any "
"wrapped value, nor - in case of `List` - change their order. With `IO`, this "
"can best be described as `map` not performing additional side effects."
msgstr ""

#. type: Bullet: '1. '
#: ../src/Tutorial/Functor.md:385
#, markdown-text
msgid ""
"Write your own implementations of `Functor'` for `Maybe`, `List`, `List1`, "
"`Vect n`, `Either e`, and `Pair a`."
msgstr ""

#. type: Bullet: '2. '
#: ../src/Tutorial/Functor.md:388
#, markdown-text
msgid ""
"Write a named implementation of `Functor` for pairs of functors (similar to "
"the one implemented for `Product`)."
msgstr ""

#. type: Bullet: '3. '
#: ../src/Tutorial/Functor.md:391
#, markdown-text
msgid ""
"Implement `Functor` for data type `Identity` (which is available from "
"`Control.Monad.Identity` in *base*):"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:392
#, no-wrap
msgid ""
"   record Identity a where\n"
"     constructor Id\n"
"     value : a\n"
msgstr ""

#. type: Bullet: '4. '
#: ../src/Tutorial/Functor.md:404
#, markdown-text
msgid ""
"Here is a curious one: Implement `Functor` for `Const e` (which is also "
"available from `Control.Applicative.Const` in *base*). You might be confused "
"about the fact that the second type parameter has absolutely no relevance at "
"runtime, as there is no value of that type. Such types are sometimes called "
"*phantom types*. They can be quite useful for tagging values with additional "
"typing information."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:407
#, markdown-text, no-wrap
msgid ""
"   Don't let the above confuse you: There is only one possible "
"implementation.\n"
"   As usual, use holes and let the compiler guide you if you get lost.\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:408
#, no-wrap
msgid ""
"   record Const (e,a : Type) where\n"
"     constructor MkConst\n"
"     value : e\n"
msgstr ""

#. type: Bullet: '5. '
#: ../src/Tutorial/Functor.md:416
#, markdown-text
msgid ""
"Here is a sum type for describing CRUD operations (Create, Read, Update, and "
"Delete) in a data store:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:426
#, markdown-text, no-wrap
msgid "   Implement `Functor` for `Crud i`.\n"
msgstr ""

#. type: Bullet: '6. '
#: ../src/Tutorial/Functor.md:428
#, markdown-text
msgid "Here is a sum type for describing responses from a data server:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:439
#, markdown-text, no-wrap
msgid "   Implement `Functor` for `Repsonse e i`.\n"
msgstr ""

#. type: Bullet: '7. '
#: ../src/Tutorial/Functor.md:441
#, markdown-text
msgid "Implement `Functor` for `Validated e`:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:442
#, no-wrap
msgid ""
"   data Validated : (e,a : Type) -> Type where\n"
"     Invalid : (err : e) -> Validated e a\n"
"     Valid   : (val : a) -> Validated e a\n"
msgstr ""

#. type: Title ##
#: ../src/Tutorial/Functor.md:448
#, markdown-text, no-wrap
msgid "Applicative"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:453
#, markdown-text
msgid ""
"While `Functor` allows us to map a pure, unary function over a value in a "
"context, it doesn't allow us to combine n such values under an n-ary "
"function."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:455
#, markdown-text
msgid "For instance, consider the following functions:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:456
#, no-wrap
msgid ""
"liftMaybe2 : (a -> b -> c) -> Maybe a -> Maybe b -> Maybe c\n"
"liftMaybe2 f (Just va) (Just vb) = Just $ f va vb\n"
"liftMaybe2 _ _         _         = Nothing\n"
"\n"
"liftVect2 : (a -> b -> c) -> Vect n a -> Vect n b -> Vect n c\n"
"liftVect2 _ []        []        = []\n"
"liftVect2 f (x :: xs) (y :: ys) = f x y :: liftVect2 f xs ys\n"
"\n"
"liftIO2 : (a -> b -> c) -> IO a -> IO b -> IO c\n"
"liftIO2 f ioa iob = fromPrim $ go (toPrim ioa) (toPrim iob)\n"
"  where go : PrimIO a -> PrimIO b -> PrimIO c\n"
"        go pa pb w =\n"
"          let MkIORes va w2 = pa w\n"
"              MkIORes vb w3 = pb w2\n"
"           in MkIORes (f va vb) w3\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:478
#, markdown-text
msgid ""
"This behavior is not covered by `Functor`, yet it is a very common thing to "
"do. For instance, we might want to read two numbers from standard input "
"(both operations might fail), calculating the product of the two. Here's the "
"code:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:479
#, no-wrap
msgid ""
"multNumbers : Num a => Neg a => IO (Maybe a)\n"
"multNumbers = do\n"
"  s1 <- getLine\n"
"  s2 <- getLine\n"
"  pure $ liftMaybe2 (*) (parseInteger s1) (parseInteger s2)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:490
#, markdown-text
msgid ""
"And it won't stop here. We might just as well want to have `liftMaybe3` for "
"ternary functions and three `Maybe` arguments and so on, for arbitrary "
"numbers of arguments."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:493
#, markdown-text
msgid ""
"But there is more: We'd also like to lift pure values into the context in "
"question. With this, we could do the following:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:494
#, no-wrap
msgid ""
"liftMaybe3 : (a -> b -> c -> d) -> Maybe a -> Maybe b -> Maybe c -> Maybe "
"d\n"
"liftMaybe3 f (Just va) (Just vb) (Just vc) = Just $ f va vb vc\n"
"liftMaybe3 _ _         _         _         = Nothing\n"
"\n"
"pureMaybe : a -> Maybe a\n"
"pureMaybe = Just\n"
"\n"
"multAdd100 : Num a => Neg a => String -> String -> Maybe a\n"
"multAdd100 s t = liftMaybe3 calc (parseInteger s) (parseInteger t) (pure "
"100)\n"
"  where calc : a -> a -> a -> a\n"
"        calc x y z = x * y + z\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:511
#, markdown-text
msgid ""
"As you'll of course already know, I am now going to present a new interface "
"to encapsulate this behavior. It's called `Applicative`.  Here is its "
"definition and an example implementation:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:512
#, no-wrap
msgid ""
"interface Functor' f => Applicative' f where\n"
"  app   : f (a -> b) -> f a -> f b\n"
"  pure' : a -> f a\n"
"\n"
"implementation Applicative' Maybe where\n"
"  app (Just fun) (Just val) = Just $ fun val\n"
"  app _          _          = Nothing\n"
"\n"
"  pure' = Just\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:527
#, markdown-text, no-wrap
msgid ""
"Interface `Applicative` is of course already exported by the *Prelude*.\n"
"There, function `app` is an operator sometimes called *app* or *apply*:\n"
"`(<*>)`.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:530
#, markdown-text
msgid ""
"You may wonder, how functions like `liftMaybe2` or `liftIO3` are related to "
"operator *apply*. Let me demonstrate this:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:531
#, no-wrap
msgid ""
"liftA2 : Applicative f => (a -> b -> c) -> f a -> f b -> f c\n"
"liftA2 fun fa fb = pure fun <*> fa <*> fb\n"
"\n"
"liftA3 : Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d\n"
"liftA3 fun fa fb fc = pure fun <*> fa <*> fb <*> fc\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:544
#, markdown-text, no-wrap
msgid ""
"It is really important for you to understand what's going on here, so "
"let's\n"
"break these down. If we specialize `liftA2` to use `Maybe` for `f`,\n"
"`pure fun` is of type `Maybe (a -> b -> c)`. Likewise, `pure fun <*> fa`\n"
"is of type `Maybe (b -> c)`, as `(<*>)` will apply the value stored\n"
"in `fa` to the function stored in `pure fun` (currying!).\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:550
#, markdown-text
msgid ""
"You'll often see such chains of applications of *apply*, the number of "
"*applies* corresponding to the arity of the function we lift.  You'll "
"sometimes also see the following, which allows us to drop the initial call "
"to `pure`, and use the operator version of `map` instead:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:551
#, no-wrap
msgid ""
"liftA2' : Applicative f => (a -> b -> c) -> f a -> f b -> f c\n"
"liftA2' fun fa fb = fun <$> fa <*> fb\n"
"\n"
"liftA3' : Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d\n"
"liftA3' fun fa fb fc = fun <$> fa <*> fb <*> fc\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:564
#, markdown-text
msgid ""
"So, interface `Applicative` allows us to lift values (and functions!)  into "
"computational contexts and apply them to values in the same contexts. Before "
"we will see an extended example why this is useful, I'll quickly introduce "
"some syntactic sugar for working with applicative functors."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Functor.md:565
#, markdown-text, no-wrap
msgid "Idiom Brackets"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:571
#, markdown-text
msgid ""
"The programming style used for implementing `liftA2'` and `liftA3'` is also "
"referred to as *applicative style* and is used a lot in Haskell for "
"combining several effectful computations with a single pure function."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:575
#, markdown-text
msgid ""
"In Idris, there is an alternative to using such chains of operator "
"applications: Idiom brackets. Here's another reimplementation of `liftA2` "
"and `liftA3`:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:576
#, no-wrap
msgid ""
"liftA2'' : Applicative f => (a -> b -> c) -> f a -> f b -> f c\n"
"liftA2'' fun fa fb = [| fun fa fb |]\n"
"\n"
"liftA3'' : Applicative f => (a -> b -> c -> d) -> f a -> f b -> f c -> f d\n"
"liftA3'' fun fa fb fc = [| fun fa fb fc |]\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:590
#, markdown-text, no-wrap
msgid ""
"The above implementations will be desugared to the one given\n"
"for `liftA2` and `liftA3`, again *before disambiguating,\n"
"type checking, and filling in of implicit values*. Like with the\n"
"*bind* operator, we can therefore write custom implementations\n"
"for `pure` and `(<*>)`, and Idris will use these if it\n"
"can disambiguate between the overloaded function names.\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Functor.md:591
#, markdown-text, no-wrap
msgid "Use Case: CSV Reader"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:604
#, markdown-text
msgid ""
"In order to understand the power and versatility that comes with applicative "
"functors, we will look at a slightly extended example. We are going to write "
"some utilities for parsing and decoding content from CSV files. These are "
"files where each line holds a list of values separated by commas (or some "
"other delimiter). Typically, they are used to store tabular data, for "
"instance from spread sheet applications. What we would like to do is convert "
"lines in a CSV file and store the result in custom records, where each "
"record field corresponds to a column in the table."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:609
#, markdown-text
msgid ""
"For instance, here is a simple example file, containing tabular user "
"information from a web store: First name, last name, age (optional), email "
"address, gender, and password."
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functor.md:610
#, no-wrap
msgid ""
"Jon,Doe,42,jon@doe.ch,m,weijr332sdk\n"
"Jane,Doe,,jane@doe.ch,f,aa433sd112\n"
"Stefan,Hoeck,,nope@goaway.ch,m,password123\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:621
#, markdown-text
msgid ""
"And here are the Idris data types necessary to hold this information at "
"runtime. We use again custom string wrappers for increased type safety and "
"because it will allow us to define for each data type what we consider to be "
"valid input:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:622
#, no-wrap
msgid ""
"data Gender = Male | Female | Other\n"
"\n"
"record Name where\n"
"  constructor MkName\n"
"  value : String\n"
"\n"
"record Email where\n"
"  constructor MkEmail\n"
"  value : String\n"
"\n"
"record Password where\n"
"  constructor MkPassword\n"
"  value : String\n"
"\n"
"record User where\n"
"  constructor MkUser\n"
"  firstName : Name\n"
"  lastName  : Name\n"
"  age       : Maybe Nat\n"
"  email     : Email\n"
"  gender    : Gender\n"
"  password  : Password\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:650
#, markdown-text
msgid ""
"We start by defining an interface for reading fields in a CSV file and "
"writing implementations for the data types we'd like to read:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:651
#, no-wrap
msgid ""
"interface CSVField a where\n"
"  read : String -> Maybe a\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:659
#, markdown-text
msgid ""
"Below are implementations for `Gender` and `Bool`. I decided to in these "
"cases encode each value with a single lower case character:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:660
#, no-wrap
msgid ""
"CSVField Gender where\n"
"  read \"m\" = Just Male\n"
"  read \"f\" = Just Female\n"
"  read \"o\" = Just Other\n"
"  read _   = Nothing\n"
"\n"
"CSVField Bool where\n"
"  read \"t\" = Just True\n"
"  read \"f\" = Just False\n"
"  read _   = Nothing\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:675
#, markdown-text
msgid "For numeric types, we can use the parsing functions from `Data.String`:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:676
#, no-wrap
msgid ""
"CSVField Nat where\n"
"  read = parsePositive\n"
"\n"
"CSVField Integer where\n"
"  read = parseInteger\n"
"\n"
"CSVField Double where\n"
"  read = parseDouble\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:692
#, markdown-text, no-wrap
msgid ""
"For optional values, the stored type must itself\n"
"come with an instance of `CSVField`. We can then treat\n"
"the empty string `\"\"` as `Nothing`, while a non-empty\n"
"string will be passed to the encapsulated type's field reader.\n"
"(Remember that `(<$>)` is an alias for `map`.)\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:693
#, no-wrap
msgid ""
"CSVField a => CSVField (Maybe a) where\n"
"  read \"\" = Just Nothing\n"
"  read s  = Just <$> read s\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:703
#, markdown-text
msgid ""
"Finally, for our string wrappers, we need to decide what we consider to be "
"valid values. For simplicity, I decided to limit the length of allowed "
"strings and the set of valid characters."
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:704
#, no-wrap
msgid ""
"readIf : (String -> Bool) -> (String -> a) -> String -> Maybe a\n"
"readIf p mk s = if p s then Just (mk s) else Nothing\n"
"\n"
"isValidName : String -> Bool\n"
"isValidName s =\n"
"  let len = length s\n"
"   in 0 < len && len <= 100 && all isAlpha (unpack s)\n"
"\n"
"CSVField Name where\n"
"  read = readIf isValidName MkName\n"
"\n"
"isEmailChar : Char -> Bool\n"
"isEmailChar '.' = True\n"
"isEmailChar '@' = True\n"
"isEmailChar c   = isAlphaNum c\n"
"\n"
"isValidEmail : String -> Bool\n"
"isValidEmail s =\n"
"  let len = length s\n"
"   in 0 < len && len <= 100 && all isEmailChar (unpack s)\n"
"\n"
"CSVField Email where\n"
"  read = readIf isValidEmail MkEmail\n"
"\n"
"isPasswordChar : Char -> Bool\n"
"isPasswordChar ' ' = True\n"
"isPasswordChar c   = not (isControl c) && not (isSpace c)\n"
"\n"
"isValidPassword : String -> Bool\n"
"isValidPassword s =\n"
"  let len = length s\n"
"   in 8 < len && len <= 100 && all isPasswordChar (unpack s)\n"
"\n"
"CSVField Password where\n"
"  read = readIf isValidPassword MkPassword\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:745
#, markdown-text
msgid ""
"In a later chapter, we will learn about refinement types and how to store an "
"erased proof of validity together with a validated value."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:749
#, markdown-text
msgid ""
"We can now start to decode whole lines in a CSV file.  In order to do so, we "
"first introduce a custom error type encapsulating how things can go wrong:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:750
#, no-wrap
msgid ""
"data CSVError : Type where\n"
"  FieldError           : (line, column : Nat) -> (str : String) -> "
"CSVError\n"
"  UnexpectedEndOfInput : (line, column : Nat) -> CSVError\n"
"  ExpectedEndOfInput   : (line, column : Nat) -> CSVError\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:760
#, markdown-text
msgid ""
"We can now use `CSVField` to read a single field at a given line and "
"position in a CSV file, and return a `FieldError` in case of a failure."
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:761
#, no-wrap
msgid ""
"readField : CSVField a => (line, column : Nat) -> String -> Either CSVError "
"a\n"
"readField line col str =\n"
"  maybe (Left $ FieldError line col str) Right (read str)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:772
#, markdown-text
msgid ""
"If we know in advance the number of fields we need to read, we can try and "
"convert a list of strings to a `Vect` of the given length. This facilitates "
"reading record values of a known number of fields, as we get the correct "
"number of string variables when pattern matching on the vector:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:773
#, no-wrap
msgid ""
"toVect : (n : Nat) -> (line, col : Nat) -> List a -> Either CSVError (Vect n "
"a)\n"
"toVect 0     line _   []        = Right []\n"
"toVect 0     line col _         = Left (ExpectedEndOfInput line col)\n"
"toVect (S k) line col []        = Left (UnexpectedEndOfInput line col)\n"
"toVect (S k) line col (x :: xs) = (x ::) <$> toVect k line (S col) xs\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:783
#, markdown-text
msgid ""
"Finally, we can implement function `readUser` to try and convert a single "
"line in a CSV-file to a value of type `User`:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:784
#, no-wrap
msgid ""
"readUser' : (line : Nat) -> List String -> Either CSVError User\n"
"readUser' line ss = do\n"
"  [fn,ln,a,em,g,pw] <- toVect 6 line 0 ss\n"
"  [| MkUser (readField line 1 fn)\n"
"            (readField line 2 ln)\n"
"            (readField line 3 a)\n"
"            (readField line 4 em)\n"
"            (readField line 5 g)\n"
"            (readField line 6 pw) |]\n"
"\n"
"readUser : (line : Nat) -> String -> Either CSVError User\n"
"readUser line = readUser' line . forget . split (',' ==)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:800 ../src/Tutorial/Traverse.md:122
#, markdown-text
msgid "Let's give this a go at the REPL:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functor.md:801
#, no-wrap
msgid ""
"Tutorial.Functor> readUser 1 \"Joe,Foo,46,j@f.ch,m,pw1234567\"\n"
"Right (MkUser (MkName \"Joe\") (MkName \"Foo\")\n"
"  (Just 46) (MkEmail \"j@f.ch\") Male (MkPassword \"pw1234567\"))\n"
"Tutorial.Functor> readUser 7 \"Joe,Foo,46,j@f.ch,m,shortPW\"\n"
"Left (FieldError 7 6 \"shortPW\")\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:816
#, markdown-text
msgid ""
"Note, how in the implementation of `readUser'` we used an idiom bracket to "
"map a function of six arguments (`MkUser`)  over six values of type `Either "
"CSVError`. This will automatically succeed, if and only if all of the "
"parsings have succeeded. It would have been notoriously cumbersome resulting "
"in much less readable code to implement `readUser'` with a succession of six "
"nested pattern matches."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:819
#, markdown-text
msgid ""
"However, the idiom bracket above looks still quite repetitive.  Surely, we "
"can do better?"
msgstr ""

#. type: Title ####
#: ../src/Tutorial/Functor.md:820
#, markdown-text, no-wrap
msgid "A Case for Heterogeneous Lists"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:827
#, markdown-text
msgid ""
"It is time to learn about a family of types, which can be used as a generic "
"representation for record types, and which will allow us to represent and "
"read rows in heterogeneous tables with a minimal amount of code: "
"Heterogeneous lists."
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:828
#, no-wrap
msgid ""
"namespace HList\n"
"  public export\n"
"  data HList : (ts : List Type) -> Type where\n"
"    Nil  : HList Nil\n"
"    (::) : (v : t) -> (vs : HList ts) -> HList (t :: ts)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:841
#, markdown-text
msgid ""
"A heterogeneous list is a list type indexed over a *list of types*.  This "
"allows us to at each position store a value of the type at the same position "
"in the list index. For instance, here is a variant, which stores three "
"values of types `Bool`, `Nat`, and `Maybe String` (in that order):"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:842
#, no-wrap
msgid ""
"hlist1 : HList [Bool, Nat, Maybe String]\n"
"hlist1 = [True, 12, Nothing]\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:854
#, markdown-text
msgid ""
"You could argue that heterogeneous lists are just tuples storing values of "
"the given types. That's right, of course, however, as you'll learn the hard "
"way in the exercises, we can use the list index to perform compile-time "
"computations on `HList`, for instance when concatenating two such lists to "
"keep track of the types stored in the result at the same time."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:859
#, markdown-text
msgid ""
"But first, we'll make use of `HList` as a means to concisely parse "
"CSV-lines. In order to do that, we need to introduce a new interface for "
"types corresponding to whole lines in a CSV-file:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:860
#, no-wrap
msgid ""
"interface CSVLine a where\n"
"  decodeAt : (line, col : Nat) -> List String -> Either CSVError a\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:871
#, markdown-text
msgid ""
"We'll now write two implementations of `CSVLine` for `HList`: One for the "
"`Nil` case, which will succeed if and only if the current list of strings is "
"empty. The other for the *cons* case, which will try and read a single field "
"from the head of the list and the remainder from its tail. We use again an "
"idiom bracket to concatenate the results:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:872
#, no-wrap
msgid ""
"CSVLine (HList []) where\n"
"  decodeAt _ _ [] = Right Nil\n"
"  decodeAt l c _  = Left (ExpectedEndOfInput l c)\n"
"\n"
"CSVField t => CSVLine (HList ts) => CSVLine (HList (t :: ts)) where\n"
"  decodeAt l c []        = Left (UnexpectedEndOfInput l c)\n"
"  decodeAt l c (s :: ss) = [| readField l c s :: decodeAt l (S c) ss |]\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:887
#, markdown-text
msgid ""
"And that's it! All we need to add is two utility function for decoding whole "
"lines before they have been split into tokens, one of which is specialized "
"to `HList` and takes an erased list of types as argument to make it more "
"convenient to use at the REPL:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:888
#, no-wrap
msgid ""
"decode : CSVLine a => (line : Nat) -> String -> Either CSVError a\n"
"decode line = decodeAt line 1 . forget . split (',' ==)\n"
"\n"
"hdecode :  (0 ts : List Type)\n"
"        -> CSVLine (HList ts)\n"
"        => (line : Nat)\n"
"        -> String\n"
"        -> Either CSVError (HList ts)\n"
"hdecode _ = decode\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:902
#, markdown-text
msgid "It's time to reap the fruits of our labour and give this a go at the REPL:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functor.md:903
#, no-wrap
msgid ""
"Tutorial.Functor> hdecode [Bool,Nat,Double] 1 \"f,100,12.123\"\n"
"Right [False, 100, 12.123]\n"
"Tutorial.Functor> hdecode [Name,Name,Gender] 3 \"Idris,,f\"\n"
"Left (FieldError 3 2 \"\")\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Functor.md:910
#, markdown-text, no-wrap
msgid "Applicative Laws"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:914
#, markdown-text
msgid ""
"Again, `Applicative` implementations must follow certain laws. Here they "
"are:"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Functor.md:917
#, markdown-text
msgid ""
"`pure id <*> fa = fa`: Lifting and applying the identity function has no "
"visible effect."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Functor.md:922
#, markdown-text
msgid ""
"`[| f . g |] <*> v = f <*> (g <*> v)`: I must not matter, whether we compose "
"our functions first and then apply them, or whether we apply our functions "
"first and then compose them."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:925
#, markdown-text, no-wrap
msgid ""
"  The above might be hard to understand, so here\n"
"  they are again with explicit types and implementations:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:926
#, no-wrap
msgid ""
"  compL : Maybe (b -> c) -> Maybe (a -> b) -> Maybe a -> Maybe c\n"
"  compL f g v = [| f . g |] <*> v\n"
"\n"
"  compR : Maybe (b -> c) -> Maybe (a -> b) -> Maybe a -> Maybe c\n"
"  compR f g v = f <*> (g <*> v)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:936
#, markdown-text, no-wrap
msgid ""
"  The second applicative law states, that the two implementations\n"
"  `compL` and `compR` should behave identically.\n"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Functor.md:939
#, markdown-text
msgid ""
"`pure f <*> pure x = pure (f x)`. This is also called the *homomorphism* "
"law. It should be pretty self-explaining."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Functor.md:942
#, markdown-text
msgid "`f <*> pure v = pure ($ v) <*> f`. This is called the law of *interchange*."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:944
#, markdown-text, no-wrap
msgid "  This should again be explained with a concrete example:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:945
#, no-wrap
msgid ""
"  interL : Maybe (a -> b) -> a -> Maybe b\n"
"  interL f v = f <*> pure v\n"
"\n"
"  interR : Maybe (a -> b) -> a -> Maybe b\n"
"  interR f v = pure ($ v) <*> f\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:957
#, markdown-text, no-wrap
msgid ""
"  Note, that `($ v)` has type `(a -> b) -> b`, so this\n"
"  is a function type being applied to `f`, which has\n"
"  a function of type `a -> b` wrapped in a `Maybe`\n"
"  context.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:961
#, markdown-text, no-wrap
msgid ""
"  The law of interchange states that it must not matter\n"
"  whether we apply a pure value from the left or\n"
"  right of the *apply* operator.\n"
msgstr ""

#. type: Bullet: '1. '
#: ../src/Tutorial/Functor.md:965
#, markdown-text
msgid "Implement `Applicative'` for `Either e` and `Identity`."
msgstr ""

#. type: Bullet: '2. '
#: ../src/Tutorial/Functor.md:970
#, markdown-text
msgid ""
"Implement `Applicative'` for `Vect n`. Note: In order to implement `pure`, "
"the length must be known at runtime.  This can be done by passing it as an "
"unerased implicit to the interface implementation:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:971
#, no-wrap
msgid "   implementation {n : _} -> Applicative' (Vect n) where\n"
msgstr ""

#. type: Bullet: '3. '
#: ../src/Tutorial/Functor.md:977
#, markdown-text
msgid ""
"Implement `Applicative'` for `Pair e`, with `e` having a `Monoid` "
"constraint."
msgstr ""

#. type: Bullet: '4. '
#: ../src/Tutorial/Functor.md:980
#, markdown-text
msgid ""
"Implement `Applicative` for `Const e`, with `e` having a `Monoid` "
"constraint."
msgstr ""

#. type: Bullet: '5. '
#: ../src/Tutorial/Functor.md:985
#, markdown-text
msgid ""
"Implement `Applicative` for `Validated e`, with `e` having a `Semigroup` "
"constraint. This will allow us to use `(<+>)` to accumulate errors in case "
"of two `Invalid` values in the implementation of *apply*."
msgstr ""

#. type: Bullet: '6. '
#: ../src/Tutorial/Functor.md:990
#, markdown-text
msgid ""
"Add an additional data constructor of type `CSVError -> CSVError -> "
"CSVError` to `CSVError` and use this to implement `Semigroup` for "
"`CSVError`."
msgstr ""

#. type: Bullet: '7. '
#: ../src/Tutorial/Functor.md:994
#, markdown-text
msgid ""
"Refactor our CSV-parsers and all related functions so that they return "
"`Validated` instead of `Either`. This will only work, if you solved exercise "
"6."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:1000
#, markdown-text, no-wrap
msgid ""
"   Two things to note: You will have to adjust very little of\n"
"   the existing code, as we can still use applicative syntax\n"
"   with `Validated`. Also, with this change, we enhanced our CSV-parsers\n"
"   with the ability of error accumulation. Here are some examples\n"
"   from a REPL session:\n"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functor.md:1001
#, no-wrap
msgid ""
"   Solutions.Functor> hdecode [Bool,Nat,Gender] 1 \"t,12,f\"\n"
"   Valid [True, 12, Female]\n"
"   Solutions.Functor> hdecode [Bool,Nat,Gender] 1 \"o,-12,f\"\n"
"   Invalid (App (FieldError 1 1 \"o\") (FieldError 1 2 \"-12\"))\n"
"   Solutions.Functor> hdecode [Bool,Nat,Gender] 1 \"o,-12,foo\"\n"
"   Invalid (App (FieldError 1 1 \"o\")\n"
"     (App (FieldError 1 2 \"-12\") (FieldError 1 3 \"foo\")))\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:1015
#, markdown-text, no-wrap
msgid ""
"   Behold the power of applicative functors and heterogeneous lists: With\n"
"   only a few lines of code we wrote a pure, type-safe, and total\n"
"   parser with error accumulation for lines in CSV-files, which is\n"
"   very convenient to use at the same time!\n"
msgstr ""

#. type: Bullet: '8. '
#: ../src/Tutorial/Functor.md:1018
#, markdown-text
msgid ""
"Since we introduced heterogeneous lists in this chapter, it would be a pity "
"not to experiment with them a little."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:1027
#, markdown-text, no-wrap
msgid ""
"   This exercise is meant to sharpen your skills in type wizardry.\n"
"   It therefore comes with very few hints. Try to decide yourself\n"
"   what behavior you'd expect from a given function, how to express\n"
"   this in the types, and how to implement it afterwards.\n"
"   If your types are correct and precise enough, the implementations\n"
"   will almost come for free. Don't give up too early if you get stuck.\n"
"   Only if you truly run out of ideas should you have a glance\n"
"   at the solutions (and then, only at the types at first!)\n"
msgstr ""

#. type: Bullet: '   1. '
#: ../src/Tutorial/Functor.md:1029
#, markdown-text
msgid "Implement `head` for `HList`."
msgstr ""

#. type: Bullet: '   2. '
#: ../src/Tutorial/Functor.md:1031
#, markdown-text
msgid "Implement `tail` for `HList`."
msgstr ""

#. type: Bullet: '   3. '
#: ../src/Tutorial/Functor.md:1033
#, markdown-text
msgid "Implement `(++)` for `HList`."
msgstr ""

#. type: Bullet: '   4. '
#: ../src/Tutorial/Functor.md:1037
#, markdown-text
msgid ""
"Implement `index` for `HList`. This might be harder than the other three.  "
"Go back and look how we implemented `indexList` in an [earlier "
"exercise](Dependent.md) and start from there."
msgstr ""

#. type: Bullet: '   5. '
#: ../src/Tutorial/Functor.md:1043
#, markdown-text
msgid ""
"Package *contrib*, which is part of the Idris project, provides "
"`Data.HVect.HVect`, a data type for heterogeneous vectors. The only "
"difference to our own `HList` is, that `HVect` is indexed over a vector of "
"types instead of a list of types. This makes it easier to express certain "
"operations at the type level."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:1046
#, markdown-text, no-wrap
msgid ""
"      Write your own implementation of `HVect` together with functions\n"
"      `head`, `tail`, `(++)`, and `index`.\n"
msgstr ""

#. type: Bullet: '   6. '
#: ../src/Tutorial/Functor.md:1050
#, markdown-text
msgid ""
"For a real challenge, try implementing a function for transposing a `Vect m "
"(HVect ts)`. You'll first have to be creative about how to even express this "
"in the types."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:1057
#, markdown-text, no-wrap
msgid ""
"      Note: In order to implement this, you'll need to pattern match\n"
"      on an erased argument in at least one case to help Idris with\n"
"      type inference. Pattern matching on erased arguments is forbidden\n"
"      (they are erased after all, so we can't inspect them at runtime),\n"
"      *unless* the structure of the value being matched on can be derived\n"
"      from another, un-erased argument.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:1061
#, markdown-text, no-wrap
msgid ""
"      Also, don't worry if you get stuck on this one. It took me several\n"
"      tries to figure it out. But I enjoyed the experience, so I just "
"*had*\n"
"      to include it here. :-)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:1065
#, markdown-text, no-wrap
msgid ""
"      Note, however, that such a function might be useful when working "
"with\n"
"      CSV-files, as it allows us to convert a table represented as\n"
"      rows (a vector of tuples) to one represented as columns (a tuple of "
"vectors).\n"
msgstr ""

#. type: Bullet: '9. '
#: ../src/Tutorial/Functor.md:1069
#, markdown-text
msgid ""
"Show, that the composition of two applicative functors is again an "
"applicative functor by implementing `Applicative` for `Comp f g`."
msgstr ""

#. type: Bullet: '10. '
#: ../src/Tutorial/Functor.md:1073
#, markdown-text
msgid ""
"Show, that the product of two applicative functors is again an applicative "
"functor by implementing `Applicative` for `Prod f g`."
msgstr ""

#. type: Title ##
#: ../src/Tutorial/Functor.md:1074
#, markdown-text, no-wrap
msgid "Monad"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:1081
#, markdown-text, no-wrap
msgid ""
"Finally, `Monad`. A lot of ink has been spilled about this one.\n"
"However, after what we already saw in the [chapter about `IO`](IO.md),\n"
"there is not much left to discuss here. `Monad` extends\n"
"`Applicative` and adds two new related functions: The *bind*\n"
"operator (`(>>=)`) and function `join`. Here is its definition:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:1082
#, no-wrap
msgid ""
"interface Applicative' m => Monad' m where\n"
"  bind  : m a -> (a -> m b) -> m b\n"
"  join' : m (m a) -> m a\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:1091
#, markdown-text, no-wrap
msgid ""
"Implementers of `Monad` are free to choose to either implement\n"
"`(>>=)` or `join` or both. You will show in an exercise, how\n"
"`join` can be implemented in terms of *bind* and vice versa.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:1099
#, markdown-text
msgid ""
"The big difference between `Monad` and `Applicative` is, that the former "
"allows a computation to depend on the result of an earlier computation. For "
"instance, we could decide based on a string read from standard input whether "
"to delete a file or play a song. The result of the first `IO` action "
"(reading some user input) will affect, which `IO` action to run next.  This "
"is not possible with the *apply* operator:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functor.md:1100
#, no-wrap
msgid "(<*>) : IO (a -> b) -> IO a -> IO b\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:1115
#, markdown-text, no-wrap
msgid ""
"The two `IO` actions have already been decided on when they\n"
"are being passed as arguments to `(<*>)`. The result of the first\n"
"cannot - in the general case - affect which computation to\n"
"run in the second. (Actually, with `IO` this would theoretically be\n"
"possible via side effects: The first action could write some\n"
"command to a file or overwrite some mutable state, and the\n"
"second action could read from that file or state, thus\n"
"deciding on the next thing to do. But this is a speciality\n"
"of `IO`, not of applicative functors in general. If the functor in\n"
"question was `Maybe`, `List`, or `Vector`, no such thing\n"
"would be possible.)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:1121
#, markdown-text
msgid ""
"Let's demonstrate the difference with an example. Assume we'd like to "
"enhance our CSV-reader with the ability to decode a line of tokens to a sum "
"type. For instance, we'd like to decode CRUD requests from the lines of a "
"CSV-file:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:1122
#, no-wrap
msgid ""
"data Crud : (i : Type) -> (a : Type) -> Type where\n"
"  Create : (value : a) -> Crud i a\n"
"  Update : (id : i) -> (value : a) -> Crud i a\n"
"  Read   : (id : i) -> Crud i a\n"
"  Delete : (id : i) -> Crud i a\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:1134
#, markdown-text
msgid ""
"We need a way to on each line decide, which data constructor to choose for "
"our decoding. One way to do this is to put the name of the data constructor "
"(or some other tag of identification) in the first column of the CSV-file:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:1135
#, no-wrap
msgid ""
"hlift : (a -> b) -> HList [a] -> b\n"
"hlift f [x] = f x\n"
"\n"
"hlift2 : (a -> b -> c) -> HList [a,b] -> c\n"
"hlift2 f [x,y] = f x y\n"
"\n"
"decodeCRUD :  CSVField i\n"
"           => CSVField a\n"
"           => (line : Nat)\n"
"           -> (s    : String)\n"
"           -> Either CSVError (Crud i a)\n"
"decodeCRUD l s =\n"
"  let h ::: t = split (',' ==) s\n"
"   in do\n"
"     MkName n <- readField l 1 h\n"
"     case n of\n"
"       \"Create\" => hlift  Create  <$> decodeAt l 2 t\n"
"       \"Update\" => hlift2 Update  <$> decodeAt l 2 t\n"
"       \"Read\"   => hlift  Read    <$> decodeAt l 2 t\n"
"       \"Delete\" => hlift  Delete  <$> decodeAt l 2 t\n"
"       _        => Left (FieldError l 1 n)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:1164
#, markdown-text
msgid ""
"I added two utility function for helping with type inference and to get "
"slightly nicer syntax. The important thing to note is, how we pattern match "
"on the result of the first parsing function to decide on the data "
"constructor and thus the next parsing function to use."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:1166
#, markdown-text
msgid "Here's how this works at the REPL:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functor.md:1167
#, no-wrap
msgid ""
"Tutorial.Functor> decodeCRUD {i = Nat} {a = Email} 1 \"Create,jon@doe.ch\"\n"
"Right (Create (MkEmail \"jon@doe.ch\"))\n"
"Tutorial.Functor> decodeCRUD {i = Nat} {a = Email} 1 "
"\"Update,12,jane@doe.ch\"\n"
"Right (Update 12 (MkEmail \"jane@doe.ch\"))\n"
"Tutorial.Functor> decodeCRUD {i = Nat} {a = Email} 1 \"Delete,jon@doe.ch\"\n"
"Left (FieldError 1 2 \"jon@doe.ch\")\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:1184
#, markdown-text
msgid ""
"To conclude, `Monad`, unlike `Applicative`, allows us to chain computations "
"sequentially, where intermediary results can affect the behavior of later "
"computations.  So, if you have n unrelated effectful computations and want "
"to combine them under a pure, n-ary function, `Applicative` will be "
"sufficient. If, however, you want to decide based on the result of an "
"effectful computation what computation to run next, you need a `Monad`."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:1190
#, markdown-text
msgid ""
"Note, however, that `Monad` has one important drawback compared to "
"`Applicative`: In general, monads don't compose.  For instance, there is no "
"`Monad` instance for `Either e . IO`.  We will later learn about monad "
"transformers, which can be composed with other monads."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Functor.md:1191
#, markdown-text, no-wrap
msgid "Monad Laws"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:1194
#, markdown-text
msgid "Without further ado, here are the laws for `Monad`:"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Functor.md:1198
#, markdown-text
msgid ""
"`ma >>= pure = ma` and `pure v >>= f = f v`.  These are monad's identity "
"laws. Here they are as concrete examples:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:1199
#, no-wrap
msgid ""
"  id1L : Maybe a -> Maybe a\n"
"  id1L ma = ma >>= pure\n"
"\n"
"  id2L : a -> (a -> Maybe b) -> Maybe b\n"
"  id2L v f = pure v >>= f\n"
"\n"
"  id2R : a -> (a -> Maybe b) -> Maybe b\n"
"  id2R v f = f v\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:1212
#, markdown-text, no-wrap
msgid ""
"  These two laws state that `pure` should behave\n"
"  neutrally w.r.t. *bind*.\n"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Functor.md:1218
#, markdown-text
msgid ""
"`(m >>= f) >>= g = m >>= (f >=> g)`.  This is the law of associativity for "
"monad.  You might not have seen the second operator `(>=>)`.  It can be used "
"to sequence effectful computations and has the following type:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Functor.md:1219
#, no-wrap
msgid ""
"  Tutorial.Functor> :t (>=>)\n"
"  Prelude.>=> : Monad m => (a -> m b) -> (b -> m c) -> a -> m c\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:1229
#, markdown-text, no-wrap
msgid ""
"The above are the *official* monad laws. However, we need to\n"
"consider a third one, given that in Idris (and Haskell)\n"
"`Monad` extends `Applicative`: As `(<*>)` can be implemented\n"
"in terms of `(>>=)`, the actual implementation of `(<*>)`\n"
"must behave the same as the implementation in terms of `(>>=)`:\n"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Functor.md:1231
#, markdown-text
msgid "`mf <*> ma = mf >>= (\\fun => map (fun $) ma)`."
msgstr ""

#. type: Bullet: '1. '
#: ../src/Tutorial/Functor.md:1237
#, markdown-text
msgid ""
"`Applicative` extends `Functor`, because every `Applicative` is also a "
"`Functor`. Proof this by implementing `map` in terms of `pure` and `(<*>)`."
msgstr ""

#. type: Bullet: '2. '
#: ../src/Tutorial/Functor.md:1241
#, markdown-text
msgid ""
"`Monad` extends `Applicative`, because every `Monad` is also an "
"`Applicative`. Proof this by implementing `(<*>)` in terms of `(>>=)` and "
"`pure`."
msgstr ""

#. type: Bullet: '3. '
#: ../src/Tutorial/Functor.md:1244
#, markdown-text
msgid ""
"Implement `(>>=)` in terms of `join` and other functions in the `Monad` "
"hierarchy."
msgstr ""

#. type: Bullet: '4. '
#: ../src/Tutorial/Functor.md:1247
#, markdown-text
msgid ""
"Implement `join` in terms of `(>>=)` and other functions in the `Monad` "
"hierarchy."
msgstr ""

#. type: Bullet: '5. '
#: ../src/Tutorial/Functor.md:1250
#, markdown-text
msgid "There is no lawful `Monad` implementation for `Validated e`.  Why?"
msgstr ""

#. type: Bullet: '6. '
#: ../src/Tutorial/Functor.md:1256
#, markdown-text
msgid ""
"In this slightly extended exercise, we are going to simulate CRUD operations "
"on a data store. We will use a mutable reference (imported from `Data.IORef` "
"from the *base* library)  holding a list of `User`s paired with a unique ID "
"of type `Nat` as our user data base:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:1257
#, no-wrap
msgid ""
"   DB : Type\n"
"   DB = IORef (List (Nat,User))\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:1267
#, markdown-text, no-wrap
msgid ""
"   Most operations on a database come with a risk of failure:\n"
"   When we try to update or delete a user, the entry in question\n"
"   might no longer be there. When we add a new user, a user\n"
"   with the given email address might already exist. Here is\n"
"   a custom error type to deal with this:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:1268
#, no-wrap
msgid ""
"   data DBError : Type where\n"
"     UserExists        : Email -> Nat -> DBError\n"
"     UserNotFound      : Nat -> DBError\n"
"     SizeLimitExceeded : DBError\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:1277
#, markdown-text, no-wrap
msgid ""
"   In general, our functions will therefore have a\n"
"   type similar to the following:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:1278
#, no-wrap
msgid "   someDBProg : arg1 -> arg2 -> DB -> IO (Either DBError a)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:1284
#, markdown-text, no-wrap
msgid ""
"   We'd like to abstract over this, by introducing a new wrapper\n"
"   type:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Functor.md:1285
#, no-wrap
msgid ""
"   record Prog a where\n"
"     constructor MkProg\n"
"     runProg : DB -> IO (Either DBError a)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:1294
#, markdown-text, no-wrap
msgid ""
"   We are now ready to write us some utility functions. Make sure\n"
"   to follow the following business rules when implementing the\n"
"   functions below:\n"
msgstr ""

#. type: Bullet: '   * '
#: ../src/Tutorial/Functor.md:1297
#, markdown-text
msgid ""
"Email addresses in the DB must be unique. (Consider implementing `Eq Email` "
"to verify this)."
msgstr ""

#. type: Bullet: '   * '
#: ../src/Tutorial/Functor.md:1299
#, markdown-text
msgid "The size limit of 1000 entries must not be exceeded."
msgstr ""

#. type: Bullet: '   * '
#: ../src/Tutorial/Functor.md:1303
#, markdown-text
msgid ""
"Operations trying to lookup a user by their ID must fail with `UserNotFound` "
"in case no entry was found in the DB."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:1308
#, markdown-text, no-wrap
msgid ""
"   You'll need the following functions from `Data.IORef` when working\n"
"   with mutable references: `newIORef`, `readIORef`, and `writeIORef`.\n"
"   In addition, functions `Data.List.lookup` and `Data.List.find` might\n"
"   be useful to implement some of the functions below.\n"
msgstr ""

#. type: Bullet: '   1. '
#: ../src/Tutorial/Functor.md:1310
#, markdown-text
msgid "Implement interfaces `Functor`, `Applicative`, and `Monad` for `Prog`."
msgstr ""

#. type: Bullet: '   2. '
#: ../src/Tutorial/Functor.md:1312
#, markdown-text
msgid "Implement interface `HasIO` for `Prog`."
msgstr ""

#. type: Bullet: '   3. '
#: ../src/Tutorial/Functor.md:1314
#, markdown-text
msgid "Implement the following utility functions:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:1317
#, markdown-text, no-wrap
msgid ""
"      ```idris\n"
"      throw : DBError -> Prog a\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:1319
#, markdown-text, no-wrap
msgid "      getUsers : Prog (List (Nat,User))\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:1322
#, markdown-text, no-wrap
msgid ""
"      -- check the size limit!\n"
"      putUsers : List (Nat,User) -> Prog ()\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:1326
#, markdown-text, no-wrap
msgid ""
"      -- implement this in terms of `getUsers` and `putUsers`\n"
"      modifyDB : (List (Nat,User) -> List (Nat,User)) -> Prog ()\n"
"      ```\n"
msgstr ""

#. type: Bullet: '   4. '
#: ../src/Tutorial/Functor.md:1330
#, markdown-text
msgid ""
"Implement function `lookupUser`. This should fail with an appropriate error, "
"if a user with the given ID cannot be found."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:1334
#, markdown-text, no-wrap
msgid ""
"      ```idris\n"
"      lookupUser : (id : Nat) -> Prog User\n"
"      ```\n"
msgstr ""

#. type: Bullet: '   5. '
#: ../src/Tutorial/Functor.md:1339
#, markdown-text
msgid ""
"Implement function `deleteUser`. This should fail with an appropriate error, "
"if a user with the given ID cannot be found. Make use of `lookupUser` in "
"your implementation."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:1343
#, markdown-text, no-wrap
msgid ""
"      ```idris\n"
"      deleteUser : (id : Nat) -> Prog ()\n"
"      ```\n"
msgstr ""

#. type: Bullet: '   6. '
#: ../src/Tutorial/Functor.md:1349
#, markdown-text
msgid ""
"Implement function `addUser`. This should fail, if a user with the given "
"`Email` already exists, or if the data banks size limit of 1000 entries is "
"exceeded.  In addition, this should create and return a unique ID for the "
"new user entry."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:1353
#, markdown-text, no-wrap
msgid ""
"      ```idris\n"
"      addUser : (new : User) -> Prog Nat\n"
"      ```\n"
msgstr ""

#. type: Bullet: '   7. '
#: ../src/Tutorial/Functor.md:1358
#, markdown-text
msgid ""
"Implement function `updateUser`. This should fail, if the user in question "
"cannot be found or a user with the updated user's `Email` already exists.  "
"The returned value should be the updated user."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:1362
#, markdown-text, no-wrap
msgid ""
"      ```idris\n"
"      updateUser : (id : Nat) -> (mod : User -> User) -> Prog User\n"
"      ```\n"
msgstr ""

#. type: Bullet: '   8. '
#: ../src/Tutorial/Functor.md:1366
#, markdown-text
msgid ""
"Data type `Prog` is actually too specific. We could just as well abstract "
"over the error type and the `DB` environment:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:1372
#, markdown-text, no-wrap
msgid ""
"      ```idris\n"
"      record Prog' env err a where\n"
"        constructor MkProg'\n"
"        runProg' : env -> IO (Either err a)\n"
"      ```\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:1378
#, markdown-text, no-wrap
msgid ""
"      Verify, that all interface implementations you wrote\n"
"      for `Prog` can be used verbatim to implement the same\n"
"      interfaces for `Prog' env err`. The same goes for\n"
"      `throw` with only a slight adjustment in the function's\n"
"      type.\n"
msgstr ""

#. type: Title ##
#: ../src/Tutorial/Functor.md:1379
#, markdown-text, no-wrap
msgid "Background and further Reading"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:1388
#, markdown-text
msgid ""
"Concepts like *functor* and *monad* have their origin in *category theory*, "
"a branch of mathematics. That is also where their laws come from.  Category "
"theory was found to have applications in programming language theory, "
"especially functional programming.  It is a highly abstract topic, but there "
"is a pretty accessible introduction for programmers, written by [Bartosz "
"Milewski](https://bartoszmilewski.com/2014/10/28/category-theory-for-programmers-the-preface/)."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:1394
#, markdown-text
msgid ""
"The usefulness of applicative functors as a middle ground between functor "
"and monad was discovered several years after monads had already been in use "
"in Haskell. They where introduced in the article [*Applicative Programming "
"with Effects*](https://www.staff.city.ac.uk/~ross/papers/Applicative.html), "
"which is freely available online and a highly recommended read."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Functor.md:1401
#, markdown-text
msgid ""
"Interfaces `Functor`, `Applicative`, and `Monad` abstract over programming "
"patterns that come up when working with type constructors of type `Type -> "
"Type`. Such data types are also referred to as *values in a context*, or "
"*effectful computations*."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Functor.md:1404
#, markdown-text
msgid ""
"`Functor` allows us to *map* over values in a context without affecting the "
"context's underlying structure."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Functor.md:1407
#, markdown-text
msgid ""
"`Applicative` allows us to apply n-ary functions to n effectful computations "
"and to lift pure values into a context."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Functor.md:1411
#, markdown-text
msgid ""
"`Monad` allows us to chain effectful computations, where the intermediary "
"results can affect, which computation to run further down the chain."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Functor.md:1415
#, markdown-text
msgid ""
"Unlike `Monad`, `Functor` and `Applicative` compose: The product and "
"composition of two functors or applicatives are again functors or "
"applicatives, respectively."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Functor.md:1419
#, markdown-text
msgid ""
"Idris provides syntactic sugar for working with some of the interfaces "
"presented here: Idiom brackets for `Applicative`, *do blocks* and the bang "
"operator for `Monad`."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Functor.md:1420 ../src/Tutorial/Intro.md:430
#, markdown-text, no-wrap
msgid "What's next?"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Functor.md:1425
#, markdown-text
msgid ""
"In the [next chapter](Folds.md) we get to learn more about recursion, "
"totality checking, and an interface for collapsing container types: "
"`Foldable`."
msgstr ""

#. type: Title #
#: ../src/Tutorial/IO.md:1
#, markdown-text, no-wrap
msgid "IO: Programming with Side Effects"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:7
#, markdown-text
msgid ""
"So far, all our examples and exercises dealt with pure, total functions.  We "
"didn't read or write content from or to files, nor did we write any messages "
"to the standard output. It is time to change that and learn, how we can "
"write effectful programs in Idris."
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/IO.md:8
#, no-wrap
msgid ""
"module Tutorial.IO\n"
"\n"
"import Data.List1\n"
"import Data.String\n"
"import Data.Vect\n"
"\n"
"import System.File\n"
"\n"
"%default total\n"
msgstr ""

#. type: Title ##
#: ../src/Tutorial/IO.md:20
#, markdown-text, no-wrap
msgid "Pure Side Effects?"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:24
#, markdown-text
msgid ""
"If we once again look at the *hello world* example from the "
"[introduction](Intro.md), it had the following type and implementation:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/IO.md:25
#, no-wrap
msgid ""
"hello : IO ()\n"
"hello = putStrLn \"Hello World!\"\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:32
#, markdown-text
msgid ""
"If you load this module in a REPL session and evaluate `hello`, you'll get "
"the following:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/IO.md:33
#, no-wrap
msgid ""
"Tutorial.IO> hello\n"
"MkIO (prim__putStr \"Hello World!\")\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:41
#, markdown-text
msgid ""
"This might not be what you expected, given that we'd actually wanted the "
"program to just print \"Hello World!\". In order to explain what's going on "
"here, we need to quickly look at how evaluation at the REPL works."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:51
#, markdown-text
msgid ""
"When we evaluate some expression at the REPL, Idris tries to reduce it to a "
"value until it gets stuck somewhere. In the above case, Idris gets stuck at "
"function `prim__putStr`. This is a *foreign function* defined in the "
"*Prelude*, which has to be implemented by each backend in order to be "
"available there. At compile time (and at the REPL), Idris knows nothing "
"about the implementations of foreign functions and therefore can't reduce "
"foreign function calls, unless they are built into the compiler itself. But "
"even then, values of type `IO a` (`a` being a type parameter) are typically "
"not reduced."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:61
#, markdown-text, no-wrap
msgid ""
"It is important to understand that values of type `IO a` *describe*\n"
"a program, which, when being *executed*, will return a value of type `a`,\n"
"after performing arbitrary side effects along the way. For instance,\n"
"`putStrLn` has type `String -> IO ()`. Read this as: \"`putStrLn` is a "
"function,\n"
"which, when given a `String` argument, will return a description of\n"
"an effectful program with an output type of `()`\".\n"
"(`()` is syntactic sugar for type `Unit`, the\n"
"empty tuple defined at the *Prelude*, which has only one value called "
"`MkUnit`,\n"
"for which we can also use `()` in our code.)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:72
#, markdown-text, no-wrap
msgid ""
"Since values of type `IO a` are mere descriptions of effectful "
"computations,\n"
"functions returning such values or taking such values as\n"
"arguments are still *pure* and thus referentially transparent.\n"
"It is, however, not possible to extract a value of type `a` from\n"
"a value of type `IO a`, that is, there is no generic function `IO a -> a`,\n"
"as such a function would inadvertently execute the side\n"
"effects when extracting the result from its argument,\n"
"thus breaking referential transparency.\n"
"(Actually, there *is* such a function called `unsafePerformIO`.\n"
"Do not ever use it in your code unless you know what you are doing.)\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/IO.md:73
#, markdown-text, no-wrap
msgid "Do Blocks"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:83
#, markdown-text, no-wrap
msgid ""
"If you are new to pure functional programming, you might now - rightfully "
"-\n"
"mumble something about how useless it is to\n"
"have descriptions of effectful programs without being able to run them.\n"
"So please, hear me out. While we are not able to run values of type\n"
"`IO a` when writing programs, that is, there is no function of\n"
"type `IO a -> a`, we are able to chain such computations and describe more\n"
"complex programs. Idris provides special syntax for this: *Do blocks*.\n"
"Here's an example:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/IO.md:84
#, no-wrap
msgid ""
"readHello : IO ()\n"
"readHello = do\n"
"  name <- getLine\n"
"  putStrLn $ \"Hello \" ++ name ++ \"!\"\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:93
#, markdown-text
msgid "Before we talk about what's going on here, let's give this a go at the REPL:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/IO.md:94
#, no-wrap
msgid ""
"Tutorial.IO> :exec readHello\n"
"Stefan\n"
"Hello Stefan!\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:104
#, markdown-text
msgid ""
"This is an interactive program, which will read a line from standard input "
"(`getLine`), assign the result to variable `name`, and then use `name` to "
"create a friendly greeting and write it to standard output."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:114
#, markdown-text, no-wrap
msgid ""
"Note the `do` keyword at the beginning of the implementation of "
"`readHello`:\n"
"It starts a *do block*, where we can chain `IO` computations and bind\n"
"intermediary results to variables using arrows pointing\n"
"to the left (`<-`), which can then be used in later\n"
"`IO` actions. This concept is powerful enough to let us encapsulate "
"arbitrary\n"
"programs with side effects in a single value of type `IO`. Such a\n"
"description can then be returned by function `main`, the main entry point\n"
"to an Idris program, which is being executed when we run a compiled\n"
"Idris binary.\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/IO.md:115
#, markdown-text, no-wrap
msgid "The Difference between Program Description and Execution"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:120
#, markdown-text
msgid ""
"In order to better understand the difference between *describing* an "
"effectful computation and *executing* or *running* it, here is a small "
"program:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/IO.md:121
#, no-wrap
msgid ""
"launchMissiles : IO ()\n"
"launchMissiles = putStrLn \"Boom! You're dead.\"\n"
"\n"
"friendlyReadHello : IO ()\n"
"friendlyReadHello = do\n"
"  _ <- putStrLn \"Please enter your name.\"\n"
"  readHello\n"
"\n"
"actions : Vect 3 (IO ())\n"
"actions = [launchMissiles, friendlyReadHello, friendlyReadHello]\n"
"\n"
"runActions : Vect (S n) (IO ()) -> IO ()\n"
"runActions (_ :: xs) = go xs\n"
"  where go : Vect k (IO ()) -> IO ()\n"
"        go []        = pure ()\n"
"        go (y :: ys) = do\n"
"          _ <- y\n"
"          go ys\n"
"\n"
"readHellos : IO ()\n"
"readHellos = runActions actions\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:153
#, markdown-text, no-wrap
msgid ""
"Before I explain what the code above does, please note function\n"
"`pure` used in the implementation of `runActions`. It is\n"
"a constrained function, about which we will learn in the next\n"
"chapter. Specialized to `IO`, it has generic type `a -> IO a`:\n"
"It allows us to wrap a value in an `IO` action. The resulting\n"
"`IO` program will just return the wrapped value without performing\n"
"any side effects. We can now look at the big picture of what's\n"
"going on in `readHellos`.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:160
#, markdown-text
msgid ""
"First, we define a friendlier version of `readHello`: When executed, this "
"will ask about our name explicitly. Since we will not use the result of "
"`putStrLn` any further, we can use an underscore as a catch-all pattern "
"here. Afterwards, `readHello` is invoked. We also define `launchMissiles`, "
"which, when being executed, will lead to the destruction of planet earth."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:169
#, markdown-text
msgid ""
"Now, `runActions` is the function we use to demonstrate that *describing* an "
"`IO` action is not the same as *running* it. It will drop the first action "
"from the non-empty vector it takes as its argument and return a new `IO` "
"action, which describes the execution of the remaining `IO` actions in "
"sequence. If this behaves as expected, the first `IO` action passed to "
"`runActions` should be silently dropped together with all its potential side "
"effects."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:174
#, markdown-text
msgid ""
"When we execute `readHellos` at the REPL, we will be asked for our name "
"twice, although `actions` also contains `launchMissiles` at the "
"beginning. Luckily, although we described how to destroy the planet, the "
"action was not executed, and we are (probably) still here."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:176
#, markdown-text
msgid "From this example we learn several things:"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/IO.md:180
#, markdown-text
msgid ""
"Values of type `IO a` are *pure descriptions* of programs, which, when being "
"*executed*, perform arbitrary side effects before returning a value of type "
"`a`."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/IO.md:184
#, markdown-text
msgid ""
"Values of type `IO a` can be safely returned from functions and passed "
"around as arguments or in data structures, without the risk of them being "
"executed."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/IO.md:187
#, markdown-text
msgid ""
"Values of type `IO a` can be safely combined in *do blocks* to *describe* "
"new `IO` actions."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/IO.md:191
#, markdown-text
msgid ""
"An `IO` action will only ever get executed when it's passed to `:exec` at "
"the REPL, or when it is the `main` function of a compiled Idris program that "
"is being executed."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/IO.md:196
#, markdown-text
msgid ""
"It is not possible to ever break out of the `IO` context: There is no "
"function of type `IO a -> a`, as such a function would need to execute its "
"argument in order to extract the final result, and this would break "
"referential transparency."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/IO.md:197
#, markdown-text, no-wrap
msgid "Combining Pure Code with `IO` Actions"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:202
#, markdown-text
msgid ""
"The title of this subsection is somewhat misleading. `IO` actions *are* pure "
"values, but what is typically meant here, is that we combine non-`IO` "
"functions with effectful computations."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:208
#, markdown-text
msgid ""
"As a demonstration, in this section we are going to write a small program "
"for evaluating arithmetic expressions. We are going to keep things simple "
"and allow only expressions with a single operator and two arguments, both of "
"which must be integers, for instance `12 + 13`."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:216
#, markdown-text
msgid ""
"We are going to use function `split` from `Data.String` in *base* to "
"tokenize arithmetic expressions. We are then trying to parse the two integer "
"values and the operator. These operations might fail, since user input can "
"be invalid, so we also need an error type. We could actually just use "
"`String`, but I consider it to be good practice to use custom sum types for "
"erroneous conditions."
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/IO.md:217
#, no-wrap
msgid ""
"data Error : Type where\n"
"  NotAnInteger    : (value : String) -> Error\n"
"  UnknownOperator : (value : String) -> Error\n"
"  ParseError      : (input : String) -> Error\n"
"\n"
"dispError : Error -> String\n"
"dispError (NotAnInteger v)    = \"Not an integer: \" ++ v ++ \".\"\n"
"dispError (UnknownOperator v) = \"Unknown operator: \" ++ v ++ \".\"\n"
"dispError (ParseError v)      = \"Invalid expression: \" ++ v ++ \".\"\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:231
#, markdown-text
msgid ""
"In order to parse integer literals, we use function `parseInteger` from "
"`Data.String`:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/IO.md:232
#, no-wrap
msgid ""
"readInteger : String -> Either Error Integer\n"
"readInteger s = maybe (Left $ NotAnInteger s) Right $ parseInteger s\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:239
#, markdown-text
msgid ""
"Likewise, we declare and implement a function for parsing arithmetic "
"operators:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/IO.md:240
#, no-wrap
msgid ""
"readOperator : String -> Either Error (Integer -> Integer -> Integer)\n"
"readOperator \"+\" = Right (+)\n"
"readOperator \"*\" = Right (*)\n"
"readOperator s   = Left (UnknownOperator s)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:254
#, markdown-text
msgid ""
"We are now ready to parse and evaluate simple arithmetic expressions. This "
"consists of several steps (splitting the input string, parsing each "
"literal), each of which can fail.  Later, when we learn about monads, we "
"will see that do blocks can be used in such occasions just as well. However, "
"in this case we can use an alternative syntactic convenience: Pattern "
"matching in let bindings. Here is the code:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/IO.md:255
#, no-wrap
msgid ""
"eval : String -> Either Error Integer\n"
"eval s =\n"
"  let [x,y,z]  := forget $ split isSpace s | _ => Left (ParseError s)\n"
"      Right v1 := readInteger x  | Left e => Left e\n"
"      Right op := readOperator y | Left e => Left e\n"
"      Right v2 := readInteger z  | Left e => Left e\n"
"   in Right $ op v1 v2\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:280
#, markdown-text
msgid ""
"Let's break this down a bit. On the first line, we split the input string at "
"all whitespace occurrences. Since `split` returns a `List1` (a type for "
"non-empty lists exported from `Data.List1` in *base*) but pattern matching "
"on `List` is more convenient, we convert the result using "
"`Data.List1.forget`. Note, how we use a pattern match on the left hand side "
"of the assignment operator `:=`.  This is a partial pattern match (*partial* "
"meaning, that it doesn't cover all possible cases), therefore we have to "
"deal with the other possibilities as well, which is done after the vertical "
"line. This can be read as follows: \"If the pattern match on the left hand "
"side is successful, and we get a list of exactly three tokens, continue with "
"the `let` expression, otherwise return a `ParseError` in a `Left` "
"immediately\"."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:286
#, markdown-text
msgid ""
"The other three lines behave exactly the same: Each has a partial pattern "
"match on the left hand side with instructions what to return in case of "
"invalid input after the vertical bar. We will later see, that this syntax is "
"also available in *do blocks*."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:294
#, markdown-text
msgid ""
"Note, how all of the functionality implemented so far is *pure*, that is, it "
"does not describe computations with side effects. (One could argue that "
"already the possibility of failure is an observable *effect*, but even then, "
"the code above is still referentially transparent, can be easily tested at "
"the REPL, and evaluated at compile time, which is the important thing here.)"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:298
#, markdown-text
msgid ""
"Finally, we can wrap this functionality in an `IO` action, which reads a "
"string from standard input and tries to evaluate the arithmetic expression:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/IO.md:299
#, no-wrap
msgid ""
"exprProg : IO ()\n"
"exprProg = do\n"
"  s <- getLine\n"
"  case eval s of\n"
"    Left err  => do\n"
"      putStrLn \"An error occured:\"\n"
"      putStrLn (dispError err)\n"
"    Right res => putStrLn (s ++ \" = \" ++ show res)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:316
#, markdown-text
msgid ""
"Note, how in `exprProg` we were forced to deal with the possibility of "
"failure and handle both constructors of `Either` differently in order to "
"print a result.  Note also, that *do blocks* are ordinary expressions, and "
"we can, for instance, start a new *do block* on the right hand side of a "
"case expression."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:329
#, markdown-text
msgid ""
"In these exercises, you are going to implement some small command-line "
"applications. Some of these will potentially run forever, as they will only "
"stop when the user enters a keyword for quitting the application. Such "
"programs are no longer provably total. If you added the `%default total` "
"pragma at the top of your source file, you'll need to annotate these "
"functions with `covering`, meaning that you covered all cases in all pattern "
"matches but your program might still loop due to unrestricted recursion."
msgstr ""

#. type: Bullet: '1. '
#: ../src/Tutorial/IO.md:333
#, markdown-text
msgid ""
"Implement function `rep`, which will read a line of input from the terminal, "
"evaluate it using the given function, and print the result to standard "
"output:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/IO.md:334
#, no-wrap
msgid "   rep : (String -> String) -> IO ()\n"
msgstr ""

#. type: Bullet: '2. '
#: ../src/Tutorial/IO.md:341
#, markdown-text
msgid ""
"Implement function `repl`, which behaves just like `rep` but will repeat "
"itself forever (or until being forcefully terminated):"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/IO.md:342
#, no-wrap
msgid ""
"   covering\n"
"   repl : (String -> String) -> IO ()\n"
msgstr ""

#. type: Bullet: '3. '
#: ../src/Tutorial/IO.md:351
#, markdown-text
msgid ""
"Implement function `replTill`, which behaves just like `repl` but will only "
"continue looping if the given function returns a `Right`. If it returns a "
"`Left`, `replTill` should print the final message wrapped in the `Left` and "
"then stop."
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/IO.md:352
#, no-wrap
msgid ""
"   covering\n"
"   replTill : (String -> Either String String) -> IO ()\n"
msgstr ""

#. type: Bullet: '4. '
#: ../src/Tutorial/IO.md:364
#, markdown-text
msgid ""
"Write a program, which reads arithmetic expressions from standard input, "
"evaluates them using `eval`, and prints the result to standard output. The "
"program should loop until users stops it by entering \"done\", in which case "
"the program should terminate with a friendly greeting.  Use `replTill` in "
"your implementation."
msgstr ""

#. type: Bullet: '5. '
#: ../src/Tutorial/IO.md:373
#, markdown-text
msgid ""
"Implement function `replWith`, which behaves just like `repl` but uses some "
"internal state to accumulate values.  At each iteration (including the very "
"first one!), the current state should be printed to standard output using "
"function `dispState`, and the next state should be computed using function "
"`next`.  The loop should terminate in case of a `Left` and print a final "
"message using `dispResult`:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/IO.md:374
#, no-wrap
msgid ""
"   covering\n"
"   replWith :  (state      : s)\n"
"            -> (next       : s -> String -> Either res s)\n"
"            -> (dispState  : s -> String)\n"
"            -> (dispResult : res -> s -> String)\n"
"            -> IO ()\n"
msgstr ""

#. type: Bullet: '6. '
#: ../src/Tutorial/IO.md:388
#, markdown-text
msgid ""
"Use `replWith` from Exercise 5 to write a program for reading natural "
"numbers from standard input and printing the accumulated sum of these "
"numbers.  The program should terminate in case of invalid input and if a "
"user enters \"done\"."
msgstr ""

#. type: Title ##
#: ../src/Tutorial/IO.md:389
#, markdown-text, no-wrap
msgid "Do Blocks, Desugared"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:402
#, markdown-text
msgid ""
"Here's an important piece of information: There is nothing special about *do "
"blocks*. They are just syntactic sugar, which is converted to a sequence of "
"operator applications.  With [syntactic "
"sugar](https://en.wikipedia.org/wiki/Syntactic_sugar), we mean syntax in a "
"programming language that makes it easier to express certain things in that "
"language without making the language itself any more powerful or "
"expressive.  Here, it means you could write all the `IO` programs without "
"using `do` notation, but the code you'll write will sometimes be harder to "
"read, so *do blocks* provide nicer syntax for these occasions."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:404
#, markdown-text
msgid "Consider the following example program:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/IO.md:405
#, no-wrap
msgid ""
"sugared1 : IO ()\n"
"sugared1 = do\n"
"  str1 <- getLine\n"
"  str2 <- getLine\n"
"  str3 <- getLine\n"
"  putStrLn (str1 ++ str2 ++ str3)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:416
#, markdown-text
msgid ""
"The compiler will convert this to the following program *before "
"disambiguating function names and type checking*:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/IO.md:417
#, no-wrap
msgid ""
"desugared1 : IO ()\n"
"desugared1 =\n"
"  getLine >>= (\\str1 =>\n"
"    getLine >>= (\\str2 =>\n"
"      getLine >>= (\\str3 =>\n"
"        putStrLn (str1 ++ str2 ++ str3)\n"
"      )\n"
"    )\n"
"  )\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:432
#, markdown-text, no-wrap
msgid ""
"There is a new operator (`(>>=)`) called *bind* in the\n"
"implementation of `desugared1`. If you look at its type\n"
"at the REPL, you'll see the following:\n"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/IO.md:433
#, no-wrap
msgid ""
"Main> :t (>>=)\n"
"Prelude.>>= : Monad m => m a -> (a -> m b) -> m b\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:441
#, markdown-text
msgid ""
"This is a constrained function requiring an interface called `Monad`.  We "
"will talk about `Monad` and some of its friends in the next "
"chapter. Specialized to `IO`, *bind* has the following type:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/IO.md:442
#, no-wrap
msgid ""
"Main> :t (>>=) {m = IO}\n"
">>= : IO a -> (a -> IO b) -> IO b\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:451
#, markdown-text
msgid ""
"This describes a sequencing of `IO` actions. Upon execution, the first `IO` "
"action is being run and its result is being passed as an argument to the "
"function generating the second `IO` action, which is then also being "
"executed."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:466
#, markdown-text
msgid ""
"You might remember, that you already implemented something similar in an "
"earlier exercise: In [Algebraic Data Types](DataTypes.md), you implemented "
"*bind* for `Maybe` and `Either e`. We will learn in the next chapter, that "
"`Maybe` and `Either e` too come with an implementation of `Monad`. For now, "
"suffice to say that `Monad` allows us to run computations with some kind of "
"effect in sequence by passing the *result* of the first computation to the "
"function returning the second computation. In `desugared1` you can see, how "
"we first perform an `IO` action and use its result to compute the next `IO` "
"action and so on. The code is somewhat hard to read, since we use several "
"layers of nested anonymous function, that's why in such cases, *do blocks* "
"are a nice alternative to express the same functionality."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:471
#, markdown-text
msgid ""
"Since *do block* are always desugared to sequences of applied *bind* "
"operators, we can use them to chain any monadic computation. For instance, "
"we can rewrite function `eval` by using a *do block* like so:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/IO.md:472
#, no-wrap
msgid ""
"evalDo : String -> Either Error Integer\n"
"evalDo s = case forget $ split isSpace s of\n"
"  [x,y,z] => do\n"
"    v1 <- readInteger x\n"
"    op <- readOperator y\n"
"    v2 <- readInteger z\n"
"    Right $ op v1 v2\n"
"  _       => Left (ParseError s)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:488
#, markdown-text
msgid ""
"Don't worry, if this doesn't make too much sense yet. We will see many more "
"examples, and you'll get the hang of this soon enough. The important thing "
"to remember is how *do blocks* are always converted to sequences of *bind* "
"operators as shown in `desugared1`."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/IO.md:489
#, markdown-text, no-wrap
msgid "Binding Unit"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:492
#, markdown-text
msgid "Remember our implementation of `friendlyReadHello`? Here it is again:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/IO.md:493
#, no-wrap
msgid ""
"friendlyReadHello' : IO ()\n"
"friendlyReadHello' = do\n"
"  _ <- putStrLn \"Please enter your name.\"\n"
"  readHello\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:505
#, markdown-text
msgid ""
"The underscore in there is a bit ugly and unnecessary. In fact, a common use "
"case is to just chain effectful computations with result type `Unit` (`()`), "
"merely for the side effects they perform. For instance, we could repeat "
"`friendlyReadHello` three times, like so:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/IO.md:506
#, no-wrap
msgid ""
"friendly3 : IO ()\n"
"friendly3 = do\n"
"  _ <- friendlyReadHello\n"
"  _ <- friendlyReadHello\n"
"  friendlyReadHello\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:516
#, markdown-text
msgid ""
"This is such a common thing to do, that Idris allows us to drop the bound "
"underscores altogether:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/IO.md:517
#, no-wrap
msgid ""
"friendly4 : IO ()\n"
"friendly4 = do\n"
"  friendlyReadHello\n"
"  friendlyReadHello\n"
"  friendlyReadHello\n"
"  friendlyReadHello\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:527
#, markdown-text
msgid "Note, however, that the above gets desugared slightly differently:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/IO.md:528
#, no-wrap
msgid ""
"friendly4Desugared : IO ()\n"
"friendly4Desugared =\n"
"  friendlyReadHello >>\n"
"  friendlyReadHello >>\n"
"  friendlyReadHello >>\n"
"  friendlyReadHello\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:538
#, markdown-text, no-wrap
msgid "Operator `(>>)` has the following type:\n"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/IO.md:539
#, no-wrap
msgid ""
"Main> :t (>>)\n"
"Prelude.>> : Monad m => m () -> Lazy (m b) -> m b\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:550
#, markdown-text
msgid ""
"Note the `Lazy` keyword in the type signature. This means, that the wrapped "
"argument will be *lazily evaluated*. This makes sense in many occasions. For "
"instance, if the `Monad` in question is `Maybe` the result will be `Nothing` "
"if the first argument is `Nothing`, in which case there is no need to even "
"evaluate the second argument."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/IO.md:551
#, markdown-text, no-wrap
msgid "Do, Overloaded"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:562
#, markdown-text, no-wrap
msgid ""
"Because Idris supports function and operator overloading, we\n"
"can write custom *bind* operators, which allows us to\n"
"use *do notation* for types without an implementation\n"
"of `Monad`. For instance, here is a custom implementation of\n"
"`(>>=)` for sequencing computations returning vectors.\n"
"Every value in the first vector (of length `m`)\n"
"will be converted to a vector of length `n`, and\n"
"the results will be concatenated leading to\n"
"a vector of length `m * n`:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/IO.md:563
#, no-wrap
msgid ""
"flatten : Vect m (Vect n a) -> Vect (m * n) a\n"
"flatten []        = []\n"
"flatten (x :: xs) = x ++ flatten xs\n"
"\n"
"(>>=) : Vect m a -> (a -> Vect n b) -> Vect (m * n) b\n"
"as >>= f = flatten (map f as)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:580
#, markdown-text, no-wrap
msgid ""
"It is not possible to write an implementation of `Monad`,\n"
"which encapsulates this behavior, as the types wouldn't\n"
"match: Monadic *bind* specialized to `Vect` has\n"
"type `Vect k a -> (a -> Vect k b) -> Vect k b`. As you\n"
"see, the sizes of all three occurrences of `Vect`\n"
"have to be the same, which is not what we expressed\n"
"in our custom version of *bind*. Here is an example to\n"
"see this in action:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/IO.md:581
#, no-wrap
msgid ""
"modString : String -> Vect 4 String\n"
"modString s = [s, reverse s, toUpper s, toLower s]\n"
"\n"
"testDo : Vect 24 String\n"
"testDo = IO.do\n"
"  s1 <- [\"Hello\", \"World\"]\n"
"  s2 <- [1, 2, 3]\n"
"  modString (s1 ++ show s2)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:601
#, markdown-text
msgid ""
"Try to figure out how `testDo` works by desugaring it manually and then "
"comparing its result with what you expected at the REPL. Note, how we helped "
"Idris disambiguate, which version of the *bind* operator to use by prefixing "
"the `do` keyword with part of the operator's namespace.  In this case, this "
"wasn't strictly necessary, although `Vect k` does have an implementation of "
"`Monad`, but it is still good to know that it is possible to help the "
"compiler with disambiguating do blocks."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:605
#, markdown-text, no-wrap
msgid ""
"Of course, we can (and should!) overload `(>>)` in the\n"
"same manner as `(>>=)`, if we want to overload the\n"
"behavior of *do blocks*.\n"
msgstr ""

#. type: Title ####
#: ../src/Tutorial/IO.md:606
#, markdown-text, no-wrap
msgid "Modules and Namespaces"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:614
#, markdown-text
msgid ""
"Every data type, function, or operator can be unambiguously identified by "
"prefixing it with its *namespace*. A function's namespace typically is the "
"same as the module where it was defined.  For instance, the fully qualified "
"name of function `eval` would be `Tutorial.IO.eval`. Function and operator "
"names must be unique in their namespace."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:620
#, markdown-text
msgid ""
"As we already learned, Idris can often disambiguate between functions with "
"the same name but defined in different namespaces based on the types "
"involved. If this is not possible, we can help the compiler by *prefixing* "
"the function or operator name with a *suffix* of the full namespace. Let's "
"demonstrate this at the REPL:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/IO.md:621
#, no-wrap
msgid ""
"Tutorial.IO> :t (>>=)\n"
"Prelude.>>= : Monad m => m a -> (a -> m b) -> m b\n"
"Tutorial.IO.>>= : Vect m a -> (a -> Vect n b) -> Vect (m * n) b\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:633
#, markdown-text, no-wrap
msgid ""
"As you can see, if we load this module in a REPL session and\n"
"inspect the type of `(>>=)`, we get two results as two\n"
"operators with this name are in scope. If we only want\n"
"the REPL to print the type of our custom *bind* operator,\n"
"is is sufficient to prefix it with `IO`, although we could\n"
"also prefix it with its full namespace:\n"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/IO.md:634
#, no-wrap
msgid ""
"Tutorial.IO> :t IO.(>>=)\n"
"Tutorial.IO.>>= : Vect m a -> (a -> Vect n b) -> Vect (m * n) b\n"
"Tutorial.IO> :t Tutorial.IO.(>>=)\n"
"Tutorial.IO.>>= : Vect m a -> (a -> Vect n b) -> Vect (m * n) b\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:649
#, markdown-text
msgid ""
"Since function names must be unique in their namespace and we still may want "
"to define two overloaded versions of a function in an Idris module, Idris "
"makes it possible to add additional namespaces to modules. For instance, in "
"order to define another function called `eval`, we need to add it to its own "
"namespace (note, that all definitions in a namespace must be indented by the "
"same amount of white space):"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/IO.md:650
#, no-wrap
msgid ""
"namespace Foo\n"
"  export\n"
"  eval : Nat -> Nat -> Nat\n"
"  eval = (*)\n"
"\n"
"-- prefixing `eval` with its namespace is not strictly necessary here\n"
"testFooEval : Nat\n"
"testFooEval = Foo.eval 12 100\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:665
#, markdown-text
msgid ""
"Now, here is an important thing: For functions and data types to be "
"accessible from outside their namespace or module, they need to be "
"*exported* by annotating them with the `export` or `public export` keywords."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:674
#, markdown-text
msgid ""
"The difference between `export` and `public export` is the following: A "
"function annotated with `export` exports its type and can be called from "
"other namespaces. A data type annotated with `export` exports its type "
"constructor but not its data constructors.  A function annotated with "
"`public export` also exports its implementation. This is necessary to use "
"the function in compile-time computations. A data type annotated with "
"`public export` exports its data constructors as well."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:680
#, markdown-text
msgid ""
"In general, consider annotating data types with `public export`, since "
"otherwise you will not be able to create values of these types or "
"deconstruct them in pattern matches. Likewise, unless you plan to use your "
"functions in compile-time computations, annotate them with `export`."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/IO.md:681
#, markdown-text, no-wrap
msgid "Bind, with a Bang"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:688
#, markdown-text
msgid ""
"Sometimes, even *do blocks* are too noisy to express a combination of "
"effectful computations. In this case, we can prefix the effectful parts with "
"an exclamation mark (wrapping them in parentheses if they contain additional "
"white space), while leaving pure expressions unmodified:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/IO.md:689
#, no-wrap
msgid ""
"getHello : IO ()\n"
"getHello = putStrLn $ \"Hello \" ++ !getLine ++ \"!\"\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:695
#, markdown-text
msgid "The above gets desugared to the following *do block*:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/IO.md:696
#, no-wrap
msgid ""
"getHello' : IO ()\n"
"getHello' = do\n"
"  s <- getLine\n"
"  putStrLn $ \"Hello \" ++ s ++ \"!\"\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:704
#, markdown-text
msgid "Here is another example:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/IO.md:705
#, no-wrap
msgid ""
"bangExpr : String -> String -> String -> Maybe Integer\n"
"bangExpr s1 s2 s3 =\n"
"  Just $ !(parseInteger s1) + !(parseInteger s2) * !(parseInteger s3)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:712
#, markdown-text
msgid "And here is the desugared *do block*:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/IO.md:713
#, no-wrap
msgid ""
"bangExpr' : String -> String -> String -> Maybe Integer\n"
"bangExpr' s1 s2 s3 = do\n"
"  x1 <- parseInteger s1\n"
"  x2 <- parseInteger s2\n"
"  x3 <- parseInteger s3\n"
"  Just $ x1 + x2 * x3\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:727
#, markdown-text
msgid ""
"Please remember the following: Syntactic sugar has been introduced to make "
"code more readable or more convenient to write. If it is abused just to show "
"how clever you are, you make things harder for other people (including your "
"future self!)  reading and trying to understand your code."
msgstr ""

#. type: Bullet: '1. '
#: ../src/Tutorial/IO.md:733
#, markdown-text
msgid ""
"Reimplement the following *do blocks*, once by using *bang notation*, and "
"once by writing them in their desugared form with nested *bind*s:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/IO.md:734
#, no-wrap
msgid ""
"   ex1a : IO String\n"
"   ex1a = do\n"
"     s1 <- getLine\n"
"     s2 <- getLine\n"
"     s3 <- getLine\n"
"     pure $ s1 ++ reverse s2 ++ s3\n"
"\n"
"   ex1b : Maybe Integer\n"
"   ex1b = do\n"
"     n1 <- parseInteger \"12\"\n"
"     n2 <- parseInteger \"300\"\n"
"     Just $ n1 + n2 * 100\n"
msgstr ""

#. type: Bullet: '2. '
#: ../src/Tutorial/IO.md:752
#, markdown-text
msgid ""
"Below is the definition of an indexed family of types, the index of which "
"keeps track of whether the value in question is possibly empty or provably "
"non-empty:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:766
#, markdown-text, no-wrap
msgid ""
"   Please note, that the `Nil` case *must* have the `nonEmpty`\n"
"   tag set to `False`, while with the *cons* case, this is\n"
"   optional. So, a `List01 False a` can be empty or non-empty,\n"
"   and we'll only find out, which is the case, by pattern\n"
"   matching on it. A `List01 True a` on the other hand *must*\n"
"   be a *cons*, as for the `Nil` case the `nonEmpty` tag is\n"
"   always set to `False`.\n"
msgstr ""

#. type: Bullet: '   1. '
#: ../src/Tutorial/IO.md:768
#, markdown-text
msgid "Declare and implement function `head` for non-empty lists:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:772
#, markdown-text, no-wrap
msgid ""
"      ```idris\n"
"      head : List01 True a -> a\n"
"      ```\n"
msgstr ""

#. type: Bullet: '   2. '
#: ../src/Tutorial/IO.md:776
#, markdown-text
msgid ""
"Declare and implement function `weaken` for converting any `List01 ne a` to "
"a `List01 False a` of the same length and order of values."
msgstr ""

#. type: Bullet: '   3. '
#: ../src/Tutorial/IO.md:779
#, markdown-text
msgid ""
"Declare and implement function `tail` for extracting the possibly empty tail "
"from a non-empty list."
msgstr ""

#. type: Bullet: '   4. '
#: ../src/Tutorial/IO.md:784
#, markdown-text
msgid ""
"Implement function `(++)` for concatenating two values of type "
"`List01`. Note, how we use a type-level computation to make sure the result "
"is non-empty if and only if at least one of the two arguments is non-empty:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:788
#, markdown-text, no-wrap
msgid ""
"      ```idris\n"
"      (++) : List01 b1 a -> List01 b2 a -> List01 (b1 || b2) a\n"
"      ```\n"
msgstr ""

#. type: Bullet: '   5. '
#: ../src/Tutorial/IO.md:794
#, markdown-text
msgid ""
"Implement utility function `concat'` and use it in the implementation of "
"`concat`. Note, that in `concat` the two boolean tags are passed as "
"unrestricted implicits, since you will need to pattern match on these to "
"determine whether the result is provably non-empty or not:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:797
#, markdown-text, no-wrap
msgid ""
"      ```idris\n"
"      concat' : List01 ne1 (List01 ne2 a) -> List01 False a\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:802
#, markdown-text, no-wrap
msgid ""
"      concat :  {ne1, ne2 : _}\n"
"             -> List01 ne1 (List01 ne2 a)\n"
"             -> List01 (ne1 && ne2) a\n"
"      ```\n"
msgstr ""

#. type: Bullet: '   6. '
#: ../src/Tutorial/IO.md:804
#, markdown-text
msgid "Implement `map01`:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:808
#, markdown-text, no-wrap
msgid ""
"      ```idris\n"
"      map01 : (a -> b) -> List01 ne a -> List01 ne b\n"
"      ```\n"
msgstr ""

#. type: Bullet: '   7. '
#: ../src/Tutorial/IO.md:811
#, markdown-text
msgid ""
"Implement a custom *bind* operator in namespace `List01` for sequencing "
"computations returning `List01`s."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:814
#, markdown-text, no-wrap
msgid ""
"      Hint: Use `map01` and `concat` in your implementation and\n"
"      make sure to use unrestricted implicits where necessary.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:817
#, markdown-text, no-wrap
msgid ""
"      You can use the following examples to test your\n"
"      custom *bind* operator:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:823
#, markdown-text, no-wrap
msgid ""
"      ```idris\n"
"      -- this and lf are necessary to make sure, which tag to use\n"
"      -- when using list literals\n"
"      lt : List01 True a -> List01 True a\n"
"      lt = id\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:826
#, markdown-text, no-wrap
msgid ""
"      lf : List01 False a -> List01 False a\n"
"      lf = id\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:833
#, markdown-text, no-wrap
msgid ""
"      test : List01 True Integer\n"
"      test = List01.do\n"
"        x  <- lt [1,2,3]\n"
"        y  <- lt [4,5,6,7]\n"
"        op <- lt [(*), (+), (-)]\n"
"        [op x y]\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:841
#, markdown-text, no-wrap
msgid ""
"      test2 : List01 False Integer\n"
"      test2 = List01.do\n"
"        x  <- lt [1,2,3]\n"
"        y  <- Nil {a = Integer}\n"
"        op <- lt [(*), (+), (-)]\n"
"        lt [op x y]\n"
"      ```\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:857
#, markdown-text
msgid ""
"Some notes on Exercise 2: Here, we combined the capabilities of `List` and "
"`Data.List1` in a single indexed type family.  This allowed us to treat list "
"concatenation correctly: If at least one of the arguments is provably "
"non-empty, the result is also non-empty. To tackle this correctly with "
"`List` and `List1`, a total of four concatenation functions would have to be "
"written. So, while it is often possible to define distinct data types "
"instead of indexed families, the latter allow us to perform type-level "
"computations to be more precise about the pre- and postconditions of the "
"functions we write, at the cost of more-complex type signatures.  In "
"addition, sometimes it's not possible to derive the values of the indices "
"from pattern matching on the data values alone, so they have to be passed as "
"unerased (possibly implicit) arguments."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:864
#, markdown-text
msgid ""
"Please remember, that *do blocks* are first desugared, before type-checking, "
"disambiguating which *bind* operator to use, and filling in implicit "
"arguments. It is therefore perfectly fine to define *bind* operators with "
"arbitrary constraints or implicit arguments as was shown above. Idris will "
"handle all the details, *after* desugaring the *do blocks*."
msgstr ""

#. type: Title ##
#: ../src/Tutorial/IO.md:865
#, markdown-text, no-wrap
msgid "Working with Files"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:872
#, markdown-text
msgid ""
"Module `System.File` from the *base* library exports utilities necessary to "
"work with file handles and read and write from and to files. When you have a "
"file path (for instance \"/home/hock/idris/tutorial/tutorial.ipkg\"), the "
"first thing we will typically do is to try and create a file handle (of type "
"`System.File.File` by calling `fileOpen`)."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:874
#, markdown-text
msgid "Here is a program for counting all empty lines in a Unix/Linux-file:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/IO.md:875
#, no-wrap
msgid ""
"covering\n"
"countEmpty : (path : String) -> IO (Either FileError Nat)\n"
"countEmpty path = openFile path Read >>= either (pure . Left) (go 0)\n"
"  where covering go : Nat -> File -> IO (Either FileError Nat)\n"
"        go k file = do\n"
"          False <- fEOF file | True => closeFile file $> Right k\n"
"          Right \"\\n\" <- fGetLine file\n"
"            | Right _  => go k file\n"
"            | Left err => closeFile file $> Left err\n"
"          go (k + 1) file\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:894
#, markdown-text, no-wrap
msgid ""
"In the example above, I invoked `(>>=)` without starting a *do block*.\n"
"Make sure you understand what's going on here. Reading concise functional\n"
"code is important in order to understand other people's code.\n"
"Have a look at function `either` at the REPL, try figuring out what\n"
"`(pure . Left)` does, and note how we use a curried version of `go`\n"
"as the second argument to `either`.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:905
#, markdown-text
msgid ""
"Function `go` calls for some additional explanations. First, note how we "
"used the same syntax for pattern matching intermediary results as we also "
"saw for `let` bindings. As you can see, we can use several vertical bars to "
"handle more than one additional pattern. In order to read a single line from "
"a file, we use function `fGetLine`. As with most operations working with the "
"file system, this function might fail with a `FileError`, which we have to "
"handle correctly. Note also, that `fGetLine` will return the line including "
"its trailing newline character `'\\n'`, so in order to check for empty "
"lines, we have to match against `\"\\n\"` instead of the empty string "
"`\"\"`."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:910
#, markdown-text
msgid ""
"Finally, `go` is not provably total and rightfully so.  Files like "
"`/dev/urandom` or `/dev/zero` provide infinite streams of data, so "
"`countEmpty` will never terminate when invoked with such a file path."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/IO.md:911
#, markdown-text, no-wrap
msgid "Safe Resource Handling"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:919
#, markdown-text
msgid ""
"Note, how we had to manually open and close the file handle in "
"`countEmpty`. This is error-prone and tedious. Resource handling is a big "
"topic, and we definitely won't be going into the details here, but there is "
"a convenient function exported from `System.File`: `withFile`, which handles "
"the opening, closing and handling of file errors for us."
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/IO.md:920
#, no-wrap
msgid ""
"covering\n"
"countEmpty' : (path : String) -> IO (Either FileError Nat)\n"
"countEmpty' path = withFile path Read pure (go 0)\n"
"  where covering go : Nat -> File -> IO (Either FileError Nat)\n"
"        go k file = do\n"
"          False <- fEOF file | True => pure (Right k)\n"
"          Right \"\\n\" <- fGetLine file\n"
"            | Right _  => go k file\n"
"            | Left err => pure (Left err)\n"
"          go (k + 1) file\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:937
#, markdown-text
msgid ""
"Go ahead, and have a look at the type of `withFile`, then have a look how we "
"use it to simplify the implementation of `countEmpty'`. Reading and "
"understanding slightly more complex function types is important when "
"learning to program in Idris."
msgstr ""

#. type: Title ####
#: ../src/Tutorial/IO.md:938
#, markdown-text, no-wrap
msgid "Interface `HasIO`"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:948
#, markdown-text
msgid ""
"When you look at the `IO` functions we used so far, you'll notice that most "
"if not all of them actually don't work with `IO` itself but with a type "
"parameter `io` with a constraint of `HasIO`. This interface allows us to "
"*lift* a value of type `IO a` into another context. We will see use cases "
"for this in later chapters, especially when we talk about monad "
"transformers. For now, you can treat these `io` parameters as being "
"specialized to `IO`."
msgstr ""

#. type: Bullet: '1. '
#: ../src/Tutorial/IO.md:959
#, markdown-text
msgid ""
"As we have seen in the examples above, `IO` actions working with file "
"handles often come with the risk of failure. We can therefore simplify "
"things by writing some utility functions and a custom *bind* operator to "
"work with these nested effects. In a new namespace `IOErr`, implement the "
"following utility functions and use these to further cleanup the "
"implementation of `countEmpty'`:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/IO.md:960
#, no-wrap
msgid ""
"   pure : a -> IO (Either e a)\n"
"\n"
"   fail : e -> IO (Either e a)\n"
"\n"
"   lift : IO a -> IO (Either e a)\n"
"\n"
"   catch : IO (Either e1 a) -> (e1 -> IO (Either e2 a)) -> IO (Either e2 "
"a)\n"
"\n"
"   (>>=) : IO (Either e a) -> (a -> IO (Either e b)) -> IO (Either e b)\n"
"\n"
"   (>>) : IO (Either e ()) -> Lazy (IO (Either e a)) -> IO (Either e a)\n"
msgstr ""

#. type: Bullet: '2. '
#: ../src/Tutorial/IO.md:977
#, markdown-text
msgid ""
"Write a function `countWords` for counting the words in a file.  Consider "
"using `Data.String.words` and the utilities from exercise 1 in your "
"implementation."
msgstr ""

#. type: Bullet: '3. '
#: ../src/Tutorial/IO.md:983
#, markdown-text
msgid ""
"We can generalize the functionality used in `countEmpty` and `countWords`, "
"by implementing a helper function for iterating over the lines in a file and "
"accumulating some state along the way. Implement `withLines` and use it to "
"reimplement `countEmpty` and `countWords`:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/IO.md:984
#, no-wrap
msgid ""
"   covering\n"
"   withLines :  (path : String)\n"
"             -> (accum : s -> String -> s)\n"
"             -> (initialState : s)\n"
"             -> IO (Either FileError s)\n"
msgstr ""

#. type: Bullet: '4. '
#: ../src/Tutorial/IO.md:996
#, markdown-text
msgid ""
"We often use a `Monoid` for accumulating values.  It is therefore convenient "
"to specialize `withLines` for this case. Use `withLines` to implement "
"`foldLines` according to the type given below:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/IO.md:997
#, no-wrap
msgid ""
"   covering\n"
"   foldLines :  Monoid s\n"
"             => (path : String)\n"
"             -> (f    : String -> s)\n"
"             -> IO (Either FileError s)\n"
msgstr ""

#. type: Bullet: '5. '
#: ../src/Tutorial/IO.md:1012
#, markdown-text
msgid ""
"Implement function `wordCount` for counting the number of lines, words, and "
"characters in a text document. Define a custom record type together with an "
"implementation of `Monoid` for storing and accumulating these values and use "
"`foldLines` in your implementation of `wordCount`."
msgstr ""

#. type: Title ##
#: ../src/Tutorial/IO.md:1013
#, markdown-text, no-wrap
msgid "How `IO` is Implemented"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:1019
#, markdown-text
msgid ""
"In this final section of an already lengthy chapter, we will risk a glance "
"at how `IO` is implemented in Idris. It is interesting to note, that `IO` is "
"not a built-in type but a regular data type with only one minor "
"speciality. Let's learn about it at the REPL:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/IO.md:1020
#, no-wrap
msgid ""
"Tutorial.IO> :doc IO\n"
"data PrimIO.IO : Type -> Type\n"
"  Totality: total\n"
"  Constructor: MkIO : (1 _ : PrimIO a) -> IO a\n"
"  Hints:\n"
"    Applicative IO\n"
"    Functor IO\n"
"    HasLinearIO IO\n"
"    Monad IO\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:1037
#, markdown-text
msgid ""
"Here, we learn that `IO` has a single data constructor called `MkIO`, which "
"takes a single argument of type `PrimIO a` with quantity *1*. We are not "
"going to talk about the quantities here, as in fact they are not important "
"to understand how `IO` works."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:1039
#, markdown-text
msgid "Now, `PrimIO a` is a type alias for the following function:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/IO.md:1040
#, no-wrap
msgid ""
"Tutorial.IO> :printdef PrimIO\n"
"PrimIO.PrimIO : Type -> Type\n"
"PrimIO a = (1 _ : %World) -> IORes a\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:1049
#, markdown-text
msgid ""
"Again, don't mind the quantities. There is only one piece of the puzzle "
"missing: `IORes a`, which is a publicly exported record type:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/IO.md:1050
#, no-wrap
msgid ""
"Solutions.IO> :doc IORes\n"
"data PrimIO.IORes : Type -> Type\n"
"  Totality: total\n"
"  Constructor: MkIORes : a -> (1 _ : %World) -> IORes a\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:1059
#, markdown-text
msgid ""
"So, to put this all together, `IO` is a wrapper around something similar to "
"the following function type:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/IO.md:1060
#, no-wrap
msgid "%World -> (a, %World)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:1072
#, markdown-text
msgid ""
"You can think of type `%World` as a placeholder for the state of the outside "
"world of a program (file system, memory, network connections, and so "
"on). Conceptually, to execute an `IO a` action, we pass it the current state "
"of the world, and in return get an updated world state plus a result of type "
"`a`. The world state being updated represents all the side effects "
"describable in a computer program."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:1088
#, markdown-text
msgid ""
"Now, it is important to understand that there is no such thing as the *state "
"of the world*. The `%World` type is just a placeholder, which is converted "
"to some kind of constant that's passed around and never inspected at "
"runtime. So, if we had a value of type `%World`, we could pass it to an `IO "
"a` action and execute it, and this is exactly what happens at runtime: A "
"single value of type `%World` (an uninteresting placeholder like `null`, "
"`0`, or - in case of the JavaScript backends - `undefined`)  is passed to "
"the `main` function, thus setting the whole program in motion. However, it "
"is impossible to programmatically create a value of type `%World` (it is an "
"abstract, primitive type), and therefore we cannot ever extract a value of "
"type `a` from an `IO a` action (modulo `unsafePerformIO`)."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:1094
#, markdown-text
msgid ""
"Once we will talk about monad transformers and the state monad, you will see "
"that `IO` is nothing else but a state monad in disguise but with an abstract "
"state type, which makes it impossible for us to run the stateful "
"computation."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/IO.md:1099
#, markdown-text
msgid ""
"Values of type `IO a` describe programs with side effects, which will "
"eventually result in a value of type `a`."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/IO.md:1104
#, markdown-text
msgid ""
"While we cannot safely extract a value of type `a` from an `IO a`, we can "
"use several combinators and syntactic constructs to combine `IO` actions and "
"build more-complex programs."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/IO.md:1107
#, markdown-text
msgid ""
"*Do blocks* offer a convenient way to run and combine `IO` actions "
"sequentially."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/IO.md:1110
#, markdown-text
msgid ""
"*Do blocks* are desugared to nested applications of *bind* operators "
"(`(>>=)`)."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/IO.md:1114
#, markdown-text
msgid ""
"*Bind* operators, and thus *do blocks*, can be overloaded to achieve custom "
"behavior instead of the default (monadic) *bind*."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/IO.md:1117
#, markdown-text
msgid ""
"Under the hood, `IO` actions are stateful computations operating on a "
"symbolic `%World` state."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/IO.md:1123
#, markdown-text
msgid ""
"Now, that we had a glimpse at *monads* and the *bind* operator, it is time "
"to in the [next chapter](Functor.md) introduce `Monad` and some related "
"interfaces for real."
msgstr ""

#. type: Title #
#: ../src/Tutorial/Interfaces.md:1
#, markdown-text, no-wrap
msgid "Interfaces"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:9
#, markdown-text
msgid ""
"Function overloading - the definition of functions with the same name but "
"different implementations - is a concept found in many programming "
"languages. Idris natively supports overloading of functions: Two functions "
"with the same name can be defined in different modules or namespaces, and "
"Idris will try to disambiguate between these based on the types "
"involved. Here is an example:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Interfaces.md:10
#, no-wrap
msgid ""
"module Tutorial.Interfaces\n"
"\n"
"%default total\n"
"\n"
"namespace Bool\n"
"  export\n"
"  size : Bool -> Integer\n"
"  size True  = 1\n"
"  size False = 0\n"
"\n"
"namespace Integer\n"
"  export\n"
"  size : Integer -> Integer\n"
"  size = id\n"
"\n"
"namespace List\n"
"  export\n"
"  size : List a -> Integer\n"
"  size = cast . length\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:35
#, markdown-text
msgid ""
"Here, we defined three different functions called `size`, each in its own "
"namespace. We can disambiguate between these by prefixing them with their "
"namespace:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Interfaces.md:36
#, no-wrap
msgid ""
"Tutorial.Interfaces> :t Bool.size\n"
"Tutorial.Interfaces.Bool.size : Bool -> Integer\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:42
#, markdown-text
msgid "However, this is usually not necessary:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Interfaces.md:43
#, no-wrap
msgid ""
"mean : List Integer -> Integer\n"
"mean xs = sum xs `div` size xs\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:51
#, markdown-text
msgid ""
"As you can see, Idris can disambiguate between the different `size` "
"functions, since `xs` is of type `List Integer`, which unifies only with "
"`List a`, the argument type of `List.size`."
msgstr ""

#. type: Title ##
#: ../src/Tutorial/Interfaces.md:52
#, markdown-text, no-wrap
msgid "Interface Basics"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:57
#, markdown-text
msgid ""
"While function overloading as described above works well, there are use "
"cases, where this form of overloaded functions leads to a lot of code "
"duplication."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:61
#, markdown-text
msgid ""
"As an example, consider a function `cmp` (short for *compare*, which is "
"already exported by the *Prelude*), for describing an ordering for the "
"values of type `String`:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Interfaces.md:62
#, no-wrap
msgid "cmp : String -> String -> Ordering\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:70
#, markdown-text
msgid ""
"We'd also like to have similar functions for many other data types.  "
"Function overloading allows us to do just that, but `cmp` is not an isolated "
"piece of functionality. From it, we can derive functions like "
"`greaterThan'`, `lessThan'`, `minimum'`, `maximum'`, and many others:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Interfaces.md:71
#, no-wrap
msgid ""
"lessThan' : String -> String -> Bool\n"
"lessThan' s1 s2 = LT == cmp s1 s2\n"
"\n"
"greaterThan' : String -> String -> Bool\n"
"greaterThan' s1 s2 = GT == cmp s1 s2\n"
"\n"
"minimum' : String -> String -> String\n"
"minimum' s1 s2 =\n"
"  case cmp s1 s2 of\n"
"    LT => s1\n"
"    _  => s2\n"
"\n"
"maximum' : String -> String -> String\n"
"maximum' s1 s2 =\n"
"  case cmp s1 s2 of\n"
"    GT => s1\n"
"    _  => s2\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:94
#, markdown-text
msgid ""
"We'd need to implement all of these again for the other types with a `cmp` "
"function, and most if not all of these implementations would be identical to "
"the ones written above. That's a lot of code repetition."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:99
#, markdown-text
msgid ""
"One way to solve this is to use higher-order functions.  For instance, we "
"could define function `minimumBy`, which takes a comparison function as its "
"first argument and returns the smaller of the two remaining arguments:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Interfaces.md:100
#, no-wrap
msgid ""
"minimumBy : (a -> a -> Ordering) -> a -> a -> a\n"
"minimumBy f a1 a2 =\n"
"  case f a1 a2 of\n"
"    LT => a1\n"
"    _  => a2\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:114
#, markdown-text
msgid ""
"This solution is another proof of how higher-order functions allow us to "
"reduce code duplication. However, the need to explicitly pass around the "
"comparison function all the time can get tedious as well.  It would be nice, "
"if we could teach Idris to come up with such a function on its own."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:116
#, markdown-text
msgid "Interfaces solve exactly this issue. Here's an example:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Interfaces.md:117
#, no-wrap
msgid ""
"interface Comp a where\n"
"  comp : a -> a -> Ordering\n"
"\n"
"implementation Comp Bits8 where\n"
"  comp = compare\n"
"\n"
"implementation Comp Bits16 where\n"
"  comp = compare\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:133
#, markdown-text
msgid ""
"The code above defines *interface* `Comp` providing function `comp` for "
"calculating the ordering for two values of a type `a`, followed by two "
"*implementations* of this interface for types `Bits8` and `Bits16`. Note, "
"that the `implementation` keyword is optional."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:137
#, markdown-text
msgid ""
"The `comp` implementations for `Bits8` and `Bits16` both use function "
"`compare`, which is part of a similar interface from the *Prelude* called "
"`Ord`."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:139
#, markdown-text
msgid "The next step is to look at the type of `comp` at the REPL:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Interfaces.md:140
#, no-wrap
msgid ""
"Tutorial.Interfaces> :t comp\n"
"Tutorial.Interfaces.comp : Comp a => a -> a -> Ordering\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:154
#, markdown-text, no-wrap
msgid ""
"The interesting part in the type signature of `comp` is\n"
"the initial `Comp a =>` argument. Here, `Comp` is a *constraint* on\n"
"type parameter `a`. This signature can be read as:\n"
"\"For any type `a`, given an implementation\n"
"of interface `Comp` for `a`, we can compare two values\n"
"of type `a` and return an `Ordering` for these.\"\n"
"Whenever we invoke `comp`, we expect Idris to come up with a\n"
"value of type `Comp a` on its own, hence the new `=>` arrow.\n"
"If Idris fails to do so, it will answer with a type error.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:158
#, markdown-text
msgid ""
"We can now use `comp` in the implementations of related functions.  All we "
"have to do is to also prefix these derived functions with a `Comp` "
"constraint:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Interfaces.md:159
#, no-wrap
msgid ""
"lessThan : Comp a => a -> a -> Bool\n"
"lessThan s1 s2 = LT == comp s1 s2\n"
"\n"
"greaterThan : Comp a => a -> a -> Bool\n"
"greaterThan s1 s2 = GT == comp s1 s2\n"
"\n"
"minimum : Comp a => a -> a -> a\n"
"minimum s1 s2 =\n"
"  case comp s1 s2 of\n"
"    LT => s1\n"
"    _  => s2\n"
"\n"
"maximum : Comp a => a -> a -> a\n"
"maximum s1 s2 =\n"
"  case comp s1 s2 of\n"
"    GT => s1\n"
"    _  => s2\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:185
#, markdown-text
msgid ""
"Note, how the definition of `minimum` is almost identical to "
"`minimumBy`. The only difference being that in case of `minimumBy` we had to "
"pass the comparison function as an explicit argument, while for `minimum` it "
"is provided as part of the `Comp` implementation, which is passed around by "
"Idris for us."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:188
#, markdown-text
msgid ""
"Thus, we have defined all these utility functions once and for all for every "
"type with an implementation of interface `Comp`."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:195
#, markdown-text, no-wrap
msgid ""
"1. Implement function `anyLarger`, which should return `True`,\n"
"if and only if a list of values contains at least one element larger\n"
"than a given reference value. Use interface `Comp` in your\n"
"implementation.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:200
#, markdown-text, no-wrap
msgid ""
"2. Implement function `allLarger`, which should return `True`,\n"
"if and only if a list of values contains *only* elements larger\n"
"than a given reference value. Note, that this is trivially true\n"
"for the empty list. Use interface `Comp` in your implementation.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:206
#, markdown-text, no-wrap
msgid ""
"3. Implement function `maxElem`, which tries to extract the\n"
"largest element from a list of values with a `Comp` implementation.\n"
"Likewise for `minElem`, which tries to extract the smallest element.\n"
"Note, that the possibility of the list being empty must be considered\n"
"when deciding on the output type.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:210
#, markdown-text, no-wrap
msgid ""
"4. Define an interface `Concat` for values like lists or\n"
"strings, which can be concatenated. Provide implementations\n"
"for lists and strings.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:215
#, markdown-text, no-wrap
msgid ""
"5. Implement function `concatList` for concatenating the\n"
"values in a list holding values with a `Concat` implementation.\n"
"Make sure to reflect the possibility of the list being empty in your\n"
"output type.\n"
msgstr ""

#. type: Title ##
#: ../src/Tutorial/Interfaces.md:216
#, markdown-text, no-wrap
msgid "More about Interfaces"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:224
#, markdown-text
msgid ""
"In the last section, we learned about the very basics of interfaces: Why "
"they are useful and how to define and implement them.  In this section, we "
"will learn about some slightly advanced concepts: Extending interfaces, "
"interfaces with constraints, and default implementations."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Interfaces.md:225
#, markdown-text, no-wrap
msgid "Extending Interfaces"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:233
#, markdown-text
msgid ""
"Some interfaces form a kind of hierarchy. For instance, for the `Concat` "
"interface used in exercise 4, there might be a child interface called "
"`Empty`, for those types, which have a neutral element with relation to "
"concatenation.  In such a case, we make an implementation of `Concat` a "
"prerequisite for implementing `Empty`:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Interfaces.md:234
#, no-wrap
msgid ""
"interface Concat a where\n"
"  concat : a -> a -> a\n"
"\n"
"implementation Concat String where\n"
"  concat = (++)\n"
"\n"
"interface Concat a => Empty a where\n"
"  empty : a\n"
"\n"
"implementation Empty String where\n"
"  empty = \"\"\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:254
#, markdown-text, no-wrap
msgid ""
"`Concat a => Empty a` should be read as: \"An implementation\n"
"of `Concat` for type `a` is a *prerequisite* for there being\n"
"an implementation of `Empty` for `a`.\"\n"
"But this also means that, whenever we have an implementation\n"
"of interface `Empty`, we *must* also have an implementation of `Concat`\n"
"and can invoke the corresponding functions:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Interfaces.md:255
#, no-wrap
msgid ""
"concatListE : Empty a => List a -> a\n"
"concatListE []        = empty\n"
"concatListE (x :: xs) = concat x (concatListE xs)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:264
#, markdown-text
msgid ""
"Note, how in the type of `concatListE` we only used an `Empty` constraint, "
"and how in the implementation we were still able to invoke both `empty` and "
"`concat`."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Interfaces.md:265
#, markdown-text, no-wrap
msgid "Constrained Implementations"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:273
#, markdown-text
msgid ""
"Sometimes, it is only possible to implement an interface for a generic type, "
"if its type parameters implement this interface as well. For instance, "
"implementing interface `Comp` for `Maybe a` makes sense only if type `a` "
"itself implements `Comp`. We can constrain interface implementations with "
"the same syntax we use for constrained functions:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Interfaces.md:274
#, no-wrap
msgid ""
"implementation Comp a => Comp (Maybe a) where\n"
"  comp Nothing  Nothing  = EQ\n"
"  comp (Just _) Nothing  = GT\n"
"  comp Nothing  (Just _) = LT\n"
"  comp (Just x) (Just y) = comp x y\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:292
#, markdown-text
msgid ""
"This is not the same as extending an interface, although the syntax looks "
"very similar. Here, the constraint lies on a *type parameter* instead of the "
"full type.  The last line in the implementation of `Comp (Maybe a)` compares "
"the values stored in the two `Just`s. This is only possible, if there is a "
"`Comp` implementation for these values as well. Go ahead, and remove the "
"`Comp a` constraint from the above implementation. Learning to read and "
"understand Idris' type errors is important for fixing them."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:295
#, markdown-text
msgid "The good thing is, that Idris will solve all these constraints for us:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Interfaces.md:296
#, no-wrap
msgid ""
"maxTest : Maybe Bits8 -> Ordering\n"
"maxTest = comp (Just 12)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:305
#, markdown-text
msgid ""
"Here, Idris tries to find an implementation for `Comp (Maybe Bits8)`.  In "
"order to do so, it needs an implementation for `Comp Bits8`.  Go ahead, and "
"replace `Bits8` in the type of `maxTest` with `Bits64`, and have a look at "
"the error message Idris produces."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Interfaces.md:306
#, markdown-text, no-wrap
msgid "Default Implementations"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:320
#, markdown-text
msgid ""
"Sometimes, we'd like to pack several related functions in an interface to "
"allow programmers to implement each in the most efficient way, although they "
"*could* be implemented in terms of each other. For instance, consider an "
"interface `Equals` for comparing two values for equality, with functions "
"`eq` returning `True` if two values are equal and `neq` returning `True` if "
"they are not. Surely, we can implement `neq` in terms of `eq`, so most of "
"the time when implementing `Equals`, we will only implement the latter.  In "
"this case, we can give an implementation for `neq` already in the definition "
"of `Equals`:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Interfaces.md:321
#, no-wrap
msgid ""
"interface Equals a where\n"
"  eq : a -> a -> Bool\n"
"\n"
"  neq : a -> a -> Bool\n"
"  neq a1 a2 = not (eq a1 a2)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:332
#, markdown-text
msgid ""
"If in an implementation of `Equals` we only implement `eq`, Idris will use "
"the default implementation for `neq` as shown above:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Interfaces.md:333
#, no-wrap
msgid ""
"Equals String where\n"
"  eq = (==)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:340
#, markdown-text
msgid ""
"If on the other hand we'd like to provide explicit implementations for both "
"functions, we can do so as well:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Interfaces.md:341
#, no-wrap
msgid ""
"Equals Bool where\n"
"  eq True True   = True\n"
"  eq False False = True\n"
"  eq _ _         = False\n"
"\n"
"  neq True  False = True\n"
"  neq False True  = True\n"
"  neq _ _         = False\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:358
#, markdown-text, no-wrap
msgid ""
"1. Implement interfaces `Equals`, `Comp`, `Concat`, and\n"
"  `Empty` for pairs, constraining your implementations as necessary.\n"
"  (Note, that multiple constraints can be given sequentially like\n"
"  other function arguments: `Comp a => Comp b => Comp (a,b)`.)\n"
msgstr ""

#. type: Bullet: '2. '
#: ../src/Tutorial/Interfaces.md:361
#, markdown-text
msgid ""
"Below is an implementation of a binary tree. Implement interfaces `Equals` "
"and `Concat` for this type."
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Interfaces.md:362
#, no-wrap
msgid ""
"   data Tree : Type -> Type where\n"
"     Leaf : a -> Tree a\n"
"     Node : Tree a -> Tree a -> Tree a\n"
msgstr ""

#. type: Title ##
#: ../src/Tutorial/Interfaces.md:368
#, markdown-text, no-wrap
msgid "Interfaces in the *Prelude*"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:374
#, markdown-text
msgid ""
"The Idris *Prelude* provides several interfaces plus implementations that "
"are useful in almost every non-trivial program. I'll introduce the basic "
"ones here. The more advanced ones will be discussed in later chapters."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:378
#, markdown-text
msgid ""
"Most of these interfaces come with associated mathematical laws, and "
"implementations are assumed to adhere to these laws. These laws will be "
"given here as well."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Interfaces.md:379
#, markdown-text, no-wrap
msgid "`Eq`"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:389
#, markdown-text
msgid ""
"Probably the most often used interface, `Eq` corresponds to interface "
"`Equals` we used above as an example. Instead of `eq` and `neq`, `Eq` "
"provides two operators `(==)` and `(/=)` for comparing two values of the "
"same type for being equal or not. Most of the data types defined in the "
"*Prelude* come with an implementation of `Eq`, and whenever programmers "
"define their own data types, `Eq` is typically one of the first interfaces "
"they implement."
msgstr ""

#. type: Title ####
#: ../src/Tutorial/Interfaces.md:390
#, markdown-text, no-wrap
msgid "`Eq` Laws"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:393
#, markdown-text
msgid "We expect the following laws to hold for all implementations of `Eq`:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:396
#, markdown-text, no-wrap
msgid ""
"* `(==)` is *reflexive*: `x == x = True` for all `x`. This means, that\n"
"every value is equal to itself.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:399
#, markdown-text, no-wrap
msgid ""
"* `(==)` is *symmetric*: `x == y = y == x` for all `x` and `y`.\n"
"This means, that the order of arguments passed to `(==)` does not matter.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:402
#, markdown-text, no-wrap
msgid ""
"* `(==)` is *transitive*: From `x == y = True` and `y == z = True` follows\n"
"`x == z = True`.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:405
#, markdown-text, no-wrap
msgid ""
"* `(/=)` is the negation of `(==)`: `x == y = not (x /= y)`\n"
"for all `x` and `y`.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:410
#, markdown-text
msgid ""
"In theory, Idris has the power to verify these laws at compile time for many "
"non-primitive types. However, out of pragmatism this is not required when "
"implementing `Eq`, since writing such proofs can be quite involved."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Interfaces.md:411
#, markdown-text, no-wrap
msgid "`Ord`"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:419
#, markdown-text, no-wrap
msgid ""
"The pendant to `Comp` in the *Prelude* is interface `Ord`. In addition\n"
"to `compare`, which is identical to our own `comp` it provides comparison\n"
"operators `(>=)`, `(>)`, `(<=)`, and `(<)`, as well as utility functions\n"
"`max` and `min`. Unlike `Comp`, `Ord` extends `Eq`,\n"
"so whenever there is an `Ord` constraint, we also have access to operators\n"
"`(==)` and `(/=)` and related functions.\n"
msgstr ""

#. type: Title ####
#: ../src/Tutorial/Interfaces.md:420
#, markdown-text, no-wrap
msgid "`Ord` Laws"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:423
#, markdown-text
msgid "We expect the following laws to hold for all implementations of `Ord`:"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Interfaces.md:433
#, markdown-text
msgid "`(<=)` is *reflexive* and *transitive*."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:433
#, markdown-text, no-wrap
msgid ""
"* `(<=)` is *antisymmetric*: From `x <= y = True` and `y <= x = True`\n"
"follows `x == y = True`.\n"
"* `x <= y = y >= x`.\n"
"* `x < y = not (y <= x)`\n"
"* `x > y = not (y >= x)`\n"
"* `compare x y = EQ` => `x == y = True`\n"
"* `compare x y == GT = x > y`\n"
"* `compare x y == LT = x < y`\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Interfaces.md:434
#, markdown-text, no-wrap
msgid "`Semigroup` and `Monoid`"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:439
#, markdown-text, no-wrap
msgid ""
"`Semigroup` is the pendant to our example interface `Concat`,\n"
"with operator `(<+>)` (also called *append*) corresponding\n"
"to function `concat`.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:442
#, markdown-text
msgid ""
"Likewise, `Monoid` corresponds to `Empty`, with `neutral` corresponding to "
"`empty`."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:449
#, markdown-text
msgid ""
"These are incredibly important interfaces, which can be used to combine two "
"or more values of a data type into a single value of the same type. Examples "
"include but are not limited to addition or multiplication of numeric types, "
"concatenation of sequences of data, or sequencing of computations."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:455
#, markdown-text
msgid ""
"As an example, consider a data type for representing distances in a "
"geometric application. We could just use `Double` for this, but that's not "
"very type safe. It would be better to use a single field record wrapping "
"values type `Double`, to give such values clear semantics:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Interfaces.md:456
#, no-wrap
msgid ""
"record Distance where\n"
"  constructor MkDistance\n"
"  meters : Double\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:465
#, markdown-text
msgid ""
"There is a natural way for combining two distances: We sum up the values "
"they hold. This immediately leads to an implementation of `Semigroup`:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Interfaces.md:466
#, no-wrap
msgid ""
"Semigroup Distance where\n"
"  x <+> y = MkDistance $ x.meters + y.meters\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:474
#, markdown-text
msgid ""
"It is also immediately clear, that zero is the neutral element of this "
"operation: Adding zero to any value does not affect the value at all.  This "
"allows us to implement `Monoid` as well:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Interfaces.md:475
#, no-wrap
msgid ""
"Monoid Distance where\n"
"  neutral = MkDistance 0\n"
msgstr ""

#. type: Title ####
#: ../src/Tutorial/Interfaces.md:480
#, markdown-text, no-wrap
msgid "`Semigroup` and `Monoid` Laws"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:484
#, markdown-text
msgid ""
"We expect the following laws to hold for all implementations of `Semigroup` "
"and `Monoid`:"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Interfaces.md:489
#, markdown-text
msgid ""
"`(<+>)` is *associative*: `x <+> (y <+> z) = (x <+> y) <+> z`, for all "
"values `x`, `y`, and `z`."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Interfaces.md:489
#, markdown-text
msgid ""
"`neutral` is the *neutral element* with relation to `(<+>)`: `neutral <+> x "
"= x <+> neutral = x`, for all `x`."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Interfaces.md:490
#, markdown-text, no-wrap
msgid "`Show`"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:497
#, markdown-text
msgid ""
"The `Show` interface is mainly used for debugging purposes, and is supposed "
"to display values of a given type as a string, typically closely resembling "
"the Idris code used to create the value. This includes the proper wrapping "
"of arguments in parentheses where necessary. For instance, experiment with "
"the output of the following function at the REPL:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Interfaces.md:498
#, no-wrap
msgid ""
"showExample : Maybe (Either String (List (Maybe Integer))) -> String\n"
"showExample = show\n"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Interfaces.md:505
#, no-wrap
msgid ""
"Tutorial.Interfaces> showExample (Just (Right [Just 12, Nothing]))\n"
"\"Just (Right [Just 12, Nothing])\"\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:511
#, markdown-text
msgid "We will learn how to implement instances of `Show` in an exercise."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Interfaces.md:512
#, markdown-text, no-wrap
msgid "Overloaded Literals"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:524
#, markdown-text
msgid ""
"Literal values in Idris, such as integer literals (`12001`), string literals "
"(`\"foo bar\"`), floating point literals (`12.112`), and character literals "
"(`'$'`) can be overloaded. This means, that we can create values of types "
"other than `String` from just a string literal. The exact workings of this "
"has to wait for another section, but for many common cases, it is sufficient "
"for a value to implement interfaces `FromString` (for using string "
"literals), `FromChar` (for using character literals), or `FromDouble` (for "
"using floating point literals).  The case of integer literals is special, "
"and will be discussed in the next section."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:531
#, markdown-text
msgid ""
"Here is an example of using `FromString`. Assume, we write an application "
"where users can identify themselves with a username and password. Both "
"consist of strings of characters, so it is pretty easy to confuse and mix up "
"the two things, although they clearly have very different semantics.  In "
"these cases, it is advisable to come up with new types for the two, "
"especially since getting these things wrong is a security concern."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:533
#, markdown-text
msgid "Here are three example record types to do this:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Interfaces.md:534
#, no-wrap
msgid ""
"record UserName where\n"
"  constructor MkUserName\n"
"  name : String\n"
"\n"
"record Password where\n"
"  constructor MkPassword\n"
"  value : String\n"
"\n"
"record User where\n"
"  constructor MkUser\n"
"  name     : UserName\n"
"  password : Password\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:551
#, markdown-text
msgid ""
"In order to create a value of type `User`, even for testing, we'd have to "
"wrap all strings using the given constructors:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Interfaces.md:552
#, no-wrap
msgid ""
"hock : User\n"
"hock = MkUser (MkUserName \"hock\") (MkPassword \"not telling\")\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:560
#, markdown-text
msgid ""
"This is rather cumbersome, and some people might think this to be too high a "
"price to pay just for an increase in type safety (I'd tend to disagree).  "
"Luckily, we can get the convenience of string literals back very easily:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Interfaces.md:561
#, no-wrap
msgid ""
"FromString UserName where\n"
"  fromString = MkUserName\n"
"\n"
"FromString Password where\n"
"  fromString = MkPassword\n"
"\n"
"hock2 : User\n"
"hock2 = MkUser \"hock\" \"not telling\"\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Interfaces.md:572
#, markdown-text, no-wrap
msgid "Numeric Interfaces"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:577
#, markdown-text
msgid ""
"The *Prelude* also exports several interfaces providing the usual arithmetic "
"operations. Below is a comprehensive list of the interfaces and the "
"functions each provides:"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Interfaces.md:582
#, markdown-text
msgid "`Num`"
msgstr ""

#. type: Bullet: '  * '
#: ../src/Tutorial/Interfaces.md:582
#, markdown-text
msgid "`(+)` : Addition"
msgstr ""

#. type: Bullet: '  * '
#: ../src/Tutorial/Interfaces.md:582
#, markdown-text
msgid "`(*)` : Multiplication"
msgstr ""

#. type: Bullet: '  * '
#: ../src/Tutorial/Interfaces.md:582
#, markdown-text
msgid "`fromInteger` : Overloaded integer literals"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Interfaces.md:586
#, markdown-text
msgid "`Neg`"
msgstr ""

#. type: Bullet: '  * '
#: ../src/Tutorial/Interfaces.md:586
#, markdown-text
msgid "`negate` : Negation"
msgstr ""

#. type: Bullet: '  * '
#: ../src/Tutorial/Interfaces.md:586
#, markdown-text
msgid "`(-)` : Subtraction"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Interfaces.md:590
#, markdown-text
msgid "`Integral`"
msgstr ""

#. type: Bullet: '  * '
#: ../src/Tutorial/Interfaces.md:590
#, markdown-text
msgid "`div` : Integer division"
msgstr ""

#. type: Bullet: '  * '
#: ../src/Tutorial/Interfaces.md:590
#, markdown-text
msgid "`mod` : Modulo operation"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Interfaces.md:594
#, markdown-text
msgid "`Fractional`"
msgstr ""

#. type: Bullet: '  * '
#: ../src/Tutorial/Interfaces.md:594
#, markdown-text
msgid "`(/)` : Division"
msgstr ""

#. type: Bullet: '  * '
#: ../src/Tutorial/Interfaces.md:594
#, markdown-text
msgid "`recip` : Calculates the reciprocal of a value"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:599
#, markdown-text
msgid ""
"As you can see: We need to implement interface `Num` to use integer literals "
"for a given type. In order to use negative integer literals like `-12`, we "
"also have to implement interface `Neg`."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Interfaces.md:600
#, markdown-text, no-wrap
msgid "`Cast`"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:607
#, markdown-text
msgid ""
"The last interface we will quickly discuss in this section is `Cast`. It is "
"used to convert values of one type to values of another via function "
"`cast`. `Cast` is special, since it is parameterized over *two* type "
"parameters unlike the other interfaces we looked at so far, with only one "
"type parameter."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:614
#, markdown-text
msgid ""
"So far, `Cast` is mainly used for interconversion between primitive types in "
"the standard libraries, especially numeric types. When you look at the "
"implementations exported from the *Prelude* (for instance, by invoking `:doc "
"Cast` at the REPL), you'll see that there are dozens of implementations for "
"most pairings of primitive types."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:623
#, markdown-text
msgid ""
"Although `Cast` would also be useful for other conversions (for going from "
"`Maybe` to `List` or for going from `Either e` to `Maybe`, for instance), "
"the *Prelude* and *base* seem not to introduce these consistently. For "
"instance, there are `Cast` implementations from going from `SnocList` to "
"`List` and vice versa, but not for going from `Vect n` to `List`, or for "
"going from `List1` to `List`, although these would be just as feasible."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:629
#, markdown-text
msgid ""
"These exercises are meant to make you comfortable with implementing "
"interfaces for your own data types, as you will have to do so regularly when "
"writing Idris code."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:635
#, markdown-text
msgid ""
"While it is immediately clear why interfaces like `Eq`, `Ord`, or `Num` are "
"useful, the usability of `Semigroup` and `Monoid` may be harder to "
"appreciate at first.  Therefore, there are several exercises where you'll "
"implement different instances for these."
msgstr ""

#. type: Bullet: '1. '
#: ../src/Tutorial/Interfaces.md:639
#, markdown-text
msgid ""
"Define a record type `Complex` for complex numbers, by pairing two values of "
"type `Double`.  Implement interfaces `Eq`, `Num`, `Neg`, and `Fractional` "
"for `Complex`."
msgstr ""

#. type: Bullet: '2. '
#: ../src/Tutorial/Interfaces.md:643
#, markdown-text
msgid ""
"Implement interface `Show` for `Complex`. Have a look at data type `Prec` "
"and function `showPrec` and how these are used in the *Prelude* to implement "
"instances for `Either` and `Maybe`."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:647
#, markdown-text, no-wrap
msgid ""
"   Verify the correct behavior of your implementation by wrapping\n"
"   a value of type `Complex` in a `Just` and `show` the result at\n"
"   the REPL.\n"
msgstr ""

#. type: Bullet: '3. '
#: ../src/Tutorial/Interfaces.md:649
#, markdown-text
msgid "Consider the following wrapper for optional values:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Interfaces.md:650
#, no-wrap
msgid ""
"   record First a where\n"
"     constructor MkFirst\n"
"     value : Maybe a\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:660
#, markdown-text, no-wrap
msgid ""
"   Implement interfaces `Eq`, `Ord`, `Show`, `FromString`, `FromChar`, "
"`FromDouble`,\n"
"   `Num`, `Neg`, `Integral`, and `Fractional` for `First a`. All of these "
"will require\n"
"   corresponding constraints on type parameter `a`. Consider implementing "
"and\n"
"   using the following utility functions where they make sense:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Interfaces.md:661
#, no-wrap
msgid ""
"   pureFirst : a -> First a\n"
"\n"
"   mapFirst : (a -> b) -> First a -> First b\n"
"\n"
"   mapFirst2 : (a -> b -> c) -> First a -> First b -> First c\n"
msgstr ""

#. type: Bullet: '4. '
#: ../src/Tutorial/Interfaces.md:673
#, markdown-text
msgid ""
"Implement interfaces `Semigroup` and `Monoid` for `First a` in such a way, "
"that `(<+>)` will return the first non-nothing argument and `neutral` is the "
"corresponding neutral element. There must be no constraints on type "
"parameter `a` in these implementations."
msgstr ""

#. type: Bullet: '5. '
#: ../src/Tutorial/Interfaces.md:676
#, markdown-text
msgid ""
"Repeat exercises 3 and 4 for record `Last`. The `Semigroup` implementation "
"should return the last non-nothing value."
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Interfaces.md:677
#, no-wrap
msgid ""
"   record Last a where\n"
"     constructor MkLast\n"
"     value : Maybe a\n"
msgstr ""

#. type: Bullet: '6. '
#: ../src/Tutorial/Interfaces.md:687
#, markdown-text
msgid ""
"Function `foldMap` allows us to map a function returning a `Monoid` over a "
"list of values and accumulate the result using `(<+>)` at the same time.  "
"This is a very powerful way to accumulate the values stored in a list.  Use "
"`foldMap` and `Last` to extract the last element (if any) from a list."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:692
#, markdown-text, no-wrap
msgid ""
"   Note, that the type of `foldMap` is more general and not specialized\n"
"   to lists only. It works also for `Maybe`, `Either` and other container\n"
"   types we haven't looked at so far. We will learn about\n"
"   interface `Foldable` in a later section.\n"
msgstr ""

#. type: Bullet: '7. '
#: ../src/Tutorial/Interfaces.md:694
#, markdown-text
msgid "Consider record wrappers `Any` and `All` for boolean values:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Interfaces.md:695
#, no-wrap
msgid ""
"   record Any where\n"
"     constructor MkAny\n"
"     any : Bool\n"
"\n"
"   record All where\n"
"     constructor MkAll\n"
"     all : Bool\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:708
#, markdown-text, no-wrap
msgid ""
"   Implement `Semigroup` and `Monoid` for `Any`, so that the result of\n"
"   `(<+>)` is `True`, if and only if at least one of the arguments is "
"`True`.\n"
"   Make sure that `neutral` is indeed the neutral element for this "
"operation.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:712
#, markdown-text, no-wrap
msgid ""
"   Likewise, implement `Semigroup` and `Monoid` for `All`, so that the "
"result of\n"
"   `(<+>)` is `True`, if and only if both of the arguments are `True`.\n"
"   Make sure that `neutral` is indeed the neutral element for this "
"operation.\n"
msgstr ""

#. type: Bullet: '8. '
#: ../src/Tutorial/Interfaces.md:715
#, markdown-text
msgid ""
"Implement functions `anyElem` and `allElems` using `foldMap` and `Any` or "
"`All`, respectively:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Interfaces.md:716
#, no-wrap
msgid ""
"   -- True, if the predicate holds for at least one element\n"
"   anyElem : (a -> Bool) -> List a -> Bool\n"
"\n"
"   -- True, if the predicate holds for all elements\n"
"   allElems : (a -> Bool) -> List a -> Bool\n"
msgstr ""

#. type: Bullet: '9. '
#: ../src/Tutorial/Interfaces.md:726
#, markdown-text
msgid "Record wrappers `Sum` and `Product` are mainly used to hold numeric types."
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Interfaces.md:727
#, no-wrap
msgid ""
"   record Sum a where\n"
"     constructor MkSum\n"
"     value : a\n"
"\n"
"   record Product a where\n"
"     constructor MkProduct\n"
"     value : a\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:739
#, markdown-text, no-wrap
msgid ""
"   Given an implementation of `Num a`, implement `Semigroup (Sum a)`\n"
"   and `Monoid (Sum a)`, so that `(<+>)` corresponds to addition.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:742
#, markdown-text, no-wrap
msgid ""
"   Likewise, implement `Semigroup (Product a)` and `Monoid (Product a)`,\n"
"   so that `(<+>)` corresponds to multiplication.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:745
#, markdown-text, no-wrap
msgid ""
"   When implementing `neutral`, remember that you can use integer\n"
"   literals when working with numeric types.\n"
msgstr ""

#. type: Bullet: '10. '
#: ../src/Tutorial/Interfaces.md:748
#, markdown-text
msgid ""
"Implement `sumList` and `productList` by using `foldMap` together with the "
"wrappers from Exercise 9:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:751
#, markdown-text, no-wrap
msgid ""
"    ```idris\n"
"    sumList : Num a => List a -> a\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:754
#, markdown-text, no-wrap
msgid ""
"    productList : Num a => List a -> a\n"
"    ```\n"
msgstr ""

#. type: Bullet: '11. '
#: ../src/Tutorial/Interfaces.md:760
#, markdown-text
msgid ""
"To appreciate the power and versatility of `foldMap`, after solving "
"exercises 6 to 10 (or by loading `Solutions.Inderfaces` in a REPL session), "
"run the following at the REPL, which will - in a single list traversal! - "
"calculate the first and last element of the list as well as the sum and "
"product of all values."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:765
#, markdown-text, no-wrap
msgid ""
"    ```repl\n"
"    > foldMap (\\x => (pureFirst x, pureLast x, MkSum x, MkProduct x)) "
"[3,7,4,12]\n"
"    (MkFirst (Just 3), (MkLast (Just 12), (MkSum 26, MkProduct 1008)))\n"
"    ```\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:772
#, markdown-text, no-wrap
msgid ""
"    Note, that there are also `Semigroup` implementations for\n"
"    types with an `Ord` implementation, which will return\n"
"    the smaller or larger of two values. In case of types\n"
"    with an absolute minimum or maximum (for instance, 0 for\n"
"    natural numbers, or 0 and 255 for `Bits8`), these can even\n"
"    be extended to `Monoid`.\n"
msgstr ""

#. type: Bullet: '12. '
#: ../src/Tutorial/Interfaces.md:778
#, markdown-text
msgid ""
"In an earlier exercise, you implemented a data type representing chemical "
"elements and wrote a function for calculating their atomic masses. Define a "
"new single field record type for representing atomic masses, and implement "
"interfaces `Eq`, `Ord`, `Show`, `FromDouble`, `Semigroup`, and `Monoid` for "
"this."
msgstr ""

#. type: Bullet: '13. '
#: ../src/Tutorial/Interfaces.md:782
#, markdown-text
msgid ""
"Use the new data type from exercise 12 to calculate the atomic mass of an "
"element and compute the molecular mass of a molecule given by its formula."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:785
#, markdown-text, no-wrap
msgid ""
"    Hint: With a suitable utility function, you can use `foldMap`\n"
"    once again for this.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:791
#, markdown-text
msgid ""
"Final notes: If you are new to functional programming, make sure to give "
"your implementations of exercises 6 to 10 a try at the REPL.  Note, how we "
"can implement all of these functions with a minimal amount of code and how, "
"as shown in exercise 11, these behaviors can be combined in a single list "
"traversal."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Interfaces.md:807
#, markdown-text
msgid ""
"Interfaces allow us to implement the same function with different behavior "
"for different types."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Interfaces.md:807
#, markdown-text
msgid ""
"Functions taking one or more interface implementations as arguments are "
"called *constrained functions*."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Interfaces.md:807
#, markdown-text
msgid "Interfaces can be organized hierarchically by *extending* other interfaces."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Interfaces.md:807
#, markdown-text
msgid ""
"Interfaces implementations can themselves be *constrained* requiring other "
"implementations to be available."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Interfaces.md:807
#, markdown-text
msgid ""
"Interface functions can be given a *default implementation*, which can be "
"overridden by implementers, for instance for reasons of efficiency."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Interfaces.md:807
#, markdown-text
msgid ""
"Certain interfaces allow us to use literal values such as string or integer "
"literals for our own data types."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:812
#, markdown-text
msgid ""
"Note, that I did not yet tell the whole story about literal values in this "
"section. More details for using literals with types that accept only a "
"restricted set of values can be found in the chapter about "
"[primitives](Prim.md)."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Interfaces.md:819
#, markdown-text
msgid ""
"In the [next chapter](Functions2.md), we have a closer look at functions and "
"their types. We will learn about named arguments, implicit arguments, and "
"erased arguments as well as some constructors for implementing more complex "
"functions."
msgstr ""

#. type: Title #
#: ../src/Tutorial/Intro.md:1
#, markdown-text, no-wrap
msgid "Introduction"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Intro.md:15
#, markdown-text
msgid ""
"Welcome to my Idris 2 tutorial. I'll try and treat as many aspects of the "
"Idris 2 programming language as possible here.  All `.md` files in here a "
"literate Idris files: They consist of Markdown (hence the `.md` ending), "
"which is being pretty printed by GitHub together with Idris code blocks, "
"which can be type checked and built by the Idris compiler (more on this "
"later).  Note, however, that regular Idris source files use an `.idr` "
"ending, and that you go with that file type unless you end up writing much "
"more prose than code as I do at the moment. Later in this tutorial, you'll "
"have to solve some exercises, the solutions of which can be found in the "
"`src/Solutions` subfolder. There, I use regular `.idr` files."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Intro.md:19
#, markdown-text
msgid ""
"Every Idris source file should typically start with a module name plus some "
"necessary imports, and this document is no exception:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Intro.md:20
#, no-wrap
msgid "module Tutorial.Intro\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Intro.md:27
#, markdown-text
msgid ""
"A module name consists of a list of identifiers separated by dots and must "
"reflect the folder structure plus the module file's name."
msgstr ""

#. type: Title ##
#: ../src/Tutorial/Intro.md:28
#, markdown-text, no-wrap
msgid "About the Idris Programming Language"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Intro.md:33
#, markdown-text
msgid ""
"Idris is a *pure*, *dependently typed*, *total* *functional* programming "
"language. I'll quickly explain each of these adjectives in this section."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Intro.md:34
#, markdown-text, no-wrap
msgid "Functional Programming"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Intro.md:42
#, markdown-text
msgid ""
"In functional programming languages, functions are first-class constructs, "
"meaning that they can be assigned to variables, passed as arguments to other "
"functions, and returned as results from functions. Unlike for instance in "
"object-oriented programming languages, in functional programming, functions "
"are the main form of abstraction."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Intro.md:46
#, markdown-text
msgid ""
"Functional programming languages are concerned with the evaluation of "
"functions, unlike classical imperative languages, which are concerned with "
"the execution of statements."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Intro.md:47
#, markdown-text, no-wrap
msgid "Pure Functional Programming"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Intro.md:57
#, markdown-text
msgid ""
"Pure functional programming languages come with an additional important "
"guarantee: Functions don't have side effects like writing to a file or "
"mutating global state. They can only compute a result from their arguments "
"possibly by invoking other pure functions, *and nothing else*. As a "
"consequence, given the same input, they will *always* generate the same "
"output.  This property is known as [referential "
"transparency](https://en.wikipedia.org/wiki/Referential_transparency)."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Intro.md:59
#, markdown-text
msgid "Pure functions have several advantages:"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Intro.md:62
#, markdown-text
msgid ""
"They can easily be tested by specifying (possibly randomly generated)  sets "
"of input arguments together with the expected results."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Intro.md:66
#, markdown-text
msgid ""
"They are thread-safe, since the don't mutate global state, and as such can "
"be freely used in several computations running in parallel."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Intro.md:68
#, markdown-text
msgid "There are, of course, also some disadvantages:"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Intro.md:71
#, markdown-text
msgid "Some algorithms are hard to implement efficiently using only pure functions."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Intro.md:75
#, markdown-text
msgid ""
"Writing programs that actually *do* something (have some observable effect) "
"is a bit trickier but certainly possible."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Intro.md:83
#, markdown-text
msgid ""
"Idris is a strongly, statically typed programming language. This means, that "
"ever Idris expression is given a *type* (for instance: integer, list of "
"strings, boolean, function from integer to boolean, etc.)  and types are "
"verified at compile time to rule out certain common programming errors."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Intro.md:89
#, markdown-text
msgid ""
"For instance, if a function expects an argument of type `String` (a sequence "
"of unicode characters, such as `\"Hello123\"`), it is a *type error* to "
"invoke this function with an argument of type `Integer`, and the Idris "
"compiler will refuse to generate an executable from such an ill-typed "
"program."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Intro.md:97
#, markdown-text
msgid ""
"Even more, Idris is *dependently typed*, which is one of its most "
"characteristic properties in the landscape of programming languages. In "
"Idris, types are *first class*: Types can be passed as arguments to "
"functions, and functions can return types as their results. Even more, types "
"can *depend* on other *values*.  What this means, and why this is incredibly "
"useful, we'll explore in due time."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Intro.md:98
#, markdown-text, no-wrap
msgid "Total Functions"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Intro.md:104
#, markdown-text
msgid ""
"A *total* function is a pure function, that is guaranteed to return a value "
"of the expected return type for every possible input in a finite amount of "
"time. A total function will never fail with an exception or loop infinitely."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Intro.md:113
#, markdown-text
msgid ""
"Idris comes with a totality checker built in, which enables us to verify the "
"functions we write to be provably total. Totality in Idris is opt-in, as in "
"general, checking the totality of an arbitrary computer program is "
"undecidable (see also the [halting "
"problem](https://en.wikipedia.org/wiki/Halting_problem)).  However, if we "
"annotate a function with the `total` keyword, Idris will fail with a type "
"error, if its totality checker cannot verify that the function in question "
"is indeed total."
msgstr ""

#. type: Title ##
#: ../src/Tutorial/Intro.md:114
#, markdown-text, no-wrap
msgid "Using the REPL"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Intro.md:121
#, markdown-text
msgid ""
"Idris comes with a useful REPL (an acronym for *Read Evaluate Print Loop*), "
"which we will use for tinkering with small ideas, and for quickly "
"experimenting with the code we just wrote.  In order to start a REPL "
"session, run the following command in a terminal."
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Intro.md:122
#, no-wrap
msgid "rlwrap idris2\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Intro.md:131
#, markdown-text
msgid ""
"(Using command-line utility `rlwrap` is optional. It leads to a somewhat "
"nicer user experience, as it allows us to use the up and down arrow keys to "
"scroll through a history of commands and expressions we entered. It should "
"be available for most Linux distributions.)"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Intro.md:133
#, markdown-text
msgid "Idris should now be ready to accept you commands:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Intro.md:134
#, no-wrap
msgid ""
"     ____    __     _         ___\n"
"    /  _/___/ /____(_)____   |__ \\\n"
"    / // __  / ___/ / ___/   __/ /     Version 0.5.1-3c532ea35\n"
"  _/ // /_/ / /  / (__  )   / __/      https://www.idris-lang.org\n"
" /___/\\__,_/_/  /_/____/   /____/      Type :? for help\n"
"\n"
"Welcome to Idris 2.  Enjoy yourself!\n"
"Main>\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Intro.md:147
#, markdown-text
msgid ""
"We can go ahead and enter some simple arithmetic expressions. Idris will "
"*evaluate* these and print the result:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Intro.md:148
#, no-wrap
msgid ""
"Main> 2 * 4\n"
"8\n"
"Main> 3 * (7 + 100)\n"
"321\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Intro.md:157
#, markdown-text
msgid ""
"Since every expression in Idris has an associated *type*, we might want to "
"inspect these as well:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Intro.md:158
#, no-wrap
msgid ""
"Main> :t 2\n"
"2 : Integer\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Intro.md:166
#, markdown-text
msgid ""
"Here `:t` is a command of the Idris REPL (it is not part of the Idris "
"programming language), and it is used to inspect the type of an expression."
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Intro.md:167
#, no-wrap
msgid ""
"Main> :t 2 * 4\n"
"2 * 4 : Integer\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Intro.md:182
#, markdown-text
msgid ""
"Whenever we perform calculations with integer literals without being "
"explicit about the types we want to use, Idris will use `Integer` as a "
"default. `Integer` is an arbitrary precision signed integer type. It is one "
"of the *primitive types* built into the language. Other primitives include "
"fixed precision signed and unsigned integral types (`Bits8`, `Bits16`, "
"`Bits32` `Bits64`, `Int8`, `Int16`, `Int32`, and `Int64`), double precision "
"(64 bit) floating point numbers (`Double`), unicode characters (`Char`) and "
"strings of unicode characters (`String`).  We will use many of these in due "
"time."
msgstr ""

#. type: Title ##
#: ../src/Tutorial/Intro.md:183
#, markdown-text, no-wrap
msgid "A First Idris Program"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Intro.md:190
#, markdown-text
msgid ""
"We will often start up a REPL for tinkering with small parts of the Idris "
"language, for reading some documentation, or for inspecting the content of "
"an Idris module, but now we will write a minimal Idris program to get "
"started with the language. Here comes the mandatory *Hello World*:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Intro.md:191
#, no-wrap
msgid ""
"main : IO ()\n"
"main = putStrLn \"Hello World!\"\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Intro.md:199
#, markdown-text
msgid ""
"We will inspect the code above in some detail in a moment, but first we'd "
"like to compile and run it. From this project's root directory, run the "
"following:"
msgstr ""

#. type: Fenced code block (sh)
#: ../src/Tutorial/Intro.md:199
#, no-wrap
msgid "idris2 --find-ipkg -o hello src/Tutorial/Intro.md\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Intro.md:207
#, markdown-text
msgid ""
"This will create executable `hello` in directory `build/exec`, which can be "
"invoked from the command-line like so (without the dollar prefix; this is "
"used here to distinguish the terminal command from its output):"
msgstr ""

#. type: Fenced code block (sh)
#: ../src/Tutorial/Intro.md:208
#, no-wrap
msgid ""
"$ build/exec/hello\n"
"Hello World!\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Intro.md:219
#, markdown-text
msgid ""
"The `--find-ipkg` option will look for an `.ipkg` file in the current "
"directory or one of its parent directories, from which it will get other "
"settings like the source directory to use (`src` in our case). The `-o` "
"option gives the name of the executable to be generated. Type `idris2 "
"--help` for a list of available command-line options and environment "
"variables."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Intro.md:222
#, markdown-text
msgid ""
"As an alternative, you can also load this source file in a REPL session and "
"invoke function `main` from there:"
msgstr ""

#. type: Fenced code block (sh)
#: ../src/Tutorial/Intro.md:223
#, no-wrap
msgid "rlwrap idris2 --find-ipkg src/Tutorial/Intro.md\n"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Intro.md:227
#, no-wrap
msgid ""
"Tutorial.Intro> :exec main\n"
"Hello World!\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Intro.md:234
#, markdown-text
msgid ""
"Go ahead and try both ways of building and running function `main` on your "
"system!"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Intro.md:239
#, markdown-text
msgid ""
"Note: It might be instructive to omit the `--find-ipkg` option.  You will "
"get an error message about the module name `Tutorial.Intro` not matching the "
"file path `src/Tutorial/Intro.md`. You can also use option `--source-dir "
"src` to silence this error."
msgstr ""

#. type: Title ##
#: ../src/Tutorial/Intro.md:240
#, markdown-text, no-wrap
msgid "The Shape of an Idris Definition"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Intro.md:244
#, markdown-text
msgid ""
"Now that we executed our first Idris program, we will talk a bit more about "
"the code we had to write to define it."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Intro.md:251
#, markdown-text
msgid ""
"A typical top level function in Idris consists of three things: The "
"function's name (`main` in our case), its type (`IO ()`)  plus its "
"implementation (`putStrLn \"Hello World\"`). It is easier to explain these "
"things with a couple of simple examples. Below, we define a top level "
"constant for the largest unsigned eight bit integer:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Intro.md:252
#, no-wrap
msgid ""
"maxBits8 : Bits8\n"
"maxBits8 = 255\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Intro.md:266
#, markdown-text
msgid ""
"The first line can be read as: \"We'd like to declare (nullary)  function "
"`maxBits8`. It is of type `Bits8`\". This is called the *function "
"declaration*: We declare, that there shall be a function of the given name "
"and type. The second line reads: \"The result of invoking `maxBits8` should "
"be `255`.\" (As you can see, we can use integer literals for other integral "
"types than just `Integer`.) This is called the *function definition*: "
"Function `maxBits8` should behave as described here when being evaluated."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Intro.md:269
#, markdown-text
msgid ""
"We can inspect this at the REPL. Load this source file into an Idris REPL "
"(as described above), and run the following tests."
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Intro.md:270
#, no-wrap
msgid ""
"Tutorial.Intro> maxBits8\n"
"255\n"
"Tutorial.Intro> :t maxBits8\n"
"Tutorial.Intro.maxBits8 : Bits8\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Intro.md:278
#, markdown-text
msgid "We can also use `maxBits8` as part of another expression:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Intro.md:279
#, no-wrap
msgid ""
"Tutorial.Intro> maxBits8 - 100\n"
"155\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Intro.md:286
#, markdown-text
msgid ""
"I called `maxBits8` a *nullary function*, which is just a fancy word for "
"*constant*. Let's write and test our first *real* function:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Intro.md:287
#, no-wrap
msgid ""
"distanceToMax : Bits8 -> Bits8\n"
"distanceToMax n = maxBits8 - n\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Intro.md:299
#, markdown-text, no-wrap
msgid ""
"This introduces some new syntax and a new kind of type: Function\n"
"types. `distanceToMax : Bits8 -> Bits8` can be read as follows:\n"
"\"`distanceToMax` is a function of one argument of type `Bits8`, which\n"
"returns a result of type `Bits8`\". In the implementation, the argument\n"
"is given a local identifier `n`, which is then used in the\n"
"calculation on the right hand side. Again, go ahead and try this\n"
"function at the REPL:\n"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Intro.md:300
#, no-wrap
msgid ""
"Tutorial.Intro> distanceToMax 12\n"
"243\n"
"Tutorial.Intro> :t distanceToMax\n"
"Tutorial.Intro.distanceToMax : Bits8 -> Bits8\n"
"Tutorial.Intro> :t distanceToMax 12\n"
"distanceToMax 12 : Bits8\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Intro.md:311
#, markdown-text
msgid ""
"As a final example, let's implement a function to calculate the square of an "
"integer:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Intro.md:312
#, no-wrap
msgid ""
"square : Integer -> Integer\n"
"square n = n * n\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Intro.md:325
#, markdown-text
msgid ""
"We now learn a very important aspect of programming in Idris: Idris is a "
"*statically typed* programming language. We are not allowed to freely mix "
"types as we please. Doing so will result in an error message from the type "
"checker (which is part of the compilation process of Idris).  For instance, "
"if we try the following at the REPL, we will get a type error:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Intro.md:326
#, no-wrap
msgid ""
"Tutorial.Intro> square maxBits8\n"
"Error: ...\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Intro.md:336
#, markdown-text
msgid ""
"The reason: `square` expects an argument of type `Integer`, but `maxBits8` "
"is of type `Bits8`. Many primitive types are interconvertible (sometimes "
"with the risk of loss of precision) using function `cast` (more on the "
"details later):"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Intro.md:337
#, no-wrap
msgid ""
"Tutorial.Intro> square (cast maxBits8)\n"
"65025\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Intro.md:348
#, markdown-text
msgid ""
"Note, that in the example above the result is much larger that "
"`maxBits8`. The reason is, that `maxBits8` is first converted to an "
"`Integer` of the same value, which is then squared. If on the other hand we "
"squared `maxBits8` directly, the result would be truncated to still fit the "
"valid range of `Bits8`:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Intro.md:349
#, no-wrap
msgid ""
"Tutorial.Intro> maxBits8 * maxBits8\n"
"1\n"
msgstr ""

#. type: Title ##
#: ../src/Tutorial/Intro.md:354
#, markdown-text, no-wrap
msgid "Where to get Help"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Intro.md:359
#, markdown-text
msgid ""
"There are several resources available online and in print, where you can "
"find help and documentation about the Idris programming language. Here is a "
"non-comprehensive list of them:"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Intro.md:361
#, markdown-text
msgid ""
"[Type-Driven Development with "
"Idris](https://www.manning.com/books/type-driven-development-with-idris)"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Intro.md:368
#, markdown-text, no-wrap
msgid ""
"  *The* Idris book! This describes in great detail\n"
"  the core concepts for using Idris and dependent types\n"
"  to write robust and concise code. It uses Idris 1 in\n"
"  its examples, so parts of it have to be slightly adjusted\n"
"  when using Idris 2. There is also a\n"
"  [list of required "
"updates](https://idris2.readthedocs.io/en/latest/typedd/typedd.html).\n"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Intro.md:370
#, markdown-text
msgid ""
"[A Crash Course in Idris "
"2](https://idris2.readthedocs.io/en/latest/tutorial/index.html)"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Intro.md:375
#, markdown-text, no-wrap
msgid ""
"  The official Idris 2 tutorial. A comprehensive but dense explanation of\n"
"  all features of Idris 2. I find this to be useful as a reference, and as "
"such\n"
"  it is highly accessible. However, it is not an introduction to "
"functional\n"
"  programming or type-driven development in general.\n"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Intro.md:377
#, markdown-text
msgid "[The Idris 2 GitHub Repository](https://github.com/idris-lang/Idris2)"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Intro.md:384
#, markdown-text, no-wrap
msgid ""
"  Look here for detailed installation instructions and some\n"
"  introductory material. There is also a "
"[wiki](https://github.com/idris-lang/Idris2/wiki),\n"
"  where you can find a [list of editor "
"plugins](https://github.com/idris-lang/Idris2/wiki/The-Idris-editor-experience),\n"
"  a [list of community "
"libraries](https://github.com/idris-lang/Idris2/wiki/Libraries),\n"
"  a [list of external "
"backends](https://github.com/idris-lang/Idris2/wiki/External-backends),\n"
"  and other useful information.\n"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Intro.md:386
#, markdown-text
msgid "[The Idris 2 Discord Channel](https://discord.gg/UX68fDs2jc)"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Intro.md:392
#, markdown-text, no-wrap
msgid ""
"  If you get stuck with a piece of code, want to ask about some\n"
"  obscure language feature, want to promote your new library,\n"
"  or want to just hang out with other Idris programmers, this\n"
"  is the place to go. The discord channel is pretty active and\n"
"  *very* friendly towards newcomers.\n"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Intro.md:394
#, markdown-text
msgid "The Idris REPL"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Intro.md:400
#, markdown-text, no-wrap
msgid ""
"  Finally, a lot of useful information can be provided by\n"
"  Idris itself. I tend to have at least one REPL session open all the\n"
"  time when programming in Idris. My editor (neovim) is set up\n"
"  to use the [language server for Idris "
"2](https://github.com/idris-community/idris2-lsp),\n"
"  which is incredibly useful. In the REPL,\n"
msgstr ""

#. type: Bullet: '  * '
#: ../src/Tutorial/Intro.md:417
#, markdown-text
msgid ""
"use `:t` to inspect the type of an expression or meta variable (hole): `:t "
"foldl`,"
msgstr ""

#. type: Bullet: '  * '
#: ../src/Tutorial/Intro.md:417
#, markdown-text
msgid ""
"use `:ti` to inspect the type of a function including implicit arguments: "
"`:ti foldl`,"
msgstr ""

#. type: Bullet: '  * '
#: ../src/Tutorial/Intro.md:417
#, markdown-text
msgid "use `:m` to list all meta variables (holes) in scope,"
msgstr ""

#. type: Bullet: '  * '
#: ../src/Tutorial/Intro.md:417
#, markdown-text
msgid ""
"use `:doc` to access the documentation of a top level function (`:doc the`), "
"a data type plus all its constructors and available hints (`:doc Bool`), a "
"language feature (`:doc case`, `:doc let`, `:doc interface`, `:doc record`, "
"or even `:doc ?`), or an interface (`:doc Uninhabited`),"
msgstr ""

#. type: Bullet: '  * '
#: ../src/Tutorial/Intro.md:417
#, markdown-text
msgid ""
"use `:module` to import a module from one of the available packages: "
"`:module Data.Vect`,"
msgstr ""

#. type: Bullet: '  * '
#: ../src/Tutorial/Intro.md:417
#, markdown-text
msgid ""
"use `:browse` to list the names and types of all functions exported by a "
"loaded module: `:browse Data.Vect`,"
msgstr ""

#. type: Bullet: '  * '
#: ../src/Tutorial/Intro.md:417
#, markdown-text
msgid ""
"use `:help` to get a list of other commands plus a short description for "
"each."
msgstr ""

#. type: Title ##
#: ../src/Tutorial/Intro.md:418
#, markdown-text, no-wrap
msgid "Summary"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Intro.md:425
#, markdown-text
msgid ""
"In this introduction we learned about the most basic features of the Idris "
"programming language. We used the REPL to tinker with our ideas and inspect "
"the types of things in our code, and we used the Idris compiler to compile "
"an Idris source file to an executable."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Intro.md:429
#, markdown-text
msgid ""
"We also learned about the basic shape of a top level definition in Idris, "
"which always consists of an identifier (its name), a type, and an "
"implementation."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Intro.md:436
#, markdown-text
msgid ""
"In the [next chapter](Functions1.md), we start programming in Idris for "
"real. We learn how to write our own pure functions, how functions compose, "
"and how we can treat functions just like other values and pass them around "
"as arguments to other functions."
msgstr ""

#. type: Title #
#: ../src/Tutorial/Predicates.md:1
#, markdown-text, no-wrap
msgid "Predicates and Proof Search"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:12
#, markdown-text
msgid ""
"In the [last chapter](Eq.md) we learned about propositional equality, which "
"allowed us to proof that two values are equal. Equality is a relation "
"between values, and we used an indexed data type to encode this relation by "
"limiting the degrees of freedom of the indices in the sole data "
"constructor. There are other relations and contracts we can encode this "
"way. This will allow us to restrict the values we accept as a function's "
"arguments or the values returned by functions."
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:13
#, no-wrap
msgid ""
"module Tutorial.Predicates\n"
"\n"
"import Data.Either\n"
"import Data.List1\n"
"import Data.String\n"
"import Data.Vect\n"
"import Data.HList\n"
"import Decidable.Equality\n"
"\n"
"import Text.CSV\n"
"import System.File\n"
"\n"
"%default total\n"
msgstr ""

#. type: Title ##
#: ../src/Tutorial/Predicates.md:29
#, markdown-text, no-wrap
msgid "Preconditions"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:38
#, markdown-text
msgid ""
"Often, when we implement functions operating on values of a given type, not "
"all values are considered to be valid arguments for the function in "
"question. For instance, we typically do not allow division by zero, as the "
"result is undefined in the general case. This concept of putting a "
"*precondition* on a function argument comes up pretty often, and there are "
"several ways to go about this."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:45
#, markdown-text
msgid ""
"A very common operation when working with lists or other container types is "
"to extract the first value in the sequence.  This function, however, cannot "
"work in the general case, because in order to extract a value from a list, "
"the list must not be empty. Here are a couple of ways to encode and "
"implement this, each with its own advantages and disadvantages:"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Predicates.md:57
#, markdown-text
msgid ""
"Wrap the result in a failure type, such as a `Maybe` or `Either e` with some "
"custom error type `e`. This makes it immediately clear that the function "
"might not be able to return a result. It is a natural way to deal with "
"unvalidated input from unknown sources. The drawback of this approach is "
"that results will carry the `Maybe` stain, even in situations when we *know* "
"that the *nil* case is impossible, for instance because we know the value of "
"the list argument at compile-time, or because we already *refined* the input "
"value in such a way that we can be sure it is not empty (due to an earlier "
"pattern match, for instance)."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Predicates.md:67
#, markdown-text
msgid ""
"Define a new data type for non-empty lists and use this as the function's "
"argument. This is the approach taken in module `Data.List1`. It allows us to "
"return a pure value (meaning \"not wrapped in a failure type\" here), "
"because the function cannot possibly fail, but it comes with the burden of "
"reimplementing many of the utility functions and interfaces we already "
"implemented for `List`. For a very common data structure this can be a valid "
"option, but for rare use cases it is often too cumbersome."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Predicates.md:81
#, markdown-text
msgid ""
"Use an index to keep track of the property we are interested in. This was "
"the approach we took with type family `List01`, which we saw in several "
"examples and exercises in this guide so far. This is also the approach taken "
"with vectors, where we use the exact length as our index, which is even more "
"expressive. While this allows us to implement many functions only once and "
"with greater precision at the type level, it also comes with the burden of "
"keeping track of changes in the types, making for more complex function "
"types and forcing us to at times return existentially quantified wrappers "
"(for instance, dependent pairs), because the outcome of a computation is not "
"known until runtime."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Predicates.md:87
#, markdown-text
msgid ""
"Fail with a runtime exception. This is a popular solution in many "
"programming languages (even Haskell), but in Idris we try to avoid this, "
"because it breaks totality in a way, which also affects client "
"code. Luckily, we can make use of our powerful type system to avoid this "
"situation in general."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Predicates.md:94
#, markdown-text
msgid ""
"Take an additional (possibly erased) argument of a type we can use as a "
"witness that the input value is of the correct kind or shape. This is the "
"solution we will discuss in this chapter in great detail. It is an "
"incredibly powerful way to talk about restrictions on values without having "
"to replicate a lot of already existing functionality."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:100
#, markdown-text
msgid ""
"There is a time and place for most if not all of the solutions listed above "
"in Idris, but we will often turn to the last one and refine function "
"arguments with predicates (so called *preconditions*), because it makes our "
"functions nice to use at runtime *and* compile time."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Predicates.md:101
#, markdown-text, no-wrap
msgid "Example: Non-empty Lists"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:107
#, markdown-text
msgid ""
"Remember how we implemented an indexed data type for propositional equality: "
"We restricted the valid values of the indices in the constructors. We can do "
"the same thing for a predicate for non-empty lists:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:108
#, no-wrap
msgid ""
"data NotNil : (as : List a) -> Type where\n"
"  IsNotNil : NotNil (h :: t)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:117
#, markdown-text
msgid ""
"This is a single-value data type, so we can always use it as an erased "
"function argument and still pattern match on it. We can now use this to "
"implement a safe and pure `head` function:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:118
#, no-wrap
msgid ""
"head1 : (as : List a) -> (0 _ : NotNil as) -> a\n"
"head1 (h :: _) _ = h\n"
"head1 [] IsNotNil impossible\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:129
#, markdown-text
msgid ""
"Note, how value `IsNotNil` is a *witness* that its index, which corresponds "
"to our list argument, is indeed non-empty, because this is what we specified "
"in its type.  The impossible case in the implementation of `head1` is not "
"strictly necessary here. It was given above for completeness."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:134
#, markdown-text
msgid ""
"We call `NotNil` a *predicate* on lists, as it restricts the values allowed "
"in the index. We can express a function's preconditions by adding additional "
"(possibly erased) predicates to the function's list of arguments."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:138
#, markdown-text
msgid ""
"The first really cool thing is how we can safely use `head1`, if we can at "
"compile-time show that our list argument is indeed non-empty:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:139
#, no-wrap
msgid ""
"headEx1 : Nat\n"
"headEx1 = head1 [1,2,3] IsNotNil\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:152
#, markdown-text
msgid ""
"It is a bit cumbersome that we have to pass the `IsNotNil` proof "
"manually. Before we scratch that itch, we will first discuss what to do with "
"lists, the values of which are not known until runtime. For these cases, we "
"have to try and produce a value of the predicate programmatically by "
"inspecting the runtime list value. In the most simple case, we can wrap the "
"proof in a `Maybe`, but if we can show that our predicate is *decidable*, we "
"can get even stronger guarantees by returning a `Dec`:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:153
#, no-wrap
msgid ""
"Uninhabited (NotNil []) where\n"
"  uninhabited IsNotNil impossible\n"
"\n"
"nonEmpty : (as : List a) -> Dec (NotNil as)\n"
"nonEmpty (x :: xs) = Yes IsNotNil\n"
"nonEmpty []        = No uninhabited\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:164
#, markdown-text
msgid ""
"With this, we can implement function `headMaybe`, which is to be used with "
"lists of unknown origin:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:165
#, no-wrap
msgid ""
"headMaybe1 : List a -> Maybe a\n"
"headMaybe1 as = case nonEmpty as of\n"
"  Yes prf => Just $ head1 as prf\n"
"  No  _   => Nothing\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:176
#, markdown-text
msgid ""
"Of course, for trivial functions like `headMaybe` it makes more sense to "
"implement them directly by pattern matching on the list argument, but we "
"will soon see examples of predicates the values of which are more cumbersome "
"to create."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Predicates.md:177
#, markdown-text, no-wrap
msgid "Auto Implicits"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:187
#, markdown-text
msgid ""
"Having to manually pass a proof of being non-empty to `head1` makes this "
"function unnecessarily verbose to use at compile time. Idris allows us to "
"define implicit function arguments, the values of which it tries to assemble "
"on its own by means of a technique called *proof search*. This is not to be "
"confused with type inference, which means inferring values or types from the "
"surrounding context. It's best to look at some examples to explain the "
"difference."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:190
#, markdown-text
msgid ""
"Let us first have a look at the following implementation of `replicate` for "
"vectors:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:191
#, no-wrap
msgid ""
"replicate' : {n : _} -> a -> Vect n a\n"
"replicate' {n = 0}   _ = []\n"
"replicate' {n = S _} v = v :: replicate' v\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:202
#, markdown-text
msgid ""
"Function `replicate'` takes an unerased implicit argument.  The *value* of "
"this argument must be derivable from the surrounding context. For instance, "
"in the following example it is immediately clear that `n` equals three, "
"because that is the length of the vector we want:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:203
#, no-wrap
msgid ""
"replicateEx1 : Vect 3 Nat\n"
"replicateEx1 = replicate' 12\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:211
#, markdown-text
msgid ""
"In the next example, the value of `n` is not known at compile time, but it "
"is available as an unerased implicit, so this can again be passed as is to "
"`replicate'`:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:212
#, no-wrap
msgid ""
"replicateEx2 : {n : _} -> Vect n Nat\n"
"replicateEx2 = replicate' 12\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:223
#, markdown-text
msgid ""
"However, in the following example, the value of `n` can't be inferred, as "
"the intermediary vector is immediately converted to a list of unknown "
"length. Although Idris could try and insert any value for `n` here, it won't "
"do so, because it can't be sure that this is the length we want. We "
"therefore have to pass the length explicitly:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:224
#, no-wrap
msgid ""
"replicateEx3 : List Nat\n"
"replicateEx3 = toList $ replicate' {n = 17} 12\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:234
#, markdown-text
msgid ""
"Note, how the *value* of `n` had to be inferable in these examples, which "
"means it had to make an appearance in the surrounding context. With auto "
"implicit arguments, this works differently. Here is the `head` example, this "
"time with an auto implicit:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:235
#, no-wrap
msgid ""
"head : (as : List a) -> {auto 0 prf : NotNil as} -> a\n"
"head (x :: _) = x\n"
"head [] impossible\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:249
#, markdown-text
msgid ""
"Note the `auto` keyword before the quantity of implicit argument `prf`. This "
"means, we want Idris to construct this value on its own, without it being "
"visible in the surrounding context.  In order to do so, Idris will have to "
"at compile time know the structure of the list argument `as`. It will then "
"try and build such a value from the data type's constructors. If it "
"succeeds, this value will then be automatically filled in as the desired "
"argument, otherwise, Idris will fail with a type error."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:251
#, markdown-text
msgid "Let's see this in action:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:252
#, no-wrap
msgid ""
"headEx3 : Nat\n"
"headEx3 = Predicates.head [1,2,3]\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:258
#, markdown-text
msgid "The following example fails with an error:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:259
#, no-wrap
msgid ""
"failing \"Can't find an implementation\\nfor NotNil [].\"\n"
"  errHead : Nat\n"
"  errHead = Predicates.head []\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:276
#, markdown-text, no-wrap
msgid ""
"Wait! \"Can't find an implementation for...\"? Is this not the\n"
"error message we get for missing interface implementations?\n"
"That's correct, and I'll show you that interface resolution\n"
"is just proof search at the end of this chapter. What I can\n"
"show you already, is that writing the lengthy `{auto prf : t} ->`\n"
"all the times can be cumbersome. Idris therefore allows us\n"
"to use the same syntax as for constrained functions instead:\n"
"`(prf : t) =>`, or even `t =>`, if we don't need to name the\n"
"constraint. As usual, we can then access a constraint in the\n"
"function body by its name (if any). Here is another implementation\n"
"of `head`:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:277
#, no-wrap
msgid ""
"head' : (as : List a) -> (0 _ : NotNil as) => a\n"
"head' (x :: _) = x\n"
"head' [] impossible\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:287
#, markdown-text
msgid ""
"During proof search, Idris will also look for values of the required type in "
"the current function context. This allows us to implement `headMaybe` "
"without having to pass on the `NotNil` proof manually:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:288
#, no-wrap
msgid ""
"headMaybe : List a -> Maybe a\n"
"headMaybe as = case nonEmpty as of\n"
"  -- `prf` is available during proof seach\n"
"  Yes prf => Just $ Predicates.head as\n"
"  No  _   => Nothing\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:304
#, markdown-text
msgid ""
"To conclude: Predicates allow us to restrict the values a function accepts "
"as arguments. At runtime, we need to build such *witnesses* by pattern "
"matching on the function arguments. These operations can typically fail. At "
"compile time, we can let Idris try and build these values for us using a "
"technique called *proof search*. This allows us to make functions safe and "
"convenient to use at the same time."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:312
#, markdown-text
msgid ""
"In these exercises, you'll have to implement several functions making use of "
"auto implicits, to constrain the values accepted as function arguments. The "
"results should be *pure*, that is, not wrapped in a failure type like "
"`Maybe`."
msgstr ""

#. type: Bullet: '1. '
#: ../src/Tutorial/Predicates.md:314
#, markdown-text
msgid "Implement `tail` for lists."
msgstr ""

#. type: Bullet: '2. '
#: ../src/Tutorial/Predicates.md:318
#, markdown-text
msgid ""
"Implement `concat1` and `foldMap1` for lists. These should work like "
"`concat` and `foldMap`, but taking only a `Semigroup` constraint on the "
"element type."
msgstr ""

#. type: Bullet: '3. '
#: ../src/Tutorial/Predicates.md:321
#, markdown-text
msgid ""
"Implement functions for returning the largest and smallest element in a "
"list."
msgstr ""

#. type: Bullet: '4. '
#: ../src/Tutorial/Predicates.md:325
#, markdown-text
msgid ""
"Define a predicate for strictly positive natural numbers and use it to "
"implement a safe and provably total division function on natural numbers."
msgstr ""

#. type: Bullet: '5. '
#: ../src/Tutorial/Predicates.md:330
#, markdown-text
msgid ""
"Define a predicate for a non-empty `Maybe` and use it to safely extract the "
"value stored in a `Just`. Show that this predicate is decidable by "
"implementing a corresponding conversion function."
msgstr ""

#. type: Bullet: '6. '
#: ../src/Tutorial/Predicates.md:334
#, markdown-text
msgid ""
"Define and implement functions for safely extracting values from a `Left` "
"and a `Right` by using suitable predicates.  Show again that these "
"predicates are decidable."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:339
#, markdown-text
msgid ""
"The predicates you implemented in these exercises are already available in "
"the *base* library: `Data.List.NonEmpty`, `Data.Maybe.IsJust`, "
"`Data.Either.IsLeft`, `Data.Either.IsRight`, and `Data.Nat.IsSucc`."
msgstr ""

#. type: Title ##
#: ../src/Tutorial/Predicates.md:340
#, markdown-text, no-wrap
msgid "Contracts between Values"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:346
#, markdown-text
msgid ""
"The predicates we saw so far restricted the values of a single type, but it "
"is also possible to define predicates describing contracts between several "
"values of possibly distinct types."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Predicates.md:347
#, markdown-text, no-wrap
msgid "The `Elem` Predicate"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:351
#, markdown-text
msgid ""
"Assume we'd like to extract a value of a given type from a heterogeneous "
"list:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:352
#, no-wrap
msgid "get' : (0 t : Type) -> HList ts -> t\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:358
#, markdown-text
msgid ""
"This can't work in general: If we could implement this we would immediately "
"have a proof of void:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:359
#, no-wrap
msgid ""
"voidAgain : Void\n"
"voidAgain = get' Void []\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:367
#, markdown-text
msgid ""
"The problem is obvious: The type of which we'd like to extract a value must "
"be an element of the index of the heterogeneous list.  Here is a predicate, "
"with which we can express this:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:368
#, no-wrap
msgid ""
"data Elem : (elem : a) -> (as : List a) -> Type where\n"
"  Here  : Elem x (x :: xs)\n"
"  There : Elem x xs -> Elem x (y :: xs)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:386
#, markdown-text
msgid ""
"This is a predicate describing a contract between two values: A value of "
"type `a` and a list of `a`s. Values of this predicate are witnesses that the "
"value is an element of the list.  Note, how this is defined recursively: The "
"case where the value we look for is at the head of the list is handled by "
"the `Here` constructor, where the same variable (`x`) is used for the "
"element and the head of the list. The case where the value is deeper within "
"the list is handled by the `There` constructor. This can be read as follows: "
"If `x` is and element of `xs`, then `x` is also an element of `y :: xs` for "
"any value `y`. Let's write down some examples to get a feel for these:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:387
#, no-wrap
msgid ""
"MyList : List Nat\n"
"MyList = [1,3,7,8,4,12]\n"
"\n"
"oneElemMyList : Elem 1 MyList\n"
"oneElemMyList = Here\n"
"\n"
"sevenElemMyList : Elem 7 MyList\n"
"sevenElemMyList = There $ There Here\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:402
#, markdown-text
msgid ""
"Now, `Elem` is just another way of indexing into a list of values. Instead "
"of using a `Fin` index, which is limited by the list's length, we use a "
"proof that a value can be found at a certain position."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:405
#, markdown-text
msgid ""
"We can use the `Elem` predicate to extract a value from the desired type of "
"a heterogeneous list:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:406
#, no-wrap
msgid "get : (0 t : Type) -> HList ts -> (prf : Elem t ts) => t\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:415
#, markdown-text
msgid ""
"It is important to note that the auto implicit must not be erased in this "
"case. This is no longer a single value data type, and we must be able to "
"pattern match on this value in order to figure out, how far within the "
"heterogeneous list our value is stored:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:416
#, no-wrap
msgid ""
"get t (v :: vs) {prf = Here}    = v\n"
"get t (v :: vs) {prf = There p} = get t vs\n"
"get _ [] impossible\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:425
#, markdown-text
msgid ""
"It can be instructive to implement `get` yourself, using holes on the right "
"hand side to see the context and types of values Idris infers based on the "
"value of the `Elem` predicate."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:427
#, markdown-text
msgid "Let's give this a spin at the REPL:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Predicates.md:428
#, no-wrap
msgid ""
"Tutorial.Predicates> get Nat [\"foo\", Just \"bar\", S Z]\n"
"1\n"
"Tutorial.Predicates> get Nat [\"foo\", Just \"bar\"]\n"
"Error: Can't find an implementation for Elem Nat [String, Maybe String].\n"
"\n"
"(Interactive):1:1--1:28\n"
" 1 | get Nat [\"foo\", Just \"bar\"]\n"
"     ^^^^^^^^^^^^^^^^^^^^^^^^^^^\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:446
#, markdown-text
msgid ""
"With this example we start to appreciate what *proof search* actually means: "
"Given a value `v` and a list of values `vs`, Idris tries to find a proof "
"that `v` is an element of `vs`.  Now, before we continue, please note that "
"proof search is not a silver bullet. The search algorithm has a reasonably "
"limited *search depth*, and will fail with the search if this limit is "
"exceeded. For instance:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:447
#, no-wrap
msgid ""
"Tps : List Type\n"
"Tps = List.replicate 50 Nat ++ [Maybe String]\n"
"\n"
"hlist : HList Tps\n"
"hlist = [ 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n"
"        , 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n"
"        , 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n"
"        , 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n"
"        , 0, 0, 0, 0, 0, 0, 0, 0, 0, 0\n"
"        , Nothing ]\n"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Predicates.md:462
#, no-wrap
msgid ""
"Tutorial.Predicates> get (Maybe String) hlist\n"
"Error: Can't find an implementation for Elem (Maybe String) [Nat,...\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:474
#, markdown-text
msgid ""
"As you can see, Idris fails to find a proof that `Maybe String` is an "
"element of `Tps`. The search depth can be increased with the "
"`%auto_implicit_depth` directive, which will hold for the rest of the source "
"file or until set to a different value.  The default value is set at 25. In "
"general, it is not advisable to set this to a too large value as this can "
"drastically increase compile times."
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:475
#, no-wrap
msgid ""
"%auto_implicit_depth 100\n"
"aMaybe : Maybe String\n"
"aMaybe = get _ hlist\n"
"\n"
"%auto_implicit_depth 25\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Predicates.md:483
#, markdown-text, no-wrap
msgid "Use Case: A nicer Schema"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:492
#, markdown-text
msgid ""
"In the chapter about [sigma types](DPair.md), we introduced a schema for CSV "
"files. This was not very nice to use, because we had to use natural numbers "
"to access a certain column. Even worse, users of our small library had to do "
"the same. There was no way to define a name for each column and access "
"columns by name. We are going to change this. Here is an encoding for this "
"use case:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:493
#, no-wrap
msgid ""
"data ColType = I64 | Str | Boolean | Float\n"
"\n"
"IdrisType : ColType -> Type\n"
"IdrisType I64     = Int64\n"
"IdrisType Str     = String\n"
"IdrisType Boolean = Bool\n"
"IdrisType Float   = Double\n"
"\n"
"record Column where\n"
"  constructor MkColumn\n"
"  name : String\n"
"  type : ColType\n"
"\n"
"infixr 8 :>\n"
"\n"
"(:>) : String -> ColType -> Column\n"
"(:>) = MkColumn\n"
"\n"
"Schema : Type\n"
"Schema = List Column\n"
"\n"
"Show ColType where\n"
"  show I64     = \"I64\"\n"
"  show Str     = \"Str\"\n"
"  show Boolean = \"Boolean\"\n"
"  show Float   = \"Float\"\n"
"\n"
"Show Column where\n"
"  show (MkColumn n ct) = \"\\{n}:\\{show ct}\"\n"
"\n"
"showSchema : Schema -> String\n"
"showSchema = concat . intersperse \",\" . map show\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:531
#, markdown-text
msgid ""
"As you can see, in a schema we now pair a column's type with its name. Here "
"is an example schema for a CSV file holding information about employees in a "
"company:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:532
#, no-wrap
msgid ""
"EmployeeSchema : Schema\n"
"EmployeeSchema = [ \"firstName\"  :> Str\n"
"                 , \"lastName\"   :> Str\n"
"                 , \"email\"      :> Str\n"
"                 , \"age\"        :> I64\n"
"                 , \"salary\"     :> Float\n"
"                 , \"management\" :> Boolean\n"
"                 ]\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:549
#, markdown-text
msgid ""
"Such a schema could of course again be read from user input, but we will "
"wait with implementing a parser until later in this chapter.  Using this new "
"schema with an `HList` directly led to issues with type inference, therefore "
"I quickly wrote a custom row type: A heterogeneous list indexed over a "
"schema."
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:550
#, no-wrap
msgid ""
"data Row : Schema -> Type where\n"
"  Nil  : Row []\n"
"\n"
"  (::) :  {0 name : String}\n"
"       -> {0 type : ColType}\n"
"       -> (v : IdrisType type)\n"
"       -> Row ss\n"
"       -> Row (name :> type :: ss)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:565
#, markdown-text
msgid ""
"In the signature of *cons*, I list the erased implicit arguments "
"explicitly. This is good practice, as otherwise Idris will often issue "
"shadowing warnings when using such data constructors in client code."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:567
#, markdown-text
msgid "We can now define a type alias for CSV rows representing employees:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:568
#, no-wrap
msgid ""
"0 Employee : Type\n"
"Employee = Row EmployeeSchema\n"
"\n"
"hock : Employee\n"
"hock = [ \"Stefan\", \"Hck\", \"hock@foo.com\", 46, 5443.2, False ]\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:584
#, markdown-text
msgid ""
"Note, how I gave `Employee` a zero quantity. This means, we are only ever "
"allowed to use this function at compile time but never at runtime. This is a "
"safe way to make sure our type-level functions and aliases do not leak into "
"the executable when we build our application. We are allowed to use "
"zero-quantity functions and values in type signatures and when computing "
"other erased values, but not for runtime-relevant computations."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:602
#, markdown-text
msgid ""
"We would now like to access a value in a row based on the name given. For "
"this, we write a custom predicate, which serves as a witness that a column "
"with the given name is part of the schema. Now, here is an important thing "
"to note: In this predicate we include an index for the *type* of the column "
"with the given name. We need this, because when we access a column by name, "
"we need a way to figure out the return type. But during proof search, this "
"type will have to be derived by Idris based on the column name and schema in "
"question (otherwise, the proof search will fail unless the return type is "
"known in advance).  We therefore *must* tell Idris, that it can't include "
"this type in the list of search criteria, otherwise it will try and infer "
"the column type from the context (using type inference) before running the "
"proof search. This can be done by listing the indices to be used in the "
"search like so: `[search name schema]`."
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:603
#, no-wrap
msgid ""
"data InSchema :  (name    : String)\n"
"              -> (schema  : Schema)\n"
"              -> (colType : ColType)\n"
"              -> Type where\n"
"  [search name schema]\n"
"  IsHere  : InSchema n (n :> t :: ss) t\n"
"  IsThere : InSchema n ss t -> InSchema n (fld :: ss) t\n"
"\n"
"Uninhabited (InSchema n [] c) where\n"
"  uninhabited IsHere impossible\n"
"  uninhabited (IsThere _) impossible\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:619
#, markdown-text
msgid ""
"With this, we are now ready to access the value at a given column based on "
"the column's name:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:620
#, no-wrap
msgid ""
"getAt :  {0 ss : Schema}\n"
"      -> (name : String)\n"
"      -> (row  : Row ss)\n"
"      -> (prf  : InSchema name ss c)\n"
"      => IdrisType c\n"
"getAt name (v :: vs) {prf = IsHere}    = v\n"
"getAt name (_ :: vs) {prf = IsThere p} = getAt name vs\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:638
#, markdown-text
msgid ""
"Below is an example how to use this at compile time. Note the amount of work "
"Idris performs for us: It first comes up with proofs that `firstName`, "
"`lastName`, and `age` are indeed valid names in the `Employee` schema. From "
"these proofs it automatically figures out the return types of the calls to "
"`getAt` and extracts the corresponding values from the row. All of this "
"happens in a provably total and type safe way."
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:639
#, no-wrap
msgid ""
"shoeck : String\n"
"shoeck =  getAt \"firstName\" hock\n"
"       ++ \" \"\n"
"       ++ getAt \"lastName\" hock\n"
"       ++ \": \"\n"
"       ++ show (getAt \"age\" hock)\n"
"       ++ \" years old.\"\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:657
#, markdown-text
msgid ""
"In order to at runtime specify a column name, we need a way for computing "
"values of type `InSchema` by comparing the column names with the schema in "
"question. Since we have to compare two string values for being "
"propositionally equal, we use the `DecEq` implementation for `String` here "
"(Idris provides `DecEq` implementations for all primitives). We extract the "
"column type at the same time and pair this (as a dependent pair) with the "
"`InSchema` proof:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:658
#, no-wrap
msgid ""
"inSchema : (ss : Schema) -> (n : String) -> Maybe (c ** InSchema n ss c)\n"
"inSchema []                    _ = Nothing\n"
"inSchema (MkColumn cn t :: xs) n = case decEq cn n of\n"
"  Yes Refl   => Just (t ** IsHere)\n"
"  No  contra => case inSchema xs n of\n"
"    Just (t ** prf) => Just $ (t ** IsThere prf)\n"
"    Nothing         => Nothing\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:671
#, markdown-text
msgid ""
"At the end of this chapter we will use `InSchema` in our CSV command-line "
"application to list all values in a column."
msgstr ""

#. type: Bullet: '1. '
#: ../src/Tutorial/Predicates.md:676
#, markdown-text
msgid ""
"Show that `InSchema` is decidable by changing the output type of `inSchema` "
"to `Dec (c ** InSchema n ss c)`."
msgstr ""

#. type: Bullet: '2. '
#: ../src/Tutorial/Predicates.md:679
#, markdown-text
msgid ""
"Declare and implement a function for modifying a field in a row based on the "
"column name given."
msgstr ""

#. type: Bullet: '3. '
#: ../src/Tutorial/Predicates.md:684
#, markdown-text
msgid ""
"Define a predicate to be used as a witness that one list contains only "
"elements in the second list in the same order and use this predicate to "
"extract several columns from a row at once."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:688
#, markdown-text, no-wrap
msgid ""
"   For instance, `[2,4,5]` contains elements from\n"
"   `[1,2,3,4,5,6]` in the correct order, but `[4,2,5]`\n"
"   does not.\n"
msgstr ""

#. type: Bullet: '4. '
#: ../src/Tutorial/Predicates.md:694
#, markdown-text
msgid ""
"Improve the functionality from exercise 3 by defining a new predicate, "
"witnessing that all strings in a list correspond to column names in a schema "
"(in arbitrary order).  Use this to extract several columns from a row at "
"once in arbitrary order."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:698
#, markdown-text, no-wrap
msgid ""
"   Hint: Make sure to include the resulting schema as an index,\n"
"   but search only based on the list of names and the input\n"
"   schema.\n"
msgstr ""

#. type: Title ##
#: ../src/Tutorial/Predicates.md:699
#, markdown-text, no-wrap
msgid "Use Case: Flexible Error Handling"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:718
#, markdown-text
msgid ""
"A recurring pattern when writing larger applications is the combination of "
"different parts of a program each with their own failure types in a larger "
"effectful computation.  We saw this, for instance, when implementing a "
"command-line tool for handling CSV files. There, we read and wrote data from "
"and to files, we parsed column types and schemata, we parsed row and column "
"indices and command-line commands.  All these operations came with the "
"potential of failure and might be implemented in different parts of our "
"application.  In order to unify these different failure types, we wrote a "
"custom sum type encapsulating each of them, and wrote a single handler for "
"this sum type. This approach was alright then, but it does not scale well "
"and is lacking in terms of flexibility. We are therefore trying a different "
"approach here. Before we continue, we quickly implement a couple of "
"functions with the potential of failure plus some custom error types:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:719
#, no-wrap
msgid ""
"record NoNat where\n"
"  constructor MkNoNat\n"
"  str : String\n"
"\n"
"readNat' : String -> Either NoNat Nat\n"
"readNat' s = maybeToEither (MkNoNat s) $ parsePositive s\n"
"\n"
"record NoColType where\n"
"  constructor MkNoColType\n"
"  str : String\n"
"\n"
"readColType' : String -> Either NoColType ColType\n"
"readColType' \"I64\"     = Right I64\n"
"readColType' \"Str\"     = Right Str\n"
"readColType' \"Boolean\" = Right Boolean\n"
"readColType' \"Float\"   = Right Float\n"
"readColType' s         = Left $ MkNoColType s\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:746
#, markdown-text
msgid ""
"However, if we wanted to parse a `Fin n`, there'd be already two ways how "
"this could fail: The string in question could not represent a natural number "
"(leading to a `NoNat` error), or it could be out of bounds (leading to an "
"`OutOfBounds` error).  We have to somehow encode these two possibilities in "
"the return type, for instance, by using an `Either` as the error type:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:747
#, no-wrap
msgid ""
"record OutOfBounds where\n"
"  constructor MkOutOfBounds\n"
"  size  : Nat\n"
"  index : Nat\n"
"\n"
"readFin' : {n : _} -> String -> Either (Either NoNat OutOfBounds) (Fin n)\n"
"readFin' s = do\n"
"  ix <- mapFst Left (readNat' s)\n"
"  maybeToEither (Right $ MkOutOfBounds n ix) $ natToFin ix n\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:767
#, markdown-text
msgid ""
"This is incredibly ugly. A custom sum type might have been slightly better, "
"but we still would have to use `mapFst` when invoking `readNat'`, and "
"writing custom sum types for every possible combination of errors will get "
"cumbersome very quickly as well.  What we are looking for, is a generalized "
"sum type: A type indexed by a list of types (the possible choices) holding a "
"single value of exactly one of the types in question.  Here is a first naive "
"try:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:768
#, no-wrap
msgid ""
"data Sum : List Type -> Type where\n"
"  MkSum : (val : t) -> Sum ts\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:783
#, markdown-text
msgid ""
"However, there is a crucial piece of information missing: We have not "
"verified that `t` is an element of `ts`, nor *which* type it actually is. In "
"fact, this is another case of an erased existential, and we will have no way "
"to at runtime learn something about `t`. What we need to do is to pair the "
"value with a proof, that its type `t` is an element of `ts`.  We could use "
"`Elem` again for this, but for some use cases we will require access to the "
"number of types in the list.  We will therefore use a vector instead of a "
"list as our index.  Here is a predicate similar to `Elem` but for vectors:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:784
#, no-wrap
msgid ""
"data Has :  (v : a) -> (vs  : Vect n a) -> Type where\n"
"  Z : Has v (v :: vs)\n"
"  S : Has v vs -> Has v (w :: vs)\n"
"\n"
"Uninhabited (Has v []) where\n"
"  uninhabited Z impossible\n"
"  uninhabited (S _) impossible\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:797
#, markdown-text
msgid ""
"A value of type `Has v vs` is a witness that `v` is an element of `vs`. With "
"this, we can now implement an indexed sum type (also called an *open "
"union*):"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:798
#, no-wrap
msgid ""
"data Union : Vect n Type -> Type where\n"
"  U : (ix : Has t ts) -> (val : t) -> Union ts\n"
"\n"
"Uninhabited (Union []) where\n"
"  uninhabited (U ix _) = absurd ix\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:811
#, markdown-text
msgid ""
"Note the difference between `HList` and `Union`. `HList` is a *generalized "
"product type*: It holds a value for each type in its index. `Union` is a "
"*generalized sum type*: It holds only a single value, which must be of a "
"type listed in the index.  With this we can now define a much more flexible "
"error type:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:812
#, no-wrap
msgid ""
"0 Err : Vect n Type -> Type -> Type\n"
"Err ts t = Either (Union ts) t\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:820
#, markdown-text
msgid ""
"A function returning an `Err ts a` describes a computation, which can fail "
"with one of the errors listed in `ts`.  We first need some utility "
"functions."
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:821
#, no-wrap
msgid ""
"inject : (prf : Has t ts) => (v : t) -> Union ts\n"
"inject v = U prf v\n"
"\n"
"fail : Has t ts => (err : t) -> Err ts a\n"
"fail err = Left $ inject err\n"
"\n"
"failMaybe : Has t ts => (err : Lazy t) -> Maybe a -> Err ts a\n"
"failMaybe err = maybeToEither (inject err)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:834
#, markdown-text
msgid "Next, we can write more flexible versions of the parsers we wrote above:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:835
#, no-wrap
msgid ""
"readNat : Has NoNat ts => String -> Err ts Nat\n"
"readNat s = failMaybe (MkNoNat s) $ parsePositive s\n"
"\n"
"readColType : Has NoColType ts => String -> Err ts ColType\n"
"readColType \"I64\"     = Right I64\n"
"readColType \"Str\"     = Right Str\n"
"readColType \"Boolean\" = Right Boolean\n"
"readColType \"Float\"   = Right Float\n"
"readColType s         = fail $ MkNoColType s\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:849
#, markdown-text
msgid ""
"Before we implement `readFin`, we introduce a short cut for specifying that "
"several error types must be present:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:850
#, no-wrap
msgid ""
"0 Errs : List Type -> Vect n Type -> Type\n"
"Errs []        _  = ()\n"
"Errs (x :: xs) ts = (Has x ts, Errs xs ts)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:860
#, markdown-text
msgid ""
"Function `Errs` returns a tuple of constraints. This can be used as a "
"witness that all listed types are present in the vector of types: Idris will "
"automatically extract the proofs from the tuple as needed."
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:862
#, no-wrap
msgid ""
"readFin : {n : _} -> Errs [NoNat, OutOfBounds] ts => String -> Err ts (Fin "
"n)\n"
"readFin s = do\n"
"  S ix <- readNat s | Z => fail (MkOutOfBounds n Z)\n"
"  failMaybe (MkOutOfBounds n (S ix)) $ natToFin ix n\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:871
#, markdown-text
msgid "As a last example, here are parsers for schemata and CSV rows:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:872
#, no-wrap
msgid ""
"fromCSV : String -> List String\n"
"fromCSV = forget . split (',' ==)\n"
"\n"
"record InvalidColumn where\n"
"  constructor MkInvalidColumn\n"
"  str : String\n"
"\n"
"readColumn : Errs [InvalidColumn, NoColType] ts => String -> Err ts Column\n"
"readColumn s = case forget $ split (':' ==) s of\n"
"  [n,ct] => MkColumn n <$> readColType ct\n"
"  _      => fail $ MkInvalidColumn s\n"
"\n"
"readSchema : Errs [InvalidColumn, NoColType] ts => String -> Err ts Schema\n"
"readSchema = traverse readColumn . fromCSV\n"
"\n"
"data RowError : Type where\n"
"  InvalidField  : (row, col : Nat) -> (ct : ColType) -> String -> RowError\n"
"  UnexpectedEOI : (row, col : Nat) -> RowError\n"
"  ExpectedEOI   : (row, col : Nat) -> RowError\n"
"\n"
"decodeField :  Has RowError ts\n"
"            => (row,col : Nat)\n"
"            -> (c : ColType)\n"
"            -> String\n"
"            -> Err ts (IdrisType c)\n"
"decodeField row col c s =\n"
"  let err = InvalidField row col c s\n"
"   in case c of\n"
"        I64     => failMaybe err $ read s\n"
"        Str     => failMaybe err $ read s\n"
"        Boolean => failMaybe err $ read s\n"
"        Float   => failMaybe err $ read s\n"
"\n"
"decodeRow :  Has RowError ts\n"
"          => {s : _}\n"
"          -> (row : Nat)\n"
"          -> (str : String)\n"
"          -> Err ts (Row s)\n"
"decodeRow row = go 1 s . fromCSV\n"
"  where go : Nat -> (cs : Schema) -> List String -> Err ts (Row cs)\n"
"        go k []       []                    = Right []\n"
"        go k []       (_ :: _)              = fail $ ExpectedEOI row k\n"
"        go k (_ :: _) []                    = fail $ UnexpectedEOI row k\n"
"        go k (MkColumn n c :: cs) (s :: ss) =\n"
"          [| decodeField row k c s :: go (S k) cs ss |]\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:925
#, markdown-text
msgid ""
"Here is an example REPL session, where I test `readSchema`. I defined "
"variable `ts` using the `:let` command to make this more convenient.  Note, "
"how the order of error types is of no importance, as long as types "
"`InvalidColumn` and `NoColType` are present in the list of errors:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Predicates.md:926
#, no-wrap
msgid ""
"Tutorial.Predicates> :let ts = the (Vect 3 _) "
"[NoColType,NoNat,InvalidColumn]\n"
"Tutorial.Predicates> readSchema {ts} \"foo:bar\"\n"
"Left (U Z (MkNoColType \"bar\"))\n"
"Tutorial.Predicates> readSchema {ts} \"foo:Float\"\n"
"Right [MkColumn \"foo\" Float]\n"
"Tutorial.Predicates> readSchema {ts} \"foo Float\"\n"
"Left (U (S (S Z)) (MkInvalidColumn \"foo Float\"))\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Predicates.md:936
#, markdown-text, no-wrap
msgid "Error Handling"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:943
#, markdown-text
msgid ""
"There are several techniques for handling errors, all of which are useful at "
"times. For instance, we might want to handle some errors early on and "
"individually, while dealing with others much later in our application. Or we "
"might want to handle them all in one fell swoop. We look at both approaches "
"here."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:950
#, markdown-text
msgid ""
"First, in order to handle a single error individually, we need to *split* a "
"union into one of two possibilities: A value of the error type in question "
"or a new union, holding one of the other error types. We need a new "
"predicate for this, which not only encodes the presence of a value in a "
"vector but also the result of removing that value:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:951
#, no-wrap
msgid ""
"data Rem : (v : a) -> (vs : Vect (S n) a) -> (rem : Vect n a) -> Type "
"where\n"
"  [search v vs]\n"
"  RZ : Rem v (v :: rem) rem\n"
"  RS : Rem v vs rem -> Rem v (w :: vs) (w :: rem)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:962
#, markdown-text
msgid ""
"Once again, we want to use one of the indices (`rem`) in our functions' "
"return types, so we only use the other indices during proof search. Here is "
"a function for splitting off a value from an open union:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:963
#, no-wrap
msgid ""
"split : (prf : Rem t ts rem) => Union ts -> Either t (Union rem)\n"
"split {prf = RZ}   (U Z     val) = Left val\n"
"split {prf = RZ}   (U (S x) val) = Right (U x val)\n"
"split {prf = RS p} (U Z     val) = Right (U Z val)\n"
"split {prf = RS p} (U (S x) val) = case split {prf = p} (U x val) of\n"
"  Left vt        => Left vt\n"
"  Right (U ix y) => Right $ U (S ix) y\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:977
#, markdown-text
msgid ""
"This tries to extract a value of type `t` from a union. If it works, the "
"result is wrapped in a `Left`, otherwise a new union is returned in a "
"`Right`, but this one has `t` removed from its list of possible types."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:982
#, markdown-text
msgid ""
"With this, we can implement a handler for single errors.  Error handling "
"often happens in an effectful context (we might want to print a message to "
"the console or write the error to a log file), so we use an applicative "
"effect type to handle errors in."
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:983
#, no-wrap
msgid ""
"handle :  Applicative f\n"
"       => Rem t ts rem\n"
"       => (h : t -> f a)\n"
"       -> Err ts a\n"
"       -> f (Err rem a)\n"
"handle h (Left x)  = case split x of\n"
"  Left v    => Right <$> h v\n"
"  Right err => pure $ Left err\n"
"handle _ (Right x) = pure $ Right x\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:998
#, markdown-text
msgid ""
"For handling all errors at once, we can use a handler type indexed by the "
"vector of errors, and parameterized by the output type:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:999
#, no-wrap
msgid ""
"namespace Handler\n"
"  public export\n"
"  data Handler : (ts : Vect n Type) -> (a : Type) -> Type where\n"
"    Nil  : Handler [] a\n"
"    (::) : (t -> a) -> Handler ts a -> Handler (t :: ts) a\n"
"\n"
"extract : Handler ts a -> Has t ts -> t -> a\n"
"extract (f :: _)  Z     val = f val\n"
"extract (_ :: fs) (S y) val = extract fs y val\n"
"extract []        ix    _   = absurd ix\n"
"\n"
"handleAll : Applicative f => Handler ts (f a) -> Err ts a -> f a\n"
"handleAll _ (Right v)       = pure v\n"
"handleAll h (Left $ U ix v) = extract h ix v\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:1019
#, markdown-text
msgid ""
"Below, we will see an additional way of handling all errors at once by "
"defining a custom interface for error handling."
msgstr ""

#. type: Bullet: '1. '
#: ../src/Tutorial/Predicates.md:1023
#, markdown-text
msgid "Implement the following utility functions for `Union`:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:1024
#, no-wrap
msgid ""
"   project : (0 t : Type) -> (prf : Has t ts) => Union ts -> Maybe t\n"
"\n"
"   project1 : Union [t] -> t\n"
"\n"
"   safe : Err [] a -> a\n"
msgstr ""

#. type: Bullet: '2. '
#: ../src/Tutorial/Predicates.md:1034
#, markdown-text
msgid ""
"Implement the following two functions for embedding an open union in a "
"larger set of possibilities.  Note the unerased implicit in `extend`!"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:1035
#, no-wrap
msgid ""
"   weaken : Union ts -> Union (ts ++ ss)\n"
"\n"
"   extend : {m : _} -> {0 pre : Vect m _} -> Union ts -> Union (pre ++ ts)\n"
msgstr ""

#. type: Bullet: '3. '
#: ../src/Tutorial/Predicates.md:1043
#, markdown-text
msgid ""
"Find a general way to embed a `Union ts` in a `Union ss`, so that the "
"following is possible:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:1044
#, no-wrap
msgid ""
"   embedTest :  Err [NoNat,NoColType] a\n"
"             -> Err [FileError, NoColType, OutOfBounds, NoNat] a\n"
"   embedTest = mapFst embed\n"
msgstr ""

#. type: Bullet: '4. '
#: ../src/Tutorial/Predicates.md:1052
#, markdown-text
msgid ""
"Make `handle` more powerful, by letting the handler convert the error in "
"question to an `f (Err rem a)`."
msgstr ""

#. type: Title ##
#: ../src/Tutorial/Predicates.md:1053
#, markdown-text, no-wrap
msgid "The Truth about Interfaces"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:1065
#, markdown-text
msgid ""
"Well, here it finally is: The truth about interfaces. Internally, an "
"interface is just a record data type, with its fields corresponding to the "
"members of the interface. An interface implementation is a *value* of such a "
"record, annotated with a `%hint` pragma (see below) to make the value "
"available during proof search. Finally, a constrained function is just a "
"function with one or more auto implicit arguments. For instance, here is the "
"same function for looking up an element in a list, once with the known "
"syntax for constrained functions, and once with an auto implicit "
"argument. The code produced by Idris is the same in both cases:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:1066
#, no-wrap
msgid ""
"isElem1 : Eq a => a -> List a -> Bool\n"
"isElem1 v []        = False\n"
"isElem1 v (x :: xs) = x == v || isElem1 v xs\n"
"\n"
"isElem2 : {auto _ : Eq a} -> a -> List a -> Bool\n"
"isElem2 v []        = False\n"
"isElem2 v (x :: xs) = x == v || isElem2 v xs\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:1079
#, markdown-text
msgid ""
"Being mere records, we can also take interfaces as regular function "
"arguments and dissect them with a pattern match:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:1080
#, no-wrap
msgid ""
"eq : Eq a -> a -> a -> Bool\n"
"eq (MkEq feq fneq) = feq\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Predicates.md:1085
#, markdown-text, no-wrap
msgid "A manual Interface Definition"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:1093
#, markdown-text
msgid ""
"I'll now demonstrate how we can achieve the same behavior with proof search "
"as with a regular interface definition plus implementations. Since I want to "
"finish the CSV example with our new error handling tools, we are going to "
"implement some error handlers.  First, an interface is just a record:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:1094
#, no-wrap
msgid ""
"record Print a where\n"
"  constructor MkPrint\n"
"  print' : a -> String\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:1104
#, markdown-text
msgid ""
"In order to access the record in a constrained function, we use the "
"`%search` keyword, which will try to conjure a value of the desired type "
"(`Print a` in this case) by means of a proof search:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:1105
#, no-wrap
msgid ""
"print : Print a => a -> String\n"
"print = print' %search\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:1112
#, markdown-text
msgid ""
"As an alternative, we could use a named constraint, and access it directly "
"via its name:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:1113
#, no-wrap
msgid ""
"print2 : (impl : Print a) => a -> String\n"
"print2 = print' impl\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:1120
#, markdown-text
msgid ""
"As yet another alternative, we could use the syntax for auto implicit "
"arguments:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:1121
#, no-wrap
msgid ""
"print3 : {auto impl : Print a} -> a -> String\n"
"print3 = print' impl\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:1129
#, markdown-text, no-wrap
msgid ""
"All three versions of `print` behave exactly the same at runtime.\n"
"So, whenever we write `{auto x : Foo} ->` we can just as well\n"
"write `(x : Foo) =>` and vice versa.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:1133
#, markdown-text
msgid ""
"Interface implementations are just values of the given record type, but in "
"order to be available during proof search, these need to be annotated with a "
"`%hint` pragma:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:1134
#, no-wrap
msgid ""
"%hint\n"
"noNatPrint : Print NoNat\n"
"noNatPrint = MkPrint $ \\e => \"Not a natural number: \\{e.str}\"\n"
"\n"
"%hint\n"
"noColTypePrint : Print NoColType\n"
"noColTypePrint = MkPrint $ \\e => \"Not a column type: \\{e.str}\"\n"
"\n"
"%hint\n"
"outOfBoundsPrint : Print OutOfBounds\n"
"outOfBoundsPrint = MkPrint $ \\e => \"Index is out of bounds: \\{show "
"e.index}\"\n"
"\n"
"%hint\n"
"rowErrorPrint : Print RowError\n"
"rowErrorPrint = MkPrint $\n"
"  \\case InvalidField r c ct s =>\n"
"          \"Not a \\{show ct} in row \\{show r}, column \\{show "
"c}. \\{s}\"\n"
"        UnexpectedEOI r c =>\n"
"          \"Unexpected end of input in row \\{show r}, column \\{show "
"c}.\"\n"
"        ExpectedEOI r c =>\n"
"          \"Expected end of input in row \\{show r}, column \\{show c}.\"\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:1162
#, markdown-text
msgid ""
"We can also write an implementation of `Print` for a union or errors. For "
"this, we first come up with a proof that all types in the union's index come "
"with an implementation of `Print`:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:1163
#, no-wrap
msgid ""
"0 All : (f : a -> Type) -> Vect n a -> Type\n"
"All f []        = ()\n"
"All f (x :: xs) = (f x, All f xs)\n"
"\n"
"unionPrintImpl : All Print ts => Union ts -> String\n"
"unionPrintImpl (U Z val)     = print val\n"
"unionPrintImpl (U (S x) val) = unionPrintImpl $ U x val\n"
"\n"
"%hint\n"
"unionPrint : All Print ts => Print (Union ts)\n"
"unionPrint = MkPrint unionPrintImpl\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:1184
#, markdown-text
msgid ""
"Defining interfaces this way can be an advantage, as there is much less "
"magic going on, and we have more fine grained control over the types and "
"values of our fields. Note also, that all of the magic comes from the search "
"hints, with which our \"interface implementations\" were annotated.  These "
"made the corresponding values and functions available during proof search."
msgstr ""

#. type: Title ####
#: ../src/Tutorial/Predicates.md:1185
#, markdown-text, no-wrap
msgid "Parsing CSV Commands"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:1195
#, markdown-text
msgid ""
"To conclude this chapter, we reimplement our CSV command parser, using the "
"flexible error handling approach from the last section. While not "
"necessarily less verbose than the original parser, this approach decouples "
"the handling of errors and printing of error messages from the rest of the "
"application: Functions with a possibility of failure are reusable in "
"different contexts, as are the pretty printers we use for the error "
"messages."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:1198
#, markdown-text
msgid ""
"First, we repeat some stuff from earlier chapters. I sneaked in a new "
"command for printing all values in a column:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:1199
#, no-wrap
msgid ""
"record Table where\n"
"  constructor MkTable\n"
"  schema : Schema\n"
"  size   : Nat\n"
"  rows   : Vect size (Row schema)\n"
"\n"
"data Command : (t : Table) -> Type where\n"
"  PrintSchema :  Command t\n"
"  PrintSize   :  Command t\n"
"  New         :  (newSchema : Schema) -> Command t\n"
"  Prepend     :  Row (schema t) -> Command t\n"
"  Get         :  Fin (size t) -> Command t\n"
"  Delete      :  Fin (size t) -> Command t\n"
"  Col         :  (name : String)\n"
"              -> (tpe  : ColType)\n"
"              -> (prf  : InSchema name t.schema tpe)\n"
"              -> Command t\n"
"  Quit        : Command t\n"
"\n"
"applyCommand : (t : Table) -> Command t -> Table\n"
"applyCommand t                 PrintSchema = t\n"
"applyCommand t                 PrintSize   = t\n"
"applyCommand _                 (New ts)    = MkTable ts _ []\n"
"applyCommand (MkTable ts n rs) (Prepend r) = MkTable ts _ $ r :: rs\n"
"applyCommand t                 (Get x)     = t\n"
"applyCommand t                 Quit        = t\n"
"applyCommand t                 (Col _ _ _) = t\n"
"applyCommand (MkTable ts n rs) (Delete x)  = case n of\n"
"  S k => MkTable ts k (deleteAt x rs)\n"
"  Z   => absurd x\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:1235
#, markdown-text
msgid ""
"Next, below is the command parser reimplemented. In total, it can fail in "
"seven different was, at least some of which might also be possible in other "
"parts of a larger application."
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:1236
#, no-wrap
msgid ""
"record UnknownCommand where\n"
"  constructor MkUnknownCommand\n"
"  str : String\n"
"\n"
"%hint\n"
"unknownCommandPrint : Print UnknownCommand\n"
"unknownCommandPrint = MkPrint $ \\v => \"Unknown command: \\{v.str}\"\n"
"\n"
"record NoColName where\n"
"  constructor MkNoColName\n"
"  str : String\n"
"\n"
"%hint\n"
"noColNamePrint : Print NoColName\n"
"noColNamePrint = MkPrint $ \\v => \"Unknown column: \\{v.str}\"\n"
"\n"
"0 CmdErrs : Vect 7 Type\n"
"CmdErrs = [ InvalidColumn\n"
"          , NoColName\n"
"          , NoColType\n"
"          , NoNat\n"
"          , OutOfBounds\n"
"          , RowError\n"
"          , UnknownCommand ]\n"
"\n"
"readCommand : (t : Table) -> String -> Err CmdErrs (Command t)\n"
"readCommand _                \"schema\"  = Right PrintSchema\n"
"readCommand _                \"size\"    = Right PrintSize\n"
"readCommand _                \"quit\"    = Right Quit\n"
"readCommand (MkTable ts n _) s         = case words s of\n"
"  [\"new\",    str] => New     <$> readSchema str\n"
"  \"add\" ::   ss   => Prepend <$> decodeRow 1 (unwords ss)\n"
"  [\"get\",    str] => Get     <$> readFin str\n"
"  [\"delete\", str] => Delete  <$> readFin str\n"
"  [\"column\", str] => case inSchema ts str of\n"
"    Just (ct ** prf) => Right $ Col str ct prf\n"
"    Nothing          => fail $ MkNoColName str\n"
"  _               => fail $ MkUnknownCommand s\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:1280
#, markdown-text
msgid ""
"Note, how we could invoke functions like `readFin` or `readSchema` directly, "
"because the necessary error types are part of our list of possible errors."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:1286
#, markdown-text
msgid ""
"To conclude this sections, here is the functionality for printing the result "
"of a command plus the application's main loop. Most of this is repeated from "
"earlier chapters, but note how we can handle all errors at once with a "
"single call to `print`:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Predicates.md:1287
#, no-wrap
msgid ""
"encodeField : (t : ColType) -> IdrisType t -> String\n"
"encodeField I64     x     = show x\n"
"encodeField Str     x     = show x\n"
"encodeField Boolean True  = \"t\"\n"
"encodeField Boolean False = \"f\"\n"
"encodeField Float   x     = show x\n"
"\n"
"encodeRow : (s : Schema) -> Row s -> String\n"
"encodeRow s = concat . intersperse \",\" . go s\n"
"  where go : (s' : Schema) -> Row s' -> Vect (length s') String\n"
"        go []        []        = []\n"
"        go (MkColumn _ c :: cs) (v :: vs) = encodeField c v :: go cs vs\n"
"\n"
"encodeCol :  (name : String)\n"
"          -> (c    : ColType)\n"
"          -> InSchema name s c\n"
"          => Vect n (Row s)\n"
"          -> String\n"
"encodeCol name c = unlines . toList . map (\\r => encodeField c $ getAt name "
"r)\n"
"\n"
"result :  (t : Table) -> Command t -> String\n"
"result t PrintSchema   = \"Current schema: \\{showSchema t.schema}\"\n"
"result t PrintSize     = \"Current size: \\{show t.size}\"\n"
"result _ (New ts)      = \"Created table. Schema: \\{showSchema ts}\"\n"
"result t (Prepend r)   = \"Row prepended: \\{encodeRow t.schema r}\"\n"
"result _ (Delete x)    = \"Deleted row: \\{show $ FS x}.\"\n"
"result _ Quit          = \"Goodbye.\"\n"
"result t (Col n c prf) = \"Column \\{n}:\\n\\{encodeCol n c t.rows}\"\n"
"result t (Get x)       =\n"
"  \"Row \\{show $ FS x}: \\{encodeRow t.schema (index x t.rows)}\"\n"
"\n"
"covering\n"
"runProg : Table -> IO ()\n"
"runProg t = do\n"
"  putStr \"Enter a command: \"\n"
"  str <- getLine\n"
"  case readCommand t str of\n"
"    Left err   => putStrLn (print err) >> runProg t\n"
"    Right Quit => putStrLn (result t Quit)\n"
"    Right cmd  => putStrLn (result t cmd) >>\n"
"                  runProg (applyCommand t cmd)\n"
"\n"
"covering\n"
"main : IO ()\n"
"main = runProg $ MkTable [] _ []\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:1336
#, markdown-text
msgid "Here is an example REPL session:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Predicates.md:1337
#, no-wrap
msgid ""
"Tutorial.Predicates> :exec main\n"
"Enter a command: new name:Str,age:Int64,salary:Float\n"
"Not a column type: Int64\n"
"Enter a command: new name:Str,age:I64,salary:Float\n"
"Created table. Schema: name:Str,age:I64,salary:Float\n"
"Enter a command: add John Doe,44,3500\n"
"Row prepended: \"John Doe\",44,3500.0\n"
"Enter a command: add Jane Doe,50,4000\n"
"Row prepended: \"Jane Doe\",50,4000.0\n"
"Enter a command: get 1\n"
"Row 1: \"Jane Doe\",50,4000.0\n"
"Enter a command: column salary\n"
"Column salary:\n"
"4000.0\n"
"3500.0\n"
"\n"
"Enter a command: quit\n"
"Goodbye.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Predicates.md:1367
#, markdown-text
msgid ""
"Predicates allow us to describe contracts between types and to refine the "
"values we accept as valid function arguments.  They allow us to make a "
"function safe and convenient to use at runtime *and* compile time by using "
"them as auto implicit arguments, which Idris should try to construct on its "
"own if it has enough information about the structure of a function's "
"arguments."
msgstr ""

#. type: Title #
#: ../src/Tutorial/Prim.md:1
#, markdown-text, no-wrap
msgid "Primitives"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:7
#, markdown-text
msgid ""
"In the topics we covered so far, we hardly ever talked about primitive types "
"in Idris. They where around and we used them in some computations, but I "
"never really explained how they work and where they come from, nor did I "
"show in detail what we can and can't do with them."
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:8
#, no-wrap
msgid ""
"module Tutorial.Prim\n"
"\n"
"import Data.Bits\n"
"import Data.String\n"
"\n"
"%default total\n"
msgstr ""

#. type: Title ##
#: ../src/Tutorial/Prim.md:17
#, markdown-text, no-wrap
msgid "How Primitives are Implemented"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Prim.md:19
#, markdown-text, no-wrap
msgid "A Short Note on Backends"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:30
#, markdown-text
msgid ""
"According to [Wikipedia](https://en.wikipedia.org/wiki/Compiler), a compiler "
"is \"a computer program that translates computer code written in one "
"programming language (the source language) into another language (the target "
"language)\". The Idris compiler is exactly that: A program translating "
"programs written in Idris into programs written in Chez Scheme. This scheme "
"code is then parsed and interpreted by a Chez Scheme interpreter, which must "
"be installed on the computers we use to run compiled Idris programs."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:37
#, markdown-text
msgid ""
"But that's only part of the story. Idris 2 was from the beginning designed "
"to support different code generators (so called *backends*), which allows us "
"to write Idris code to target different platforms, and your Idris "
"installation comes with several additional backends available. You can "
"specify the backend to use with the `--cg` command line argument (`cg` "
"stands for *code generator*). For instance:"
msgstr ""

#. type: Fenced code block (sh)
#: ../src/Tutorial/Prim.md:38
#, no-wrap
msgid "idris2 --cg racket\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:45
#, markdown-text
msgid ""
"Here is a non-comprehensive list of the backends available with a standard "
"Idris installation (the name to be used in the command line argument is "
"given in parentheses):"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:54
#, markdown-text
msgid ""
"Racket Scheme (`racket`): This is a different flavour of the scheme "
"programming language, which can be useful to use when Chez Scheme is not "
"available on your operating system."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:54
#, markdown-text
msgid "Node.js (`node`): This converts an Idris program to JavaScript."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:54
#, markdown-text
msgid ""
"Browser (`javascript`): Another JavaScript backend which allows you to write "
"web applications which run in the browser in Idris."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:54
#, markdown-text
msgid ""
"RefC (`refc`): A backend compiling Idris to C code, which is then further "
"compiled by a C compiler."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:57
#, markdown-text
msgid ""
"I plan to at least cover the JavaScript backends in some more detail in "
"another part of this Idris guide, as I use them pretty often myself."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:62
#, markdown-text
msgid ""
"There are also several external backends not officially supported by the "
"Idris project, amongst which are backends for compiling Idris code to Java "
"and Python. You can find a list of external backends on the [Idris "
"Wiki](https://github.com/idris-lang/Idris2/wiki/1-%5BLanguage%5D-External-backends)."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Prim.md:63
#, markdown-text, no-wrap
msgid "The Idris Primitives"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:69
#, markdown-text
msgid ""
"A *primitive data type* is a type that is built into the Idris compiler "
"together with a set of *primitive functions*, which are used to perform "
"calculations on the primitives. You will therefore not find a definition of "
"a primitive type or function in the source code of the *Prelude*."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:71
#, markdown-text
msgid "Here is again the list of primitive types in Idris:"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:98
#, markdown-text
msgid "Signed, fixed precision integers:"
msgstr ""

#. type: Bullet: '  * '
#: ../src/Tutorial/Prim.md:98
#, markdown-text
msgid "`Int8`: Integer in the range [-128,127]"
msgstr ""

#. type: Bullet: '  * '
#: ../src/Tutorial/Prim.md:98
#, markdown-text
msgid "`Int16`: Integer in the range [-32768,32767]"
msgstr ""

#. type: Bullet: '  * '
#: ../src/Tutorial/Prim.md:98
#, markdown-text
msgid "`Int32`: Integer in the range [-2147483648,2147483647]"
msgstr ""

#. type: Bullet: '  * '
#: ../src/Tutorial/Prim.md:98
#, markdown-text
msgid "`Int64`: Integer in the range [-9223372036854775808,9223372036854775807]"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:98
#, markdown-text
msgid "Unsigned, fixed precision integers:"
msgstr ""

#. type: Bullet: '  * '
#: ../src/Tutorial/Prim.md:98
#, markdown-text
msgid "`Bits8`: Integer in the range [0,255]"
msgstr ""

#. type: Bullet: '  * '
#: ../src/Tutorial/Prim.md:98
#, markdown-text
msgid "`Bits16`: Integer in the range [0,65535]"
msgstr ""

#. type: Bullet: '  * '
#: ../src/Tutorial/Prim.md:98
#, markdown-text
msgid "`Bits32`: Integer in the range [0,4294967295]"
msgstr ""

#. type: Bullet: '  * '
#: ../src/Tutorial/Prim.md:98
#, markdown-text
msgid "`Bits64`: Integer in the range [0,18446744073709551615]"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:98
#, markdown-text
msgid "`Integer`: A signed, arbitrary precision integer."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:98
#, markdown-text
msgid "`Double`: A double precision (64 bit) floating point number."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:98
#, markdown-text
msgid "`Char`: A unicode character."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:98
#, markdown-text
msgid "`String`: A sequence of unicode characters."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:98
#, markdown-text
msgid ""
"`%World`: A symbolic representation of the current world state.  We learned "
"about this when I showed you how `IO` is implemented.  Most of the time, you "
"will not handle values of this type in your own code."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:98
#, markdown-text, no-wrap
msgid ""
"* `Int`: This one is special. It is a fixed precision, signed integer,\n"
"   but the bit size is somewhat dependent on the backend and\n"
"   (maybe) platform we use.\n"
"   For instance, if you use the default Chez Scheme backend, `Int` is\n"
"   a 64 bit signed integer, while on the JavaScript backends it is a\n"
"   32 bit signed integer for performance reasons. Therefore, `Int` comes\n"
"   with very few guarantees, and you should use one of the well\n"
"   specified integer types listed above whenever possible.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:104
#, markdown-text
msgid ""
"It can be instructive to learn, where in the compiler's source code the "
"primitive types and functions are defined. This source code can be found in "
"folder `src` of the [Idris project](https://github.com/idris-lang/Idris2)  "
"and the primitive types are the constant constructors of data type "
"`Core.TT.Constant`."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Prim.md:105
#, markdown-text, no-wrap
msgid "Primitive Functions"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:112
#, markdown-text
msgid ""
"All calculations operating on primitives are based on two kinds of primitive "
"functions: The ones built into the compiler (see below) and the ones defined "
"by programmers via the foreign function interface (FFI), about which I'll "
"talk in another chapter."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:119
#, markdown-text
msgid ""
"Built-in primitive functions are functions known to the compiler the "
"definition of which can not be found in the *Prelude*. They define the core "
"functionality available for the primitive types. Typically, you do not "
"invoke these directly (although it is perfectly fine to do so in most cases) "
"but via functions and interfaces exported by the *Prelude* or the *base* "
"library."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:123
#, markdown-text
msgid ""
"For instance, the primitive function for adding two eight bit unsigned "
"integers is `prim__add_Bits8`. You can inspect its type and behavior at the "
"REPL:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Prim.md:124
#, no-wrap
msgid ""
"Tutorial.Prim> :t prim__add_Bits8\n"
"prim__add_Bits8 : Bits8 -> Bits8 -> Bits8\n"
"Tutorial.Prim> prim__add_Bits8 12 100\n"
"112\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:148
#, markdown-text
msgid ""
"If you look at the source code implementing interface `Num` for `Bits8`, you "
"will see that the plus operator just invokes `prim__add_Bits8` "
"internally. The same goes for most of the other functions in primitive "
"interface implementations.  For instance, every primitive type with the "
"exception of `%World` comes with primitive comparison functions.  For "
"`Bits8`, these are: `prim__eq_Bits8`, `prim__gt_Bits8`, `prim__lt_Bits8`, "
"`prim__gte_Bits8`, and `prim__lte_Bits8`.  Note, that these functions do not "
"return a `Bool` (which is *not* a primitive type in Idris), but an "
"`Int`. They are therefore not as safe or convenient to use as the "
"corresponding operator implementations form interfaces `Eq` and `Comp`.  On "
"the other hand, they do not go via a conversion to `Bool` and might "
"therefore perform slightly better in performance critical code (which you "
"can only identify after some serious profiling)."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:152
#, markdown-text
msgid ""
"As with primitive types, the primitive functions are listed as constructors "
"in a data type (`Core.TT.PrimFn`) in the compiler sources. We will look at "
"most of these in the following sections."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Prim.md:153
#, markdown-text, no-wrap
msgid "Consequences of being Primitive"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:163
#, markdown-text
msgid ""
"Primitive functions and types are opaque to the compiler in most regards: "
"They have to be defined and implemented by each backend individually, "
"therefore, the compiler knows nothing about the inner structure of a "
"primitive value nor about the inner workings of primitive functions. For "
"instance, in the following recursive function, *we* know that the argument "
"in the recursive call must be converging towards the base case (unless there "
"is a bug in the backend we use), but the compiler does not:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:164
#, no-wrap
msgid ""
"covering\n"
"replicateBits8' : Bits8 -> a -> List a\n"
"replicateBits8' 0 _ = []\n"
"replicateBits8' n v = v :: replicateBits8' (n - 1) v\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:174
#, markdown-text
msgid ""
"In these cases, we either must be content with just a *covering* function, "
"or we use `assert_smaller` to convince the totality checker (the preferred "
"way):"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:175
#, no-wrap
msgid ""
"replicateBits8 : Bits8 -> a -> List a\n"
"replicateBits8 0 _ = []\n"
"replicateBits8 n v = v :: replicateBits8 (assert_smaller n $ n - 1) v\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:184
#, markdown-text
msgid ""
"I have shown you the risks of using `assert_smaller` before, so we must be "
"extra careful in making sure that the new function argument is indeed "
"smaller with relation to the base case."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:189
#, markdown-text
msgid ""
"While Idris knows nothing about the internal workings of primitives and "
"related functions, most of these functions still reduce during evaluation "
"when fed with values known at compile time. For instance, we can trivially "
"proof that for `Bits8` the following equation holds:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:190
#, no-wrap
msgid ""
"zeroBits8 : the Bits8 0 = 255 + 1\n"
"zeroBits8 = Refl\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:200
#, markdown-text
msgid ""
"Having no clue about the internal structure of a primitive nor about the "
"implementations of primitive functions, Idris can't help us proofing any "
"*general* properties of such functions and values. Here is an example to "
"demonstrate this. Assume we'd like to wrap a list in a data type indexed by "
"the list's length:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:201
#, no-wrap
msgid ""
"data LenList : (n : Nat) -> Type -> Type where\n"
"  MkLenList : (as : List a) -> LenList (length as) a\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:209
#, markdown-text
msgid ""
"When we concatenate two `LenList`s, the length indices should be "
"added. That's how list concatenation affects the length of lists. We can "
"safely teach Idris that this is true:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:210
#, no-wrap
msgid ""
"0 concatLen : (xs,ys : List a) -> length xs + length ys = length (xs ++ "
"ys)\n"
"concatLen []        ys = Refl\n"
"concatLen (x :: xs) ys = cong S $ concatLen xs ys\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:217
#, markdown-text
msgid "With the above lemma, we can implement concatenation of `LenList`:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:218
#, no-wrap
msgid ""
"(++) : LenList m a -> LenList n a -> LenList (m + n) a\n"
"MkLenList xs ++ MkLenList ys =\n"
"  rewrite concatLen xs ys in MkLenList (xs ++ ys)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:231
#, markdown-text
msgid ""
"The same is not possible for strings. There are applications where pairing a "
"string with its length would be useful (for instance, if we wanted to make "
"sure that strings are getting strictly shorter during parsing and will "
"therefore eventually be wholly consumed), but Idris cannot help us getting "
"these things right.  There is no way to implement and thus proof the "
"following lemma in a safe way:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:232
#, no-wrap
msgid "0 concatLenStr : (a,b : String) -> length a + length b = length (a ++ b)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:237
#, markdown-text, no-wrap
msgid "<!-- markdownlint-disable MD026 -->\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Prim.md:237
#, markdown-text, no-wrap
msgid "Believe Me!"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:239
#, markdown-text, no-wrap
msgid "<!-- markdownlint-enable MD026 -->\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:245
#, markdown-text
msgid ""
"In order to implement `concatLenStr`, we have to abandon all safety and use "
"the ten ton wrecking ball of type coercion: `believe_me`. This primitive "
"function allows us to freely coerce a value of any type into a value of any "
"other type.  Needless to say, this is only safe if we *really* know what we "
"are doing:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:246
#, no-wrap
msgid "concatLenStr a b = believe_me $ Refl {x = length a + length b}\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:257
#, markdown-text
msgid ""
"The explicit assignment of variable `x` in `{x = length a + length b}` is "
"necessary, because otherwise Idris will complain about an *unsolved hole*: "
"It can't infer the type of parameter `x` in the `Refl` constructor. We could "
"assign any type to `x` here, because we are passing the result to "
"`believe_me` anyway, but I consider it to be good practice to assign one of "
"the two sides of the equality to make our intention clear."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:262
#, markdown-text
msgid ""
"The higher the complexity of a primitive type, the riskier it is to assume "
"even the most basic properties for it to hold.  For instance, we might act "
"under the delusion that floating point addition is associative:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:263
#, no-wrap
msgid ""
"0 doubleAddAssoc : (x,y,z : Double) -> x + (y + z) = (x + y) + z\n"
"doubleAddAssoc x y z = believe_me $ Refl {x = x + (y + z)}\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:270
#, markdown-text
msgid "Well, guess what: That's a lie. And lies lead us straight into the `Void`:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:271
#, no-wrap
msgid ""
"Tiny : Double\n"
"Tiny = 0.0000000000000001\n"
"\n"
"One : Double\n"
"One = 1.0\n"
"\n"
"wrong : (0 _ : 1.0000000000000002 = 1.0) -> Void\n"
"wrong Refl impossible\n"
"\n"
"boom : Void\n"
"boom = wrong (doubleAddAssoc One Tiny Tiny)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:291
#, markdown-text
msgid ""
"Here's what happens in the code above: The call to `doubleAddAssoc` returns "
"a proof that `One + (Tiny + Tiny)` is equal to `(One + Tiny) + Tiny`. But "
"`One + (Tiny + Tiny)` equals `1.0000000000000002`, while `(One + Tiny) + "
"Tiny` equals `1.0`.  We can therefore pass our (wrong) proof to `wrong`, "
"because it is of the correct type, and from this follows a proof of `Void`."
msgstr ""

#. type: Title ##
#: ../src/Tutorial/Prim.md:292
#, markdown-text, no-wrap
msgid "Working with Strings"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:297
#, markdown-text
msgid ""
"Module `Data.String` in *base* offers a rich set of functions for working "
"with strings. All these are based on the following primitive operations "
"built into the compiler:"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:305
#, markdown-text
msgid "`prim__strLength`: Returns the length of a string."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:305
#, markdown-text
msgid "`prim__strHead`: Extracts the first character from a string."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:305
#, markdown-text
msgid "`prim__strTail`: Removes the first character from a string."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:305
#, markdown-text
msgid "`prim__strCons`: Prepends a character to a string."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:305
#, markdown-text
msgid "`prim__strAppend`: Appends two strings."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:305
#, markdown-text
msgid "`prim__strIndex`: Extracts a character at the given position from a string."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:305
#, markdown-text
msgid "`prim__strSubstr`: Extracts the substring between the given positions."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:311
#, markdown-text
msgid ""
"Needless to say, not all of these functions are total. Therefore, Idris must "
"make sure that invalid calls do not reduce during compile time, as otherwise "
"the compiler would crash. If, however we force the evaluation of a partial "
"primitive function by compiling and running the corresponding program, this "
"program will crash with an error:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Prim.md:312
#, no-wrap
msgid ""
"Tutorial.Prim> prim__strTail \"\"\n"
"prim__strTail \"\"\n"
"Tutorial.Prim> :exec putStrLn (prim__strTail \"\")\n"
"Exception in substring: 1 and 0 are not valid start/end indices for \"\"\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:323
#, markdown-text
msgid ""
"Note, how `prim__strTail \"\"` is not reduced at the REPL and how the same "
"expression leads to a runtime exception if we compile and execute the "
"program. Valid calls to `prim__strTail` are reduced just fine, however:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:324
#, no-wrap
msgid ""
"tailExample : prim__strTail \"foo\" = \"oo\"\n"
"tailExample = Refl\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Prim.md:329
#, markdown-text, no-wrap
msgid "Pack and Unpack"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:339
#, markdown-text
msgid ""
"Two of the most important functions for working with strings are `unpack` "
"and `pack`, which convert a string to a list of characters and vice "
"versa. This allows us to conveniently implement many string operations by "
"iterating or folding over the list of characters instead. This might not "
"always be the most efficient thing to do, but unless you plan to handle very "
"large amounts of text, they work and perform reasonably well."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Prim.md:340
#, markdown-text, no-wrap
msgid "String Interpolation"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:345
#, markdown-text
msgid ""
"Idris allows us to include arbitrary string expressions in a string literal "
"by wrapping them in curly braces, the first of which has to be escaped with "
"a backslash. For instance:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:346
#, no-wrap
msgid ""
"interpEx1 : Bits64 -> Bits64 -> String\n"
"interpEx1 x y = \"\\{show x} + \\{show y} = \\{show $ x + y}\"\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:356
#, markdown-text
msgid ""
"This is a very convenient way to assemble complex strings from values of "
"different types.  In addition, there is interface `Interpolation`, which "
"allows us to use values in interpolated strings without having to convert "
"them to strings first:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:357
#, no-wrap
msgid ""
"data Element = H | He | C | N | O | F | Ne\n"
"\n"
"Formula : Type\n"
"Formula = List (Element,Nat)\n"
"\n"
"Interpolation Element where\n"
"  interpolate H  = \"H\"\n"
"  interpolate He = \"He\"\n"
"  interpolate C  = \"C\"\n"
"  interpolate N  = \"N\"\n"
"  interpolate O  = \"O\"\n"
"  interpolate F  = \"F\"\n"
"  interpolate Ne = \"Ne\"\n"
"\n"
"Interpolation (Element,Nat) where\n"
"  interpolate (_, 0) = \"\"\n"
"  interpolate (x, 1) = \"\\{x}\"\n"
"  interpolate (x, k) = \"\\{x}\\{show k}\"\n"
"\n"
"Interpolation Formula where\n"
"  interpolate = foldMap interpolate\n"
"\n"
"ethanol : String\n"
"ethanol = \"The formulat of ethanol is: \\{[(C,2),(H,6),(O, the Nat 1)]}\"\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Prim.md:384
#, markdown-text, no-wrap
msgid "Raw and Multiline String Literals"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:388
#, markdown-text
msgid ""
"In string literals, we have to escape certain characters like quotes, "
"backslashes or new line characters. For instance:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:389
#, no-wrap
msgid ""
"escapeExample : String\n"
"escapeExample = \"A quote: \\\". \\nThis is on a new line.\\nA backslash: "
"\\\\\"\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:398
#, markdown-text
msgid ""
"Idris allows us to enter raw string literals, where there is no need to "
"escape quotes and backslashes, by pre- and postfixing the wrapping quote "
"characters with the same number of hash characters. For instance:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:399
#, no-wrap
msgid ""
"rawExample : String\n"
"rawExample = #\"A quote: \". A blackslash: \\\"#\n"
"\n"
"rawExample2 : String\n"
"rawExample2 = ##\"A quote: \". A blackslash: \\\"##\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:411
#, markdown-text
msgid ""
"With raw string literals, it is still possible to use string interpolation, "
"but the opening curly brace has to be prefixed with a backslash and the same "
"number of hashes as are being used for opening and closing the string "
"literal:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:412
#, no-wrap
msgid ""
"rawInterpolExample : String\n"
"rawInterpolExample = ##\"An interpolated \"string\": \\##{rawExample}\"##\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:424
#, markdown-text
msgid ""
"Finally, Idris also allows us to conveniently write multiline strings. These "
"can be pre- and postfixed with hashes if we want raw multiline string "
"literals, and they also can be combined with string interpolation. Multiline "
"literals are opened and closed with triple quote characters. Indenting the "
"closing triple quotes allows us to indent the whole multiline "
"literal. Whitespace used for indentation will not appear in the resulting "
"string. For instance:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:425
#, no-wrap
msgid ""
"multiline1 : String\n"
"multiline1 = \"\"\"\n"
"  And I raise my head and stare\n"
"  Into the eyes of a stranger\n"
"  I've always known that the mirror never lies\n"
"  People always turn away\n"
"  From the eyes of a stranger\n"
"  Afraid to see what hides behind the stare\n"
"  \"\"\"\n"
"\n"
"multiline2 : String\n"
"multiline2 = #\"\"\"\n"
"  An example for a simple expression:\n"
"  \"foo\" ++ \"bar\".\n"
"  This is reduced to \"\\#{\"foo\" ++ \"bar\"}\".\n"
"  \"\"\"#\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:447
#, markdown-text
msgid ""
"Make sure to look at the example strings at the REPL to see the effect of "
"interpolation and raw string literals and compare it with the syntax we "
"used."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:454
#, markdown-text
msgid ""
"In these exercises, you are supposed to implement a bunch of utility "
"functions for consuming and converting strings.  I don't give the expected "
"types here, because you are supposed to come up with those yourself."
msgstr ""

#. type: Bullet: '1. '
#: ../src/Tutorial/Prim.md:458
#, markdown-text
msgid ""
"Implement functions similar to `map`, `filter`, and `mapMaybe` for "
"strings. The output type of these should always be a string."
msgstr ""

#. type: Bullet: '2. '
#: ../src/Tutorial/Prim.md:461
#, markdown-text
msgid "Implement functions similar to `foldl` and `foldMap` for strings."
msgstr ""

#. type: Bullet: '3. '
#: ../src/Tutorial/Prim.md:464
#, markdown-text
msgid ""
"Implement a function similar to `traverse` for strings. The output type "
"should be a wrapped string."
msgstr ""

#. type: Bullet: '4. '
#: ../src/Tutorial/Prim.md:467
#, markdown-text
msgid ""
"Implement the bind operator for strings. The output type should again be a "
"string."
msgstr ""

#. type: Title ##
#: ../src/Tutorial/Prim.md:468
#, markdown-text, no-wrap
msgid "Integers"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:475
#, markdown-text
msgid ""
"As listed at the beginning of this chapter, Idris provides different "
"fixed-precision signed and unsigned integer types as well as `Integer`, an "
"arbitrary precision signed integer type.  All of them come with the "
"following primitive functions (given here for `Bits8` as an example):"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:486
#, markdown-text
msgid "`prim__add_Bits8`: Integer addition."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:486
#, markdown-text
msgid "`prim__sub_Bits8`: Integer subtraction."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:486
#, markdown-text
msgid "`prim__mul_Bits8`: Integer multiplication."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:486
#, markdown-text
msgid "`prim__div_Bits8`: Integer division."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:486
#, markdown-text
msgid "`prim__mod_Bits8`: Modulo function."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:486
#, markdown-text
msgid "`prim__shl_Bits8`: Bitwise left shift."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:486
#, markdown-text
msgid "`prim__shr_Bits8`: Bitwise right shift."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:486
#, markdown-text
msgid "`prim__and_Bits8`: Bitwise *and*."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:486
#, markdown-text
msgid "`prim__or_Bits8`: Bitwise *or*."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:486
#, markdown-text
msgid "`prim__xor_Bits8`: Bitwise *xor*."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:493
#, markdown-text
msgid ""
"Typically, you use the functions for addition and multiplication through the "
"operators from interface `Num`, the function for subtraction through "
"interface `Neg`, and the functions for division (`div` and `mod`) through "
"interface `Integral`.  The bitwise operations are available through "
"interfaces `Data.Bits.Bits` and `Data.Bits.FiniteBits`."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:497
#, markdown-text
msgid ""
"For all integral types, the following laws are assumed to hold for numeric "
"operations (`x`, `y`, and `z` are arbitrary value of the same primitive "
"integral type):"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:507
#, markdown-text
msgid "`x + y = y + x`: Addition is commutative."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:507
#, markdown-text
msgid "`x + (y + z) = (x + y) + z`: Addition is associative."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:507
#, markdown-text
msgid "`x + 0 = x`: Zero is the neutral element of addition."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:507
#, markdown-text
msgid "`x - x = x + (-x) = 0`: `-x` is the additive inverse of `x`."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:507
#, markdown-text
msgid "`x * y = y * x`: Multiplication is commutative."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:507
#, markdown-text
msgid "`x * (y * z) = (x * y) * z`: Multiplication is associative."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:507
#, markdown-text
msgid "`x * 1 = x`: One is the neutral element of multiplication."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:507
#, markdown-text
msgid "`x * (y + z) = x * y + x * z`: The distributive law holds."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:507
#, markdown-text
msgid "``y * (x `div` y) + (x `mod` y) = x`` (for `y /= 0`)."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:515
#, markdown-text
msgid ""
"Please note, that the officially supported backends use *Euclidian modulus* "
"for calculating `mod`: For `y /= 0`, ``x `mod` y`` is always a non-negative "
"value strictly smaller than `abs y`, so that the law given above does "
"hold. If `x` or `y` are negative numbers, this is different to what many "
"other languages do but for good reasons as explained in the following "
"[article](https://www.microsoft.com/en-us/research/publication/division-and-modulus-for-computer-scientists/)."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Prim.md:516
#, markdown-text, no-wrap
msgid "Unsigned Integers"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:526
#, markdown-text
msgid ""
"The unsigned fixed precision integer types (`Bits8`, `Bits16`, `Bits32`, and "
"`Bits64`) come with implementations of all integral interfaces (`Num`, "
"`Neg`, and `Integral`) and the two interfaces for bitwise operations (`Bits` "
"and `FiniteBits`).  All functions with the exception of `div` and `mod` are "
"total. Overflows are handled by calculating the remainder modulo "
"`2^bitsize`. For instance, for `Bits8`, all operations calculate their "
"results modulo 256:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Prim.md:527
#, no-wrap
msgid ""
"Main> the Bits8 255 + 1\n"
"0\n"
"Main> the Bits8 255 + 255\n"
"254\n"
"Main> the Bits8 128 * 2 + 7\n"
"7\n"
"Main> the Bits8 12 - 13\n"
"255\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Prim.md:538
#, markdown-text, no-wrap
msgid "Signed Integers"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:549
#, markdown-text
msgid ""
"Like the unsigned integer types, the signed fixed precision integer types "
"(`Int8`, `Int16`, `Int32`, and `Int64`) come with implementations of all "
"integral interfaces and the two interfaces for bitwise operations (`Bits` "
"and `FiniteBits`).  Overflows are handled by calculating the remainder "
"modulo `2^bitsize` and adding the lower bound (a negative number)  if the "
"result is still out of range. For instance, for `Int8`, all operations "
"calculate their results modulo 256, subtracting 128 if the result is still "
"out of bounds:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Prim.md:550
#, no-wrap
msgid ""
"Main> the Int8 2 * 127\n"
"-2\n"
"Main> the Int8 3 * 127\n"
"125\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Prim.md:557
#, markdown-text, no-wrap
msgid "Bitwise Operations"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:568
#, markdown-text
msgid ""
"Module `Data.Bits` exports interfaces for performing bitwise operations on "
"integral types. I'm going to show a couple of examples on unsigned 8-bit "
"numbers (`Bits8`) to explain the concept to readers new to bitwise "
"arithmetics. Note, that this is much easier to grasp for unsigned integer "
"types than for the signed versions.  Those have to include information about "
"the *sign* of numbers in their bit pattern, and it is assumed that signed "
"integers in Idris use a [two's complement "
"representation](https://en.wikipedia.org/wiki/Two%27s_complement), about "
"which I will not go into the details here."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:573
#, markdown-text
msgid ""
"An unsigned 8-bit binary number is represented internally as a sequence of "
"eight bits (with values 0 or 1), each of which corresponds to a power of "
"2. For instance, the number 23 (= 16 + 4 + 2 + 1) is represented as `0001 "
"0111`:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Prim.md:574
#, no-wrap
msgid ""
"23 in binary:    0  0  0  1    0  1  1  1\n"
"\n"
"Bit number:      7  6  5  4    3  2  1  0\n"
"Decimal value: 128 64 32 16    8  4  2  1\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:583
#, markdown-text
msgid ""
"We can use function `testBit` to check if the bit at the given position is "
"set or not:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Prim.md:584
#, no-wrap
msgid ""
"Tutorial.Prim> testBit (the Bits8 23) 0\n"
"True\n"
"Tutorial.Prim> testBit (the Bits8 23) 1\n"
"True\n"
"Tutorial.Prim> testBit (the Bits8 23) 3\n"
"False\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:595
#, markdown-text
msgid ""
"Likewise, we can use functions `setBit` and `clearBit` to set or unset a bit "
"at a certain position:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Prim.md:596
#, no-wrap
msgid ""
"Tutorial.Prim> setBit (the Bits8 23) 3\n"
"31\n"
"Tutorial.Prim> clearBit (the Bits8 23) 2\n"
"19\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:610
#, markdown-text
msgid ""
"There are also operators `(.&.)` (bitwise *and*) and `(.|.)` (bitwise *or*) "
"as well as function `xor` (bitwise *exclusive or*)  for performing boolean "
"operations on integral values.  For instance `x .&. y` has exactly those "
"bits set, which both `x` and `y` have set, while `x .|. y` has all bits set "
"that are either set in `x` or `y` (or both), and ``x `xor` y`` has those "
"bits set that are set in exactly one of the two values:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Prim.md:611
#, no-wrap
msgid ""
"23 in binary:          0  0  0  1    0  1  1  1\n"
"11 in binary:          0  0  0  0    1  0  1  1\n"
"\n"
"23 .&. 11 in binary:   0  0  0  0    0  0  1  1\n"
"23 .|. 11 in binary:   0  0  0  1    1  1  1  1\n"
"23 `xor` 11 in binary: 0  0  0  1    1  1  0  0\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:621
#, markdown-text
msgid "And here are the examples at the REPL:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Prim.md:622
#, no-wrap
msgid ""
"Tutorial.Prim> the Bits8 23 .&. 11\n"
"3\n"
"Tutorial.Prim> the Bits8 23 .|. 11\n"
"31\n"
"Tutorial.Prim> the Bits8 23 `xor` 11\n"
"28\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:637
#, markdown-text
msgid ""
"Finally, it is possible to shift all bits to the right or left by a certain "
"number of steps by using functions `shiftR` and `shiftL`, respectively "
"(overflowing bits will just be dropped).  A left shift can therefore be "
"viewed as a multiplication by a power of two, while a right shift can be "
"seen as a division by a power of two:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Prim.md:638
#, no-wrap
msgid ""
"22 in binary:            0  0  0  1    0  1  1  0\n"
"\n"
"22 `shiftL` 2 in binary: 0  1  0  1    1  0  0  0\n"
"22 `shiftR` 1 in binary: 0  0  0  0    1  0  1  1\n"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Prim.md:647
#, no-wrap
msgid ""
"Tutorial.Prim> the Bits8 22 `shiftL` 2\n"
"88\n"
"Tutorial.Prim> the Bits8 22 `shiftR` 1\n"
"11\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:657
#, markdown-text
msgid ""
"Bitwise operations are often used in specialized code or certain "
"high-performance applications. As programmers, we have to know they exist "
"and how they work."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Prim.md:658
#, markdown-text, no-wrap
msgid "Integer Literals"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:666
#, markdown-text
msgid ""
"So far, we always required an implementation of `Num` in order to be able to "
"use integer literals for a given type. However, it is actually only "
"necessary to implement a function `fromInteger` converting an `Integer` to "
"the type in question. As we will see in the last section, such a function "
"can even restrict the values allowed as valid literals."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:671
#, markdown-text
msgid ""
"For instance, assume we'd like to define a data type for representing the "
"charge of a chemical molecule. Such a value can be positive or negative and "
"(theoretically) of almost arbitrary magnitude:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:672
#, no-wrap
msgid ""
"record Charge where\n"
"  constructor MkCharge\n"
"  value : Integer\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:683
#, markdown-text
msgid ""
"It makes sense to be able to sum up charges, but not to multiply them. They "
"should therefore have an implementation of `Monoid` but not of `Num`. Still, "
"we'd like to have the convenience of integer literals when using constant "
"charges at compile time. Here's how to do this:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:684
#, no-wrap
msgid ""
"fromInteger : Integer -> Charge\n"
"fromInteger = MkCharge\n"
"\n"
"Semigroup Charge where\n"
"  x <+> y = MkCharge $ x.value + y.value\n"
"\n"
"Monoid Charge where\n"
"  neutral = 0\n"
msgstr ""

#. type: Title ####
#: ../src/Tutorial/Prim.md:695
#, markdown-text, no-wrap
msgid "Alternative Bases"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:702
#, markdown-text
msgid ""
"In addition to the well known decimal literals, it is also possible to use "
"integer literals in binary, octal, or hexadecimal representation. These have "
"to be prefixed with a zero following by a `b`, `o`, or `x` for binary, "
"octal, and hexadecimal, respectively:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Prim.md:703
#, no-wrap
msgid ""
"Tutorial.Prim> 0b1101\n"
"13\n"
"Tutorial.Prim> 0o773\n"
"507\n"
"Tutorial.Prim> 0xffa2\n"
"65442\n"
msgstr ""

#. type: Bullet: '1. '
#: ../src/Tutorial/Prim.md:716
#, markdown-text
msgid ""
"Define a wrapper record for integral values and implement `Monoid` so that "
"`(<+>)` corresponds to `(.&.)`."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:719
#, markdown-text, no-wrap
msgid ""
"   Hint: Have a look at the functions available from interface\n"
"   `Bits` to find a value suitable as the neutral element.\n"
msgstr ""

#. type: Bullet: '2. '
#: ../src/Tutorial/Prim.md:722
#, markdown-text
msgid ""
"Define a wrapper record for integral values and implement `Monoid` so that "
"`(<+>)` corresponds to `(.|.)`."
msgstr ""

#. type: Bullet: '3. '
#: ../src/Tutorial/Prim.md:725
#, markdown-text
msgid ""
"Use bitwise operations to implement a function, which tests if a given value "
"of type `Bits64` is even or not."
msgstr ""

#. type: Bullet: '4. '
#: ../src/Tutorial/Prim.md:727
#, markdown-text
msgid "Convert a value of type `Bits64` to a string in binary representation."
msgstr ""

#. type: Bullet: '5. '
#: ../src/Tutorial/Prim.md:729
#, markdown-text
msgid "Convert a value of type `Bits64` to a string in hexadecimal representation."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:732
#, markdown-text, no-wrap
msgid ""
"   Hint: Use `shiftR` and `(.&. 15)` to access subsequent packages of\n"
"   four bits.\n"
msgstr ""

#. type: Title ##
#: ../src/Tutorial/Prim.md:733
#, markdown-text, no-wrap
msgid "Refined Primitives"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:741
#, markdown-text
msgid ""
"We often do not want to allow all values of a type in a certain context. For "
"instance, `String` as an arbitrary sequence of UTF-8 characters (several of "
"which are not even printable), is too general most of the time. Therefore, "
"it is usually advisable to rule out invalid values early on, by pairing a "
"value with an erased proof of validity."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:749
#, markdown-text
msgid ""
"We have learned how we can write elegant predicates, with which we can proof "
"our functions to be total, and from which we can - in the ideal case - "
"derive other, related predicates. However, when we define predicates on "
"primitives they are to a certain degree doomed to live in isolation, unless "
"we come up with a set of primitive axioms (implemented most likely using "
"`believe_me`), with which we can manipulate our predicates."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Prim.md:750
#, markdown-text, no-wrap
msgid "Use Case: ASCII Strings"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:756
#, markdown-text
msgid ""
"String encodings is a difficult topic, so in many low level routines it "
"makes sense to rule out most characters from the beginning. Assume "
"therefore, we'd like to make sure the strings we accept in our application "
"only consist of ASCII characters:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:757
#, no-wrap
msgid ""
"isAsciiChar : Char -> Bool\n"
"isAsciiChar c = ord c <= 127\n"
"\n"
"isAsciiString : String -> Bool\n"
"isAsciiString = all isAsciiChar . unpack\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:767
#, markdown-text
msgid ""
"We can now *refine* a string value by pairing it with an erased proof of "
"validity:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:768
#, no-wrap
msgid ""
"record Ascii where\n"
"  constructor MkAscii\n"
"  value : String\n"
"  0 prf : isAsciiString value === True\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:779
#, markdown-text
msgid ""
"It is now *impossible* to at runtime or compile time create a value of type "
"`Ascii` without first validating the wrapped string. With this, it is "
"already pretty easy to safely wrap strings at compile time in a value of "
"type `Ascii`:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:780
#, no-wrap
msgid ""
"hello : Ascii\n"
"hello = MkAscii \"Hello World!\" Refl\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:800
#, markdown-text
msgid ""
"And yet, it would be much more convenient to still use string literals for "
"this, without having to sacrifice the comfort of safety. To do so, we can't "
"use interface `FromString`, as its function `fromString` would force us to "
"convert *any* string, even an invalid one. However, we actually don't need "
"an implementation of `FromString` to support string literals, just like we "
"didn't require an implementation of `Num` to support integer literals.  What "
"we really need is a function named `fromString`. Now, when string literals "
"are desugared, they are converted to invocations of `fromString` with the "
"given string value as its argument.  For instance, literal `\"Hello\"` gets "
"desugared to `fromString \"Hello\"`.  This happens before type checking and "
"filling in of (auto) implicit values. It is therefore perfectly fine, to "
"define a custom `fromString` function with an erased auto implicit argument "
"as a proof of validity:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:801
#, no-wrap
msgid ""
"fromString : (s : String) -> {auto 0 prf : isAsciiString s === True} -> "
"Ascii\n"
"fromString s = MkAscii s prf\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:808
#, markdown-text
msgid ""
"With this, we can us (valid) string literals for coming up with values of "
"type `Ascii` directly:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:809
#, no-wrap
msgid ""
"hello2 : Ascii\n"
"hello2 = \"Hello World!\"\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:817
#, markdown-text
msgid ""
"In order to at runtime create values of type `Ascii` from strings of an "
"unknown source, we can use a refinement function returning some kind of "
"failure type:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:818
#, no-wrap
msgid ""
"test : (b : Bool) -> Dec (b === True)\n"
"test True  = Yes Refl\n"
"test False = No absurd\n"
"\n"
"ascii : String -> Maybe Ascii\n"
"ascii x = case test (isAsciiString x) of\n"
"  Yes prf   => Just $ MkAscii x prf\n"
"  No contra => Nothing\n"
msgstr ""

#. type: Title ####
#: ../src/Tutorial/Prim.md:829
#, markdown-text, no-wrap
msgid "Disadvantages of Boolean Proofs"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:834
#, markdown-text
msgid ""
"For many use cases, what we described above for ASCII strings can take us "
"very far. However, one drawback of this approach is that we can't safely "
"perform any computations with the proofs at hand."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:839
#, markdown-text
msgid ""
"For instance, we know it will be perfectly fine to concatenate two ASCII "
"strings, but in order to convince Idris of this, we will have to use "
"`believe_me`, because we will not be able to proof the following lemma "
"otherwise:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:840
#, no-wrap
msgid ""
"0 allAppend :  (f : Char -> Bool)\n"
"            -> (s1,s2 : String)\n"
"            -> (p1 : all f (unpack s1) === True)\n"
"            -> (p2 : all f (unpack s2) === True)\n"
"            -> all f (unpack (s1 ++ s2)) === True\n"
"allAppend f s1 s2 p1 p2 = believe_me $ Refl {x = True}\n"
"\n"
"namespace Ascii\n"
"  export\n"
"  (++) : Ascii -> Ascii -> Ascii\n"
"  MkAscii s1 p1 ++ MkAscii s2 p2 =\n"
"    MkAscii (s1 ++ s2) (allAppend isAsciiChar s1 s2 p1 p2)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:861
#, markdown-text
msgid ""
"The same goes for all operations extracting a substring from a given string: "
"We will have to implement according rules using `believe_me`. Finding a "
"reasonable set of axioms to conveniently deal with refined primitives can "
"therefore be challenging at times, and whether such axioms are even required "
"very much depends on the use case at hand."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Prim.md:862
#, markdown-text, no-wrap
msgid "Use Case: Sanitized HTML"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:869
#, markdown-text
msgid ""
"Assume you write a simple web application for scientific discourse between "
"registered users. To keep things simple, we only consider unformatted text "
"input here. Users can write arbitrary text in a text field and upon hitting "
"Enter, the message is displayed to all other registered users."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:871
#, markdown-text
msgid "Assume now a user decides to enter the following text:"
msgstr ""

#. type: Fenced code block (html)
#: ../src/Tutorial/Prim.md:872
#, no-wrap
msgid "<script>alert(\"Hello World!\")</script>\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:884
#, markdown-text
msgid ""
"Well, it could have been (much) worse. Still, unless we take measures to "
"prevent this from happening, this might embed a JavaScript program in our "
"web page we never intended to have there! What I described here, is a well "
"known security vulnerability called [cross-site "
"scripting](https://en.wikipedia.org/wiki/Cross-site_scripting).  It allows "
"users of web pages to enter malicious JavaScript code in text fields, which "
"will then be included in the page's HTML structure and executed when it is "
"being displayed to other users."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:891
#, markdown-text, no-wrap
msgid ""
"We want to make sure, that this cannot happen on our own web page.\n"
"In order to protect us from this attack, we could for instance disallow\n"
"certain characters like `'<'` or `'>'` completely (although this might not\n"
"be enough!), but if our chat service is targeted at programmers,\n"
"this will be overly restrictive. An alternative\n"
"is to escape certain characters before rendering them on the page.\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:892
#, no-wrap
msgid ""
"escape : String -> String\n"
"escape = concat . map esc . unpack\n"
"  where esc : Char -> String\n"
"        esc '<'  = \"&lt;\"\n"
"        esc '>'  = \"&gt;\"\n"
"        esc '\"'  = \"&quot;\"\n"
"        esc '&'  = \"&amp;\"\n"
"        esc '\\'' = \"&apos;\"\n"
"        esc c    = singleton c\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:910
#, markdown-text
msgid ""
"What we now want to do is to store a string together with a proof that is "
"was properly escaped. This is another form of existential quantification: "
"\"Here is a string, and there once existed another string, which we passed "
"to `escape` and arrived at the string we have now\". Here's how to encode "
"this:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:911
#, no-wrap
msgid ""
"record Escaped where\n"
"  constructor MkEscaped\n"
"  value    : String\n"
"  0 origin : String\n"
"  0 prf    : escape origin === value\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:925
#, markdown-text
msgid ""
"Whenever we now embed a string of unknown origin in our web page, we can "
"request a value of type `Escaped` and have the very strong guarantee that we "
"are no longer vulnerable to cross-site scripting attacks. Even better, it is "
"also possible to safely embed string literals known at compile time without "
"the need to escape them first:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:926
#, no-wrap
msgid ""
"namespace Escaped\n"
"  export\n"
"  fromString : (s : String) -> {auto 0 prf : escape s === s} -> Escaped\n"
"  fromString s = MkEscaped s s prf\n"
"\n"
"escaped : Escaped\n"
"escaped = \"Hello World!\"\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:941
#, markdown-text
msgid ""
"In this massive set of exercises, you are going to build a small library for "
"working with predicates on primitives.  We want to keep the following goals "
"in mind:"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:955
#, markdown-text
msgid ""
"We want to use the usual operations of propositional logic to combine "
"predicates: Negation, conjuction (logical *and*), and disjunction (logical "
"*or*)."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:955
#, markdown-text
msgid ""
"All predicates should be erased at runtime. If we proof something about a "
"primitive number, we want to make sure not to carry around a huge proof of "
"validity."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:955
#, markdown-text
msgid ""
"Calculations on predicates should make no appearance at runtime (with the "
"exception of `decide`; see below)."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Prim.md:955
#, markdown-text
msgid ""
"Recursive calculations on predicates should be tail recursive if they are "
"used in implementations of `decide`. This might be tough to achieve. If you "
"can't find a tail recursive solution for a given problem, use what feels "
"most natural instead."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:980
#, markdown-text
msgid ""
"A note on efficiency: In order to be able to run computations on our "
"predicates, we try to convert primitive values to algebraic data types as "
"often and as soon as possible: Unsigned integers will be converted to `Nat` "
"using `cast`, and strings will be converted to `List Char` using `unpack`.  "
"This allows us to work with proofs on `Nat` and `List` most of the time, and "
"such proofs can be implemented without resorting to `believe_me` or other "
"cheats. However, the one advantage of primitive types over algebraic data "
"types is that they often perform much better. This is especially critical "
"when comparing integral types with `Nat`: Operations on natural numbers "
"often run with `O(n)` time complexity, where `n` is the size of one of the "
"natural numbers involved, while with `Bits64`, for instance, many operations "
"run in fast constant time (`O(1)`). Luckily, the Idris compiler optimizes "
"many functions on natural number to use the corresponding `Integer` "
"operations at runtime. This has the advantage that we can still use proper "
"induction to proof stuff about natural numbers at compile time, while "
"getting the benefit of fast integer operations at runtime. However, "
"operations on `Nat` do run with `O(n)` time complexity and *compile "
"time*. Proofs working on large natural number will therefore drastically "
"slow down the compiler. A way out of this is discussed at the end of this "
"section of exercises."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:983
#, markdown-text
msgid ""
"Enough talk, let's begin! To start with, you are given the following "
"utilities:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:984
#, no-wrap
msgid ""
"-- Like `Dec` but with erased proofs. Constructors `Yes0`\n"
"-- and `No0` will be converted to constants `0` and `1` by\n"
"-- the compiler!\n"
"data Dec0 : (prop : Type) -> Type where\n"
"  Yes0 : (0 prf : prop) -> Dec0 prop\n"
"  No0  : (0 contra : prop -> Void) -> Dec0 prop\n"
"\n"
"-- For interfaces with more than one parameter (`a` and `p`\n"
"-- in this example) sometimes one parameter can be determined\n"
"-- by knowing the other. For instance, if we know what `p` is,\n"
"-- we will most certainly also know what `a` is. We therefore\n"
"-- specify that proof search on `Decidable` should only be\n"
"-- based on `p` by listing `p` after a vertical bar: `| p`.\n"
"-- This is like specifing the search parameter(s) of\n"
"-- a data type with `[search p]` as was shown in the chapter\n"
"-- about predicates.\n"
"-- Specifying a single search parameter as shown here can\n"
"-- drastically help with type inference.\n"
"interface Decidable (0 a : Type) (0 p : a -> Type) | p where\n"
"  decide : (v : a) -> Dec0 (p v)\n"
"\n"
"-- We often have to pass `p` explicitly in order to help Idris with\n"
"-- type inference. In such cases, it is more convenient to use\n"
"-- `decideOn pred` instead of `decide {p = pred}`.\n"
"decideOn : (0 p : a -> Type) -> Decidable a p => (v : a) -> Dec0 (p v)\n"
"decideOn _ = decide\n"
"\n"
"-- Some primitive predicates can only be reasonably implemented\n"
"-- using boolean functions. This utility helps with decidability\n"
"-- on such proofs.\n"
"test0 : (b : Bool) -> Dec0 (b === True)\n"
"test0 True  = Yes0 Refl\n"
"test0 False = No0 absurd\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1025
#, markdown-text
msgid ""
"We also want to run decidable computations at compile time. This is often "
"much more efficient than running a direct proof search on an inductive "
"type. We therefore come up with a predicate witnessing that a `Dec0` value "
"is actually a `Yes0` together with two utility functions:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:1026
#, no-wrap
msgid ""
"data IsYes0 : (d : Dec0 prop) -> Type where\n"
"  ItIsYes0 : IsYes0 (Yes0 prf)\n"
"\n"
"0 fromYes0 : (d : Dec0 prop) -> (0 prf : IsYes0 d) => prop\n"
"fromYes0 (Yes0 x) = x\n"
"fromYes0 (No0 contra) impossible\n"
"\n"
"0 safeDecideOn :  (0 p : a -> Type)\n"
"               -> Decidable a p\n"
"               => (v : a)\n"
"               -> (0 prf : IsYes0 (decideOn p v))\n"
"               => p v\n"
"safeDecideOn p v = fromYes0 $ decideOn p v\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1045
#, markdown-text
msgid ""
"Finally, as we are planning to refine mostly primitives, we will at times "
"require some sledge hammer to convince Idris that we know what we are doing:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:1046
#, no-wrap
msgid ""
"-- only use this if you are sure that `decideOn p v`\n"
"-- will return a `Yes0`!\n"
"0 unsafeDecideOn : (0 p : a -> Type) -> Decidable a p => (v : a) -> p v\n"
"unsafeDecideOn p v = case decideOn p v of\n"
"  Yes0 prf => prf\n"
"  No0  _   =>\n"
"    assert_total $ idris_crash \"Unexpected refinement failure in "
"`unsafeRefineOn`\"\n"
msgstr ""

#. type: Bullet: '1. '
#: ../src/Tutorial/Prim.md:1058
#, markdown-text
msgid "We start with equality proofs. Implement `Decidable` for `Equal v`."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1061
#, markdown-text, no-wrap
msgid ""
"   Hint: Use `DecEq` from module `Decidable.Equality` as a constraint\n"
"         and make sure that `v` is available at runtime.\n"
msgstr ""

#. type: Bullet: '2. '
#: ../src/Tutorial/Prim.md:1063
#, markdown-text
msgid "We want to be able to negate a predicate:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:1064
#, no-wrap
msgid ""
"   data Neg : (p : a -> Type) -> a -> Type where\n"
"     IsNot : {0 p : a -> Type} -> (contra : p v -> Void) -> Neg p v\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1070
#, markdown-text, no-wrap
msgid "   Implement `Decidable` for `Neg p` using a suitable constraint.\n"
msgstr ""

#. type: Bullet: '3. '
#: ../src/Tutorial/Prim.md:1072
#, markdown-text
msgid "We want to describe the conjunction of two predicates:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:1073
#, no-wrap
msgid ""
"   data (&&) : (p,q : a -> Type) -> a -> Type where\n"
"     Both : {0 p,q : a -> Type} -> (prf1 : p v) -> (prf2 : q v) -> (&&) p q "
"v\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1079
#, markdown-text, no-wrap
msgid "   Implement `Decidable` for `(p && q)` using suitable constraints.\n"
msgstr ""

#. type: Bullet: '4. '
#: ../src/Tutorial/Prim.md:1083
#, markdown-text
msgid ""
"Come up with a data type called `(||)` for the disjunction (logical *or*) of "
"two predicates and implement `Decidable` using suitable constraints."
msgstr ""

#. type: Bullet: '5. '
#: ../src/Tutorial/Prim.md:1086
#, markdown-text
msgid ""
"Proof [De Morgan's laws](https://en.wikipedia.org/wiki/De_Morgan%27s_laws)  "
"by implementing the following propositions:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:1087
#, no-wrap
msgid ""
"   negOr : Neg (p || q) v -> (Neg p && Neg q) v\n"
"\n"
"   andNeg : (Neg p && Neg q) v -> Neg (p || q) v\n"
"\n"
"   orNeg : (Neg p || Neg q) v -> Neg (p && q) v\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1100
#, markdown-text, no-wrap
msgid ""
"   The last of De Morgan's implications is harder to type and proof\n"
"   as we need a way to come up with values of type `p v` and `q v`\n"
"   and show that not both can exist. Here is a way to encode this\n"
"   (annotated with quantity 0 as we will need to access an erased\n"
"   contraposition):\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:1101
#, no-wrap
msgid ""
"   0 negAnd :  Decidable a p\n"
"            => Decidable a q\n"
"            => Neg (p && q) v\n"
"            -> (Neg p || Neg q) v\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1111
#, markdown-text, no-wrap
msgid ""
"   When you implement `negAnd`, remember that you can freely access\n"
"   erased (implicit) arguments, because `negAnd` itself can only be\n"
"   used in an erased context.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1117
#, markdown-text
msgid ""
"So far, we implemented the tools to algebraically describe and combine "
"several predicate. It is now time to come up with some examples. As a first "
"use case, we will focus on limiting the valid range of natural numbers. For "
"this, we use the following data type:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:1118
#, no-wrap
msgid ""
"-- Proof that m <= n\n"
"data (<=) : (m,n : Nat) -> Type where\n"
"  ZLTE : 0 <= n\n"
"  SLTE : m <= n -> S m <= S n\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1128
#, markdown-text
msgid ""
"This is similar to `Data.Nat.LTE` but I find operator notation often to be "
"clearer.  We also can define and use the following aliases:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Prim.md:1129
#, no-wrap
msgid ""
"(>=) : (m,n : Nat) -> Type\n"
"m >= n = n <= m\n"
"\n"
"(<) : (m,n : Nat) -> Type\n"
"m < n = S m <= n\n"
"\n"
"(>) : (m,n : Nat) -> Type\n"
"m > n = n < m\n"
"\n"
"LessThan : (m,n : Nat) -> Type\n"
"LessThan m = (< m)\n"
"\n"
"To : (m,n : Nat) -> Type\n"
"To m = (<= m)\n"
"\n"
"GreaterThan : (m,n : Nat) -> Type\n"
"GreaterThan m = (> m)\n"
"\n"
"From : (m,n : Nat) -> Type\n"
"From m = (>= m)\n"
"\n"
"FromTo : (lower,upper : Nat) -> Nat -> Type\n"
"FromTo l u = From l && To u\n"
"\n"
"Between : (lower,upper : Nat) -> Nat -> Type\n"
"Between l u = GreaterThan l && LessThan u\n"
msgstr ""

#. type: Bullet: '6. '
#: ../src/Tutorial/Prim.md:1171
#, markdown-text
msgid ""
"Coming up with a value of type `m <= n` by pattern matching on `m` and `n` "
"is highly inefficient for large values of `m`, as it will require `m` "
"iterations to do so. However, while in an erased context, we don't need to "
"hold a value of type `m <= n`. We only need to show, that such a value "
"follows from a more efficient computation. Such a computation is `compare` "
"for natural numbers: Although this is implemented in the *Prelude* with a "
"pattern match on its arguments, it is optimized by the compiler to a "
"comparison of integers which runs in constant time even for very large "
"numbers.  Since `Prelude.(<=)` for natural numbers is implemented in terms "
"of `compare`, it runs just as efficiently."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1175
#, markdown-text, no-wrap
msgid ""
"   We therefore need to proof the following two lemmas (make\n"
"   sure to not confuse `Prelude.(<=)` with `Prim.(<=)` in\n"
"   these declarations):\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:1176
#, no-wrap
msgid ""
"   0 fromLTE : (n1,n2 : Nat) -> (n1 <= n2) === True -> n1 <= n2\n"
"\n"
"   0 toLTE : (n1,n2 : Nat) -> n1 <= n2 -> (n1 <= n2) === True\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1185
#, markdown-text, no-wrap
msgid ""
"   They come with a quantity of 0, because they are just as inefficient\n"
"   as the other computations we discussed above. We therefore want\n"
"   to make absolutely sure that they will never be used at runtime!\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1190
#, markdown-text, no-wrap
msgid ""
"   Now, implement `Decidable Nat (<= n)`, making use of `test0`,\n"
"   `fromLTE`, and `toLTE`.\n"
"   Likewise, implement `Decidable Nat (m <=)`, because we require\n"
"   both kinds of predicates.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1193
#, markdown-text, no-wrap
msgid ""
"   Note: You should by know figure out yourself that `n` must be\n"
"   available at runtime and how to make sure that this is the case.\n"
msgstr ""

#. type: Bullet: '7. '
#: ../src/Tutorial/Prim.md:1198
#, markdown-text
msgid ""
"Proof that `(<=)` is reflexive and transitive by declaring and implementing "
"corresponding propositions. As we might require the proof of transitivity to "
"chain several values of type `(<=)`, it makes sense to also define a short "
"operator alias for this."
msgstr ""

#. type: Bullet: '8. '
#: ../src/Tutorial/Prim.md:1200
#, markdown-text
msgid "Proof that from `n > 0` follows `IsSucc n` and vise versa."
msgstr ""

#. type: Bullet: '9. '
#: ../src/Tutorial/Prim.md:1207
#, markdown-text
msgid ""
"Declare and implement safe division and modulo functions for `Bits64`, by "
"requesting an erased proof that the denominator is strictly positive when "
"cast to a natural number. In case of the modulo function, return a refined "
"value carrying an erased proof that the result is strictly smaller than the "
"modulus:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Prim.md:1208
#, no-wrap
msgid ""
"   safeMod :  (x,y : Bits64)\n"
"           -> (0 prf : cast y > 0)\n"
"           => Subset Bits64 (\\v => cast v < cast y)\n"
msgstr ""

#. type: Bullet: '10. '
#: ../src/Tutorial/Prim.md:1218
#, markdown-text
msgid ""
"We will use the predicates and utilities we defined so far to convert a "
"value of type `Bits64` to a string of digits in base `b` with `2 <= b && b "
"<= 16`.  To do so, implement the following skeleton definitions:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1223
#, markdown-text, no-wrap
msgid ""
"    ```idris\n"
"    -- this will require some help from `assert_total`\n"
"    -- and `idris_crash`.\n"
"    digit : (v : Bits64) -> (0 prf : cast v < 16) => Char\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1228
#, markdown-text, no-wrap
msgid ""
"    record Base where\n"
"      constructor MkBase\n"
"      value : Bits64\n"
"      0 prf : FromTo 2 16 (cast value)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1230
#, markdown-text, no-wrap
msgid "    base : Bits64 -> Maybe Base\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1235
#, markdown-text, no-wrap
msgid ""
"    namespace Base\n"
"      public export\n"
"      fromInteger : (v : Integer) -> {auto 0 _ : IsJust (base $ cast v)} -> "
"Base\n"
"    ```\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1241
#, markdown-text, no-wrap
msgid ""
"    Finally, implement `digits`, using `safeDiv` and `safeMod`\n"
"    in your implementation. This might be challenging, as you will\n"
"    have to manually transform some proofs to satisfy the type\n"
"    checker. You might also require `assert_smaller` in the\n"
"    recursive step.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1245
#, markdown-text, no-wrap
msgid ""
"    ```idris\n"
"    digits : Bits64 -> Base -> String\n"
"    ```\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1255
#, markdown-text
msgid ""
"We will now turn our focus on strings. Two of the most obvious ways in which "
"we can restrict the strings we accept are by limiting the set of characters "
"and limiting their lengths. More advanced refinements might require strings "
"to match a certain pattern or regular expression. In such cases, we might "
"either go for a boolean check or use a custom data type representing the "
"different parts of the pattern, but we will not cover these topics here."
msgstr ""

#. type: Bullet: '11. '
#: ../src/Tutorial/Prim.md:1258
#, markdown-text
msgid "Implement the following aliases for useful predicates on characters."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1262
#, markdown-text, no-wrap
msgid ""
"    Hint: Use `cast` to convert characters to natural numbers,\n"
"    use `(<=)` and `InRange` to specify regions of characters,\n"
"    and use `(||)` to combine regions of characters.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1266
#, markdown-text, no-wrap
msgid ""
"    ```idris\n"
"    -- Characters <= 127\n"
"    IsAscii : Char -> Type\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1269
#, markdown-text, no-wrap
msgid ""
"    -- Characters <= 255\n"
"    IsLatin : Char -> Type\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1272
#, markdown-text, no-wrap
msgid ""
"    -- Characters in the interval ['A','Z']\n"
"    IsUpper : Char -> Type\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1275
#, markdown-text, no-wrap
msgid ""
"    -- Characters in the interval ['a','z']\n"
"    IsLower : Char -> Type\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1278
#, markdown-text, no-wrap
msgid ""
"    -- Lower or upper case characters\n"
"    IsAlpha : Char -> Type\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1281
#, markdown-text, no-wrap
msgid ""
"    -- Characters in the range ['0','9']\n"
"    IsDigit : Char -> Type\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1284
#, markdown-text, no-wrap
msgid ""
"    -- Digits or characters from the alphabet\n"
"    IsAlphaNum : Char -> Type\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1287
#, markdown-text, no-wrap
msgid ""
"    -- Characters in the ranges [0,31] or [127,159]\n"
"    IsControl : Char -> Type\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1290
#, markdown-text, no-wrap
msgid ""
"    -- An ASCII character that is not a control character\n"
"    IsPlainAscii : Char -> Type\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1294
#, markdown-text, no-wrap
msgid ""
"    -- A latin character that is not a control character\n"
"    IsPlainLatin : Char -> Type\n"
"    ```\n"
msgstr ""

#. type: Bullet: '12. '
#: ../src/Tutorial/Prim.md:1301
#, markdown-text
msgid ""
"The advantage of this more modular approach to predicates on primitives is "
"that we can safely run calculations on our predicates and get the strong "
"guarantees from the existing proofs on inductive types like `Nat` and "
"`List`. Here are some examples of such calculations and conversions, all of "
"which can be implemented without cheating:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1304
#, markdown-text, no-wrap
msgid ""
"    ```idris\n"
"    0 plainToAscii : IsPlainAscii c -> IsAscii c\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1306
#, markdown-text, no-wrap
msgid "    0 digitToAlphaNum : IsDigit c -> IsAlphaNum c\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1308
#, markdown-text, no-wrap
msgid "    0 alphaToAlphaNum : IsAlpha c -> IsAlphaNum c\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1310
#, markdown-text, no-wrap
msgid "    0 lowerToAlpha : IsLower c -> IsAlpha c\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1312
#, markdown-text, no-wrap
msgid "    0 upperToAlpha : IsUpper c -> IsAlpha c\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1314
#, markdown-text, no-wrap
msgid "    0 lowerToAlphaNum : IsLower c -> IsAlphaNum c\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1317
#, markdown-text, no-wrap
msgid ""
"    0 upperToAlphaNum : IsUpper c -> IsAlphaNum c\n"
"    ```\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1324
#, markdown-text, no-wrap
msgid ""
"    The following (`asciiToLatin`) is trickier. Remember that\n"
"    `(<=)` is transitive. However, in your invocation of the proof\n"
"    of transitivity, you will not be able to apply direct proof search "
"using\n"
"    `%search` because the search depth is too small. You could\n"
"    increase the search depth, but it is much more efficient\n"
"    to use `safeDecideOn` instead.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1327
#, markdown-text, no-wrap
msgid ""
"    ```idris\n"
"    0 asciiToLatin : IsAscii c -> IsLatin c\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1330
#, markdown-text, no-wrap
msgid ""
"    0 plainAsciiToPlainLatin : IsPlainAscii c -> IsPlainLatin c\n"
"    ```\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1334
#, markdown-text
msgid ""
"Before we turn our full attention to predicates on strings, we have to cover "
"lists first, because we will often treat strings as lists of characters."
msgstr ""

#. type: Bullet: '13. '
#: ../src/Tutorial/Prim.md:1336
#, markdown-text
msgid "Implement `Decidable` for `Head`:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1341
#, markdown-text, no-wrap
msgid ""
"    ```idris\n"
"    data Head : (p : a -> Type) -> List a -> Type where\n"
"      AtHead : {0 p : a -> Type} -> (0 prf : p v) -> Head p (v :: vs)\n"
"    ```\n"
msgstr ""

#. type: Bullet: '14. '
#: ../src/Tutorial/Prim.md:1343
#, markdown-text
msgid "Implement `Decidable` for `Length`:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1350
#, markdown-text, no-wrap
msgid ""
"    ```idris\n"
"    data Length : (p : Nat -> Type) -> List a -> Type where\n"
"      HasLength :  {0 p : Nat -> Type}\n"
"                -> (0 prf : p (List.length vs))\n"
"                -> Length p vs\n"
"    ```\n"
msgstr ""

#. type: Bullet: '15. '
#: ../src/Tutorial/Prim.md:1354
#, markdown-text
msgid ""
"The following predicate is a proof that all values in a list of values "
"fulfill the given predicate. We will use this to limit the valid set of "
"characters in a string."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1363
#, markdown-text, no-wrap
msgid ""
"    ```idris\n"
"    data All : (p : a -> Type) -> (as : List a) -> Type where\n"
"      Nil  : All p []\n"
"      (::) :  {0 p : a -> Type}\n"
"           -> (0 h : p v)\n"
"           -> (0 t : All p vs)\n"
"           -> All p (v :: vs)\n"
"    ```\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1365
#, markdown-text, no-wrap
msgid "    Implement `Decidable` for `All`.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1373
#, markdown-text, no-wrap
msgid ""
"    For a real challenge, try to make your implementation of\n"
"    `decide` tail recursive. This will be important for real world\n"
"    applications on the JavaScript backends, where we might want to\n"
"    refine strings of thousands of characters without overflowing the\n"
"    stack at runtime. In order to come up with a tail recursive "
"implementation,\n"
"    you will need an additional data type `AllSnoc` witnessing that a "
"predicate\n"
"    holds for all elements in a `SnocList`.\n"
msgstr ""

#. type: Bullet: '16. '
#: ../src/Tutorial/Prim.md:1379
#, markdown-text
msgid ""
"It's time to come to an end here. An identifier in Idris is a sequence of "
"alphanumeric characters, possibly separated by underscore characters "
"(`_`). In addition, all identifiers must start with a letter.  Given this "
"specification, implement predicate `IdentChar`, from which we can define a "
"new wrapper type for identifiers:"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1382
#, markdown-text, no-wrap
msgid ""
"    ```idris\n"
"    0 IdentChars : List Char -> Type\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1388
#, markdown-text, no-wrap
msgid ""
"    record Identifier where\n"
"      constructor MkIdentifier\n"
"      value : String\n"
"      0 prf : IdentChars (unpack value)\n"
"    ```\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1391
#, markdown-text, no-wrap
msgid ""
"    Implement a factory method `identifier` for converting strings\n"
"    of unknown source at runtime:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1395
#, markdown-text, no-wrap
msgid ""
"    ```idris\n"
"    identifier : String -> Maybe Identifier\n"
"    ```\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1398
#, markdown-text, no-wrap
msgid ""
"    In addition, implement `fromString` for `Identifier` and verify,\n"
"    that the following is a valid identifier:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1403
#, markdown-text, no-wrap
msgid ""
"    ```idris\n"
"    testIdent : Identifier\n"
"    testIdent = \"fooBar_123\"\n"
"    ```\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Prim.md:1409
#, markdown-text
msgid ""
"Final remarks: Proofing stuff about the primitives can be challenging, both "
"when deciding on what axioms to use and when trying to make things perform "
"well at runtime and compile time. I'm experimenting with a library, which "
"deals with these issues. It is not yet finished, but you can have a look at "
"it [here](https://github.com/stefan-hoeck/idris2-prim)."
msgstr ""

#. type: Title #
#: ../src/Tutorial/Traverse.md:1
#, markdown-text, no-wrap
msgid "Effectful Traversals"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:11
#, markdown-text
msgid ""
"In this chapter, we are going to bring our treatment of the higher-kinded "
"interfaces in the *Prelude* to an end. In order to do so, we will continue "
"developing the CSV reader we started implementing in chapter [Functor and "
"Friends](Functor.md). I moved some of the data types and interfaces from "
"that chapter to their own modules, so we can import them here without the "
"need to start from scratch."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:16
#, markdown-text
msgid ""
"Note that unlike in our original CSV reader, we will use `Validated` instead "
"of `Either` for handling exceptions, since this will allow us to accumulate "
"all errors when reading a CSV file."
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:17
#, no-wrap
msgid ""
"module Tutorial.Traverse\n"
"\n"
"import Data.HList\n"
"import Data.IORef\n"
"import Data.List1\n"
"import Data.String\n"
"import Data.Validated\n"
"import Data.Vect\n"
"import Text.CSV\n"
"\n"
"%default total\n"
msgstr ""

#. type: Title ##
#: ../src/Tutorial/Traverse.md:31
#, markdown-text, no-wrap
msgid "Reading CSV Tables"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:37
#, markdown-text
msgid ""
"We stopped developing our CSV reader with function `hdecode`, which allows "
"us to read a single line in a CSV file and decode it to a heterogeneous "
"list.  As a reminder, here is how to use `hdecode` at the REPL:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Traverse.md:38
#, no-wrap
msgid ""
"Tutorial.Traverse> hdecode [Bool,String,Bits8] 1 \"f,foo,12\"\n"
"Valid [False, \"foo\", 12]\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:51
#, markdown-text
msgid ""
"The next step will be to parse a whole CSV table, represented as a list of "
"strings, where each string corresponds to one of the table's rows.  We will "
"go about this stepwise as there are several aspects about doing this "
"properly. What we are looking for - eventually - is a function of the "
"following type (we are going to implement several versions of this function, "
"hence the numbering):"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:52
#, no-wrap
msgid ""
"hreadTable1 :  (0 ts : List Type)\n"
"            -> CSVLine (HList ts)\n"
"            => List String\n"
"            -> Validated CSVError (List $ HList ts)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:61
#, markdown-text
msgid "In our first implementation, we are not going to care about line numbers:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:62
#, no-wrap
msgid ""
"hreadTable1 _  []        = pure []\n"
"hreadTable1 ts (s :: ss) = [| hdecode ts 0 s :: hreadTable1 ts ss |]\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:72
#, markdown-text
msgid ""
"Note, how we can just use applicative syntax in the implementation of "
"`hreadTable1`. To make this clearer, I used `pure []` on the first line "
"instead of the more specific `Valid []`. In fact, if we used `Either` or "
"`Maybe` instead of `Validated` for error handling, the implementation of "
"`hreadTable1` would look exactly the same."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:81
#, markdown-text, no-wrap
msgid ""
"The question is: Can we extract a pattern to abstract over\n"
"from this observation? What we do in `hreadTable1` is running\n"
"an effectful computation of type `String -> Validated CSVError (HList ts)`\n"
"over a list of strings, so that the result is a list of `HList ts`\n"
"wrapped in a `Validated CSVError`. The first step of abstraction\n"
"should be to use type parameters for the input and output:\n"
"Run a computation of type `a -> Validated CSVError b` over a\n"
"list `List a`:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:82
#, no-wrap
msgid ""
"traverseValidatedList :  (a -> Validated CSVError b)\n"
"                      -> List a\n"
"                      -> Validated CSVError (List b)\n"
"traverseValidatedList _ []        = pure []\n"
"traverseValidatedList f (x :: xs) = [| f x :: traverseValidatedList f xs "
"|]\n"
"\n"
"hreadTable2 :  (0 ts : List Type)\n"
"            -> CSVLine (HList ts)\n"
"            => List String\n"
"            -> Validated CSVError (List $ HList ts)\n"
"hreadTable2 ts = traverseValidatedList (hdecode ts 0)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:104
#, markdown-text
msgid ""
"But our observation was, that the implementation of `hreadTable1` would be "
"exactly the same if we used `Either CSVError` or `Maybe` as our effect types "
"instead of `Validated CSVError`.  So, the next step should be to abstract "
"over the *effect type*.  We note, that we used applicative syntax (idiom "
"brackets and `pure`) in our implementation, so we will need to write a "
"function with an `Applicative` constraint on the effect type:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:105
#, no-wrap
msgid ""
"traverseList :  Applicative f => (a -> f b) -> List a -> f (List b)\n"
"traverseList _ []        = pure []\n"
"traverseList f (x :: xs) = [| f x :: traverseList f xs |]\n"
"\n"
"hreadTable3 :  (0 ts : List Type)\n"
"            -> CSVLine (HList ts)\n"
"            => List String\n"
"            -> Validated CSVError (List $ HList ts)\n"
"hreadTable3 ts = traverseList (hdecode ts 0)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:120
#, markdown-text
msgid ""
"Note, how the implementation of `traverseList` is exactly the same as the "
"one of `traverseValidatedList`, but the types are more general and "
"therefore, `traverseList` is much more powerful."
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Traverse.md:123
#, no-wrap
msgid ""
"Tutorial.Traverse> hreadTable3 [Bool,Bits8] [\"f,12\",\"t,0\"]\n"
"Valid [[False, 12], [True, 0]]\n"
"Tutorial.Traverse> hreadTable3 [Bool,Bits8] [\"f,12\",\"t,1000\"]\n"
"Invalid (FieldError 0 2 \"1000\")\n"
"Tutorial.Traverse> hreadTable3 [Bool,Bits8] [\"1,12\",\"t,1000\"]\n"
"Invalid (Append (FieldError 0 1 \"1\") (FieldError 0 2 \"1000\"))\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:139
#, markdown-text
msgid ""
"This works very well already, but note how our error messages do not yet "
"print the correct line numbers. That's not surprising, as we are using a "
"dummy constant in our call to `hdecode`.  We will look at how we can come up "
"with the line numbers on the fly when we talk about stateful computations "
"later in this chapter.  For now, we could just manually annotate the lines "
"with their numbers and pass a list of pairs to `hreadTable`:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:140
#, no-wrap
msgid ""
"hreadTable4 :  (0 ts : List Type)\n"
"            -> CSVLine (HList ts)\n"
"            => List (Nat, String)\n"
"            -> Validated CSVError (List $ HList ts)\n"
"hreadTable4 ts = traverseList (uncurry $ hdecode ts)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:154
#, markdown-text
msgid ""
"If this is the first time you came across function `uncurry`, make sure you "
"have a look at its type and try to figure out why it is used here. There are "
"several utility functions like this in the *Prelude*, such as `curry`, "
"`uncurry`, `flip`, or even `id`, all of which can be very useful when "
"working with higher-order functions."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:157
#, markdown-text
msgid ""
"While not perfect, this version at least allows us to verify at the REPL "
"that the line numbers are passed to the error messages correctly:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Traverse.md:158
#, no-wrap
msgid ""
"Tutorial.Traverse> hreadTable4 [Bool,Bits8] [(1,\"t,1000\"),(2,\"1,100\")]\n"
"Invalid (Append (FieldError 1 2 \"1000\") (FieldError 2 1 \"1\"))\n"
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Traverse.md:163
#, markdown-text, no-wrap
msgid "Interface Traversable"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:172
#, markdown-text
msgid ""
"Now, here is an interesting observation: We can implement a function like "
"`traverseList` for other container types as well. You might think that's "
"obvious, given that we can convert container types to lists via function "
"`toList` from interface `Foldable`. However, while going via `List` might be "
"feasible in some occasions, it is undesirable in general, as we loose typing "
"information. For instance, here is such a function for `Vect`:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:173
#, no-wrap
msgid ""
"traverseVect' : Applicative f => (a -> f b) -> Vect n a -> f (List b)\n"
"traverseVect' fun = traverseList fun . toList\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:182
#, markdown-text
msgid ""
"Note how we lost all information about the structure of the original "
"container type. What we are looking for is a function like `traverseVect'`, "
"which keeps this type level information: The result should be a vector of "
"the same length as the input."
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:183
#, no-wrap
msgid ""
"traverseVect : Applicative f => (a -> f b) -> Vect n a -> f (Vect n b)\n"
"traverseVect _   []        = pure []\n"
"traverseVect fun (x :: xs) = [| fun x :: traverseVect fun xs |]\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:193
#, markdown-text
msgid ""
"That's much better! And as I wrote above, we can easily get the same for "
"other container types like `List1`, `SnocList`, `Maybe`, and so on.  As "
"usual, some derived functions will follow immediately from `traverseXY`.  "
"For instance:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:194
#, no-wrap
msgid ""
"sequenceList : Applicative f => List (f a) -> f (List a)\n"
"sequenceList = traverseList id\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:202
#, markdown-text
msgid ""
"All of this calls for a new interface, which is called `Traversable` and is "
"exported from the *Prelude*. Here is its definition (with primes for "
"disambiguation):"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:203
#, no-wrap
msgid ""
"interface Functor t => Foldable t => Traversable' t where\n"
"  traverse' : Applicative f => (a -> f b) -> t a -> f (t b)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:214
#, markdown-text
msgid ""
"Function `traverse` is one of the most abstract and versatile functions "
"available from the *Prelude*. Just how powerful it is will only become clear "
"once you start using it over and over again in your code. However, it will "
"be the goal of the remainder of this chapter to show you several diverse and "
"interesting use cases."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:229
#, markdown-text
msgid ""
"For now, we will quickly focus on the degree of abstraction.  Function "
"`traverse` is parameterized over no less than four parameters: The container "
"type `t` (`List`, `Vect n`, `Maybe`, to just name a few), the effect type "
"(`Validated e`, `IO`, `Maybe`, and so on), the input element type `a`, and "
"the output element type `b`. Considering that the libraries bundled with the "
"Idris project export more than 30 data types with an implementation of "
"`Applicative` and more than ten traversable container types, there are "
"literally hundreds of combinations for traversing a container with an "
"effectful computation. This number gets even larger once we realize that "
"traversable containers - like applicative functors - are closed under "
"composition (see the exercises and the final section in this chapter)."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Traverse.md:230
#, markdown-text, no-wrap
msgid "Traversable Laws"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:233
#, markdown-text
msgid "There are two laws function `traverse` must obey:"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Traverse.md:241
#, markdown-text
msgid ""
"`traverse (Id . f) = Id . map f`: Traversing over the `Identity` monad is "
"just functor `map`."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Traverse.md:241
#, markdown-text
msgid ""
"`traverse (MkComp . map f . g) = MkComp . map (traverse f) . traverse g`: "
"Traversing with a composition of effects must be the same when being done in "
"a single traversal (left hand side) or a sequence of two traversals (right "
"hand side)."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:246
#, markdown-text
msgid ""
"Since `map id = id` (functor's identity law), we can derive from the first "
"law that `traverse Id = Id`. This means, that `traverse` must not change the "
"size or shape of the container type, nor is it allowed to change the order "
"of elements."
msgstr ""

#. type: Bullet: '1. '
#: ../src/Tutorial/Traverse.md:253
#, markdown-text
msgid ""
"It is interesting that `Traversable` has a `Functor` constraint. Proof that "
"every `Traversable` is automatically a `Functor` by implementing `map` in "
"terms of `traverse`."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:255
#, markdown-text, no-wrap
msgid "   Hint: Remember `Control.Monad.Identity`.\n"
msgstr ""

#. type: Bullet: '2. '
#: ../src/Tutorial/Traverse.md:259
#, markdown-text
msgid ""
"Likewise, proof that every `Traversable` is a `Foldable` by implementing "
"`foldMap` in terms of `Traverse`."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:261
#, markdown-text, no-wrap
msgid "   Hint: Remember `Control.Applicative.Const`.\n"
msgstr ""

#. type: Bullet: '3. '
#: ../src/Tutorial/Traverse.md:264
#, markdown-text
msgid ""
"To gain some routine, implement `Traversable'` for `List1`, `Either e`, and "
"`Maybe`."
msgstr ""

#. type: Bullet: '4. '
#: ../src/Tutorial/Traverse.md:266
#, markdown-text
msgid "Implement `Traversable` for `List01 ne`:"
msgstr ""

#. type: Bullet: '5. '
#: ../src/Tutorial/Traverse.md:275
#, markdown-text
msgid ""
"Implement `Traversable` for rose trees. Try to satisfy the totality checker "
"without cheating."
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:276
#, no-wrap
msgid ""
"   record Tree a where\n"
"     constructor Node\n"
"     value  : a\n"
"     forest : List (Tree a)\n"
msgstr ""

#. type: Bullet: '6. '
#: ../src/Tutorial/Traverse.md:284
#, markdown-text
msgid "Implement `Traversable` for `Crud i`:"
msgstr ""

#. type: Bullet: '7. '
#: ../src/Tutorial/Traverse.md:294
#, markdown-text
msgid "Implement `Traversable` for `Response e i`:"
msgstr ""

#. type: Bullet: '8. '
#: ../src/Tutorial/Traverse.md:307
#, markdown-text
msgid ""
"Like `Functor`, `Applicative` and `Foldable`, `Traversable` is closed under "
"composition. Proof this by implementing `Traversable` for `Comp` and "
"`Product`:"
msgstr ""

#. type: Title ##
#: ../src/Tutorial/Traverse.md:319
#, markdown-text, no-wrap
msgid "Programming with State"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:324
#, markdown-text
msgid ""
"Let's go back to our CSV reader. In order to get reasonable error messages, "
"we'd like to tag each line with its index:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:325
#, no-wrap
msgid "zipWithIndex : List a -> List (Nat, a)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:331
#, markdown-text
msgid ""
"It is, of course, very easy to come up with an ad hoc implementation for "
"this:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:332
#, no-wrap
msgid ""
"zipWithIndex = go 1\n"
"  where go : Nat -> List a -> List (Nat,a)\n"
"        go _ []        = []\n"
"        go n (x :: xs) = (n,x) :: go (S n) xs\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:344
#, markdown-text
msgid ""
"While this is perfectly fine, we should still note that we might want to do "
"the same thing with the elements of trees, vectors, non-empty lists and so "
"on.  And again, we are interested in whether there is some form of "
"abstraction we can use to describe such computations."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Traverse.md:345
#, markdown-text, no-wrap
msgid "Mutable References in Idris"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:352
#, markdown-text
msgid ""
"Let us for a moment think about how we'd do such a thing in an imperative "
"language. There, we'd probably define a local (mutable) variable to keep "
"track of the current index, which would then be increased while iterating "
"over the list in a `for`- or `while`-loop."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:363
#, markdown-text
msgid ""
"In Idris, there is no such thing as mutable state.  Or is there? Remember, "
"how we used a mutable reference to simulate a data base connection in an "
"earlier exercise. There, we actually used some truly mutable state. However, "
"since accessing or modifying a mutable variable is not a referential "
"transparent operation, such actions have to be performed within `IO`.  Other "
"than that, nothing keeps us from using mutable variables in our code. The "
"necessary functionality is available from module `Data.IORef` from the "
"*base* library."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:367
#, markdown-text
msgid ""
"As a quick exercise, try to implement a function, which - given an `IORef "
"Nat` - pairs a value with the current index and increases the index "
"afterwards."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:369
#, markdown-text
msgid "Here's how I would do this:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:370
#, no-wrap
msgid ""
"pairWithIndexIO : IORef Nat -> a -> IO (Nat,a)\n"
"pairWithIndexIO ref va = do\n"
"  ix <- readIORef ref\n"
"  writeIORef ref (S ix)\n"
"  pure (ix,va)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:387
#, markdown-text, no-wrap
msgid ""
"Note, that every time we *run* `pairWithIndexIO ref`, the\n"
"natural number stored in `ref` is incremented by one.\n"
"Also, look at the type of `pairWithIndexIO ref`: `a -> IO (Nat,a)`.\n"
"We want to apply this effectful computation to each element\n"
"in a list, which should lead to a new list wrapped in `IO`,\n"
"since all of this describes a single computation with side\n"
"effects. But this is *exactly* what function `traverse` does: Our\n"
"input type is `a`, our output type is `(Nat,a)`, our\n"
"container type is `List`, and the effect type is `IO`!\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:388
#, no-wrap
msgid ""
"zipListWithIndexIO : IORef Nat -> List a -> IO (List (Nat,a))\n"
"zipListWithIndexIO ref = traverse (pairWithIndexIO ref)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:397
#, markdown-text
msgid ""
"Now *this* is really powerful: We could apply the same function to *any* "
"traversable data structure. It therefore makes absolutely no sense to "
"specialize `zipListWithIndexIO` to lists only:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:398
#, no-wrap
msgid ""
"zipWithIndexIO : Traversable t => IORef Nat -> t a -> IO (t (Nat,a))\n"
"zipWithIndexIO ref = traverse (pairWithIndexIO ref)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:405
#, markdown-text
msgid ""
"To please our intellectual minds even more, here is the same function in "
"point-free style:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:406
#, no-wrap
msgid ""
"zipWithIndexIO' : Traversable t => IORef Nat -> t a -> IO (t (Nat,a))\n"
"zipWithIndexIO' = traverse . pairWithIndexIO\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:413
#, markdown-text
msgid ""
"All that's left to do now is to initialize a new mutable variable before "
"passing it to `zipWithIndexIO`:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:414
#, no-wrap
msgid ""
"zipFromZeroIO : Traversable t => t a -> IO (t (Nat,a))\n"
"zipFromZeroIO ta = newIORef 0 >>= (`zipWithIndexIO` ta)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:420
#, markdown-text
msgid "Quickly, let's give this a go at the REPL:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Traverse.md:421
#, no-wrap
msgid ""
"> :exec zipFromZeroIO {t = List} [\"hello\", \"world\"] >>= printLn\n"
"[(0, \"hello\"), (1, \"world\")]\n"
"> :exec zipFromZeroIO (Just 12) >>= printLn\n"
"Just (0, 12)\n"
"> :exec zipFromZeroIO {t = Vect 2} [\"hello\", \"world\"] >>= printLn\n"
"[(0, \"hello\"), (1, \"world\")]\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:432
#, markdown-text
msgid ""
"Thus, we solved the problem of tagging each element with its index once and "
"for all for all traversable container types."
msgstr ""

#. type: Title ###
#: ../src/Tutorial/Traverse.md:433
#, markdown-text, no-wrap
msgid "The State Monad"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:441
#, markdown-text
msgid ""
"Alas, while the solution presented above is elegant and performs very well, "
"it still carries its `IO` stain, which is fine if we are already in `IO` "
"land, but unacceptable otherwise. We do not want to make our otherwise pure "
"functions much harder to test and reason about just for a simple case of "
"stateful element tagging."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:450
#, markdown-text
msgid ""
"Luckily, there is an alternative to using a mutable reference, which allows "
"us to keep our computations pure and untainted. However, it is not easy to "
"come upon this alternative on one's own, and it can be hard to figure out "
"what's going on here, so I'll try to introduce this slowly.  We first need "
"to ask ourselves what the essence of a \"stateful\" but otherwise pure "
"computation is. There are two essential ingredients:"
msgstr ""

#. type: Bullet: '1. '
#: ../src/Tutorial/Traverse.md:458
#, markdown-text
msgid ""
"Access to the *current* state. In case of a pure function, this means that "
"the function should take the current state as one of its arguments."
msgstr ""

#. type: Bullet: '2. '
#: ../src/Tutorial/Traverse.md:458
#, markdown-text
msgid ""
"Ability to communicate the updated state to later stateful computations. In "
"case of a pure function this means, that the function will return a pair of "
"values: The computation's result plus the updated state."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:462
#, markdown-text
msgid ""
"These two prerequisites lead to the following generic type for a pure, "
"stateful computation operating on state type `st` and producing values of "
"type `a`:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:463
#, no-wrap
msgid ""
"Stateful : (st : Type) -> (a : Type) -> Type\n"
"Stateful st a = st -> (st, a)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:470
#, markdown-text
msgid ""
"Our use case is pairing elements with indices, which can be implemented as a "
"pure, stateful computation like so:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:471
#, no-wrap
msgid ""
"pairWithIndex' : a -> Stateful Nat (Nat,a)\n"
"pairWithIndex' v index = (S index, (index,v))\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:479
#, markdown-text
msgid ""
"Note, how we at the same time increment the index, returning the incremented "
"value as the new state, while pairing the first argument with the original "
"index."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:488
#, markdown-text
msgid ""
"Now, here is an important thing to note: While `Stateful` is a useful type "
"alias, Idris in general does *not* resolve interface implementations for "
"function types. If we want to write a small library of utility functions "
"around such a type, it is therefore best to wrap it in a single-constructor "
"data type and use this as our building block for writing more complex "
"computations. We therefore introduce record `State` as a wrapper for pure, "
"stateful computations:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:489
#, no-wrap
msgid ""
"record State st a where\n"
"  constructor ST\n"
"  runST : st -> (st,a)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:496
#, markdown-text
msgid "We can now implement `pairWithIndex` in terms of `State` like so:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:497
#, no-wrap
msgid ""
"pairWithIndex : a -> State Nat (Nat,a)\n"
"pairWithIndex v = ST $ \\index => (S index, (index, v))\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:505
#, markdown-text
msgid ""
"In addition, we can define some more utility functions. Here's one for "
"getting the current state without modifying it (this corresponds to "
"`readIORef`):"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:506
#, no-wrap
msgid ""
"get : State st st\n"
"get = ST $ \\s => (s,s)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:513
#, markdown-text
msgid ""
"Here are two others, for overwriting the current state. These corresponds to "
"`writeIORef` and `modifyIORef`:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:514
#, no-wrap
msgid ""
"put : st -> State st ()\n"
"put v = ST $ \\_ => (v,())\n"
"\n"
"modify : (st -> st) -> State st ()\n"
"modify f = ST $ \\v => (f v,())\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:524
#, markdown-text
msgid ""
"Finally, we can define three functions in addition to `runST` for running "
"stateful computations"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:525
#, no-wrap
msgid ""
"runState : st -> State st a -> (st, a)\n"
"runState = flip runST\n"
"\n"
"evalState : st -> State st a -> a\n"
"evalState s = snd . runState s\n"
"\n"
"execState : st -> State st a -> st\n"
"execState s = fst . runState s\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:542
#, markdown-text
msgid ""
"All of these are useful on their own, but the real power of `State s` comes "
"from the observation that it is a monad.  Before you go on, please spend "
"some time and try implementing `Functor`, `Applicative`, and `Monad` for "
"`State s` yourself.  Even if you don't succeed, you will have an easier time "
"understanding how the implementations below work."
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:543
#, no-wrap
msgid ""
"Functor (State st) where\n"
"  map f (ST run) = ST $ \\s => let (s2,va) = run s in (s2, f va)\n"
"\n"
"Applicative (State st) where\n"
"  pure v = ST $ \\s => (s,v)\n"
"\n"
"  ST fun <*> ST val = ST $ \\s =>\n"
"    let (s2, f)  = fun s\n"
"        (s3, va) = val s2\n"
"     in (s3, f va)\n"
"\n"
"Monad (State st) where\n"
"  ST val >>= f = ST $ \\s =>\n"
"    let (s2, va) = val s\n"
"     in runST (f va) s2\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:573
#, markdown-text
msgid ""
"This may take some time to digest, so we come back to it in a slightly "
"advanced exercise. The most important thing to note is, that we use every "
"state value only ever once. We *must* make sure that the updated state is "
"passed to later computations, otherwise the information about state updates "
"is being lost. This can best be seen in the implementation of `Applicative`: "
"The initial state, `s`, is used in the computation of the function value, "
"which will also return an updated state, `s2`, which is then used in the "
"computation of the function argument. This will again return an updated "
"state, `s3`, which is passed on to later stateful computations together with "
"the result of applying `f` to `va`."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:583
#, markdown-text
msgid ""
"This sections consists of two extended exercise, the aim of which is to "
"increase your understanding of the state monad.  In the first exercise, we "
"will look at random value generation, a classical application of stateful "
"computations.  In the second exercise, we will look at an indexed version of "
"a state monad, which allows us to not only change the state's value but also "
"its *type* during computations."
msgstr ""

#. type: Bullet: '1. '
#: ../src/Tutorial/Traverse.md:590
#, markdown-text
msgid ""
"Below is the implementation of a simple pseudo-random number generator. We "
"call this a *pseudo-random* number generator, because the numbers look "
"pretty random but are generated predictably. If we initialize a series of "
"such computations with a truly random seed, most users of our library will "
"not be able to predict the outcome of our computations."
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:591
#, no-wrap
msgid ""
"   rnd : Bits64 -> Bits64\n"
"   rnd seed = fromInteger\n"
"            $ (437799614237992725 * cast seed) `mod` 2305843009213693951\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:604
#, markdown-text, no-wrap
msgid ""
"   The idea here is that the next pseudo-random number gets\n"
"   calculated from the previous one. But once we think about\n"
"   how we can use these numbers as seeds for computing\n"
"   random values of other types, we realize that these are\n"
"   just stateful computations. We can therefore write\n"
"   down an alias for random value generators as stateful\n"
"   computations:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:605
#, no-wrap
msgid ""
"   Gen : Type -> Type\n"
"   Gen = State Bits64\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:617
#, markdown-text, no-wrap
msgid ""
"   Before we begin, please note that `rnd` is not a very strong\n"
"   pseudo-random number generator. It will not generate values in\n"
"   the full 64bit range, nor is it safe to use in cryptographic\n"
"   applications. It is sufficient for our purposes in this chapter,\n"
"   however. Note also, that we could replace `rnd` with a stronger\n"
"   generator without any changes to the functions you will implement\n"
"   as part of this exercise.\n"
msgstr ""

#. type: Bullet: '   1. '
#: ../src/Tutorial/Traverse.md:622
#, markdown-text
msgid ""
"Implement `bits64` in terms of `rnd`. This should return the current state, "
"updating it afterwards by invoking function `rnd`. Make sure the state is "
"properly updated, otherwise this won't behave as expected."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:626
#, markdown-text, no-wrap
msgid ""
"      ```idris\n"
"      bits64 : Gen Bits64\n"
"      ```\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:631
#, markdown-text, no-wrap
msgid ""
"      This will be our *only* primitive generator, from which\n"
"      we will derived all the others. Therefore,\n"
"      before you continue, quickly test your implementation of\n"
"      `bits64` at the REPL:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:636
#, markdown-text, no-wrap
msgid ""
"      ```repl\n"
"      Solutions.Traverse> runState 100 bits64\n"
"      (2274787257952781382, 100)\n"
"      ```\n"
msgstr ""

#. type: Bullet: '   2. '
#: ../src/Tutorial/Traverse.md:642
#, markdown-text
msgid ""
"Implement `range64` for generating random values in the range "
"`[0,upper]`. Hint: Use `bits64` and `mod` in your implementation but make "
"sure to deal with the fact that `mod x upper` produces values in the range "
"`[0,upper)`."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:646
#, markdown-text, no-wrap
msgid ""
"      ```idris\n"
"      range64 : (upper : Bits64) -> Gen Bits64\n"
"      ```\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:649
#, markdown-text, no-wrap
msgid ""
"      Likewise, implement `interval64` for generating values\n"
"      in the range `[min a b, max a b]`:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:653
#, markdown-text, no-wrap
msgid ""
"      ```idris\n"
"      interval64 : (a,b : Bits64) -> Gen Bits64\n"
"      ```\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:655
#, markdown-text, no-wrap
msgid "      Finally, implement `interval` for arbitrary integral types.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:659
#, markdown-text, no-wrap
msgid ""
"      ```idris\n"
"      interval : Num n => Cast n Bits64 => (a,b : n) -> Gen n\n"
"      ```\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:663
#, markdown-text, no-wrap
msgid ""
"      Note, that `interval` will not generate all possible values in\n"
"      the given interval but only such values with a `Bits64`\n"
"      representation in the the range `[0,2305843009213693950]`.\n"
msgstr ""

#. type: Bullet: '   3. '
#: ../src/Tutorial/Traverse.md:665
#, markdown-text
msgid "Implement a generator for random boolean values."
msgstr ""

#. type: Bullet: '   4. '
#: ../src/Tutorial/Traverse.md:670
#, markdown-text
msgid ""
"Implement a generator for `Fin n`. You'll have to think carefully about "
"getting this one to typecheck and be accepted by the totality checker "
"without cheating.  Note: Have a look at function `Data.Fin.natToFin`."
msgstr ""

#. type: Bullet: '   5. '
#: ../src/Tutorial/Traverse.md:674
#, markdown-text
msgid ""
"Implement a generator for selecting a random element from a vector of "
"values. Use the generator from exercise 4 in your implementation."
msgstr ""

#. type: Bullet: '   6. '
#: ../src/Tutorial/Traverse.md:678
#, markdown-text
msgid ""
"Implement `vect` and `list`. In case of `list`, the first argument should be "
"used to randomly determine the length of the list."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:681
#, markdown-text, no-wrap
msgid ""
"      ```idris\n"
"      vect : {n : _} -> Gen a -> Gen (Vect n a)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:684
#, markdown-text, no-wrap
msgid ""
"      list : Gen Nat -> Gen a -> Gen (List a)\n"
"      ```\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:687
#, markdown-text, no-wrap
msgid ""
"      Use `vect` to implement utility function `testGen` for\n"
"      testing your generators at the REPL:\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:691
#, markdown-text, no-wrap
msgid ""
"      ```idris\n"
"      testGen : Bits64 -> Gen a -> Vect 10 a\n"
"      ```\n"
msgstr ""

#. type: Bullet: '   7. '
#: ../src/Tutorial/Traverse.md:693
#, markdown-text
msgid "Implement `choice`."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:697
#, markdown-text, no-wrap
msgid ""
"      ```idris\n"
"      choice : {n : _} -> Vect (S n) (Gen a) -> Gen a\n"
"      ```\n"
msgstr ""

#. type: Bullet: '   8. '
#: ../src/Tutorial/Traverse.md:699
#, markdown-text
msgid "Implement `either`."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:703
#, markdown-text, no-wrap
msgid ""
"      ```idris\n"
"      either : Gen a -> Gen b -> Gen (Either a b)\n"
"      ```\n"
msgstr ""

#. type: Bullet: '   9. '
#: ../src/Tutorial/Traverse.md:708
#, markdown-text
msgid ""
"Implement a generator for printable ASCII characters.  These are characters "
"with ASCII codes in the interval `[32,126]`. Hint: Function `chr` from the "
"*Prelude* will be useful here."
msgstr ""

#. type: Bullet: '   10. '
#: ../src/Tutorial/Traverse.md:711
#, markdown-text
msgid ""
"Implement a generator for strings. Hint: Function `pack` from the *Prelude* "
"might be useful for this."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:715
#, markdown-text, no-wrap
msgid ""
"       ```idris\n"
"       string : Gen Nat -> Gen Char -> Gen String\n"
"       ```\n"
msgstr ""

#. type: Bullet: '   11. '
#: ../src/Tutorial/Traverse.md:722
#, markdown-text
msgid ""
"We shouldn't forget about our ability to encode interesting things in the "
"types in Idris, so, for a challenge and without further ado, implement "
"`hlist` (note the distinction between `HListF` and `HList`). If you are "
"rather new to dependent types, this might take a moment to digest, so don't "
"forget to use holes."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:727
#, markdown-text, no-wrap
msgid ""
"       ```idris\n"
"       data HListF : (f : Type -> Type) -> (ts : List Type) -> Type where\n"
"         Nil  : HListF f []\n"
"         (::) : (x : f t) -> (xs : HLift f ts) -> HListF f (t :: ts)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:730
#, markdown-text, no-wrap
msgid ""
"       hlist : HListF Gen ts -> Gen (HList ts)\n"
"       ```\n"
msgstr ""

#. type: Bullet: '   12. '
#: ../src/Tutorial/Traverse.md:732
#, markdown-text
msgid "Generalize `hlist` to work with any applicative functor, not just `Gen`."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:736
#, markdown-text, no-wrap
msgid ""
"   If you arrived here, please realize how we can now generate "
"pseudo-random\n"
"   values for most primitives, as well as regular sum- and product types.\n"
"   Here is an example REPL session:\n"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Traverse.md:737
#, no-wrap
msgid ""
"   > testGen 100 $ hlist [bool, printableAscii, interval 0 127]\n"
"   [[True, ';', 5],\n"
"    [True, '^', 39],\n"
"    [False, 'o', 106],\n"
"    [True, 'k', 127],\n"
"    [False, ' ', 11],\n"
"    [False, '~', 76],\n"
"    [True, 'M', 11],\n"
"    [False, 'P', 107],\n"
"    [True, '5', 67],\n"
"    [False, '8', 9]]\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:764
#, markdown-text, no-wrap
msgid ""
"   Final remarks: Pseudo-random value generators play an important role\n"
"   in property based testing libraries like "
"[QuickCheck](https://hackage.haskell.org/package/QuickCheck)\n"
"   or [Hedgehog](https://github.com/stefan-hoeck/idris2-hedgehog).\n"
"   The idea of property based testing is to test predefined *properties* "
"of\n"
"   pure functions against a large number of randomly generated arguments,\n"
"   to get strong guarantees about these properties to hold for *all*\n"
"   possible arguments. One example would be a test for verifying\n"
"   that the result of reversing a list twice equals the original list.\n"
"   While it is possible to proof many of the simpler properties in Idris\n"
"   directly without the need for tests, this is no longer possible\n"
"   as soon as functions are involved, which don't reduce during "
"unification\n"
"   such as foreign function calls or functions not publicly exported from\n"
"   other modules.\n"
msgstr ""

#. type: Bullet: '2. '
#: ../src/Tutorial/Traverse.md:770
#, markdown-text
msgid ""
"While `State s a` gives us a convenient way to talk about stateful "
"computations, it only allows us to mutate the state's *value* but not its "
"*type*. For instance, the following function cannot be encapsulated in "
"`State` because the type of the state changes:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:771
#, no-wrap
msgid ""
"   uncons : Vect (S n) a -> (Vect n a, a)\n"
"   uncons (x :: xs) = (xs, x)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:784
#, markdown-text, no-wrap
msgid ""
"   Your task is to come up with a new state type allowing for\n"
"   such changes (sometimes referred to as an *indexed* state data type).\n"
"   The goal of this exercise is to also sharpen your skills in\n"
"   expressing things at the type level including derived function\n"
"   types and interfaces. Therefore, I will give only little\n"
"   guidance on how to go about this. If you get stuck, feel free to\n"
"   peek at the solutions but make sure to only look at the types\n"
"   at first.\n"
msgstr ""

#. type: Bullet: '   1. '
#: ../src/Tutorial/Traverse.md:790
#, markdown-text
msgid ""
"Come up with a parameterized data type for encapsulating stateful "
"computations where the input and output state type can differ. It must be "
"possible to wrap `uncons` in a value of this type."
msgstr ""

#. type: Bullet: '   2. '
#: ../src/Tutorial/Traverse.md:792
#, markdown-text
msgid "Implement `Functor` for your indexed state type."
msgstr ""

#. type: Bullet: '   3. '
#: ../src/Tutorial/Traverse.md:797
#, markdown-text
msgid ""
"It is not possible to implement `Applicative` for this *indexed* state type "
"(but see also exercise 2.vii).  Still, implement the necessary functions to "
"use it with idom brackets."
msgstr ""

#. type: Bullet: '   4. '
#: ../src/Tutorial/Traverse.md:801
#, markdown-text
msgid ""
"It is not possible to implement `Monad` for this indexed state type. Still, "
"implement the necessary functions to use it in do blocks."
msgstr ""

#. type: Bullet: '   5. '
#: ../src/Tutorial/Traverse.md:805
#, markdown-text
msgid ""
"Generalize the functions from exercises 3 and 4 with two new interfaces "
"`IxApplicative` and `IxMonad` and provide implementations of these for your "
"indexed state data type."
msgstr ""

#. type: Bullet: '   6. '
#: ../src/Tutorial/Traverse.md:809
#, markdown-text
msgid ""
"Implement functions `get`, `put`, `modify`, `runState`, `evalState`, and "
"`execState` for the indexed state data type. Make sure to adjust the type "
"parameters where necessary."
msgstr ""

#. type: Bullet: '   7. '
#: ../src/Tutorial/Traverse.md:812
#, markdown-text
msgid ""
"Show that your indexed state type is strictly more powerful than `State` by "
"implementing `Applicative` and `Monad` for it."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:816
#, markdown-text, no-wrap
msgid ""
"      Hint: Keep the input and output state identical. Note also,\n"
"      that you might need to implement `join` manually if Idris\n"
"      has trouble inferring the types correctly.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:821
#, markdown-text, no-wrap
msgid ""
"   Indexed state types can be useful when we want to make sure that\n"
"   stateful computations are combined in the correct sequence, or\n"
"   that scarce resources get cleaned up properly. We might get back\n"
"   to such use cases in later examples.\n"
msgstr ""

#. type: Title ##
#: ../src/Tutorial/Traverse.md:822
#, markdown-text, no-wrap
msgid "The Power of Composition"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:830
#, markdown-text
msgid ""
"After our excursion into the realms of stateful computations, we will go "
"back and combine mutable state with error accumulation to tag and read CSV "
"lines in a single traversal. We already defined `pairWithIndex` for tagging "
"lines with their indices.  We also have `uncurry $ hdecode ts` for decoding "
"single tagged lines.  We can now combine the two effects in a single "
"computation:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:831
#, no-wrap
msgid ""
"tagAndDecode :  (0 ts : List Type)\n"
"             -> CSVLine (HList ts)\n"
"             => String\n"
"             -> State Nat (Validated CSVError (HList ts))\n"
"tagAndDecode ts s = uncurry (hdecode ts) <$> pairWithIndex s\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:851
#, markdown-text
msgid ""
"Now, as we learned before, applicative functors are closed under "
"composition, and the result of `tagAndDecode` is a nesting of two "
"applicatives: `State Nat` and `Validated CSVError`.  The *Prelude* exports a "
"corresponding named interface implementation "
"(`Prelude.Applicative.Compose`), which we can use for traversing a list of "
"strings with `tagAndDecode`.  Remember, that we have to provide named "
"implementations explicitly.  Since `traverse` has the applicative functor as "
"its second constraint, we also need to provide the first constraint "
"(`Traversable`) explicitly. But this is going to be the unnamed default "
"implementation! To get our hands on such a value, we can use the `%search` "
"pragma:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:852
#, no-wrap
msgid ""
"readTable :  (0 ts : List Type)\n"
"          -> CSVLine (HList ts)\n"
"          => List String\n"
"          -> Validated CSVError (List $ HList ts)\n"
"readTable ts = evalState 1 . traverse @{%search} @{Compose} (tagAndDecode "
"ts)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:866
#, markdown-text
msgid ""
"This tells Idris to use the default implementation for the `Traversable` "
"constraint, and `Prelude.Applicatie.Compose` for the `Applicative` "
"constraint.  While this syntax is not very nice, it doesn't come up too "
"often, and if it does, we can improve things by providing custom functions "
"for better readability:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:867
#, no-wrap
msgid ""
"traverseComp : Traversable t\n"
"             => Applicative f\n"
"             => Applicative g\n"
"             => (a -> f (g b))\n"
"             -> t a\n"
"             -> f (g (t b))\n"
"traverseComp = traverse @{%search} @{Compose}\n"
"\n"
"readTable' :  (0 ts : List Type)\n"
"           -> CSVLine (HList ts)\n"
"           => List String\n"
"           -> Validated CSVError (List $ HList ts)\n"
"readTable' ts = evalState 1 . traverseComp (tagAndDecode ts)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:885
#, markdown-text
msgid ""
"Note, how this allows us to combine two computational effects (mutable state "
"and error accumulation) in a single list traversal."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:898
#, markdown-text
msgid ""
"But I am not yet done demonstrating the power of composition. As you showed "
"in one of the exercises, `Traversable` is also closed under composition, so "
"a nesting of traversables is again a traversable. Consider the following use "
"case: When reading a CSV file, we'd like to allow lines to be annotated with "
"additional information. Such annotations could be mere comments but also "
"some formatting instructions or other custom data tags might be feasible.  "
"Annotations are supposed to be separated from the rest of the content by a "
"single hash character (`#`).  We want to keep track of these optional "
"annotations so we come up with a custom data type encapsulating this "
"distinction:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:899
#, no-wrap
msgid ""
"data Line : Type -> Type where\n"
"  Annotated : String -> a -> Line a\n"
"  Clean     : a -> Line a\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:908
#, markdown-text
msgid ""
"This is just another container type and we can easily implement "
"`Traversable` for `Line` (do this yourself as a quick exercise):"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:909
#, no-wrap
msgid ""
"Functor Line where\n"
"  map f (Annotated s x) = Annotated s $ f x\n"
"  map f (Clean x)       = Clean $ f x\n"
"\n"
"Foldable Line where\n"
"  foldr f acc (Annotated _ x) = f x acc\n"
"  foldr f acc (Clean x)       = f x acc\n"
"\n"
"Traversable Line where\n"
"  traverse f (Annotated s x) = Annotated s <$> f x\n"
"  traverse f (Clean x)       = Clean <$> f x\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:928
#, markdown-text
msgid ""
"Below is a function for parsing a line and putting it in its correct "
"category. For simplicity, we just split the line on hashes: If the result "
"consists of exactly two strings, we treat the second part as an annotation, "
"otherwise we treat the whole line as untagged CSV content."
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:929
#, no-wrap
msgid ""
"readLine : String -> Line String\n"
"readLine s = case split ('#' ==) s of\n"
"  h ::: [t] => Annotated t h\n"
"  _         => Clean s\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:938
#, markdown-text
msgid ""
"We are now going to implement a function for reading whole CSV tables, "
"keeping track of line annotations:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:939
#, no-wrap
msgid ""
"readCSV :  (0 ts : List Type)\n"
"        -> CSVLine (HList ts)\n"
"        => String\n"
"        -> Validated CSVError (List $ Line $ HList ts)\n"
"readCSV ts = evalState 1\n"
"           . traverse @{Compose} @{Compose} (tagAndDecode ts)\n"
"           . map readLine\n"
"           . lines\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:966
#, markdown-text
msgid ""
"Let's digest this monstrosity. This is written in point-free style, so we "
"have to read it from end to beginning. First, we split the whole string at "
"line breaks, getting a list of strings (function `Data.String.lines`). Next, "
"we analyze each line, keeping track of optional annotations (`map "
"readLine`).  This gives us a value of type `List (Line String)`. Since this "
"is a nesting of traversables, we invoke `traverse` with a named instance "
"from the *Prelude*: `Prelude.Traversable.Compose`.  Idris can disambiguate "
"this based on the types, so we can drop the namespace prefix. But the "
"effectful computation we run over the list of lines results in a composition "
"of applicative functors, so we also need the named implementation for "
"compositions of applicatives in the second constraint (again without need of "
"an explicit prefix, which would be `Prelude.Applicative` here).  Finally, we "
"evaluate the stateful computation with `evalState 1`."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:974
#, markdown-text
msgid ""
"Honestly, I wrote all of this without verifying if it works, so let's give "
"it a go at the REPL. I'll provide two example strings for this, a valid one "
"without errors, and an invalid one. I use *multiline string literals* here, "
"about which I'll talk in more detail in a later chapter. For the moment, "
"note that these allow us to conveniently enter string literals with line "
"breaks:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:975
#, no-wrap
msgid ""
"validInput : String\n"
"validInput = \"\"\"\n"
"  f,12,-13.01#this is a comment\n"
"  t,100,0.0017\n"
"  t,1,100.8#color: red\n"
"  f,255,0.0\n"
"  f,24,1.12e17\n"
"  \"\"\"\n"
"\n"
"invalidInput : String\n"
"invalidInput = \"\"\"\n"
"  o,12,-13.01#another comment\n"
"  t,100,0.0017\n"
"  t,1,abc\n"
"  f,256,0.0\n"
"  f,24,1.12e17\n"
"  \"\"\"\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:996
#, markdown-text
msgid "And here's how it goes at the REPL:"
msgstr ""

#. type: Fenced code block (repl)
#: ../src/Tutorial/Traverse.md:997
#, no-wrap
msgid ""
"Tutorial.Traverse> readCSV [Bool,Bits8,Double] validInput\n"
"Valid [Annotated \"this is a comment\" [False, 12, -13.01],\n"
"       Clean [True, 100, 0.0017],\n"
"       Annotated \"color: red\" [True, 1, 100.8],\n"
"       Clean [False, 255, 0.0],\n"
"       Clean [False, 24, 1.12e17]]\n"
"\n"
"Tutorial.Traverse> readCSV [Bool,Bits8,Double] invalidInput\n"
"Invalid (Append (FieldError 1 1 \"o\")\n"
"  (Append (FieldError 3 3 \"abc\") (FieldError 4 2 \"256\")))\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:1015
#, markdown-text
msgid ""
"It is pretty amazing how we wrote dozens of lines of code, always being "
"guided by the type- and totality checkers, arriving eventually at a function "
"for parsing properly typed CSV tables with automatic line numbering and "
"error accumulation, all of which just worked on first try."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:1025
#, markdown-text
msgid ""
"The *Prelude* provides three additional interfaces for container types "
"parameterized over *two* type parameters such as `Either` or `Pair`: "
"`Bifunctor`, `Bifoldable`, and `Bitraversable`. In the following exercises "
"we get some hands-one experience working with these. You are supposed to "
"look up what functions they provide and how to implement and use them "
"yourself."
msgstr ""

#. type: Bullet: '1. '
#: ../src/Tutorial/Traverse.md:1029
#, markdown-text
msgid ""
"Assume we'd like to not only interpret CSV content but also the optional "
"comment tags in our CSV files.  For this, we could use a data type such as "
"`Tagged`:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:1030
#, no-wrap
msgid ""
"   data Tagged : (tag, value : Type) -> Type where\n"
"     Tag  : tag -> value -> Tagged tag value\n"
"     Pure : value -> Tagged tag value\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:1039
#, markdown-text, no-wrap
msgid ""
"   Implement interfaces `Functor`, `Foldable`, and `Traversable`\n"
"   but also `Bifunctor`, `Bifoldable`, and `Bitraversable`\n"
"   for `Tagged`.\n"
msgstr ""

#. type: Bullet: '2. '
#: ../src/Tutorial/Traverse.md:1045
#, markdown-text
msgid ""
"Show that the composition of a bifunctor with two functors such as `Either "
"(List a) (Maybe b)` is again a bifunctor by defining a dedicated wrapper "
"type for such compositions and writing a corresponding implementation of "
"`Bifunctor`.  Likewise for `Bifoldable`/`Foldable` and "
"`Bitraversable`/`Traversable`."
msgstr ""

#. type: Bullet: '3. '
#: ../src/Tutorial/Traverse.md:1051
#, markdown-text
msgid ""
"Show that the composition of a functor with a bifunctor such as `List "
"(Either a b)` is again a bifunctor by defining a dedicated wrapper type for "
"such compositions and writing a corresponding implementation of "
"`Bifunctor`.  Likewise for `Bifoldable`/`Foldable` and "
"`Bitraversable`/`Traversable`."
msgstr ""

#. type: Bullet: '4. '
#: ../src/Tutorial/Traverse.md:1055
#, markdown-text
msgid ""
"We are now going to adjust `readCSV` in such a way that it decodes comment "
"tags and CSV content in a single traversal.  We need a new error type to "
"include invalid tags for this:"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:1056
#, no-wrap
msgid ""
"   data TagError : Type where\n"
"     CE         : CSVError -> TagError\n"
"     InvalidTag : (line : Nat) -> (tag : String) -> TagError\n"
"     Append     : TagError -> TagError -> TagError\n"
"\n"
"   Semigroup TagError where (<+>) = Append\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:1066
#, markdown-text, no-wrap
msgid "   For testing, we also define a simple data type for color tags:\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:1067
#, no-wrap
msgid "   data Color = Red | Green | Blue\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:1076
#, markdown-text, no-wrap
msgid ""
"   You should now implement the following functions, but\n"
"   please note that while `readColor` will need to\n"
"   access the current line number in case of an error,\n"
"   it must *not* increase it, as otherwise line numbers\n"
"   will be wrong in the invocation of `tagAndDecodeTE`.\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:1077
#, no-wrap
msgid ""
"   readColor : String -> State Nat (Validated TagError Color)\n"
"\n"
"   readTaggedLine : String -> Tagged String String\n"
"\n"
"   tagAndDecodeTE :  (0 ts : List Type)\n"
"                  -> CSVLine (HList ts)\n"
"                  => String\n"
"                  -> State Nat (Validated TagError (HList ts))\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:1094
#, markdown-text, no-wrap
msgid ""
"   Finally, implement `readTagged` by using the wrapper type\n"
"   from exercise 3 as well as `readColor` and `tagAndDecodeTE`\n"
"   in a call to `bitraverse`.\n"
"   The implementation will look very similar to `readCSV` but\n"
"   with some additional wrapping and unwrapping at the right\n"
"   places.\n"
msgstr ""

#. type: Fenced code block (idris)
#: ../src/Tutorial/Traverse.md:1095
#, no-wrap
msgid ""
"   readTagged :  (0 ts : List Type)\n"
"              -> CSVLine (HList ts)\n"
"              => String\n"
"              -> Validated TagError (List $ Tagged Color $ HList ts)\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:1103
#, markdown-text, no-wrap
msgid "   Test your implementation with some example strings at the REPL.\n"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:1108
#, markdown-text
msgid ""
"You can find more examples for functor/bifunctor compositions in Haskell's "
"[bifunctors](https://hackage.haskell.org/package/bifunctors)  package."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:1117
#, markdown-text
msgid ""
"Interface `Traversable` and its main function `traverse` are incredibly "
"powerful forms of abstraction - even more so, because both `Applicative` and "
"`Traversable` are closed under composition. If you are interested in "
"additional use cases, the publication, which introduced `Traversable` to "
"Haskell, is a highly recommended read: [The Essence of the Iterator "
"Pattern](https://www.cs.ox.ac.uk/jeremy.gibbons/publications/iterator.pdf)"
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:1124
#, markdown-text
msgid ""
"The *base* library provides an extended version of the state monad in module "
"`Control.Monad.State`. We will look at this in more detail when we talk "
"about monad transformers.  Please note also, that `IO` itself is implemented "
"as a [simple state monad](IO.md#how-io-is-implemented)  over an abstract, "
"primitive state type: `%World`."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:1126
#, markdown-text
msgid "Here's a short summary of what we learned in this chapter:"
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Traverse.md:1138
#, markdown-text
msgid ""
"Function `traverse` is used to run effectful computations over container "
"types without affecting their size or shape."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Traverse.md:1138
#, markdown-text
msgid ""
"We can use `IORef` as mutable references in stateful computations running in "
"`IO`."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Traverse.md:1138
#, markdown-text
msgid ""
"For referentially transparent computations with \"mutable\" state, the "
"`State` monad is extremely useful."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Traverse.md:1138
#, markdown-text
msgid ""
"Applicative functors are closed under composition, so we can run several "
"effectful computations in a single traversal."
msgstr ""

#. type: Bullet: '* '
#: ../src/Tutorial/Traverse.md:1138
#, markdown-text
msgid ""
"Traversables are also closed under composition, so we can use `traverse` to "
"operate on a nesting of containers."
msgstr ""

#. type: Plain text
#: ../src/Tutorial/Traverse.md:1146
#, markdown-text
msgid ""
"For now, this concludes our introduction of the *Prelude*'s higher-kinded "
"interfaces, which started with the introduction of `Functor`, `Applicative`, "
"and `Monad`, before moving on to `Foldable`, and - last but definitely not "
"least - `Traversable`.  There's one still missing - `Alternative` - but this "
"will have to wait a bit longer, because we need to first make our brains "
"smoke with some more type-level wizardry."
msgstr ""

#. type: Title #
#: ../README.md:1
#, markdown-text, no-wrap
msgid "Functional Programming in Idris 2"
msgstr ""

#. type: Plain text
#: ../README.md:7
#, markdown-text
msgid ""
"The goal of this project is quickly explained: To become a more or less "
"comprehensive guide to the Idris programming language, with a lot of "
"introductory material targeted at newcomers to functional programming."
msgstr ""

#. type: Plain text
#: ../README.md:15
#, markdown-text
msgid ""
"The content will be organized in several parts, with the part about the core "
"language features being the main guide to functional programming in "
"Idris. Every part consists of several chapters, each trying to cover in "
"depth a certain aspect of the Idris programming language and its core "
"libraries. Most chapters come with (sometimes lots of) exercises, with "
"solutions available in directory `src/Solutions`."
msgstr ""

#. type: Plain text
#: ../README.md:20
#, markdown-text
msgid ""
"Right now, even the part about core language features is not yet finished, "
"but is being actively developed and tried on several of my own students, "
"some of which are completely new to functional programming."
msgstr ""

#. type: Title ##
#: ../README.md:21
#, markdown-text, no-wrap
msgid "Table of Contents"
msgstr ""

#. type: Title ###
#: ../README.md:23
#, markdown-text, no-wrap
msgid "Part 1: Core Language Features"
msgstr ""

#. type: Plain text
#: ../README.md:29
#, markdown-text
msgid ""
"This part tries to give a solid introduction to the Idris programming "
"language. If you are new to functional programming, make sure to follow "
"these chapters in order and *solve all the exercises*."
msgstr ""

#. type: Plain text
#: ../README.md:34
#, markdown-text
msgid ""
"If you already used other pure functional programming languages like "
"Haskell, you might go through the introductory material (Functions Part 1, "
"Algebraic Data Types, and Interfaces) pretty quickly, as most of this stuff "
"will already be familiar to you."
msgstr ""

#. type: Bullet: '1. '
#: ../README.md:103
#, markdown-text
msgid "[Introduction](src/Tutorial/Intro.md)"
msgstr ""

#. type: Bullet: '   1. '
#: ../README.md:103
#, markdown-text
msgid ""
"[About the Idris Programming "
"Language](src/Tutorial/Intro.md#about-the-idris-programming-language)"
msgstr ""

#. type: Bullet: '   2. '
#: ../README.md:103
#, markdown-text
msgid "[Using the REPL](src/Tutorial/Intro.md#using-the-repl)"
msgstr ""

#. type: Bullet: '   3. '
#: ../README.md:103
#, markdown-text
msgid "[A First Idris Program](src/Tutorial/Intro.md#a-first-idris-program)"
msgstr ""

#. type: Bullet: '   4. '
#: ../README.md:103
#, markdown-text
msgid ""
"[The Shape of an Idris "
"Definition](src/Tutorial/Intro.md#the-shape-of-an-idris-definition)"
msgstr ""

#. type: Bullet: '   5. '
#: ../README.md:103
#, markdown-text
msgid "[Where to get Help](src/Tutorial/Intro.md#where-to-get-help)"
msgstr ""

#. type: Bullet: '2. '
#: ../README.md:103
#, markdown-text
msgid "[Functions Part 1](src/Tutorial/Functions1.md)"
msgstr ""

#. type: Bullet: '   1. '
#: ../README.md:103
#, markdown-text
msgid ""
"[Functions with more that one "
"Argument](src/Tutorial/Functions1.md#functions-with-more-that-one-argument)"
msgstr ""

#. type: Bullet: '   2. '
#: ../README.md:103
#, markdown-text
msgid "[Function Composition](src/Tutorial/Functions1.md#function-composition)"
msgstr ""

#. type: Bullet: '   3. '
#: ../README.md:103
#, markdown-text
msgid "[Higher-order Functions](src/Tutorial/Functions1.md#higher-order-functions)"
msgstr ""

#. type: Bullet: '   4. '
#: ../README.md:103
#, markdown-text
msgid "[Currying](src/Tutorial/Functions1.md#currying)"
msgstr ""

#. type: Bullet: '   5. '
#: ../README.md:103
#, markdown-text
msgid "[Anonymous Functions](src/Tutorial/Functions1.md#anonymous-functions)"
msgstr ""

#. type: Bullet: '   6. '
#: ../README.md:103
#, markdown-text
msgid "[Operators](src/Tutorial/Functions1.md#operators)"
msgstr ""

#. type: Bullet: '3. '
#: ../README.md:103
#, markdown-text
msgid "[Algebraic Data Types](src/Tutorial/DataTypes.md)"
msgstr ""

#. type: Bullet: '   1. '
#: ../README.md:103
#, markdown-text
msgid "[Enumerations](src/Tutorial/DataTypes.md#enumerations)"
msgstr ""

#. type: Bullet: '   2. '
#: ../README.md:103
#, markdown-text
msgid "[Sum Types](src/Tutorial/DataTypes.md#sum-types)"
msgstr ""

#. type: Bullet: '   3. '
#: ../README.md:103
#, markdown-text
msgid "[Records](src/Tutorial/DataTypes.md#records)"
msgstr ""

#. type: Bullet: '   4. '
#: ../README.md:103
#, markdown-text
msgid "[Generic Data Types](src/Tutorial/DataTypes.md#generic-data-types)"
msgstr ""

#. type: Bullet: '   5. '
#: ../README.md:103
#, markdown-text
msgid ""
"[Alternative Syntax for Data "
"Definitions](src/Tutorial/DataTypes.md#alternative-syntax-for-data-definitions)"
msgstr ""

#. type: Bullet: '4. '
#: ../README.md:103
#, markdown-text
msgid "[Interfaces](src/Tutorial/Interfaces.md)"
msgstr ""

#. type: Bullet: '   1. '
#: ../README.md:103
#, markdown-text
msgid "[Interface Basics](src/Tutorial/Interfaces.md#interface-basics)"
msgstr ""

#. type: Bullet: '   2. '
#: ../README.md:103
#, markdown-text
msgid "[More about Interfaces](src/Tutorial/Interfaces.md#more-about-interfaces)"
msgstr ""

#. type: Bullet: '   3. '
#: ../README.md:103
#, markdown-text
msgid ""
"[Interfaces in the "
"Prelude](src/Tutorial/Interfaces.md#interfaces-in-the-prelude)"
msgstr ""

#. type: Bullet: '5. '
#: ../README.md:103
#, markdown-text
msgid "[Functions Part 2](src/Tutorial/Functions2.md)"
msgstr ""

#. type: Bullet: '   1. '
#: ../README.md:103
#, markdown-text
msgid ""
"[Let Bindings and Local "
"Definitions](src/Tutorial/Functions2.md#let-bindings-and-local-definitions)"
msgstr ""

#. type: Bullet: '   2. '
#: ../README.md:103
#, markdown-text
msgid ""
"[The Truth about Function "
"Arguments](src/Tutorial/Functions2.md#the-truth-about-function-arguments)"
msgstr ""

#. type: Bullet: '   3. '
#: ../README.md:103
#, markdown-text
msgid "[Programming with Holes](src/Tutorial/Functions2.md#programming-with-holes)"
msgstr ""

#. type: Bullet: '6. '
#: ../README.md:103
#, markdown-text
msgid "[Dependent Types](src/Tutorial/Dependent.md)"
msgstr ""

#. type: Bullet: '   1. '
#: ../README.md:103
#, markdown-text
msgid "[Length-Indexed Lists](src/Tutorial/Dependent.md#length-indexed-lists)"
msgstr ""

#. type: Bullet: '   2. '
#: ../README.md:103
#, markdown-text
msgid ""
"[Fin: Safe Indexing into "
"Vectors](src/Tutorial/Dependent.md#fin-safe-indexing-into-vectors)"
msgstr ""

#. type: Bullet: '   3. '
#: ../README.md:103
#, markdown-text
msgid ""
"[Compile-Time "
"Computations](src/Tutorial/Dependent.md#compile-time-computations)"
msgstr ""

#. type: Bullet: '7. '
#: ../README.md:103
#, markdown-text
msgid "[IO: Programming with Side Effects](src/Tutorial/IO.md)"
msgstr ""

#. type: Bullet: '   1. '
#: ../README.md:103
#, markdown-text
msgid "[Pure Side Effects?](src/Tutorial/IO.md#pure-side-effects)"
msgstr ""

#. type: Bullet: '   2. '
#: ../README.md:103
#, markdown-text
msgid "[Do Blocks, Desugared](src/Tutorial/IO.md#do-blocks-desugared)"
msgstr ""

#. type: Bullet: '   3. '
#: ../README.md:103
#, markdown-text
msgid "[Working with Files](src/Tutorial/IO.md#working-with-files)"
msgstr ""

#. type: Bullet: '   4. '
#: ../README.md:103
#, markdown-text
msgid "[How IO is Implemented](src/Tutorial/IO.md#how-io-is-implemented)"
msgstr ""

#. type: Bullet: '8. '
#: ../README.md:103
#, markdown-text
msgid "[Functor and Friends](src/Tutorial/Functor.md)"
msgstr ""

#. type: Bullet: '   1. '
#: ../README.md:103
#, markdown-text
msgid "[Functor](src/Tutorial/Functor.md#functor)"
msgstr ""

#. type: Bullet: '   2. '
#: ../README.md:103
#, markdown-text
msgid "[Applicative](src/Tutorial/Functor.md#applicative)"
msgstr ""

#. type: Bullet: '   3. '
#: ../README.md:103
#, markdown-text
msgid "[Monad](src/Tutorial/Functor.md#monad)"
msgstr ""

#. type: Bullet: '   4. '
#: ../README.md:103
#, markdown-text
msgid ""
"[Background and further "
"Reading](src/Tutorial/Functor.md#background-and-further-reading)"
msgstr ""

#. type: Bullet: '9. '
#: ../README.md:103
#, markdown-text
msgid "[Recursion and Folds](src/Tutorial/Folds.md)"
msgstr ""

#. type: Bullet: '   1. '
#: ../README.md:103
#, markdown-text
msgid "[Recursion](src/Tutorial/Folds.md#recursion)"
msgstr ""

#. type: Bullet: '   2. '
#: ../README.md:103
#, markdown-text
msgid ""
"[A few Notes on Totality "
"Checking](src/Tutorial/Folds.md#a-few-notes-on-totality-checking)"
msgstr ""

#. type: Bullet: '   3. '
#: ../README.md:103
#, markdown-text
msgid "[Interface Foldable](src/Tutorial/Folds.md#interface-foldable)"
msgstr ""

#. type: Bullet: '10. '
#: ../README.md:103
#, markdown-text
msgid "[Effectful Traversals](src/Tutorial/Traverse.md)"
msgstr ""

#. type: Bullet: '    1. '
#: ../README.md:103
#, markdown-text
msgid "[Reading CSV Tables](src/Tutorial/Traverse.md#reading-csv-tables)"
msgstr ""

#. type: Bullet: '    2. '
#: ../README.md:103
#, markdown-text
msgid "[Programming with State](src/Tutorial/Traverse.md#programming-with-state)"
msgstr ""

#. type: Bullet: '    3. '
#: ../README.md:103
#, markdown-text
msgid ""
"[The Power of "
"Composition](src/Tutorial/Traverse.md#the-power-of-composition)"
msgstr ""

#. type: Bullet: '11. '
#: ../README.md:103
#, markdown-text
msgid "[Sigma Types](src/Tutorial/DPair.md)"
msgstr ""

#. type: Bullet: '    1. '
#: ../README.md:103
#, markdown-text
msgid "[Dependent Pairs](src/Tutorial/DPair.md#dependent-pairs)"
msgstr ""

#. type: Bullet: '    2. '
#: ../README.md:103
#, markdown-text
msgid "[Use Case: Nucleic Acids](src/Tutorial/DPair.md#use-case-nucleic-acids)"
msgstr ""

#. type: Bullet: '    3. '
#: ../README.md:103
#, markdown-text
msgid ""
"[Use Case: CSV Files with a "
"Schema](src/Tutorial/DPair.md#use-case-csv-files-with-a-schema)"
msgstr ""

#. type: Bullet: '12. '
#: ../README.md:103
#, markdown-text
msgid "[Propositional Equality](src/Tutorial/Eq.md)"
msgstr ""

#. type: Bullet: '    1. '
#: ../README.md:103
#, markdown-text
msgid "[Equality as a Type](src/Tutorial/Eq.md#equality-as-a-type)"
msgstr ""

#. type: Bullet: '    2. '
#: ../README.md:103
#, markdown-text
msgid "[Programs as Proofs](src/Tutorial/Eq.md#programs-as-proofs)"
msgstr ""

#. type: Bullet: '    3. '
#: ../README.md:103
#, markdown-text
msgid "[Into the Void](src/Tutorial/Eq.md#into-the-void)"
msgstr ""

#. type: Bullet: '    4. '
#: ../README.md:103
#, markdown-text
msgid "[Rewrite Rules](src/Tutorial/Eq.md#rewrite-rules)"
msgstr ""

#. type: Bullet: '13. '
#: ../README.md:103
#, markdown-text
msgid "[Predicates and Proof Search](src/Tutorial/Predicates.md)"
msgstr ""

#. type: Bullet: '    1. '
#: ../README.md:103
#, markdown-text
msgid "[Preconditions](src/Tutorial/Predicates.md#preconditions)"
msgstr ""

#. type: Bullet: '    2. '
#: ../README.md:103
#, markdown-text
msgid ""
"[Contracts between "
"Values](src/Tutorial/Predicates.md#contracts-between-values)"
msgstr ""

#. type: Bullet: '    3. '
#: ../README.md:103
#, markdown-text
msgid ""
"[Use Case: Flexible Error "
"Handling](src/Tutorial/Predicates.md#use-case-flexible-error-handling)"
msgstr ""

#. type: Bullet: '    4. '
#: ../README.md:103
#, markdown-text
msgid ""
"[The Truth about "
"Interfaces](src/Tutorial/Predicates.md#the-truth-about-interfaces)"
msgstr ""

#. type: Bullet: '14. '
#: ../README.md:103
#, markdown-text
msgid "[Primitives](src/Tutorial/Prim.md)"
msgstr ""

#. type: Bullet: '    1. '
#: ../README.md:103
#, markdown-text
msgid ""
"[How Primitives are "
"Implemented](src/Tutorial/Prim.md#how-primitives-are-implemented)"
msgstr ""

#. type: Bullet: '    2. '
#: ../README.md:103
#, markdown-text
msgid "[Working with Strings](src/Tutorial/Prim.md#working-with-strings)"
msgstr ""

#. type: Bullet: '    3. '
#: ../README.md:103
#, markdown-text
msgid "[Integers](src/Tutorial/Prim.md#integers)"
msgstr ""

#. type: Bullet: '    4. '
#: ../README.md:103
#, markdown-text
msgid "[Refined Primitives](src/Tutorial/Prim.md#refined-primitives)"
msgstr ""

#. type: Title ###
#: ../README.md:104
#, markdown-text, no-wrap
msgid "Part 2: Appendices"
msgstr ""

#. type: Plain text
#: ../README.md:110
#, markdown-text
msgid ""
"The appendices can be used as references for the topics at hand. I plan to "
"eventually have a concise reference on Idris syntax, typical error messages, "
"the module system, interactive editing and possibly others."
msgstr ""

#. type: Bullet: '1. '
#: ../README.md:112
#, markdown-text
msgid "[Interactive Editing in Neovim](src/Appendices/Neovim.md)"
msgstr ""

#. type: Title ##
#: ../README.md:113
#, markdown-text, no-wrap
msgid "Prerequisites"
msgstr ""

#. type: Plain text
#: ../README.md:119
#, markdown-text
msgid ""
"At the moment, this project is being actively developed and evolved against "
"the main branch of the Idris 2 repository.  It is being tested nightly on "
"GitHub and built against the latest commit of the Idris 2 main branch as "
"well as the Idris 2 commit listed in file `.idris-version`."
msgstr ""
